GitDiffStart: a684f6d497d17aacc2cf2caac17eade055c612a8 | Thu Jul 14 02:56:54 2011 +0000
diff --git a/dev-tools/eclipse/dot.classpath b/dev-tools/eclipse/dot.classpath
index a4d98e4..147664f 100644
--- a/dev-tools/eclipse/dot.classpath
+++ b/dev-tools/eclipse/dot.classpath
@@ -15,9 +15,6 @@
 	<classpathentry kind="src" path="lucene/contrib/misc/src/test"/>
 	<classpathentry kind="src" path="lucene/contrib/queries/src/java"/>
 	<classpathentry kind="src" path="lucene/contrib/queries/src/test"/>
-	<classpathentry kind="src" path="lucene/contrib/queryparser/src/java"/>
-	<classpathentry kind="src" path="lucene/contrib/queryparser/src/resources"/>
-	<classpathentry kind="src" path="lucene/contrib/queryparser/src/test"/>
 	<classpathentry kind="src" path="lucene/contrib/spatial/src/java"/>
 	<classpathentry kind="src" path="lucene/contrib/spatial/src/test"/>
 	<classpathentry kind="src" path="lucene/contrib/xml-query-parser/src/java"/>
diff --git a/dev-tools/idea/.idea/modules.xml b/dev-tools/idea/.idea/modules.xml
index b497aa6..44203dc 100644
--- a/dev-tools/idea/.idea/modules.xml
+++ b/dev-tools/idea/.idea/modules.xml
@@ -10,7 +10,6 @@
       <module filepath="$PROJECT_DIR$/lucene/contrib/memory/memory.iml" />
       <module filepath="$PROJECT_DIR$/lucene/contrib/misc/misc.iml" />
       <module filepath="$PROJECT_DIR$/lucene/contrib/queries/queries-contrib.iml" />
-      <module filepath="$PROJECT_DIR$/lucene/contrib/queryparser/queryparser-contrib.iml" />
       <module filepath="$PROJECT_DIR$/lucene/contrib/spatial/spatial.iml" />
       <module filepath="$PROJECT_DIR$/lucene/contrib/xml-query-parser/xml-query-parser.iml" />
       <module filepath="$PROJECT_DIR$/modules/analysis/common/analysis-common.iml" />
diff --git a/dev-tools/idea/.idea/workspace.xml b/dev-tools/idea/.idea/workspace.xml
index 3e50b27..71b698d 100644
--- a/dev-tools/idea/.idea/workspace.xml
+++ b/dev-tools/idea/.idea/workspace.xml
@@ -148,13 +148,6 @@
       <option name="VM_PARAMETERS" value="-ea -DtempDir=temp" />
       <option name="TEST_SEARCH_SCOPE"><value defaultName="singleModule" /></option>
     </configuration>
-    <configuration default="false" name="queryparser contrib" type="JUnit" factoryName="JUnit">
-      <module name="queryparser-contrib" />
-      <option name="TEST_OBJECT" value="package" />
-      <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$/lucene/build/contrib/queryparser" />
-      <option name="VM_PARAMETERS" value="-ea -DtempDir=temp" />
-      <option name="TEST_SEARCH_SCOPE"><value defaultName="singleModule" /></option>
-    </configuration>
     <configuration default="false" name="smartcn analysis module" type="JUnit" factoryName="JUnit">
       <module name="smartcn" />
       <option name="TEST_OBJECT" value="package" />
@@ -204,7 +197,7 @@
       <option name="VM_PARAMETERS" value="-ea -DtempDir=temp" />
       <option name="TEST_SEARCH_SCOPE"><value defaultName="singleModule" /></option>
     </configuration>
-    <list size="29">
+    <list size="28">
       <item index="0" class="java.lang.String" itemvalue="JUnit.analysis-extras contrib" />
       <item index="1" class="java.lang.String" itemvalue="JUnit.benchmark module" />
       <item index="2" class="java.lang.String" itemvalue="JUnit.clustering contrib" />
@@ -226,14 +219,13 @@
       <item index="18" class="java.lang.String" itemvalue="JUnit.queries contrib" />
       <item index="19" class="java.lang.String" itemvalue="JUnit.queries module" />
       <item index="20" class="java.lang.String" itemvalue="JUnit.queryparser module" />
-      <item index="21" class="java.lang.String" itemvalue="JUnit.queryparser contrib" />
-      <item index="22" class="java.lang.String" itemvalue="JUnit.smartcn analysis module" />
-      <item index="23" class="java.lang.String" itemvalue="JUnit.solr" />
-      <item index="24" class="java.lang.String" itemvalue="JUnit.spatial contrib" />
-      <item index="25" class="java.lang.String" itemvalue="JUnit.stempel analysis module" />
-      <item index="26" class="java.lang.String" itemvalue="JUnit.suggest module" />
-      <item index="27" class="java.lang.String" itemvalue="JUnit.uima contrib" />
-      <item index="28" class="java.lang.String" itemvalue="JUnit.xml-query-parser contrib" />
+      <item index="21" class="java.lang.String" itemvalue="JUnit.smartcn analysis module" />
+      <item index="22" class="java.lang.String" itemvalue="JUnit.solr" />
+      <item index="23" class="java.lang.String" itemvalue="JUnit.spatial contrib" />
+      <item index="24" class="java.lang.String" itemvalue="JUnit.stempel analysis module" />
+      <item index="25" class="java.lang.String" itemvalue="JUnit.suggest module" />
+      <item index="26" class="java.lang.String" itemvalue="JUnit.uima contrib" />
+      <item index="27" class="java.lang.String" itemvalue="JUnit.xml-query-parser contrib" />
     </list>
   </component>
 </project>
diff --git a/dev-tools/idea/lucene/contrib/queryparser/queryparser-contrib.iml b/dev-tools/idea/lucene/contrib/queryparser/queryparser-contrib.iml
deleted file mode 100644
index 28e1a41..0000000
--- a/dev-tools/idea/lucene/contrib/queryparser/queryparser-contrib.iml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/../../build/contrib/queryparser/classes/java" />
-    <output-test url="file://$MODULE_DIR$/../../build/contrib/queryparser/classes/test" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/resources" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test" isTestSource="true" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" scope="TEST" name="JUnit" level="project" />
-    <orderEntry type="module" module-name="queries-contrib" />
-    <orderEntry type="module" module-name="misc" />
-    <orderEntry type="module" module-name="lucene" />
-    <orderEntry type="module" module-name="queryparser" />
-  </component>
-</module>
diff --git a/dev-tools/idea/modules/queryparser/queryparser.iml b/dev-tools/idea/modules/queryparser/queryparser.iml
index 50cb281..e0fddec 100644
--- a/dev-tools/idea/modules/queryparser/queryparser.iml
+++ b/dev-tools/idea/modules/queryparser/queryparser.iml
@@ -6,6 +6,7 @@
     <exclude-output />
     <content url="file://$MODULE_DIR$">
       <sourceFolder url="file://$MODULE_DIR$/src/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/resources" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/src/test" isTestSource="true" />
       <excludeFolder url="file://$MODULE_DIR$/work" />
     </content>
diff --git a/dev-tools/maven/lucene/contrib/pom.xml.template b/dev-tools/maven/lucene/contrib/pom.xml.template
index 42edcf6..b138041 100644
--- a/dev-tools/maven/lucene/contrib/pom.xml.template
+++ b/dev-tools/maven/lucene/contrib/pom.xml.template
@@ -37,7 +37,6 @@
     <module>memory</module>
     <module>misc</module>
     <module>queries</module>
-    <module>queryparser</module>
     <module>spatial</module>
     <module>xml-query-parser</module>
   </modules>
diff --git a/dev-tools/maven/lucene/contrib/queryparser/pom.xml.template b/dev-tools/maven/lucene/contrib/queryparser/pom.xml.template
deleted file mode 100644
index 4f67518..0000000
--- a/dev-tools/maven/lucene/contrib/queryparser/pom.xml.template
+++ /dev/null
@@ -1,90 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <!--
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-  -->
-  <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <groupId>org.apache.lucene</groupId>
-    <artifactId>lucene-parent</artifactId>
-    <version>@version@</version>
-    <relativePath>../../pom.xml</relativePath>
-  </parent>
-  <groupId>org.apache.lucene</groupId>
-  <artifactId>lucene-queryparser-contrib</artifactId>
-  <packaging>jar</packaging>
-  <name>Lucene Query Parser</name>
-  <description>
-    This is the Flexible Query Parser for apache lucene java
-  </description>
-  <properties>
-    <module-directory>lucene/contrib/queryparser</module-directory>
-    <build-directory>../../build/contrib/queryparser</build-directory>
-  </properties>
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>lucene-core</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>lucene-queryparser</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>lucene-core</artifactId>
-      <version>${project.version}</version>
-      <type>test-jar</type>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>lucene-test-framework</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-  <build>
-    <directory>${build-directory}</directory>
-    <outputDirectory>${build-directory}/classes/java</outputDirectory>
-    <testOutputDirectory>${build-directory}/classes/test</testOutputDirectory>
-    <sourceDirectory>src/java</sourceDirectory>
-    <testSourceDirectory>src/test</testSourceDirectory>
-    <resources>
-      <resource>
-        <directory>src/resources</directory>
-      </resource>
-    </resources>
-    <testResources>
-      <testResource>
-        <directory>${project.build.testSourceDirectory}</directory>
-        <excludes>
-          <exclude>**/*.java</exclude>
-        </excludes>
-      </testResource>
-    </testResources>
-  </build>
-</project>
diff --git a/lucene/build.xml b/lucene/build.xml
index 276e16f..8916e78 100644
--- a/lucene/build.xml
+++ b/lucene/build.xml
@@ -232,7 +232,6 @@
           <packageset dir="contrib/queries/src/java"/>
           <packageset dir="contrib/spatial/src/java"/>
           <packageset dir="contrib/xml-query-parser/src/java"/>
-          <packageset dir="contrib/queryparser/src/java"/>
           <!-- end alpha sort -->
 
           <!-- If the main javadoc Group listing includes an "Other   -->
@@ -248,7 +247,6 @@
           <group title="contrib: Memory" packages="org.apache.lucene.index.memory*"/>
           <group title="contrib: Misc " packages="org.apache.lucene.misc*"/>
           <group title="contrib: Queries" packages="org.apache.lucene.search.similar*:org.apache.lucene.search.regex*:org.apache.regexp*"/>
-          <group title="contrib: Query Parser" packages="org.apache.lucene.queryParser.*"/>
           <group title="contrib: Spatial" packages="org.apache.lucene.spatial*"/>
           <group title="contrib: XML Query Parser" packages="org.apache.lucene.xmlparser*"/>
           
@@ -415,22 +413,8 @@
   <!-- ================================================================== -->
   <!-- Build the JavaCC files into the source tree                        -->
   <!-- ================================================================== -->
-  <target name="clean-javacc">
-    <delete>
-      <fileset dir="contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser" includes="*.java">
-        <containsregexp expression="Generated.*By.*JavaCC"/>
-      </fileset>
-    </delete>
-  </target>
 
-  <target name="javacc" depends="init,javacc-check,clean-javacc,javacc-contrib-queryparser,javacc-contrib-demo"/>
-	
-  <target name="javacc-contrib-queryparser" depends="init,javacc-check" if="javacc.present">
-    <ant target="javacc"
-      dir="contrib/queryparser"
-      antfile="build.xml" 
-    />
-  </target>
+  <target name="javacc" depends="init,javacc-check,javacc-contrib-demo"/>
 
   <target name="javacc-contrib-demo" depends="init,javacc-check" if="javacc.present">
 	<ant target="javacc"
diff --git a/lucene/contrib/CHANGES.txt b/lucene/contrib/CHANGES.txt
index e496228..b26d575 100644
--- a/lucene/contrib/CHANGES.txt
+++ b/lucene/contrib/CHANGES.txt
@@ -11,6 +11,8 @@ Build
 
  * LUCENE-2995: Moved contrib/spellchecker into modules/suggest.
 
+ * LUCENE-3285: Moved contrib/queryparser into modules/queryparser
+
 New Features
 
  * LUCENE-2604: Added RegexpQuery support to contrib/queryparser.
diff --git a/lucene/contrib/queryparser/README.javacc b/lucene/contrib/queryparser/README.javacc
deleted file mode 100644
index bae1224..0000000
--- a/lucene/contrib/queryparser/README.javacc
+++ /dev/null
@@ -1,62 +0,0 @@
-NOTE: often, if you are making a small change to the .jj file, you can
-simply run "ant javacc" and skip the steps below.  JavaCC will print
-warnings like this:
-
-   Warning: ParseException.java: File is obsolete.  Please rename or delete this file so that a new one can be generated for you.
-
-which you should ignore (ie, simply keep the ParseException.java class
-that's already present).
-
-If, instead, you'd like to fully rebuild the StandardQueryParser,
-here's how:
-
-  * Delete these files:
-
-    StandardQueryParser.java
-    StandardQueryParserConstants.java
-    StandardQueryParserTokenManager.java
-    TokenMgrError.java
-    JavaCharStream.java
-    Token.java
-
-  * Run "ant javacc". That will generate the all the classes
-
-  * To avoid lots of warnings in the generated code:
-
-    add @SupressWarnings("all"), immediately preceding the class declaration to:
-
-       QueryParserTokenManager.java
-       TokenMgrError.java
-       JavaCharStream.java
-       Token.java
-       JavaCharStream.java
-
-  * Remove all imports from TokenMgrError.java
-
-  * Fix the ParseException class:
-
-    - Change it to extend from QueryNodeParseException:
-
-       "public class ParseException extends QueryNodeParseException".
-
-    - Recreate the all the constructors like this:
-
-      public ParseException(Token currentTokenVal,
-        int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
-        super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(
-          currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));
-        this.currentToken = currentTokenVal;
-        this.expectedTokenSequences = expectedTokenSequencesVal;
-        this.tokenImage = tokenImageVal;
-      }
-
-      public ParseException(Message message) {
-        super(message);
-      }
-
-      public ParseException() {
-        super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, "Error"));
-      }
-
-
-    - Fix all imports
diff --git a/lucene/contrib/queryparser/README.txt b/lucene/contrib/queryparser/README.txt
deleted file mode 100644
index 056f080..0000000
--- a/lucene/contrib/queryparser/README.txt
+++ /dev/null
@@ -1,74 +0,0 @@
-Description of Surround:
-
-Surround consists of operators (uppercase/lowercase):
-
-AND/OR/NOT/nW/nN/() as infix and
-AND/OR/nW/nN        as prefix.
-
-Distance operators W and N have default n=1, max 99.
-Implemented as SpanQuery with slop = (n - 1).
-An example prefix form is:
-
-20n(aa*, bb*, cc*)
-
-The name Surround was chosen because of this prefix form
-and because it uses the newly introduced span queries
-to implement the proximity operators.
-The names of the operators and the prefix and suffix
-forms have been borrowed from various other query
-languages described on the internet.
-
-
-Query terms from the Lucene standard query parser:
-
-field:termtext
-^ boost
-* internal and suffix truncation
-? one character
-
-
-Some examples:
-
-aa
-aa and bb
-aa and bb or cc        same effect as:  (aa and bb) or cc
-aa NOT bb NOT cc       same effect as:  (aa NOT bb) NOT cc
-
-and(aa,bb,cc)          aa and bb and cc
-99w(aa,bb,cc)          ordered span query with slop 98
-99n(aa,bb,cc)          unordered span query with slop 98
-
-20n(aa*,bb*)
-3w(a?a or bb?, cc*)
-
-title: text: aa
-title : text : aa or bb
-title:text: aa not bb
-title:aa not text:bb
-
-cc 3w dd               infix: dual.
-
-cc N dd N ee           same effect as:   (cc N dd) N ee
-
-text: aa 3d bb
-
-For examples on using the Surround language, see the
-test packages.
-
-
-Development status
-
-Not tested: multiple fields, internally mapped to OR queries,
-not compared to Lucene's MultipleFieldQuery.
-
-* suffix truncation is implemented very similar to Lucene's PrefixQuery.
-
-Wildcards (? and internal *) are implemented with regular expressions
-to allow further variations. A reimplementation using
-WildCardTermEnum (correct name?) should be no problem.
-
-Warnings about missing terms are sent to System.out, this might
-be replaced by another stream, and tested for in the tests.
-
-BooleanQueryTst.TestCollector uses a results checking method that should
-be replaced by the checking method from Lucene's TestBasics.java.
diff --git a/lucene/contrib/queryparser/build.xml b/lucene/contrib/queryparser/build.xml
deleted file mode 100644
index ab7e453..0000000
--- a/lucene/contrib/queryparser/build.xml
+++ /dev/null
@@ -1,111 +0,0 @@
-<?xml version="1.0"?>
-
-<!--
-    Licensed to the Apache Software Foundation (ASF) under one or more
-    contributor license agreements.  See the NOTICE file distributed with
-    this work for additional information regarding copyright ownership.
-    The ASF licenses this file to You under the Apache License, Version 2.0
-    the "License"); you may not use this file except in compliance with
-    the License.  You may obtain a copy of the License at
- 
-        http://www.apache.org/licenses/LICENSE-2.0
- 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
- -->
-
-<project name="queryparser-contrib" default="default">
-
-  <description>
-    Flexible Query Parser
-  </description>
-
-  <import file="../contrib-build.xml"/>
-
-  <module-uptodate name="queryparser" property="queryparser.uptodate" classpath.property="queryparser.jar"/>
-
-  <path id="classpath">
-    <pathelement path="${queryparser.jar}"/>
-    <path refid="base.classpath"/>
-  </path>
-
-  <target name="compile-core" depends="javacc-notice,build-queryparser,common.compile-core"/>
-
-  <!--
-    NOTE: see the README.javacc for details on how to fully regenerate the parser
-  -->
-  <target name="javacc" depends="javacc-flexible"/>
-
-  <target name="javacc-flexible" depends="javacc-check">
-    <delete>
-      <fileset dir="src/java/org/apache/lucene/queryParser/standard/parser" includes="*.java">
-        <containsregexp expression="Generated.*By.*JavaCC"/>
-      </fileset>
-    </delete>
-    <invoke-javacc target="src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj"
-                   outputDir="src/java/org/apache/lucene/queryParser/standard/parser"
-    />
-        <replaceregexp file="src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java"
-                             match="public class ParseException extends Exception"
-                             replace="public class ParseException extends QueryNodeParseException"
-                             flags="g"
-                             byline="false"/>
-        <replaceregexp file="src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java"
-                             match="package org.apache.lucene.queryParser.standard.parser;"
-                             replace="package org.apache.lucene.queryParser.standard.parser;${line.separator}
-${line.separator}
-import org.apache.lucene.messages.Message;${line.separator}
-import org.apache.lucene.messages.MessageImpl;${line.separator}
-import org.apache.lucene.queryParser.core.*;${line.separator}
-import org.apache.lucene.queryParser.core.messages.*;"
-                             flags="g"
-                             byline="false"/>
-        <replaceregexp file="src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java"
-                             match="^  public ParseException\(Token currentTokenVal.*$(\s\s[^}].*\n)*  \}"
-                             replace="  public ParseException(Token currentTokenVal,${line.separator}
-    int[][] expectedTokenSequencesVal, String[] tokenImageVal) {${line.separator}
-    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(${line.separator}
-    currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));${line.separator}
-    this.currentToken = currentTokenVal;${line.separator}
-    this.expectedTokenSequences = expectedTokenSequencesVal;${line.separator}
-    this.tokenImage = tokenImageVal;${line.separator}
-  }"
-                             flags="gm"
-                             byline="false"/>
-        <replaceregexp file="src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java"
-                             match="^  public ParseException\(String message.*$(\s\s[^}].*\n)*  \}"
-                             replace="  public ParseException(Message message) {${line.separator}
-    super(message);${line.separator}                      
-  }"
-                             flags="gm"
-                             byline="false"/>
-        <replaceregexp file="src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java"
-                             match="^  public ParseException\(\).*$(\s\s[^}].*\n)*  \}"
-                             replace="  public ParseException() {${line.separator}
-    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, &quot;Error&quot;));${line.separator}
-  }"
-                             flags="gm"
-                             byline="false"/>
-        <replaceregexp file="src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java"
-                             match="^  public String getMessage\(\).*$(\s\s\s\s[^}].*\n)*    \}"
-                             replace="  private static String initialise(Token currentToken, int[][] expectedTokenSequences, String[] tokenImage) {${line.separator}
-    String eol = System.getProperty(&quot;line.separator&quot;, &quot;\n&quot;);"
-                             flags="gm"
-                             byline="false"/>
-        <replaceregexp file="src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java"
-                             match="\s*protected String add_escapes.*"
-                             replace="  static private String add_escapes(String str) {"
-                             flags="g"
-                             byline="true"/>
-  </target>
-
-  <target name="build-queryparser" unless="queryparser.uptodate">
-    <echo>QueryParser Contrib building dependency modules/queryparser</echo>
-    <subant target="default">
-      <fileset dir="${common.dir}/../modules/queryparser" includes="build.xml"/>
-    </subant>
-  </target>
-</project>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeError.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeError.java
deleted file mode 100644
index cb3e77e..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeError.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package org.apache.lucene.queryParser.core;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.messages.Message;
-import org.apache.lucene.messages.NLSException;
-
-/**
- * Error class with NLS support
- * 
- * @see org.apache.lucene.messages.NLS
- * @see org.apache.lucene.messages.Message
- */
-public class QueryNodeError extends Error implements NLSException {
-  private Message message;
-
-  /**
-   * @param message
-   *          - NLS Message Object
-   */
-  public QueryNodeError(Message message) {
-    super(message.getKey());
-
-    this.message = message;
-
-  }
-
-  /**
-   * @param throwable
-   *          - @see java.lang.Error
-   */
-  public QueryNodeError(Throwable throwable) {
-    super(throwable);
-  }
-
-  /**
-   * @param message
-   *          - NLS Message Object
-   * @param throwable
-   *          - @see java.lang.Error
-   */
-  public QueryNodeError(Message message, Throwable throwable) {
-    super(message.getKey(), throwable);
-
-    this.message = message;
-
-  }
-
-  /*
-   * (non-Javadoc)
-   * 
-   * @see org.apache.lucene.messages.NLSException#getMessageObject()
-   */
-  public Message getMessageObject() {
-    return this.message;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeException.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeException.java
deleted file mode 100644
index 22db1d5..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeException.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package org.apache.lucene.queryParser.core;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-
-import org.apache.lucene.messages.Message;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.messages.NLS;
-import org.apache.lucene.messages.NLSException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-
-/**
- * <p>
- * This exception should be thrown if something wrong happens when dealing with
- * {@link QueryNode}s.
- * </p>
- * <p>
- * It also supports NLS messages.
- * </p>
- * 
- * @see Message
- * @see NLS
- * @see NLSException
- * @see QueryNode
- */
-public class QueryNodeException extends Exception implements NLSException {
-
-  protected Message message = new MessageImpl(QueryParserMessages.EMPTY_MESSAGE);
-
-  public QueryNodeException(Message message) {
-    super(message.getKey());
-
-    this.message = message;
-
-  }
-
-  public QueryNodeException(Throwable throwable) {
-    super(throwable);
-  }
-
-  public QueryNodeException(Message message, Throwable throwable) {
-    super(message.getKey(), throwable);
-
-    this.message = message;
-
-  }
-
-  public Message getMessageObject() {
-    return this.message;
-  }
-
-  @Override
-  public String getMessage() {
-    return getLocalizedMessage();
-  }
-
-  @Override
-  public String getLocalizedMessage() {
-    return getLocalizedMessage(Locale.getDefault());
-  }
-
-  public String getLocalizedMessage(Locale locale) {
-    return this.message.getLocalizedMessage(locale);
-  }
-
-  @Override
-  public String toString() {
-    return this.message.getKey() + ": " + getLocalizedMessage();
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeParseException.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeParseException.java
deleted file mode 100644
index a628574..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryNodeParseException.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package org.apache.lucene.queryParser.core;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.messages.Message;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
-
-/**
- * This should be thrown when an exception happens during the query parsing from
- * string to the query node tree.
- * 
- * @see QueryNodeException
- * @see SyntaxParser
- * @see QueryNode
- */
-public class QueryNodeParseException extends QueryNodeException {
-
-  private CharSequence query;
-
-  private int beginColumn = -1;
-
-  private int beginLine = -1;
-
-  private String errorToken = "";
-
-  public QueryNodeParseException(Message message) {
-    super(message);
-  }
-
-  public QueryNodeParseException(Throwable throwable) {
-    super(throwable);
-  }
-
-  public QueryNodeParseException(Message message, Throwable throwable) {
-    super(message, throwable);
-  }
-
-  public void setQuery(CharSequence query) {
-    this.query = query;
-    this.message = new MessageImpl(
-        QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, "");
-  }
-
-  public CharSequence getQuery() {
-    return this.query;
-  }
-
-  /**
-   * @param errorToken
-   *          the errorToken in the query
-   */
-  protected void setErrorToken(String errorToken) {
-    this.errorToken = errorToken;
-  }
-
-  public String getErrorToken() {
-    return this.errorToken;
-  }
-
-  public void setNonLocalizedMessage(Message message) {
-    this.message = message;
-  }
-
-  /**
-   * For EndOfLine and EndOfFile ("<EOF>") parsing problems the last char in the
-   * string is returned For the case where the parser is not able to figure out
-   * the line and column number -1 will be returned
-   * 
-   * @return line where the problem was found
-   */
-  public int getBeginLine() {
-    return this.beginLine;
-  }
-
-  /**
-   * For EndOfLine and EndOfFile ("<EOF>") parsing problems the last char in the
-   * string is returned For the case where the parser is not able to figure out
-   * the line and column number -1 will be returned
-   * 
-   * @return column of the first char where the problem was found
-   */
-  public int getBeginColumn() {
-    return this.beginColumn;
-  }
-
-  /**
-   * @param beginLine
-   *          the beginLine to set
-   */
-  protected void setBeginLine(int beginLine) {
-    this.beginLine = beginLine;
-  }
-
-  /**
-   * @param beginColumn
-   *          the beginColumn to set
-   */
-  protected void setBeginColumn(int beginColumn) {
-    this.beginColumn = beginColumn;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryParserHelper.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryParserHelper.java
deleted file mode 100644
index 626d8a5..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryParserHelper.java
+++ /dev/null
@@ -1,261 +0,0 @@
-package org.apache.lucene.queryParser.core;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.builders.QueryBuilder;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessor;
-
-/**
- * <p>
- * This class is a helper for the query parser framework, it does all the three
- * query parser phrases at once: text parsing, query processing and query
- * building.
- * </p>
- * <p>
- * It contains methods that allows the user to change the implementation used on
- * the three phases.
- * </p>
- * 
- * @see QueryNodeProcessor
- * @see SyntaxParser
- * @see QueryBuilder
- * @see QueryConfigHandler
- */
-public class QueryParserHelper {
-
-  private QueryNodeProcessor processor;
-
-  private SyntaxParser syntaxParser;
-
-  private QueryBuilder builder;
-
-  private QueryConfigHandler config;
-
-  /**
-   * Creates a query parser helper object using the specified configuration,
-   * text parser, processor and builder.
-   * 
-   * @param queryConfigHandler
-   *          the query configuration handler that will be initially set to this
-   *          helper
-   * @param syntaxParser
-   *          the text parser that will be initially set to this helper
-   * @param processor
-   *          the query processor that will be initially set to this helper
-   * @param builder
-   *          the query builder that will be initially set to this helper
-   * 
-   * @see QueryNodeProcessor
-   * @see SyntaxParser
-   * @see QueryBuilder
-   * @see QueryConfigHandler
-   */
-  public QueryParserHelper(QueryConfigHandler queryConfigHandler, SyntaxParser syntaxParser, QueryNodeProcessor processor,
-      QueryBuilder builder) {
-    this.syntaxParser = syntaxParser;
-    this.config = queryConfigHandler;
-    this.processor = processor;
-    this.builder = builder;
-
-    if (processor != null) {
-      processor.setQueryConfigHandler(queryConfigHandler);
-    }
-
-  }
-
-  /**
-   * Returns the processor object used to process the query node tree, it
-   * returns <code>null</code> if no processor is used.
-   * 
-   * @return the actual processor used to process the query node tree,
-   *         <code>null</code> if no processor is used
-   * 
-   * @see QueryNodeProcessor
-   * @see #setQueryNodeProcessor(QueryNodeProcessor)
-   */
-  public QueryNodeProcessor getQueryNodeProcessor() {
-    return processor;
-  }
-
-  /**
-   * Sets the processor that will be used to process the query node tree. If
-   * there is any {@link QueryConfigHandler} returned by
-   * {@link #getQueryConfigHandler()}, it will be set on the processor. The
-   * argument can be <code>null</code>, which means that no processor will be
-   * used to process the query node tree.
-   * 
-   * @param processor
-   *          the processor that will be used to process the query node tree,
-   *          this argument can be <code>null</code>
-   * 
-   * @see #getQueryNodeProcessor()
-   * @see QueryNodeProcessor
-   */
-  public void setQueryNodeProcessor(QueryNodeProcessor processor) {
-    this.processor = processor;
-    this.processor.setQueryConfigHandler(getQueryConfigHandler());
-
-  }
-
-  /**
-   * Sets the text parser that will be used to parse the query string, it cannot
-   * be <code>null</code>.
-   * 
-   * @param syntaxParser
-   *          the text parser that will be used to parse the query string
-   * 
-   * @see #getSyntaxParser()
-   * @see SyntaxParser
-   */
-  public void setSyntaxParser(SyntaxParser syntaxParser) {
-
-    if (syntaxParser == null) {
-      throw new IllegalArgumentException("textParser should not be null!");
-    }
-
-    this.syntaxParser = syntaxParser;
-
-  }
-
-  /**
-   * The query builder that will be used to build an object from the query node
-   * tree. It cannot be <code>null</code>.
-   * 
-   * @param queryBuilder
-   *          the query builder used to build something from the query node tree
-   * 
-   * @see #getQueryBuilder()
-   * @see QueryBuilder
-   */
-  public void setQueryBuilder(QueryBuilder queryBuilder) {
-
-    if (queryBuilder == null) {
-      throw new IllegalArgumentException("queryBuilder should not be null!");
-    }
-
-    this.builder = queryBuilder;
-
-  }
-
-  /**
-   * Returns the query configuration handler, which is used during the query
-   * node tree processing. It can be <code>null</code>.
-   * 
-   * @return the query configuration handler used on the query processing,
-   *         <code>null</code> if not query configuration handler is defined
-   * 
-   * @see QueryConfigHandler
-   * @see #setQueryConfigHandler(QueryConfigHandler)
-   */
-  public QueryConfigHandler getQueryConfigHandler() {
-    return config;
-  }
-
-  /**
-   * Returns the query builder used to build a object from the query node tree.
-   * The object produced by this builder is returned by
-   * {@link #parse(String, String)}.
-   * 
-   * @return the query builder
-   * 
-   * @see #setQueryBuilder(QueryBuilder)
-   * @see QueryBuilder
-   */
-  public QueryBuilder getQueryBuilder() {
-    return this.builder;
-  }
-
-  /**
-   * Returns the text parser used to build a query node tree from a query
-   * string. The default text parser instance returned by this method is a
-   * {@link SyntaxParser}.
-   * 
-   * @return the text parse used to build query node trees.
-   * 
-   * @see SyntaxParser
-   * @see #setSyntaxParser(SyntaxParser)
-   */
-  public SyntaxParser getSyntaxParser() {
-    return this.syntaxParser;
-  }
-
-  /**
-   * Sets the query configuration handler that will be used during query
-   * processing. It can be <code>null</code>. It's also set to the processor
-   * returned by {@link #getQueryNodeProcessor()}.
-   * 
-   * @param config
-   *          the query configuration handler used during query processing, it
-   *          can be <code>null</code>
-   * 
-   * @see #getQueryConfigHandler()
-   * @see QueryConfigHandler
-   */
-  public void setQueryConfigHandler(QueryConfigHandler config) {
-    this.config = config;
-    QueryNodeProcessor processor = getQueryNodeProcessor();
-
-    if (processor != null) {
-      processor.setQueryConfigHandler(config);
-    }
-
-  }
-
-  /**
-   * Parses a query string to an object, usually some query object. <br/>
-   * <br/>
-   * In this method the three phases are executed: <br/>
-   * <br/>
-   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1st - the query string is parsed using the
-   * text parser returned by {@link #getSyntaxParser()}, the result is a query
-   * node tree <br/>
-   * <br/>
-   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2nd - the query node tree is processed by the
-   * processor returned by {@link #getQueryNodeProcessor()} <br/>
-   * <br/>
-   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3th - a object is built from the query node
-   * tree using the builder returned by {@link #getQueryBuilder()}
-   * 
-   * @param query
-   *          the query string
-   * @param defaultField
-   *          the default field used by the text parser
-   * 
-   * @return the object built from the query
-   * 
-   * @throws QueryNodeException
-   *           if something wrong happens along the three phases
-   */
-  public Object parse(String query, String defaultField)
-      throws QueryNodeException {
-    QueryNode queryTree = getSyntaxParser().parse(query, defaultField);
-
-    QueryNodeProcessor processor = getQueryNodeProcessor();
-
-    if (processor != null) {
-      queryTree = processor.process(queryTree);
-    }
-
-    return getQueryBuilder().build(queryTree);
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/QueryBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/QueryBuilder.java
deleted file mode 100644
index 509833f..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/QueryBuilder.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.apache.lucene.queryParser.core.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-
-/**
- * This interface is used by implementors classes that builds some kind of
- * object from a query tree.
- * 
- * @see QueryTreeBuilder
- */
-public interface QueryBuilder {
-
-  /**
-   * Builds some kind of object from a query tree.
-   * 
-   * @param queryNode
-   *          the query tree root node
-   * 
-   * @return some object generated from the query tree
-   * 
-   * @throws QueryNodeException
-   */
-  Object build(QueryNode queryNode) throws QueryNodeException;
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/QueryTreeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/QueryTreeBuilder.java
deleted file mode 100644
index fe20a84..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/QueryTreeBuilder.java
+++ /dev/null
@@ -1,223 +0,0 @@
-package org.apache.lucene.queryParser.core.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.HashMap;
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
-
-/**
- * This class should be used when there is a builder for each type of node.
- * 
- * The type of node may be defined in 2 different ways: - by the field name,
- * when the node implements the {@link FieldableNode} interface - by its class,
- * it keeps checking the class and all the interfaces and classes this class
- * implements/extends until it finds a builder for that class/interface
- * 
- * This class always check if there is a builder for the field name before it
- * checks for the node class. So, field name builders have precedence over class
- * builders.
- * 
- * When a builder is found for a node, it's called and the node is passed to the
- * builder. If the returned built object is not <code>null</code>, it's tagged
- * on the node using the tag {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID}.
- * 
- * The children are usually built before the parent node. However, if a builder
- * associated to a node is an instance of {@link QueryTreeBuilder}, the node is
- * delegated to this builder and it's responsible to build the node and its
- * children.
- * 
- * @see QueryBuilder
- */
-public class QueryTreeBuilder implements QueryBuilder {
-
-  /**
-   * This tag is used to tag the nodes in a query tree with the built objects
-   * produced from their own associated builder.
-   */
-  public static final String QUERY_TREE_BUILDER_TAGID = QueryTreeBuilder.class
-      .getName();
-
-  private HashMap<Class<? extends QueryNode>, QueryBuilder> queryNodeBuilders;
-
-  private HashMap<String, QueryBuilder> fieldNameBuilders;
-
-  /**
-   * {@link QueryTreeBuilder} constructor.
-   */
-  public QueryTreeBuilder() {
-    // empty constructor
-  }
-
-  /**
-   * Associates a field name with a builder.
-   * 
-   * @param fieldName the field name
-   * @param builder the builder to be associated
-   */
-  public void setBuilder(CharSequence fieldName, QueryBuilder builder) {
-
-    if (this.fieldNameBuilders == null) {
-      this.fieldNameBuilders = new HashMap<String, QueryBuilder>();
-    }
-
-    this.fieldNameBuilders.put(fieldName.toString(), builder);
-
-
-  }
-
-  /**
-   * Associates a class with a builder
-   * 
-   * @param queryNodeClass the class
-   * @param builder the builder to be associated
-   */
-  public void setBuilder(Class<? extends QueryNode> queryNodeClass,
-      QueryBuilder builder) {
-
-    if (this.queryNodeBuilders == null) {
-      this.queryNodeBuilders = new HashMap<Class<? extends QueryNode>, QueryBuilder>();
-    }
-
-    this.queryNodeBuilders.put(queryNodeClass, builder);
-
-  }
-
-  private void process(QueryNode node) throws QueryNodeException {
-
-    if (node != null) {
-      QueryBuilder builder = getBuilder(node);
-
-      if (!(builder instanceof QueryTreeBuilder)) {
-        List<QueryNode> children = node.getChildren();
-
-        if (children != null) {
-
-          for (QueryNode child : children) {
-            process(child);
-          }
-
-        }
-
-      }
-
-      processNode(node, builder);
-
-    }
-
-  }
-
-  private QueryBuilder getBuilder(QueryNode node) {
-    QueryBuilder builder = null;
-
-    if (this.fieldNameBuilders != null && node instanceof FieldableNode) {
-      CharSequence field = ((FieldableNode) node).getField();
-
-      if (field != null) {
-        field = field.toString();
-      }
-
-      builder = this.fieldNameBuilders.get(field);
-
-    }
-
-    if (builder == null && this.queryNodeBuilders != null) {
-
-      Class<?> clazz = node.getClass();
-
-      do {
-        builder = getQueryBuilder(clazz);
-
-        if (builder == null) {
-          Class<?>[] classes = node.getClass().getInterfaces();
-
-          for (Class<?> actualClass : classes) {
-            builder = getQueryBuilder(actualClass);
-
-            if (builder != null) {
-              break;
-            }
-
-          }
-
-        }
-
-      } while (builder == null && (clazz = clazz.getSuperclass()) != null);
-
-    }
-
-    return builder;
-
-  }
-
-  private void processNode(QueryNode node, QueryBuilder builder)
-      throws QueryNodeException {
-
-    if (builder == null) {
-
-      throw new QueryNodeException(new MessageImpl(
-          QueryParserMessages.LUCENE_QUERY_CONVERSION_ERROR, node
-              .toQueryString(new EscapeQuerySyntaxImpl()), node.getClass()
-              .getName()));
-
-    }
-
-    Object obj = builder.build(node);
-
-    if (obj != null) {
-      node.setTag(QUERY_TREE_BUILDER_TAGID, obj);
-    }
-
-  }
-
-  private QueryBuilder getQueryBuilder(Class<?> clazz) {
-
-    if (QueryNode.class.isAssignableFrom(clazz)) {
-      return this.queryNodeBuilders.get(clazz);
-    }
-
-    return null;
-
-  }
-
-  /**
-   * Builds some kind of object from a query tree. Each node in the query tree
-   * is built using an specific builder associated to it.
-   * 
-   * @param queryNode the query tree root node
-   * 
-   * @return the built object
-   * 
-   * @throws QueryNodeException if some node builder throws a
-   *         {@link QueryNodeException} or if there is a node which had no
-   *         builder associated to it
-   */
-  public Object build(QueryNode queryNode) throws QueryNodeException {
-    process(queryNode);
-
-    return queryNode.getTag(QUERY_TREE_BUILDER_TAGID);
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/package.html
deleted file mode 100644
index d85cebb..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/builders/package.html
+++ /dev/null
@@ -1,39 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-Contains the necessary classes to implement query builders
-
-<h2>Query Parser Builders</h2>
-<p>
-The package <tt>org.apache.lucene.queryParser.builders</tt> contains the interface that
-builders must implement, it also contain a utility {@link org.apache.lucene.queryParser.core.builders.QueryTreeBuilder}, which walks the tree
-and call the Builder for each node in the tree.
-Builder normally convert QueryNode Object into a Lucene Query Object,
-and normally it's a one-to-one mapping class.
-
-But other builders implementations can by written to convert QueryNode objects to other non lucene objects.
-</p>
-<p>
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java
deleted file mode 100644
index 2ddf8b5..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package org.apache.lucene.queryParser.core.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.HashMap;
-
-/**
- * <p>
- * This class is the base of {@link QueryConfigHandler} and {@link FieldConfig}.
- * It has operations to set, unset and get configuration values.
- * </p>
- * <p>
- * Each configuration is is a key->value pair. The key should be an unique
- * {@link ConfigurationKey} instance and it also holds the value's type.
- * </p>
- * 
- * @see ConfigurationKey
- */
-public abstract class AbstractQueryConfig {
-  
-  final private HashMap<ConfigurationKey<?>, Object> configMap = new HashMap<ConfigurationKey<?>, Object>();
-  
-  AbstractQueryConfig() {
-    // although this class is public, it can only be constructed from package
-  }
-  
-  /**
-   * Returns the value held by the given key.
-   * 
-   * @param <T> the value's type
-   * 
-   * @param key the key, cannot be <code>null</code>
-   * 
-   * @return the value held by the given key
-   */
-  @SuppressWarnings("unchecked")
-  public <T> T get(ConfigurationKey<T> key) {
-    
-    if (key == null) {
-      throw new IllegalArgumentException("key cannot be null!");
-    }
-    
-    return (T) this.configMap.get(key);
-    
-  }
-
-  /**
-   * Returns true if there is a value set with the given key, otherwise false.
-   * 
-   * @param <T> @param <T> the value's type
-   * @param key the key, cannot be <code>null</code>
-   * @return true if there is a value set with the given key, otherwise false
-   */
-  public <T> boolean has(ConfigurationKey<T> key) {
-    
-    if (key == null) {
-      throw new IllegalArgumentException("key cannot be null!");
-    }
-    
-    return this.configMap.containsKey(key);
-    
-  }
-  
-  /**
-   * Sets a key and its value.
-   * 
-   * @param <T> the value's type
-   * @param key the key, cannot be <code>null</code>
-   * @param value
-   */
-  public <T> void set(ConfigurationKey<T> key, T value) {
-    
-    if (key == null) {
-      throw new IllegalArgumentException("key cannot be null!");
-    }
-    
-    if (value == null) {
-      unset(key);
-      
-    } else {
-      this.configMap.put(key, value);
-    }
-    
-  }
-
-  /**
-   * Unsets the given key and its value.
-   * 
-   * @param <T> the value's type
-   * @param key the key
-   * @return true if the key and value was set and removed, otherwise false
-   */
-  public <T> boolean unset(ConfigurationKey<T> key) {
-    
-    if (key == null) {
-      throw new IllegalArgumentException("key cannot be null!");
-    }
-    
-    return this.configMap.remove(key) != null;
-    
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java
deleted file mode 100644
index 758eedf..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.apache.lucene.queryParser.core.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * An instance of this class represents a key that is used to retrieve a value
- * from {@link AbstractQueryConfig}. It also holds the value's type, which is
- * defined in the generic argument.
- * 
- * @see AbstractQueryConfig
- */
-final public class ConfigurationKey<T> {
-  
-  private ConfigurationKey() {}
-  
-  /**
-   * Creates a new instance.
-   * 
-   * @param <T> the value's type
-   * 
-   * @return a new instance
-   */
-  public static <T> ConfigurationKey<T> newInstance() {
-    return new ConfigurationKey<T>();
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java
deleted file mode 100644
index b7060b4..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.apache.lucene.queryParser.core.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * This class represents a field configuration.
- */
-public class FieldConfig extends AbstractQueryConfig {
-
-  private String fieldName;
-  
-  /**
-   * Constructs a {@link FieldConfig}
-   * 
-   * @param fieldName the field name, it cannot be null
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public FieldConfig(String fieldName) {
-
-    if (fieldName == null) {
-      throw new IllegalArgumentException("field name should not be null!");
-    }
-
-    this.fieldName = fieldName;
-
-  }
-
-  /**
-   * Returns the field name this configuration represents.
-   * 
-   * @return the field name
-   */
-  public String getField() {
-    return this.fieldName;
-  }
-
-  @Override
-  public String toString() {
-    return "<fieldconfig name=\"" + this.fieldName + "\" configurations=\""
-        + super.toString() + "\"/>";
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java
deleted file mode 100644
index f255027..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.apache.lucene.queryParser.core.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * This interface should be implemented by classes that wants to listen for
- * field configuration requests. The implementation receives a
- * {@link FieldConfig} object and may add/change its configuration.
- * 
- * @see FieldConfig
- * @see QueryConfigHandler
- */
-public interface FieldConfigListener {
-
-  /**
-   * This method is called ever time a field configuration is requested.
-   * 
-   * @param fieldConfig
-   *          the field configuration requested, should never be null
-   */
-  void buildFieldConfig(FieldConfig fieldConfig);
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java
deleted file mode 100644
index bcc423a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.apache.lucene.queryParser.core.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.LinkedList;
-
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessor;
-import org.apache.lucene.queryParser.core.util.StringUtils;
-
-/**
- * This class can be used to hold any query configuration and no field
- * configuration. For field configuration, it creates an empty
- * {@link FieldConfig} object and delegate it to field config listeners, 
- * these are responsible for setting up all the field configuration.
- * 
- * {@link QueryConfigHandler} should be extended by classes that intends to
- * provide configuration to {@link QueryNodeProcessor} objects.
- * 
- * The class that extends {@link QueryConfigHandler} should also provide
- * {@link FieldConfig} objects for each collection field.
- * 
- * @see FieldConfig
- * @see FieldConfigListener
- * @see QueryConfigHandler
- */
-public abstract class QueryConfigHandler extends AbstractQueryConfig {
-  
-  final private LinkedList<FieldConfigListener> listeners = new LinkedList<FieldConfigListener>();
-
-  /**
-   * Returns an implementation of
-   * {@link FieldConfig} for a specific field name. If the implemented
-   * {@link QueryConfigHandler} does not know a specific field name, it may
-   * return <code>null</code>, indicating there is no configuration for that
-   * field.
-   * 
-   * @param fieldName
-   *          the field name
-   * @return a {@link FieldConfig} object containing the field name
-   *         configuration or <code>null</code>, if the implemented
-   *         {@link QueryConfigHandler} has no configuration for that field
-   */
-  public FieldConfig getFieldConfig(String fieldName) {
-    FieldConfig fieldConfig = new FieldConfig(StringUtils.toString(fieldName));
-
-    for (FieldConfigListener listener : this.listeners) {
-      listener.buildFieldConfig(fieldConfig);
-    }
-
-    return fieldConfig;
-
-  }
-
-  /**
-   * Adds a listener. The added listeners are called in the order they are
-   * added.
-   * 
-   * @param listener
-   *          the listener to be added
-   */
-  public void addFieldConfigListener(FieldConfigListener listener) {
-    this.listeners.add(listener);
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html
deleted file mode 100644
index 4efcfe2..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html
+++ /dev/null
@@ -1,43 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-Contains the base classes used to configure the query processing
-
-<h2>Query Configuration Interfaces</h2>
-<p>
-The package <tt>org.apache.lucene.queryParser.config</tt> contains query configuration handler
-abstract class that all config handlers should extend.
-</p>
-<p>
-See {@link org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler} for a reference
-implementation.
-</p>
-<p>
-The {@link org.apache.lucene.queryParser.core.config.QueryConfigHandler} and {@link org.apache.lucene.queryParser.core.config.FieldConfig} are used in the processors to access config
-information in a flexible and independent way.
-See {@link org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor} for a 
-reference implementation.
-</p>
-</body>
-</html
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java
deleted file mode 100644
index 4e069ca..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.apache.lucene.queryParser.core.messages;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.messages.NLS;
-
-/**
- * Flexible Query Parser message bundle class
- */
-public class QueryParserMessages extends NLS {
-
-  private static final String BUNDLE_NAME = QueryParserMessages.class.getName();
-
-  private QueryParserMessages() {
-    // Do not instantiate
-  }
-
-  static {
-    // register all string ids with NLS class and initialize static string
-    // values
-    NLS.initializeMessages(BUNDLE_NAME, QueryParserMessages.class);
-  }
-
-  // static string must match the strings in the property files.
-  public static String INVALID_SYNTAX;
-  public static String INVALID_SYNTAX_CANNOT_PARSE;
-  public static String INVALID_SYNTAX_FUZZY_LIMITS;
-  public static String INVALID_SYNTAX_FUZZY_EDITS;
-  public static String INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION;
-  public static String INVALID_SYNTAX_ESCAPE_CHARACTER;
-  public static String INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE;
-  public static String NODE_ACTION_NOT_SUPPORTED;
-  public static String PARAMETER_VALUE_NOT_SUPPORTED;
-  public static String LUCENE_QUERY_CONVERSION_ERROR;
-  public static String EMPTY_MESSAGE;
-  public static String WILDCARD_NOT_SUPPORTED;
-  public static String TOO_MANY_BOOLEAN_CLAUSES;
-  public static String LEADING_WILDCARD_NOT_ALLOWED;
-  public static String COULD_NOT_PARSE_NUMBER;
-  public static String NUMBER_CLASS_NOT_SUPPORTED_BY_NUMERIC_RANGE_QUERY;
-  public static String UNSUPPORTED_NUMERIC_DATA_TYPE;
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/package.html
deleted file mode 100644
index c05fa7e..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/package.html
+++ /dev/null
@@ -1,31 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-Contains messages usually used by query parser implementations
-
-<h2>Query Parser Messages</h2>
-
-Messages for the Flexible Query Parser, they use <tt>org.apache.lucene.messages.NLS</tt> API.
-
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/AndQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/AndQueryNode.java
deleted file mode 100644
index 421be88..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/AndQueryNode.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link AndQueryNode} represents an AND boolean operation performed on a
- * list of nodes.
- */
-public class AndQueryNode extends BooleanQueryNode {
-
-  /**
-   * @param clauses
-   *          - the query nodes to be and'ed
-   */
-  public AndQueryNode(List<QueryNode> clauses) {
-    super(clauses);
-    if ((clauses == null) || (clauses.size() == 0)) {
-      throw new IllegalArgumentException(
-          "AND query must have at least one clause");
-    }
-  }
-
-  @Override
-  public String toString() {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "<boolean operation='and'/>";
-    StringBuilder sb = new StringBuilder();
-    sb.append("<boolean operation='and'>");
-    for (QueryNode child : getChildren()) {
-      sb.append("\n");
-      sb.append(child.toString());
-
-    }
-    sb.append("\n</boolean>");
-    return sb.toString();
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "";
-
-    StringBuilder sb = new StringBuilder();
-    String filler = "";
-    for (QueryNode child : getChildren()) {
-      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
-      filler = " AND ";
-    }
-
-    // in case is root or the parent is a group node avoid parenthesis
-    if ((getParent() != null && getParent() instanceof GroupQueryNode)
-        || isRoot())
-      return sb.toString();
-    else
-      return "( " + sb.toString() + " )";
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/AnyQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/AnyQueryNode.java
deleted file mode 100644
index cd6d7e2..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/AnyQueryNode.java
+++ /dev/null
@@ -1,144 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link AnyQueryNode} represents an ANY operator performed on a list of
- * nodes.
- */
-public class AnyQueryNode extends AndQueryNode {
-  private CharSequence field = null;
-  private int minimumMatchingmElements = 0;
-
-  /**
-   * @param clauses
-   *          - the query nodes to be or'ed
-   */
-  public AnyQueryNode(List<QueryNode> clauses, CharSequence field,
-      int minimumMatchingElements) {
-    super(clauses);
-    this.field = field;
-    this.minimumMatchingmElements = minimumMatchingElements;
-
-    if (clauses != null) {
-
-      for (QueryNode clause : clauses) {
-
-        if (clause instanceof FieldQueryNode) {
-
-          if (clause instanceof QueryNodeImpl) {
-            ((QueryNodeImpl) clause).toQueryStringIgnoreFields = true;
-          }
-
-          if (clause instanceof FieldableNode) {
-            ((FieldableNode) clause).setField(field);
-          }
-
-        }
-      }
-
-    }
-
-  }
-
-  public int getMinimumMatchingElements() {
-    return this.minimumMatchingmElements;
-  }
-
-  /**
-   * returns null if the field was not specified
-   * 
-   * @return the field
-   */
-  public CharSequence getField() {
-    return this.field;
-  }
-
-  /**
-   * returns - null if the field was not specified
-   * 
-   * @return the field as a String
-   */
-  public String getFieldAsString() {
-    if (this.field == null)
-      return null;
-    else
-      return this.field.toString();
-  }
-
-  /**
-   * @param field
-   *          - the field to set
-   */
-  public void setField(CharSequence field) {
-    this.field = field;
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    AnyQueryNode clone = (AnyQueryNode) super.cloneTree();
-
-    clone.field = this.field;
-    clone.minimumMatchingmElements = this.minimumMatchingmElements;
-
-    return clone;
-  }
-
-  @Override
-  public String toString() {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "<any field='" + this.field + "'  matchelements="
-          + this.minimumMatchingmElements + "/>";
-    StringBuilder sb = new StringBuilder();
-    sb.append("<any field='" + this.field + "'  matchelements="
-        + this.minimumMatchingmElements + ">");
-    for (QueryNode clause : getChildren()) {
-      sb.append("\n");
-      sb.append(clause.toString());
-    }
-    sb.append("\n</any>");
-    return sb.toString();
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    String anySTR = "ANY " + this.minimumMatchingmElements;
-
-    StringBuilder sb = new StringBuilder();
-    if (getChildren() == null || getChildren().size() == 0) {
-      // no childs case
-    } else {
-      String filler = "";
-      for (QueryNode clause : getChildren()) {
-        sb.append(filler).append(clause.toQueryString(escapeSyntaxParser));
-        filler = " ";
-      }
-    }
-
-    if (isDefaultField(this.field)) {
-      return "( " + sb.toString() + " ) " + anySTR;
-    } else {
-      return this.field + ":(( " + sb.toString() + " ) " + anySTR + ")";
-    }
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BooleanQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BooleanQueryNode.java
deleted file mode 100644
index 56cd220..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BooleanQueryNode.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link BooleanQueryNode} represents a list of elements which do not have an
- * explicit boolean operator defined between them. It can be used to express a
- * boolean query that intends to use the default boolean operator.
- */
-public class BooleanQueryNode extends QueryNodeImpl {
-
-  /**
-   * @param clauses
-   *          - the query nodes to be and'ed
-   */
-  public BooleanQueryNode(List<QueryNode> clauses) {
-    setLeaf(false);
-    allocate();
-    set(clauses);
-  }
-
-  @Override
-  public String toString() {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "<boolean operation='default'/>";
-    StringBuilder sb = new StringBuilder();
-    sb.append("<boolean operation='default'>");
-    for (QueryNode child : getChildren()) {
-      sb.append("\n");
-      sb.append(child.toString());
-    }
-    sb.append("\n</boolean>");
-    return sb.toString();
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "";
-
-    StringBuilder sb = new StringBuilder();
-    String filler = "";
-    for (QueryNode child : getChildren()) {
-      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
-      filler = " ";
-    }
-
-    // in case is root or the parent is a group node avoid parenthesis
-    if ((getParent() != null && getParent() instanceof GroupQueryNode)
-        || isRoot())
-      return sb.toString();
-    else
-      return "( " + sb.toString() + " )";
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    BooleanQueryNode clone = (BooleanQueryNode) super.cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BoostQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BoostQueryNode.java
deleted file mode 100644
index cd8620d..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BoostQueryNode.java
+++ /dev/null
@@ -1,122 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link BoostQueryNode} boosts the QueryNode tree which is under this node.
- * So, it must only and always have one child.
- * 
- * The boost value may vary from 0.0 to 1.0.
- * 
- */
-public class BoostQueryNode extends QueryNodeImpl {
-
-  private float value = 0;
-
-  /**
-   * Constructs a boost node
-   * 
-   * @param query
-   *          the query to be boosted
-   * @param value
-   *          the boost value, it may vary from 0.0 to 1.0
-   * 
-   * @throws QueryNodeException
-   */
-  public BoostQueryNode(QueryNode query, float value) throws QueryNodeException {
-    if (query == null) {
-      throw new QueryNodeError(new MessageImpl(
-          QueryParserMessages.NODE_ACTION_NOT_SUPPORTED, "query", "null"));
-    }
-
-    this.value = value;
-    setLeaf(false);
-    allocate();
-    add(query);
-  }
-
-  /**
-   * Returns the single child which this node boosts.
-   * 
-   * @return the single child which this node boosts
-   */
-  public QueryNode getChild() {
-    List<QueryNode> children = getChildren();
-
-    if (children == null || children.size() == 0) {
-      return null;
-    }
-
-    return children.get(0);
-
-  }
-
-  /**
-   * Returns the boost value. It may vary from 0.0 to 1.0.
-   * 
-   * @return the boost value
-   */
-  public float getValue() {
-    return this.value;
-  }
-
-  /**
-   * Returns the boost value parsed to a string.
-   * 
-   * @return the parsed value
-   */
-  private CharSequence getValueString() {
-    Float f = Float.valueOf(this.value);
-    if (f == f.longValue())
-      return "" + f.longValue();
-    else
-      return "" + f;
-
-  }
-
-  @Override
-  public String toString() {
-    return "<boost value='" + getValueString() + "'>" + "\n"
-        + getChild().toString() + "\n</boost>";
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChild() == null)
-      return "";
-    return getChild().toQueryString(escapeSyntaxParser) + "^"
-        + getValueString();
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    BoostQueryNode clone = (BoostQueryNode) super.cloneTree();
-
-    clone.value = this.value;
-
-    return clone;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/DeletedQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/DeletedQueryNode.java
deleted file mode 100644
index cb859f6..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/DeletedQueryNode.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.queryParser.core.processors.RemoveDeletedQueryNodesProcessor;
-
-/**
- * A {@link DeletedQueryNode} represents a node that was deleted from the query
- * node tree. It can be removed from the tree using the
- * {@link RemoveDeletedQueryNodesProcessor} processor.
- */
-public class DeletedQueryNode extends QueryNodeImpl {
-
-  public DeletedQueryNode() {
-    // empty constructor
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    return "[DELETEDCHILD]";
-  }
-
-  @Override
-  public String toString() {
-    return "<deleted/>";
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    DeletedQueryNode clone = (DeletedQueryNode) super.cloneTree();
-
-    return clone;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java
deleted file mode 100644
index b1d3b7b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java
+++ /dev/null
@@ -1,190 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax.Type;
-
-/**
- * A {@link FieldQueryNode} represents a element that contains field/text tuple
- */
-public class FieldQueryNode extends QueryNodeImpl implements FieldValuePairQueryNode<CharSequence>, TextableQueryNode {
-
-  /**
-   * The term's field
-   */
-  protected CharSequence field;
-
-  /**
-   * The term's text.
-   */
-  protected CharSequence text;
-
-  /**
-   * The term's begin position.
-   */
-  protected int begin;
-
-  /**
-   * The term's end position.
-   */
-  protected int end;
-
-  /**
-   * The term's position increment.
-   */
-  protected int positionIncrement;
-
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public FieldQueryNode(CharSequence field, CharSequence text, int begin,
-      int end) {
-    this.field = field;
-    this.text = text;
-    this.begin = begin;
-    this.end = end;
-    this.setLeaf(true);
-
-  }
-
-  protected CharSequence getTermEscaped(EscapeQuerySyntax escaper) {
-    return escaper.escape(this.text, Locale.getDefault(), Type.NORMAL);
-  }
-
-  protected CharSequence getTermEscapeQuoted(EscapeQuerySyntax escaper) {
-    return escaper.escape(this.text, Locale.getDefault(), Type.STRING);
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    if (isDefaultField(this.field)) {
-      return getTermEscaped(escaper);
-    } else {
-      return this.field + ":" + getTermEscaped(escaper);
-    }
-  }
-
-  @Override
-  public String toString() {
-    return "<field start='" + this.begin + "' end='" + this.end + "' field='"
-        + this.field + "' text='" + this.text + "'/>";
-  }
-
-  /**
-   * @return the term
-   */
-  public String getTextAsString() {
-    if (this.text == null)
-      return null;
-    else
-      return this.text.toString();
-  }
-
-  /**
-   * returns null if the field was not specified in the query string
-   * 
-   * @return the field
-   */
-  public String getFieldAsString() {
-    if (this.field == null)
-      return null;
-    else
-      return this.field.toString();
-  }
-
-  public int getBegin() {
-    return this.begin;
-  }
-
-  public void setBegin(int begin) {
-    this.begin = begin;
-  }
-
-  public int getEnd() {
-    return this.end;
-  }
-
-  public void setEnd(int end) {
-    this.end = end;
-  }
-
-  public CharSequence getField() {
-    return this.field;
-  }
-
-  public void setField(CharSequence field) {
-    this.field = field;
-  }
-
-  public int getPositionIncrement() {
-    return this.positionIncrement;
-  }
-
-  public void setPositionIncrement(int pi) {
-    this.positionIncrement = pi;
-  }
-
-  /**
-   * Returns the term.
-   * 
-   * @return The "original" form of the term.
-   */
-  public CharSequence getText() {
-    return this.text;
-  }
-
-  /**
-   * @param text
-   *          the text to set
-   */
-  public void setText(CharSequence text) {
-    this.text = text;
-  }
-
-  @Override
-  public FieldQueryNode cloneTree() throws CloneNotSupportedException {
-    FieldQueryNode fqn = (FieldQueryNode) super.cloneTree();
-    fqn.begin = this.begin;
-    fqn.end = this.end;
-    fqn.field = this.field;
-    fqn.text = this.text;
-    fqn.positionIncrement = this.positionIncrement;
-    fqn.toQueryStringIgnoreFields = this.toQueryStringIgnoreFields;
-
-    return fqn;
-
-  }
-
-	public CharSequence getValue() {
-		return getText();
-	}
-
-	public void setValue(CharSequence value) {
-		setText(value);
-	}
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldValuePairQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldValuePairQueryNode.java
deleted file mode 100644
index f73b42b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldValuePairQueryNode.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public interface FieldValuePairQueryNode<T extends Object> extends FieldableNode, ValueQueryNode<T> {
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldableNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldableNode.java
deleted file mode 100644
index ca66626..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldableNode.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * A query node implements {@link FieldableNode} interface to indicate that its
- * children and itself are associated to a specific field.
- * 
- * If it has any children which also implements this interface, it must ensure
- * the children are associated to the same field.
- * 
- */
-public interface FieldableNode extends QueryNode {
-
-  /**
-   * Returns the field associated to the node and every node under it.
-   * 
-   * @return the field name
-   */
-  CharSequence getField();
-
-  /**
-   * Associates the node to a field.
-   * 
-   * @param fieldName
-   *          the field name
-   */
-  void setField(CharSequence fieldName);
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FuzzyQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FuzzyQueryNode.java
deleted file mode 100644
index e86b3ca..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FuzzyQueryNode.java
+++ /dev/null
@@ -1,99 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link FuzzyQueryNode} represents a element that contains
- * field/text/similarity tuple
- */
-public class FuzzyQueryNode extends FieldQueryNode {
-
-  private float similarity;
-
-  private int prefixLength;
-
-  /**
-   * @param field
-   *          Name of the field query will use.
-   * @param termStr
-   *          Term token to use for building term for the query
-   */
-  /**
-   * @param field
-   *          - Field name
-   * @param term
-   *          - Value
-   * @param minSimilarity
-   *          - similarity value
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public FuzzyQueryNode(CharSequence field, CharSequence term,
-      float minSimilarity, int begin, int end) {
-    super(field, term, begin, end);
-    this.similarity = minSimilarity;
-    setLeaf(true);
-  }
-
-  public void setPrefixLength(int prefixLength) {
-    this.prefixLength = prefixLength;
-  }
-
-  public int getPrefixLength() {
-    return this.prefixLength;
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    if (isDefaultField(this.field)) {
-      return getTermEscaped(escaper) + "~" + this.similarity;
-    } else {
-      return this.field + ":" + getTermEscaped(escaper) + "~" + this.similarity;
-    }
-  }
-
-  @Override
-  public String toString() {
-    return "<fuzzy field='" + this.field + "' similarity='" + this.similarity
-        + "' term='" + this.text + "'/>";
-  }
-
-  public void setSimilarity(float similarity) {
-    this.similarity = similarity;
-  }
-
-  @Override
-  public FuzzyQueryNode cloneTree() throws CloneNotSupportedException {
-    FuzzyQueryNode clone = (FuzzyQueryNode) super.cloneTree();
-
-    clone.similarity = this.similarity;
-
-    return clone;
-  }
-
-  /**
-   * @return the similarity
-   */
-  public float getSimilarity() {
-    return this.similarity;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/GroupQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/GroupQueryNode.java
deleted file mode 100644
index dcf1788..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/GroupQueryNode.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link GroupQueryNode} represents a location where the original user typed
- * real parenthesis on the query string. This class is useful for queries like:
- * a) a AND b OR c b) ( a AND b) OR c
- * 
- * Parenthesis might be used to define the boolean operation precedence.
- */
-public class GroupQueryNode extends QueryNodeImpl {
-
-  /**
-   * This QueryNode is used to identify parenthesis on the original query string
-   */
-  public GroupQueryNode(QueryNode query) {
-    if (query == null) {
-      throw new QueryNodeError(new MessageImpl(
-          QueryParserMessages.PARAMETER_VALUE_NOT_SUPPORTED, "query", "null"));
-    }
-
-    allocate();
-    setLeaf(false);
-    add(query);
-  }
-
-  public QueryNode getChild() {
-    return getChildren().get(0);
-  }
-
-  @Override
-  public String toString() {
-    return "<group>" + "\n" + getChild().toString() + "\n</group>";
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChild() == null)
-      return "";
-
-    return "( " + getChild().toQueryString(escapeSyntaxParser) + " )";
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    GroupQueryNode clone = (GroupQueryNode) super.cloneTree();
-
-    return clone;
-  }
-
-  /**
-   * @param child
-   */
-  public void setChild(QueryNode child) {
-    List<QueryNode> list = new ArrayList<QueryNode>();
-    list.add(child);
-    this.set(list);
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/MatchAllDocsQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/MatchAllDocsQueryNode.java
deleted file mode 100644
index 4550725..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/MatchAllDocsQueryNode.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link MatchAllDocsQueryNode} indicates that a query node tree or subtree
- * will match all documents if executed in the index.
- */
-public class MatchAllDocsQueryNode extends QueryNodeImpl {
-
-  public MatchAllDocsQueryNode() {
-    // empty constructor
-  }
-
-  @Override
-  public String toString() {
-    return "<matchAllDocs field='*' term='*'/>";
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    return "*:*";
-  }
-
-  @Override
-  public MatchAllDocsQueryNode cloneTree() throws CloneNotSupportedException {
-    MatchAllDocsQueryNode clone = (MatchAllDocsQueryNode) super.cloneTree();
-
-    // nothing to clone
-
-    return clone;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/MatchNoDocsQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/MatchNoDocsQueryNode.java
deleted file mode 100644
index c6147f3..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/MatchNoDocsQueryNode.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * A {@link MatchNoDocsQueryNode} indicates that a query node tree or subtree
- * will not match any documents if executed in the index.
- * 
- */
-public class MatchNoDocsQueryNode extends DeletedQueryNode {
-
-  public MatchNoDocsQueryNode() {
-    // empty constructor
-  }
-
-  @Override
-  public String toString() {
-    return "<matchNoDocsQueryNode/>";
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ModifierQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ModifierQueryNode.java
deleted file mode 100644
index cd35224..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ModifierQueryNode.java
+++ /dev/null
@@ -1,158 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link ModifierQueryNode} indicates the modifier value (+,-,?,NONE) for
- * each term on the query string. For example "+t1 -t2 t3" will have a tree of:
- * <blockquote>
- * &lt;BooleanQueryNode&gt; &lt;ModifierQueryNode modifier="MOD_REQ"&gt; &lt;t1/&gt;
- * &lt;/ModifierQueryNode&gt; &lt;ModifierQueryNode modifier="MOD_NOT"&gt; &lt;t2/&gt;
- * &lt;/ModifierQueryNode&gt; &lt;t3/&gt; &lt;/BooleanQueryNode&gt;
- * </blockquote>
- */
-public class ModifierQueryNode extends QueryNodeImpl {
-
-  public enum Modifier {
-    MOD_NONE, MOD_NOT, MOD_REQ;
-
-    @Override
-    public String toString() {
-      switch (this) {
-      case MOD_NONE:
-        return "MOD_NONE";
-      case MOD_NOT:
-        return "MOD_NOT";
-      case MOD_REQ:
-        return "MOD_REQ";
-      }
-      // this code is never executed
-      return "MOD_DEFAULT";
-    }
-
-    public String toDigitString() {
-      switch (this) {
-      case MOD_NONE:
-        return "";
-      case MOD_NOT:
-        return "-";
-      case MOD_REQ:
-        return "+";
-      }
-      // this code is never executed
-      return "";
-    }
-
-    public String toLargeString() {
-      switch (this) {
-      case MOD_NONE:
-        return "";
-      case MOD_NOT:
-        return "NOT ";
-      case MOD_REQ:
-        return "+";
-      }
-      // this code is never executed
-      return "";
-    }
-  }
-
-  private Modifier modifier = Modifier.MOD_NONE;
-
-  /**
-   * Used to store the modifier value on the original query string
-   * 
-   * @param query
-   *          - QueryNode subtree
-   * @param mod
-   *          - Modifier Value
-   */
-  public ModifierQueryNode(QueryNode query, Modifier mod) {
-    if (query == null) {
-      throw new QueryNodeError(new MessageImpl(
-          QueryParserMessages.PARAMETER_VALUE_NOT_SUPPORTED, "query", "null"));
-    }
-
-    allocate();
-    setLeaf(false);
-    add(query);
-    this.modifier = mod;
-  }
-
-  public QueryNode getChild() {
-    return getChildren().get(0);
-  }
-
-  public Modifier getModifier() {
-    return this.modifier;
-  }
-
-  @Override
-  public String toString() {
-    return "<modifier operation='" + this.modifier.toString() + "'>" + "\n"
-        + getChild().toString() + "\n</modifier>";
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChild() == null)
-      return "";
-
-    String leftParenthensis = "";
-    String rightParenthensis = "";
-
-    if (getChild() != null && getChild() instanceof ModifierQueryNode) {
-      leftParenthensis = "(";
-      rightParenthensis = ")";
-    }
-
-    if (getChild() instanceof BooleanQueryNode) {
-      return this.modifier.toLargeString() + leftParenthensis
-          + getChild().toQueryString(escapeSyntaxParser) + rightParenthensis;
-    } else {
-      return this.modifier.toDigitString() + leftParenthensis
-          + getChild().toQueryString(escapeSyntaxParser) + rightParenthensis;
-    }
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    ModifierQueryNode clone = (ModifierQueryNode) super.cloneTree();
-
-    clone.modifier = this.modifier;
-
-    return clone;
-  }
-
-  /**
-   * @param child
-   */
-  public void setChild(QueryNode child) {
-    List<QueryNode> list = new ArrayList<QueryNode>();
-    list.add(child);
-    this.set(list);
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/NoTokenFoundQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/NoTokenFoundQueryNode.java
deleted file mode 100644
index 19083fe..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/NoTokenFoundQueryNode.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link NoTokenFoundQueryNode} is used if a term is convert into no tokens
- * by the tokenizer/lemmatizer/analyzer (null).
- */
-public class NoTokenFoundQueryNode extends DeletedQueryNode {
-
-  public NoTokenFoundQueryNode() {
-    super();
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    return "[NTF]";
-  }
-
-  @Override
-  public String toString() {
-    return "<notokenfound/>";
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    NoTokenFoundQueryNode clone = (NoTokenFoundQueryNode) super.cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/NumberQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/NumberQueryNode.java
deleted file mode 100644
index 847d78f..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/NumberQueryNode.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-public interface NumberQueryNode {
-  
-  void setNumber(Number number);
-  
-  Number getNumber();
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OpaqueQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OpaqueQueryNode.java
deleted file mode 100644
index 68ad4d4..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OpaqueQueryNode.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link OpaqueQueryNode} is used for specify values that are not supposed to
- * be parsed by the parser. For example: and XPATH query in the middle of a
- * query string a b @xpath:'/bookstore/book[1]/title' c d
- */
-public class OpaqueQueryNode extends QueryNodeImpl {
-
-  private CharSequence schema = null;
-
-  private CharSequence value = null;
-
-  /**
-   * @param schema
-   *          - schema identifier
-   * @param value
-   *          - value that was not parsed
-   */
-  public OpaqueQueryNode(CharSequence schema, CharSequence value) {
-    this.setLeaf(true);
-
-    this.schema = schema;
-    this.value = value;
-
-  }
-
-  @Override
-  public String toString() {
-    return "<opaque schema='" + this.schema + "' value='" + this.value + "'/>";
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    return "@" + this.schema + ":'" + this.value + "'";
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    OpaqueQueryNode clone = (OpaqueQueryNode) super.cloneTree();
-
-    clone.schema = this.schema;
-    clone.value = this.value;
-
-    return clone;
-  }
-
-  /**
-   * @return the schema
-   */
-  public CharSequence getSchema() {
-    return this.schema;
-  }
-
-  /**
-   * @return the value
-   */
-  public CharSequence getValue() {
-    return this.value;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OrQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OrQueryNode.java
deleted file mode 100644
index eeb5869..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OrQueryNode.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Iterator;
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link OrQueryNode} represents an OR boolean operation performed on a list
- * of nodes.
- * 
- */
-public class OrQueryNode extends BooleanQueryNode {
-
-  /**
-   * @param clauses
-   *          - the query nodes to be or'ed
-   */
-  public OrQueryNode(List<QueryNode> clauses) {
-    super(clauses);
-    if ((clauses == null) || (clauses.size() == 0)) {
-      throw new IllegalArgumentException(
-          "OR query must have at least one clause");
-    }
-  }
-
-  @Override
-  public String toString() {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "<boolean operation='or'/>";
-    StringBuilder sb = new StringBuilder();
-    sb.append("<boolean operation='or'>");
-    for (QueryNode child : getChildren()) {
-      sb.append("\n");
-      sb.append(child.toString());
-
-    }
-    sb.append("\n</boolean>");
-    return sb.toString();
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "";
-
-    StringBuilder sb = new StringBuilder();
-    String filler = "";
-    for (Iterator<QueryNode> it = getChildren().iterator(); it.hasNext();) {
-      sb.append(filler).append(it.next().toQueryString(escapeSyntaxParser));
-      filler = " OR ";
-    }
-
-    // in case is root or the parent is a group node avoid parenthesis
-    if ((getParent() != null && getParent() instanceof GroupQueryNode)
-        || isRoot())
-      return sb.toString();
-    else
-      return "( " + sb.toString() + " )";
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricQueryNode.java
deleted file mode 100644
index ce5cff6..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricQueryNode.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link ParametricQueryNode} represents LE, LT, GE, GT, EQ, NE query.
- * Example: date >= "2009-10-10" OR price = 200
- */
-public class ParametricQueryNode extends FieldQueryNode {
-
-  private CompareOperator operator;
-
-  public enum CompareOperator {
-    LE { 
-      @Override
-      public String toString() { return "<="; }
-    },
-    LT {
-      @Override
-      public String toString() { return "<";  }
-    },
-    GE {
-      @Override
-      public String toString() { return ">="; }
-    },
-    GT {
-      @Override
-      public String toString() { return ">";  }
-    },
-    EQ {
-      @Override
-      public String toString() { return "=";  }
-    },
-    NE {
-      @Override
-      public String toString() { return "!="; }
-    };
-  }
-
-  /**
-   * @param field
-   *          - field name
-   * @param comp
-   *          - CompareOperator
-   * @param value
-   *          - text value
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public ParametricQueryNode(CharSequence field, CompareOperator comp,
-      CharSequence value, int begin, int end) {
-    super(field, value, begin, end);
-    this.operator = comp;
-    setLeaf(true);
-  }
-
-  public CharSequence getOperand() {
-    return getText();
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    return this.field + "" + this.operator.toString() + "\"" + this.text + "\"";
-  }
-
-  @Override
-  public String toString() {
-    return "<parametric field='" + this.field + "' operator='"
-        + this.operator.toString() + "' text='" + this.text + "'/>";
-  }
-
-  @Override
-  public ParametricQueryNode cloneTree() throws CloneNotSupportedException {
-    ParametricQueryNode clone = (ParametricQueryNode) super.cloneTree();
-
-    clone.operator = this.operator;
-
-    return clone;
-  }
-
-  /**
-   * @return the operator
-   */
-  public CompareOperator getOperator() {
-    return this.operator;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricRangeQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricRangeQueryNode.java
deleted file mode 100644
index 4580d84..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricRangeQueryNode.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link ParametricRangeQueryNode} represents LE, LT, GE, GT, EQ, NE query.
- * Example: date >= "2009-10-10" OR price = 200
- */
-public class ParametricRangeQueryNode extends QueryNodeImpl implements
-    FieldableNode {
-
-  public ParametricRangeQueryNode(ParametricQueryNode lowerBound,
-      ParametricQueryNode upperBound) {
-
-    if (upperBound.getOperator() != CompareOperator.LE
-        && upperBound.getOperator() != CompareOperator.LT) {
-      throw new IllegalArgumentException("upper bound should have "
-          + CompareOperator.LE + " or " + CompareOperator.LT);
-    }
-
-    if (lowerBound.getOperator() != CompareOperator.GE
-        && lowerBound.getOperator() != CompareOperator.GT) {
-      throw new IllegalArgumentException("lower bound should have "
-          + CompareOperator.GE + " or " + CompareOperator.GT);
-    }
-
-    if (upperBound.getField() != lowerBound.getField()
-        || (upperBound.getField() != null && !upperBound.getField().equals(
-            lowerBound.getField()))) {
-
-      throw new IllegalArgumentException(
-          "lower and upper bounds should have the same field name!");
-
-    }
-
-    allocate();
-    setLeaf(false);
-
-    add(lowerBound);
-    add(upperBound);
-
-  }
-
-  public ParametricQueryNode getUpperBound() {
-    return (ParametricQueryNode) getChildren().get(1);
-  }
-
-  public ParametricQueryNode getLowerBound() {
-    return (ParametricQueryNode) getChildren().get(0);
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    return getLowerBound().toQueryString(escapeSyntaxParser) + " AND "
-        + getUpperBound().toQueryString(escapeSyntaxParser);
-  }
-
-  public CharSequence getField() {
-    return getLowerBound().getField();
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder("<parametricRange>\n\t");
-    sb.append(getUpperBound()).append("\n\t");
-    sb.append(getLowerBound()).append("\n");
-    sb.append("</parametricRange>\n");
-
-    return sb.toString();
-
-  }
-
-  @Override
-  public ParametricRangeQueryNode cloneTree() throws CloneNotSupportedException {
-    ParametricRangeQueryNode clone = (ParametricRangeQueryNode) super
-        .cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-
-  public void setField(CharSequence fieldName) {
-    List<QueryNode> children = getChildren();
-
-    if (children != null) {
-
-      for (QueryNode child : getChildren()) {
-
-        if (child instanceof FieldableNode) {
-          ((FieldableNode) child).setField(fieldName);
-        }
-
-      }
-
-    }
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PathQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PathQueryNode.java
deleted file mode 100644
index dfa3f7a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PathQueryNode.java
+++ /dev/null
@@ -1,218 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Locale;
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax.Type;
-
-/**
- * A {@link PathQueryNode} is used to store queries like
- * /company/USA/California /product/shoes/brown. QueryText are objects that
- * contain the text, begin position and end position in the query.
- * <p>
- * Example how the text parser creates these objects:
- * </p>
- * <pre>
- * List values = ArrayList(); 
- * values.add(new PathQueryNode.QueryText("company", 1, 7)); 
- * values.add(new PathQueryNode.QueryText("USA", 9, 12)); 
- * values.add(new PathQueryNode.QueryText("California", 14, 23)); 
- * QueryNode q = new PathQueryNode(values);
- * </pre>
- */
-public class PathQueryNode extends QueryNodeImpl {
-
-  public static class QueryText implements Cloneable {
-    CharSequence value = null;
-    /**
-     * != null The term's begin position.
-     */
-    int begin;
-
-    /**
-     * The term's end position.
-     */
-    int end;
-
-    /**
-     * @param value
-     *          - text value
-     * @param begin
-     *          - position in the query string
-     * @param end
-     *          - position in the query string
-     */
-    public QueryText(CharSequence value, int begin, int end) {
-      super();
-      this.value = value;
-      this.begin = begin;
-      this.end = end;
-    }
-
-    @Override
-    public QueryText clone() throws CloneNotSupportedException {
-      QueryText clone = (QueryText) super.clone();
-      clone.value = this.value;
-      clone.begin = this.begin;
-      clone.end = this.end;
-      return clone;
-    }
-
-    /**
-     * @return the value
-     */
-    public CharSequence getValue() {
-      return value;
-    }
-
-    /**
-     * @return the begin
-     */
-    public int getBegin() {
-      return begin;
-    }
-
-    /**
-     * @return the end
-     */
-    public int getEnd() {
-      return end;
-    }
-
-    @Override
-    public String toString() {
-      return value + ", " + begin + ", " + end;
-    }
-  }
-
-  private List<QueryText> values = null;
-
-  /**
-   * @param pathElements
-   *          - List of QueryText objects
-   */
-  public PathQueryNode(List<QueryText> pathElements) {
-    this.values = pathElements;
-    if (pathElements.size() <= 1) {
-      // this should not happen
-      throw new RuntimeException(
-          "PathQuerynode requires more 2 or more path elements.");
-    }
-  }
-
-  /**
-   * Returns the a List with all QueryText elements
-   * 
-   * @return QueryText List size
-   */
-  public List<QueryText> getPathElements() {
-    return values;
-  }
-
-  /**
-   * Returns the a List with all QueryText elements
-   */
-  public void setPathElements(List<QueryText> elements) {
-    this.values = elements;
-  }
-
-  /**
-   * Returns the a specific QueryText element
-   * 
-   * @return QueryText List size
-   */
-  public QueryText getPathElement(int index) {
-    return values.get(index);
-  }
-
-  /**
-   * Returns the CharSequence value of a specific QueryText element
-   * 
-   * @return the CharSequence for a specific QueryText element
-   */
-  public CharSequence getFirstPathElement() {
-    return values.get(0).value;
-  }
-
-  /**
-   * Returns a List QueryText element from position startIndex
-   * 
-   * @return a List QueryText element from position startIndex
-   */
-  public List<QueryText> getPathElements(int startIndex) {
-    List<PathQueryNode.QueryText> rValues = new ArrayList<PathQueryNode.QueryText>();
-    for (int i = startIndex; i < this.values.size(); i++) {
-      try {
-        rValues.add(this.values.get(i).clone());
-      } catch (CloneNotSupportedException e) {
-        // this will not happen
-      }
-    }
-    return rValues;
-  }
-
-  private CharSequence getPathString() {
-    StringBuilder path = new StringBuilder();
-
-    for (QueryText pathelement : values) {
-      path.append("/").append(pathelement.value);
-    }
-    return path.toString();
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    StringBuilder path = new StringBuilder();
-    path.append("/").append(getFirstPathElement());
-
-    for (QueryText pathelement : getPathElements(1)) {
-      CharSequence value = escaper.escape(pathelement.value, Locale
-          .getDefault(), Type.STRING);
-      path.append("/\"").append(value).append("\"");
-    }
-    return path.toString();
-  }
-
-  @Override
-  public String toString() {
-    QueryText text = this.values.get(0);
-
-    return "<path start='" + text.begin + "' end='" + text.end + "' path='"
-        + getPathString() + "'/>";
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    PathQueryNode clone = (PathQueryNode) super.cloneTree();
-
-    // copy children
-    if (this.values != null) {
-      List<QueryText> localValues = new ArrayList<QueryText>();
-      for (QueryText value : this.values) {
-        localValues.add(value.clone());
-      }
-      clone.values = localValues;
-    }
-
-    return clone;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PhraseSlopQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PhraseSlopQueryNode.java
deleted file mode 100644
index 46561f1..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PhraseSlopQueryNode.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-public class PhraseSlopQueryNode extends QueryNodeImpl implements FieldableNode {
-
-  private int value = 0;
-
-  /**
-   * @throws QueryNodeException
-   * @throws QueryNodeParseException
-   * @exception QueryNodeParseException
-   *              throw in overridden method to disallow
-   */
-  public PhraseSlopQueryNode(QueryNode query, int value)
-      throws QueryNodeException {
-    if (query == null) {
-      throw new QueryNodeError(new MessageImpl(
-          QueryParserMessages.NODE_ACTION_NOT_SUPPORTED, "query", "null"));
-    }
-
-    this.value = value;
-    setLeaf(false);
-    allocate();
-    add(query);
-  }
-
-  public QueryNode getChild() {
-    return getChildren().get(0);
-  }
-
-  public int getValue() {
-    return this.value;
-  }
-
-  private CharSequence getValueString() {
-    Float f = Float.valueOf(this.value);
-    if (f == f.longValue())
-      return "" + f.longValue();
-    else
-      return "" + f;
-
-  }
-
-  @Override
-  public String toString() {
-    return "<phraseslop value='" + getValueString() + "'>" + "\n"
-        + getChild().toString() + "\n</phraseslop>";
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChild() == null)
-      return "";
-    return getChild().toQueryString(escapeSyntaxParser) + "~"
-        + getValueString();
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    PhraseSlopQueryNode clone = (PhraseSlopQueryNode) super.cloneTree();
-
-    clone.value = this.value;
-
-    return clone;
-  }
-
-  public CharSequence getField() {
-    QueryNode child = getChild();
-
-    if (child instanceof FieldableNode) {
-      return ((FieldableNode) child).getField();
-    }
-
-    return null;
-
-  }
-
-  public void setField(CharSequence fieldName) {
-    QueryNode child = getChild();
-
-    if (child instanceof FieldableNode) {
-      ((FieldableNode) child).setField(fieldName);
-    }
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ProximityQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ProximityQueryNode.java
deleted file mode 100644
index 80fbcde..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ProximityQueryNode.java
+++ /dev/null
@@ -1,239 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link ProximityQueryNode} represents a query where the terms should meet
- * specific distance conditions. (a b c) WITHIN [SENTENCE|PARAGRAPH|NUMBER]
- * [INORDER] ("a" "b" "c") WITHIN [SENTENCE|PARAGRAPH|NUMBER] [INORDER]
- * 
- * TODO: Add this to the future standard Lucene parser/processor/builder
- */
-public class ProximityQueryNode extends BooleanQueryNode {
-
-  public enum Type {
-    PARAGRAPH {
-      @Override
-      CharSequence toQueryString() { return "WITHIN PARAGRAPH"; } 
-    },
-    SENTENCE  { 
-      @Override
-      CharSequence toQueryString() { return "WITHIN SENTENCE";  }
-    },
-    NUMBER    {
-      @Override
-      CharSequence toQueryString() { return "WITHIN";           }
-    };
-
-    abstract CharSequence toQueryString();
-  }
-
-  // utility class
-  static public class ProximityType {
-    int pDistance = 0;
-
-    Type pType = null;
-
-    public ProximityType(Type type) {
-      this(type, 0);
-    }
-
-    public ProximityType(Type type, int distance) {
-      this.pType = type;
-      this.pDistance = distance;
-    }
-  }
-
-  private Type proximityType = Type.SENTENCE;
-  private int distance = -1;
-  private boolean inorder = false;
-  private CharSequence field = null;
-
-  /**
-   * @param clauses
-   *          - QueryNode children
-   * @param field
-   *          - field name
-   * @param type
-   *          - type of proximity query
-   * @param distance
-   *          - positive integer that specifies the distance
-   * @param inorder
-   *          - true, if the tokens should be matched in the order of the
-   *          clauses
-   */
-  public ProximityQueryNode(List<QueryNode> clauses, CharSequence field,
-      Type type, int distance, boolean inorder) {
-    super(clauses);
-    setLeaf(false);
-    this.proximityType = type;
-    this.inorder = inorder;
-    this.field = field;
-    if (type == Type.NUMBER) {
-      if (distance <= 0) {
-        throw new QueryNodeError(new MessageImpl(
-            QueryParserMessages.PARAMETER_VALUE_NOT_SUPPORTED, "distance",
-            distance));
-
-      } else {
-        this.distance = distance;
-      }
-
-    }
-    clearFields(clauses, field);
-  }
-
-  /**
-   * @param clauses
-   *          - QueryNode children
-   * @param field
-   *          - field name
-   * @param type
-   *          - type of proximity query
-   * @param inorder
-   *          - true, if the tokens should be matched in the order of the
-   *          clauses
-   */
-  public ProximityQueryNode(List<QueryNode> clauses, CharSequence field,
-      Type type, boolean inorder) {
-    this(clauses, field, type, -1, inorder);
-  }
-
-  static private void clearFields(List<QueryNode> nodes, CharSequence field) {
-    if (nodes == null || nodes.size() == 0)
-      return;
-
-    for (QueryNode clause : nodes) {
-
-      if (clause instanceof FieldQueryNode) {
-        ((FieldQueryNode) clause).toQueryStringIgnoreFields = true;
-        ((FieldQueryNode) clause).setField(field);
-      }
-    }
-  }
-
-  public Type getProximityType() {
-    return this.proximityType;
-  }
-
-  @Override
-  public String toString() {
-    String distanceSTR = ((this.distance == -1) ? ("")
-        : (" distance='" + this.distance) + "'");
-
-    if (getChildren() == null || getChildren().size() == 0)
-      return "<proximity field='" + this.field + "' inorder='" + this.inorder
-          + "' type='" + this.proximityType.toString() + "'" + distanceSTR
-          + "/>";
-    StringBuilder sb = new StringBuilder();
-    sb.append("<proximity field='" + this.field + "' inorder='" + this.inorder
-        + "' type='" + this.proximityType.toString() + "'" + distanceSTR + ">");
-    for (QueryNode child : getChildren()) {
-      sb.append("\n");
-      sb.append(child.toString());
-    }
-    sb.append("\n</proximity>");
-    return sb.toString();
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    String withinSTR = this.proximityType.toQueryString()
-        + ((this.distance == -1) ? ("") : (" " + this.distance))
-        + ((this.inorder) ? (" INORDER") : (""));
-
-    StringBuilder sb = new StringBuilder();
-    if (getChildren() == null || getChildren().size() == 0) {
-      // no children case
-    } else {
-      String filler = "";
-      for (QueryNode child : getChildren()) {
-        sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
-        filler = " ";
-      }
-    }
-
-    if (isDefaultField(this.field)) {
-      return "( " + sb.toString() + " ) " + withinSTR;
-    } else {
-      return this.field + ":(( " + sb.toString() + " ) " + withinSTR + ")";
-    }
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    ProximityQueryNode clone = (ProximityQueryNode) super.cloneTree();
-
-    clone.proximityType = this.proximityType;
-    clone.distance = this.distance;
-    clone.field = this.field;
-
-    return clone;
-  }
-
-  /**
-   * @return the distance
-   */
-  public int getDistance() {
-    return this.distance;
-  }
-
-  /**
-   * returns null if the field was not specified in the query string
-   * 
-   * @return the field
-   */
-  public CharSequence getField() {
-    return this.field;
-  }
-
-  /**
-   * returns null if the field was not specified in the query string
-   * 
-   * @return the field
-   */
-  public String getFieldAsString() {
-    if (this.field == null)
-      return null;
-    else
-      return this.field.toString();
-  }
-
-  /**
-   * @param field
-   *          the field to set
-   */
-  public void setField(CharSequence field) {
-    this.field = field;
-  }
-
-  /**
-   * @return terms must be matched in the specified order
-   */
-  public boolean isInOrder() {
-    return this.inorder;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QueryNode.java
deleted file mode 100644
index dcb9805..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QueryNode.java
+++ /dev/null
@@ -1,99 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-import java.util.Map;
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link QueryNode} is a interface implemented by all nodes on a QueryNode
- * tree.
- */
-public interface QueryNode {
-
-  /** convert to a query string understood by the query parser */
-  // TODO: this interface might be changed in the future
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser);
-
-  /** for printing */
-  public String toString();
-
-  /** get Children nodes */
-  public List<QueryNode> getChildren();
-
-  /** verify if a node is a Leaf node */
-  public boolean isLeaf();
-
-  /** verify if a node contains a tag */
-  public boolean containsTag(String tagName);
-  
-  /**
-   * @param tagName
-   * @return of stored on under that tag name
-   */
-  public Object getTag(String tagName);
-  
-  public QueryNode getParent();
-
-  /**
-   * Recursive clone the QueryNode tree The tags are not copied to the new tree
-   * when you call the cloneTree() method
-   * 
-   * @return the cloned tree
-   * @throws CloneNotSupportedException
-   */
-  public QueryNode cloneTree() throws CloneNotSupportedException;
-
-  // Below are the methods that can change state of a QueryNode
-  // Write Operations (not Thread Safe)
-
-  // add a new child to a non Leaf node
-  public void add(QueryNode child);
-
-  public void add(List<QueryNode> children);
-
-  // reset the children of a node
-  public void set(List<QueryNode> children);
-
-  /**
-   * Associate the specified value with the specified tagName. If the tagName
-   * already exists, the old value is replaced. The tagName and value cannot be
-   * null. tagName will be converted to lowercase.
-   * 
-   * @param tagName
-   * @param value
-   */
-  public void setTag(String tagName, Object value);
-  
-  /**
-   * Unset a tag. tagName will be converted to lowercase.
-   * 
-   * @param tagName
-   */
-  public void unsetTag(String tagName);
-  
-  /**
-   * Returns a map containing all tags attached to this query node. 
-   * 
-   * @return a map containing all tags attached to this query node
-   */
-  public Map<String, Object> getTagMap();
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QueryNodeImpl.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QueryNodeImpl.java
deleted file mode 100644
index dcc4811..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QueryNodeImpl.java
+++ /dev/null
@@ -1,232 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.Hashtable;
-import java.util.List;
-import java.util.Map;
-import java.util.ResourceBundle;
-
-import org.apache.lucene.messages.NLS;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.util.StringUtils;
-
-/**
- * A {@link QueryNodeImpl} is the default implementation of the interface
- * {@link QueryNode}
- */
-public abstract class QueryNodeImpl implements QueryNode, Cloneable {
-
-  /* index default field */
-  // TODO remove PLAINTEXT_FIELD_NAME replacing it with configuration APIs
-  public static final String PLAINTEXT_FIELD_NAME = "_plain";
-
-  private boolean isLeaf = true;
-
-  private Hashtable<String, Object> tags = new Hashtable<String, Object>();
-
-  private List<QueryNode> clauses = null;
-
-  protected void allocate() {
-
-    if (this.clauses == null) {
-      this.clauses = new ArrayList<QueryNode>();
-
-    } else {
-      this.clauses.clear();
-    }
-
-  }
-
-  public final void add(QueryNode child) {
-
-    if (isLeaf() || this.clauses == null || child == null) {
-      throw new IllegalArgumentException(NLS
-          .getLocalizedMessage(QueryParserMessages.NODE_ACTION_NOT_SUPPORTED));
-    }
-
-    this.clauses.add(child);
-    ((QueryNodeImpl) child).setParent(this);
-
-  }
-
-  public final void add(List<QueryNode> children) {
-
-    if (isLeaf() || this.clauses == null) {
-      throw new IllegalArgumentException(NLS
-          .getLocalizedMessage(QueryParserMessages.NODE_ACTION_NOT_SUPPORTED));
-    }
-
-    for (QueryNode child : children) {
-      add(child);
-    }
-
-  }
-
-  public boolean isLeaf() {
-    return this.isLeaf;
-  }
-
-  public final void set(List<QueryNode> children) {
-
-    if (isLeaf() || this.clauses == null) {
-      ResourceBundle bundle = ResourceBundle
-          .getBundle("org.apache.lucene.queryParser.messages.QueryParserMessages");
-      String message = bundle.getObject("Q0008E.NODE_ACTION_NOT_SUPPORTED")
-          .toString();
-
-      throw new IllegalArgumentException(message);
-
-    }
-
-    // reset parent value
-    for (QueryNode child : children) {
-
-      ((QueryNodeImpl) child).setParent(null);
-
-    }
-
-    // allocate new children list
-    allocate();
-
-    // add new children and set parent
-    for (QueryNode child : children) {
-      add(child);
-    }
-  }
-
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    QueryNodeImpl clone = (QueryNodeImpl) super.clone();
-    clone.isLeaf = this.isLeaf;
-
-    // Reset all tags
-    clone.tags = new Hashtable<String, Object>();
-
-    // copy children
-    if (this.clauses != null) {
-      List<QueryNode> localClauses = new ArrayList<QueryNode>();
-      for (QueryNode clause : this.clauses) {
-        localClauses.add(clause.cloneTree());
-      }
-      clone.clauses = localClauses;
-    }
-
-    return clone;
-  }
-
-  @Override
-  public Object clone() throws CloneNotSupportedException {
-    return cloneTree();
-  }
-
-  protected void setLeaf(boolean isLeaf) {
-    this.isLeaf = isLeaf;
-  }
-
-  /**
-   * @return a List for QueryNode object. Returns null, for nodes that do not
-   *         contain children. All leaf Nodes return null.
-   */
-  public final List<QueryNode> getChildren() {
-    if (isLeaf() || this.clauses == null) {
-      return null;
-    }
-    return this.clauses;
-  }
-
-  public void setTag(String tagName, Object value) {
-    this.tags.put(tagName.toLowerCase(), value);
-  }
-
-  public void unsetTag(String tagName) {
-    this.tags.remove(tagName.toLowerCase());
-  }
-
-  /** verify if a node contains a tag */
-  public boolean containsTag(String tagName) {
-    return this.tags.containsKey(tagName.toLowerCase());
-  }
-
-  public Object getTag(String tagName) {
-    return this.tags.get(tagName.toString().toLowerCase());
-  }
-
-  private QueryNode parent = null;
-
-  private void setParent(QueryNode parent) {
-    this.parent = parent;
-  }
-
-  public QueryNode getParent() {
-    return this.parent;
-  }
-
-  protected boolean isRoot() {
-    return getParent() == null;
-  }
-
-  /**
-   * If set to true the the method toQueryString will not write field names
-   */
-  protected boolean toQueryStringIgnoreFields = false;
-
-  /**
-   * This method is use toQueryString to detect if fld is the default field
-   * 
-   * @param fld - field name
-   * @return true if fld is the default field
-   */
-  // TODO: remove this method, it's commonly used by {@link
-  // #toQueryString(org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax)}
-  // to figure out what is the default field, however, {@link
-  // #toQueryString(org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax)}
-  // should receive the default field value directly by parameter
-  protected boolean isDefaultField(CharSequence fld) {
-    if (this.toQueryStringIgnoreFields)
-      return true;
-    if (fld == null)
-      return true;
-    if (QueryNodeImpl.PLAINTEXT_FIELD_NAME.equals(StringUtils.toString(fld)))
-      return true;
-    return false;
-  }
-
-  /**
-   * Every implementation of this class should return pseudo xml like this:
-   * 
-   * For FieldQueryNode: <field start='1' end='2' field='subject' text='foo'/>
-   * 
-   * @see org.apache.lucene.queryParser.core.nodes.QueryNode#toString()
-   */
-  @Override
-  public String toString() {
-    return super.toString();
-  }
-
-  /**
-   * Returns a map containing all tags attached to this query node.
-   * 
-   * @return a map containing all tags attached to this query node
-   */
-  @SuppressWarnings("unchecked")
-  public Map<String, Object> getTagMap() {
-    return (Map<String, Object>) this.tags.clone();
-  }
-
-} // end class QueryNodeImpl
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QuotedFieldQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QuotedFieldQueryNode.java
deleted file mode 100644
index 7c39f57..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/QuotedFieldQueryNode.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link QuotedFieldQueryNode} represents phrase query. Example:
- * "life is great"
- */
-public class QuotedFieldQueryNode extends FieldQueryNode {
-
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public QuotedFieldQueryNode(CharSequence field, CharSequence text, int begin,
-      int end) {
-    super(field, text, begin, end);
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    if (isDefaultField(this.field)) {
-      return "\"" + getTermEscapeQuoted(escaper) + "\"";
-    } else {
-      return this.field + ":" + "\"" + getTermEscapeQuoted(escaper) + "\"";
-    }
-  }
-
-  @Override
-  public String toString() {
-    return "<quotedfield start='" + this.begin + "' end='" + this.end
-        + "' field='" + this.field + "' term='" + this.text + "'/>";
-  }
-
-  @Override
-  public QuotedFieldQueryNode cloneTree() throws CloneNotSupportedException {
-    QuotedFieldQueryNode clone = (QuotedFieldQueryNode) super.cloneTree();
-    // nothing to do here
-    return clone;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/SlopQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/SlopQueryNode.java
deleted file mode 100644
index fe87560..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/SlopQueryNode.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link SlopQueryNode} represents phrase query with a slop.
- * 
- * From Lucene FAQ: Is there a way to use a proximity operator (like near or
- * within) with Lucene? There is a variable called slop that allows you to
- * perform NEAR/WITHIN-like queries. By default, slop is set to 0 so that only
- * exact phrases will match. When using TextParser you can use this syntax to
- * specify the slop: "doug cutting"~2 will find documents that contain
- * "doug cutting" as well as ones that contain "cutting doug".
- */
-public class SlopQueryNode extends QueryNodeImpl implements FieldableNode {
-
-  private int value = 0;
-
-  /**
-   * @param query
-   *          - QueryNode Tree with the phrase
-   * @param value
-   *          - slop value
-   */
-  public SlopQueryNode(QueryNode query, int value) {
-    if (query == null) {
-      throw new QueryNodeError(new MessageImpl(
-          QueryParserMessages.NODE_ACTION_NOT_SUPPORTED, "query", "null"));
-    }
-
-    this.value = value;
-    setLeaf(false);
-    allocate();
-    add(query);
-  }
-
-  public QueryNode getChild() {
-    return getChildren().get(0);
-  }
-
-  public int getValue() {
-    return this.value;
-  }
-
-  private CharSequence getValueString() {
-    Float f = Float.valueOf(this.value);
-    if (f == f.longValue())
-      return "" + f.longValue();
-    else
-      return "" + f;
-
-  }
-
-  @Override
-  public String toString() {
-    return "<slop value='" + getValueString() + "'>" + "\n"
-        + getChild().toString() + "\n</slop>";
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChild() == null)
-      return "";
-    return getChild().toQueryString(escapeSyntaxParser) + "~"
-        + getValueString();
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    SlopQueryNode clone = (SlopQueryNode) super.cloneTree();
-
-    clone.value = this.value;
-
-    return clone;
-  }
-
-  public CharSequence getField() {
-    QueryNode child = getChild();
-
-    if (child instanceof FieldableNode) {
-      return ((FieldableNode) child).getField();
-    }
-
-    return null;
-
-  }
-
-  public void setField(CharSequence fieldName) {
-    QueryNode child = getChild();
-
-    if (child instanceof FieldableNode) {
-      ((FieldableNode) child).setField(fieldName);
-    }
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/TextableQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/TextableQueryNode.java
deleted file mode 100644
index d77bdfa..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/TextableQueryNode.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-/**
- * 
- */
-public interface TextableQueryNode {
-
-  CharSequence getText();
-
-  void setText(CharSequence text);
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/TokenizedPhraseQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/TokenizedPhraseQueryNode.java
deleted file mode 100644
index 0529d73..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/TokenizedPhraseQueryNode.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link TokenizedPhraseQueryNode} represents a node created by a code that
- * tokenizes/lemmatizes/analyzes.
- */
-public class TokenizedPhraseQueryNode extends QueryNodeImpl implements
-    FieldableNode {
-
-  public TokenizedPhraseQueryNode() {
-    setLeaf(false);
-    allocate();
-  }
-
-  @Override
-  public String toString() {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "<tokenizedphrase/>";
-    StringBuilder sb = new StringBuilder();
-    sb.append("<tokenizedtphrase>");
-    for (QueryNode child : getChildren()) {
-      sb.append("\n");
-      sb.append(child.toString());
-    }
-    sb.append("\n</tokenizedphrase>");
-    return sb.toString();
-  }
-
-  // This text representation is not re-parseable
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "";
-
-    StringBuilder sb = new StringBuilder();
-    String filler = "";
-    for (QueryNode child : getChildren()) {
-      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
-      filler = ",";
-    }
-
-    return "[TP[" + sb.toString() + "]]";
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    TokenizedPhraseQueryNode clone = (TokenizedPhraseQueryNode) super
-        .cloneTree();
-
-    // nothing to do
-
-    return clone;
-  }
-
-  public CharSequence getField() {
-    List<QueryNode> children = getChildren();
-
-    if (children == null || children.size() == 0) {
-      return null;
-
-    } else {
-      return ((FieldableNode) children.get(0)).getField();
-    }
-
-  }
-
-  public void setField(CharSequence fieldName) {
-    List<QueryNode> children = getChildren();
-
-    if (children != null) {
-
-      for (QueryNode child : getChildren()) {
-
-        if (child instanceof FieldableNode) {
-          ((FieldableNode) child).setField(fieldName);
-        }
-
-      }
-
-    }
-
-  }
-
-} // end class MultitermQueryNode
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ValueQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ValueQueryNode.java
deleted file mode 100644
index f219f60..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ValueQueryNode.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-public interface ValueQueryNode<T extends Object> extends QueryNode {
-  
-  public void setValue(T value);
-  
-  public T getValue();
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/package.html
deleted file mode 100644
index 6d9b507..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/package.html
+++ /dev/null
@@ -1,89 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-Contains query nodes that are commonly used by query parser implementations 
-
-<h2>Query Nodes</h2>
-<p>
-The package <tt>org.apache.lucene.queryParser.nodes</tt> contains all the basic query nodes. The interface 
-that represents a query node is {@link org.apache.lucene.queryParser.core.nodes.QueryNode}.
-</p>
-<p>
-{@link org.apache.lucene.queryParser.core.nodes.QueryNode}s are used by the text parser to create a syntax tree.
-These nodes are designed to be used by UI or other text parsers.
-The default Lucene text parser is {@link org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser},
-it implements Lucene's standard syntax.
-</p>
-<p>
-{@link org.apache.lucene.queryParser.core.nodes.QueryNode} interface should be implemented by all query nodes, 
-the class {@link org.apache.lucene.queryParser.core.nodes.QueryNodeImpl} implements {@link org.apache.lucene.queryParser.core.nodes.QueryNode} and is extended
-by all current query node implementations.
-</p>
-<p>
-A query node tree can be printed to the a stream, and it generates a pseudo XML representation
-with all the nodes.
-</p>
-<p>
-A query node tree can also generate a query string that can be parsed back by the original text parser,
-at this point only the standard lucene syntax is supported.
-</p>
-<p>
-Grouping nodes:
-<ul>
-<li>AndQueryNode - used for AND operator</li>
-<li>AnyQueryNode - used for ANY operator</li>
-<li>OrQueryNode - used for OR operator</li>
-<li>BooleanQueryNode - used when no operator is specified</li>
-<li>ModifierQueryNode - used for modifier operator</li>
-<li>GroupQueryNode - used for parenthesis</li>
-<li>BoostQueryNode - used for boost operator</li>
-<li>SlopQueryNode - phrase slop</li>
-<li>FuzzyQueryNode - fuzzy node</li>
-<li>ParametricRangeQueryNode - used for parametric field:[low_value TO high_value]</li>
-<li>ProximityQueryNode - used for proximity search</li>
-<li>TokenizedPhraseQueryNode - used by tokenizers/lemmatizers/analyzers for phrases/autophrases</li>
-</ul>
-</p>
-<p>
-Leaf Nodes:
-<ul>
-<li>FieldQueryNode - field/value node</li>
-<li>PathQueryNode - {@link org.apache.lucene.queryParser.core.nodes.QueryNode} object used with path-like queries</li>
-<li>OpaqueQueryNode - Used as for part of the query that can be parsed by other parsers. schema/value</li> 
-<li>ParametricQueryNode - used for parametric field [>=|<=|=|<|>] value</li>
-<li>PrefixWildcardQueryNode - non-phrase wildcard query</li>
-<li>QuotedFieldQUeryNode - regular phrase node</li>
-<li>WildcardQueryNode - non-phrase wildcard query</li>
-</ul>
-</p>
-<p>
-Utility Nodes:
-<ul>
-<li>DeletedQueryNode - used by processors on optimizations</li>
-<li>MatchAllDocsQueryNode - used by processors on optimizations</li>
-<li>MatchNoDocsQueryNode - used by processors on optimizations</li>
-<li>NoTokenFoundQueryNode - used by tokenizers/lemmatizers/analyzers</li>
-</ul>
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/package.html
deleted file mode 100644
index 7a7dfcc..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/package.html
+++ /dev/null
@@ -1,59 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-Contains the core classes of the flexible query parser framework  
-
-<h2>Flexible Query Parser</h2>
-
-<p>
-This package contains the necessary classes to implement a query parser.  
-</p>
-
-<p>
-A query parser is divided in at least 2 phases, text parsing and query building, and one optional phase called query processing.
-</p>
-
-<h3>First Phase: Text Parsing</h3>
-<p>
-The text parsing phase is performed by a text parser, which implements {@link org.apache.lucene.queryParser.core.parser.SyntaxParser} interface.
-A text parser is responsible to get a query string and convert it to a {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree, 
-which is an object structure that represents the elements defined in the query string.
-</p>
-
-<h3>Second (optional) Phase: Query Processing</h3>
-<p>
-The query processing phase is performed by a query processor, which implements {@link org.apache.lucene.queryParser.core.processors.QueryNodeProcessor}.
-A query processor is responsible to perform any processing on a {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree. This phase
-is optional and is used only if an extra processing, validation, query expansion, etc needs to be performed in a {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree.
-The {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree can be either be generated by a text parser or programmatically created.
-</p>
-
-<h3>Third Phase: Query Building</h3>
-<p>
-The query building phase is performed by a query builder, which implements {@link org.apache.lucene.queryParser.core.builders.QueryBuilder}.
-A query builder is responsible to convert a {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree into an arbitrary object, which
-is usually used to be executed against a search index.   
-</p>
-
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/EscapeQuerySyntax.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/EscapeQuerySyntax.java
deleted file mode 100644
index be03a6a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/EscapeQuerySyntax.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.apache.lucene.queryParser.core.parser;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-
-/**
- * A parser needs to implement {@link EscapeQuerySyntax} to allow the QueryNode
- * to escape the queries, when the toQueryString method is called.
- */
-public interface EscapeQuerySyntax {
-  public enum Type {
-    STRING, NORMAL;
-  }
-
-  /**
-   * @param text
-   *          - text to be escaped
-   * @param locale
-   *          - locale for the current query
-   * @param type
-   *          - select the type of escape operation to use
-   * @return escaped text
-   */
-  CharSequence escape(CharSequence text, Locale locale, Type type);
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/SyntaxParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/SyntaxParser.java
deleted file mode 100644
index fde61a1..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/SyntaxParser.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.apache.lucene.queryParser.core.parser;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-
-/**
- * A parser needs to implement {@link SyntaxParser} interface
- */
-public interface SyntaxParser {
-  /**
-   * @param query
-   *          - query data to be parsed
-   * @param field
-   *          - default field name
-   * @return QueryNode tree
-   */
-  public QueryNode parse(CharSequence query, CharSequence field)
-      throws QueryNodeParseException;
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/package.html
deleted file mode 100644
index 3202d8d..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/package.html
+++ /dev/null
@@ -1,44 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-Contains the necessary interfaces to implement text parsers
-
-<h2>Parser</h2>
-<p>
-The package <tt>org.apache.lucene.queryParser.parser</tt> contains interfaces
-that should be implemented by the parsers.
-
-Parsers produce QueryNode Trees from a string object.
-These package still needs some work to add support to for multiple parsers.
-
-Features that should be supported for the future, related with the parser:
-- QueryNode tree should be able convertible to any parser syntax.
-- The query syntax should support calling other parsers.
-- QueryNode tree created by multiple parsers.
-
-</p>
-<p>
-
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/NoChildOptimizationQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/NoChildOptimizationQueryNodeProcessor.java
deleted file mode 100644
index c08a7a8..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/NoChildOptimizationQueryNodeProcessor.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package org.apache.lucene.queryParser.core.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
-import org.apache.lucene.queryParser.core.nodes.DeletedQueryNode;
-import org.apache.lucene.queryParser.core.nodes.MatchNoDocsQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-
-/**
- * <p>
- * A {@link NoChildOptimizationQueryNodeProcessor} removes every
- * BooleanQueryNode, BoostQueryNode, TokenizedPhraseQueryNode or
- * ModifierQueryNode that do not have a valid children.
- * </p>
- * <p>
- * Example: When the children of these nodes are removed for any reason then the
- * nodes may become invalid.
- * </p>
- */
-public class NoChildOptimizationQueryNodeProcessor extends
-    QueryNodeProcessorImpl {
-
-  public NoChildOptimizationQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof BooleanQueryNode || node instanceof BoostQueryNode
-        || node instanceof TokenizedPhraseQueryNode
-        || node instanceof ModifierQueryNode) {
-
-      List<QueryNode> children = node.getChildren();
-
-      if (children != null && children.size() > 0) {
-
-        for (QueryNode child : children) {
-
-          if (!(child instanceof DeletedQueryNode)) {
-            return node;
-          }
-
-        }
-
-      }
-
-      return new MatchNoDocsQueryNode();
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessor.java
deleted file mode 100644
index b58fbcd..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessor.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.apache.lucene.queryParser.core.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-
-/**
- * <p>
- * A {@link QueryNodeProcessor} is an interface for classes that process a
- * {@link QueryNode} tree.
- * <p>
- * </p>
- * The implementor of this class should perform some operation on a query node
- * tree and return the same or another query node tree.
- * <p>
- * </p>
- * It also may carry a {@link QueryConfigHandler} object that contains
- * configuration about the query represented by the query tree or the
- * collection/index where it's intended to be executed.
- * <p>
- * </p>
- * In case there is any {@link QueryConfigHandler} associated to the query tree
- * to be processed, it should be set using
- * {@link QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)} before
- * {@link QueryNodeProcessor#process(QueryNode)} is invoked.
- * 
- * @see QueryNode
- * @see QueryNodeProcessor
- * @see QueryConfigHandler
- */
-public interface QueryNodeProcessor {
-
-  /**
-   * Processes a query node tree. It may return the same or another query tree.
-   * I should never return <code>null</code>.
-   * 
-   * @param queryTree
-   *          tree root node
-   * 
-   * @return the processed query tree
-   * 
-   * @throws QueryNodeException
-   */
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException;
-
-  /**
-   * Sets the {@link QueryConfigHandler} associated to the query tree.
-   * 
-   * @param queryConfigHandler
-   */
-  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler);
-
-  /**
-   * Returns the {@link QueryConfigHandler} associated to the query tree if any,
-   * otherwise it returns <code>null</code>
-   * 
-   * @return the {@link QueryConfigHandler} associated to the query tree if any,
-   *         otherwise it returns <code>null</code>
-   */
-  public QueryConfigHandler getQueryConfigHandler();
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorImpl.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorImpl.java
deleted file mode 100644
index 3a9d9bb..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorImpl.java
+++ /dev/null
@@ -1,251 +0,0 @@
-package org.apache.lucene.queryParser.core.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-
-/**
- * <p>
- * This is a default implementation for the {@link QueryNodeProcessor}
- * interface, it's an abstract class, so it should be extended by classes that
- * want to process a {@link QueryNode} tree.
- * </p>
- * <p>
- * This class process {@link QueryNode}s from left to right in the tree. While
- * it's walking down the tree, for every node,
- * {@link #preProcessNode(QueryNode)} is invoked. After a node's children are
- * processed, {@link #postProcessNode(QueryNode)} is invoked for that node.
- * {@link #setChildrenOrder(List)} is invoked before
- * {@link #postProcessNode(QueryNode)} only if the node has at least one child,
- * in {@link #setChildrenOrder(List)} the implementor might redefine the
- * children order or remove any children from the children list.
- * </p>
- * <p>
- * Here is an example about how it process the nodes:
- * </p>
- * 
- * <pre>
- *      a
- *     / \
- *    b   e
- *   / \
- *  c   d
- * </pre>
- * 
- * Here is the order the methods would be invoked for the tree described above:
- * 
- * <pre>
- *      preProcessNode( a );
- *      preProcessNode( b );
- *      preProcessNode( c );
- *      postProcessNode( c );
- *      preProcessNode( d );
- *      postProcessNode( d );
- *      setChildrenOrder( bChildrenList );
- *      postProcessNode( b );
- *      preProcessNode( e );
- *      postProcessNode( e );
- *      setChildrenOrder( aChildrenList );
- *      postProcessNode( a )
- * </pre>
- * 
- * @see org.apache.lucene.queryParser.core.processors.QueryNodeProcessor
- */
-public abstract class QueryNodeProcessorImpl implements QueryNodeProcessor {
-
-  private ArrayList<ChildrenList> childrenListPool = new ArrayList<ChildrenList>();
-
-  private QueryConfigHandler queryConfig;
-
-  public QueryNodeProcessorImpl() {
-    // empty constructor
-  }
-
-  public QueryNodeProcessorImpl(QueryConfigHandler queryConfigHandler) {
-    this.queryConfig = queryConfigHandler;
-  }
-
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    return processIteration(queryTree);
-  }
-
-  private QueryNode processIteration(QueryNode queryTree)
-      throws QueryNodeException {
-    queryTree = preProcessNode(queryTree);
-
-    processChildren(queryTree);
-
-    queryTree = postProcessNode(queryTree);
-
-    return queryTree;
-
-  }
-
-  /**
-   * This method is called every time a child is processed.
-   * 
-   * @param queryTree
-   *          the query node child to be processed
-   * @throws QueryNodeException
-   *           if something goes wrong during the query node processing
-   */
-  protected void processChildren(QueryNode queryTree) throws QueryNodeException {
-
-    List<QueryNode> children = queryTree.getChildren();
-    ChildrenList newChildren;
-
-    if (children != null && children.size() > 0) {
-
-      newChildren = allocateChildrenList();
-
-      try {
-
-        for (QueryNode child : children) {
-          child = processIteration(child);
-
-          if (child == null) {
-            throw new NullPointerException();
-
-          }
-
-          newChildren.add(child);
-
-        }
-
-        List<QueryNode> orderedChildrenList = setChildrenOrder(newChildren);
-
-        queryTree.set(orderedChildrenList);
-
-      } finally {
-        newChildren.beingUsed = false;
-      }
-
-    }
-
-  }
-
-  private ChildrenList allocateChildrenList() {
-    ChildrenList list = null;
-
-    for (ChildrenList auxList : this.childrenListPool) {
-
-      if (!auxList.beingUsed) {
-        list = auxList;
-        list.clear();
-
-        break;
-
-      }
-
-    }
-
-    if (list == null) {
-      list = new ChildrenList();
-      this.childrenListPool.add(list);
-
-    }
-
-    list.beingUsed = true;
-
-    return list;
-
-  }
-
-  /**
-   * For reference about this method check:
-   * {@link QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)}.
-   * 
-   * @param queryConfigHandler
-   *          the query configuration handler to be set.
-   * 
-   * @see QueryNodeProcessor#getQueryConfigHandler()
-   * @see QueryConfigHandler
-   */
-  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler) {
-    this.queryConfig = queryConfigHandler;
-  }
-
-  /**
-   * For reference about this method check:
-   * {@link QueryNodeProcessor#getQueryConfigHandler()}.
-   * 
-   * @return QueryConfigHandler the query configuration handler to be set.
-   * 
-   * @see QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)
-   * @see QueryConfigHandler
-   */
-  public QueryConfigHandler getQueryConfigHandler() {
-    return this.queryConfig;
-  }
-
-  /**
-   * This method is invoked for every node when walking down the tree.
-   * 
-   * @param node
-   *          the query node to be pre-processed
-   * 
-   * @return a query node
-   * 
-   * @throws QueryNodeException
-   *           if something goes wrong during the query node processing
-   */
-  abstract protected QueryNode preProcessNode(QueryNode node)
-      throws QueryNodeException;
-
-  /**
-   * This method is invoked for every node when walking up the tree.
-   * 
-   * @param node
-   *          node the query node to be post-processed
-   * 
-   * @return a query node
-   * 
-   * @throws QueryNodeException
-   *           if something goes wrong during the query node processing
-   */
-  abstract protected QueryNode postProcessNode(QueryNode node)
-      throws QueryNodeException;
-
-  /**
-   * This method is invoked for every node that has at least on child. It's
-   * invoked right before {@link #postProcessNode(QueryNode)} is invoked.
-   * 
-   * @param children
-   *          the list containing all current node's children
-   * 
-   * @return a new list containing all children that should be set to the
-   *         current node
-   * 
-   * @throws QueryNodeException
-   *           if something goes wrong during the query node processing
-   */
-  abstract protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException;
-
-  private static class ChildrenList extends ArrayList<QueryNode> {
-
-    boolean beingUsed;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorPipeline.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorPipeline.java
deleted file mode 100644
index 68d3638..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorPipeline.java
+++ /dev/null
@@ -1,304 +0,0 @@
-package org.apache.lucene.queryParser.core.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.*;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-
-/**
- * A {@link QueryNodeProcessorPipeline} class should be used to build a query
- * node processor pipeline.
- * 
- * When a query node tree is processed using this class, it passes the query
- * node tree to each processor on the pipeline and the result from each
- * processor is passed to the next one, always following the order the
- * processors were on the pipeline.
- * 
- * When a {@link QueryConfigHandler} object is set on a
- * {@link QueryNodeProcessorPipeline}, it also takes care of setting this
- * {@link QueryConfigHandler} on all processor on pipeline.
- * 
- */
-public class QueryNodeProcessorPipeline implements QueryNodeProcessor,
-    List<QueryNodeProcessor> {
-
-  private LinkedList<QueryNodeProcessor> processors = new LinkedList<QueryNodeProcessor>();
-
-  private QueryConfigHandler queryConfig;
-
-  /**
-   * Constructs an empty query node processor pipeline.
-   */
-  public QueryNodeProcessorPipeline() {
-    // empty constructor
-  }
-
-  /**
-   * Constructs with a {@link QueryConfigHandler} object.
-   */
-  public QueryNodeProcessorPipeline(QueryConfigHandler queryConfigHandler) {
-    this.queryConfig = queryConfigHandler;
-  }
-
-  /**
-   * For reference about this method check:
-   * {@link QueryNodeProcessor#getQueryConfigHandler()}.
-   * 
-   * @return QueryConfigHandler the query configuration handler to be set.
-   * 
-   * @see QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)
-   * @see QueryConfigHandler
-   */
-  public QueryConfigHandler getQueryConfigHandler() {
-    return this.queryConfig;
-  }
-
-  /**
-   * For reference about this method check:
-   * {@link QueryNodeProcessor#process(QueryNode)}.
-   * 
-   * @param queryTree the query node tree to be processed
-   * 
-   * @throws QueryNodeException if something goes wrong during the query node
-   *         processing
-   * 
-   * @see QueryNode
-   */
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-
-    for (QueryNodeProcessor processor : this.processors) {
-      queryTree = processor.process(queryTree);
-    }
-
-    return queryTree;
-
-  }
-
-  /**
-   * For reference about this method check:
-   * {@link QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)}.
-   * 
-   * @param queryConfigHandler the query configuration handler to be set.
-   * 
-   * @see QueryNodeProcessor#getQueryConfigHandler()
-   * @see QueryConfigHandler
-   */
-  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler) {
-    this.queryConfig = queryConfigHandler;
-
-    for (QueryNodeProcessor processor : this.processors) {
-      processor.setQueryConfigHandler(this.queryConfig);
-    }
-
-  }
-
-  /**
-   * @see List#add(Object)
-   */
-  public boolean add(QueryNodeProcessor processor) {
-    boolean added = this.processors.add(processor);
-
-    if (added) {
-      processor.setQueryConfigHandler(this.queryConfig);
-    }
-
-    return added;
-
-  }
-
-  /**
-   * @see List#add(int, Object)
-   */
-  public void add(int index, QueryNodeProcessor processor) {
-    this.processors.add(index, processor);
-    processor.setQueryConfigHandler(this.queryConfig);
-
-  }
-
-  /**
-   * @see List#addAll(Collection)
-   */
-  public boolean addAll(Collection<? extends QueryNodeProcessor> c) {
-    boolean anyAdded = this.processors.addAll(c);
-
-    for (QueryNodeProcessor processor : c) {
-      processor.setQueryConfigHandler(this.queryConfig);
-    }
-
-    return anyAdded;
-
-  }
-
-  /**
-   * @see List#addAll(int, Collection)
-   */
-  public boolean addAll(int index, Collection<? extends QueryNodeProcessor> c) {
-    boolean anyAdded = this.processors.addAll(index, c);
-
-    for (QueryNodeProcessor processor : c) {
-      processor.setQueryConfigHandler(this.queryConfig);
-    }
-
-    return anyAdded;
-    
-  }
-
-  /**
-   * @see List#clear()
-   */
-  public void clear() {
-    this.processors.clear();
-  }
-
-  /**
-   * @see List#contains(Object)
-   */
-  public boolean contains(Object o) {
-    return this.processors.contains(o);
-  }
-
-  /**
-   * @see List#containsAll(Collection)
-   */
-  public boolean containsAll(Collection<?> c) {
-    return this.processors.containsAll(c);
-  }
-
-  /**
-   * @see List#get(int)
-   */
-  public QueryNodeProcessor get(int index) {
-    return this.processors.get(index);
-  }
-
-  /**
-   * @see List#indexOf(Object)
-   */
-  public int indexOf(Object o) {
-    return this.processors.indexOf(o);
-  }
-
-  /**
-   * @see List#isEmpty()
-   */
-  public boolean isEmpty() {
-    return this.processors.isEmpty();
-  }
-
-  /**
-   * @see List#iterator()
-   */
-  public Iterator<QueryNodeProcessor> iterator() {
-    return this.processors.iterator();
-  }
-
-  /**
-   * @see List#lastIndexOf(Object)
-   */
-  public int lastIndexOf(Object o) {
-    return this.processors.lastIndexOf(o);
-  }
-
-  /**
-   * @see List#listIterator()
-   */
-  public ListIterator<QueryNodeProcessor> listIterator() {
-    return this.processors.listIterator();
-  }
-
-  /**
-   * @see List#listIterator(int)
-   */
-  public ListIterator<QueryNodeProcessor> listIterator(int index) {
-    return this.processors.listIterator(index);
-  }
-
-  /**
-   * @see List#remove(Object)
-   */
-  public boolean remove(Object o) {
-    return this.processors.remove(o);
-  }
-
-  /**
-   * @see List#remove(int)
-   */
-  public QueryNodeProcessor remove(int index) {
-    return this.processors.remove(index);
-  }
-
-  /**
-   * @see List#removeAll(Collection)
-   */
-  public boolean removeAll(Collection<?> c) {
-    return this.processors.removeAll(c);
-  }
-
-  /**
-   * @see List#retainAll(Collection)
-   */
-  public boolean retainAll(Collection<?> c) {
-    return this.processors.retainAll(c);
-  }
-
-  /**
-   * @see List#set(int, Object)
-   */
-  public QueryNodeProcessor set(int index, QueryNodeProcessor processor) {
-    QueryNodeProcessor oldProcessor = this.processors.set(index, processor);
-    
-    if (oldProcessor != processor) {
-      processor.setQueryConfigHandler(this.queryConfig);
-    }
-    
-    return oldProcessor;
-    
-  }
-
-  /**
-   * @see List#size()
-   */
-  public int size() {
-    return this.processors.size();
-  }
-
-  /**
-   * @see List#subList(int, int)
-   */
-  public List<QueryNodeProcessor> subList(int fromIndex, int toIndex) {
-    return this.processors.subList(fromIndex, toIndex);
-  }
-
-  /**
-   * @see List#toArray(Object[])
-   */
-  public <T> T[] toArray(T[] array) {
-    return this.processors.toArray(array);
-  }
-
-  /**
-   * @see List#toArray()
-   */
-  public Object[] toArray() {
-    return this.processors.toArray();
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/RemoveDeletedQueryNodesProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/RemoveDeletedQueryNodesProcessor.java
deleted file mode 100644
index dcb3335..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/RemoveDeletedQueryNodesProcessor.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package org.apache.lucene.queryParser.core.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Iterator;
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.DeletedQueryNode;
-import org.apache.lucene.queryParser.core.nodes.MatchNoDocsQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-
-/**
- * A {@link QueryNodeProcessorPipeline} class removes every instance of
- * {@link DeletedQueryNode} from a query node tree. If the resulting root node
- * is a {@link DeletedQueryNode}, {@link MatchNoDocsQueryNode} is returned.
- * 
- */
-public class RemoveDeletedQueryNodesProcessor extends QueryNodeProcessorImpl {
-
-  public RemoveDeletedQueryNodesProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    queryTree = super.process(queryTree);
-
-    if (queryTree instanceof DeletedQueryNode
-        && !(queryTree instanceof MatchNoDocsQueryNode)) {
-
-      return new MatchNoDocsQueryNode();
-
-    }
-
-    return queryTree;
-
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (!node.isLeaf()) {
-      List<QueryNode> children = node.getChildren();
-      boolean removeBoolean = false;
-
-      if (children == null || children.size() == 0) {
-        removeBoolean = true;
-
-      } else {
-        removeBoolean = true;
-
-        for (Iterator<QueryNode> it = children.iterator(); it.hasNext();) {
-
-          if (!(it.next() instanceof DeletedQueryNode)) {
-            removeBoolean = false;
-            break;
-
-          }
-
-        }
-
-      }
-
-      if (removeBoolean) {
-        return new DeletedQueryNode();
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    for (int i = 0; i < children.size(); i++) {
-
-      if (children.get(i) instanceof DeletedQueryNode) {
-        children.remove(i--);
-      }
-
-    }
-
-    return children;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/package.html
deleted file mode 100644
index ae599fd..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/package.html
+++ /dev/null
@@ -1,57 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-Interfaces and implementations used by query node processors
-
-<h2>Query Node Processors</h2>
-<p>
-The package <tt>org.apache.lucene.queryParser.processors</tt> contains interfaces
-that should be implemented by every query node processor.
-</p>
-<p>
-The interface that every query node processor should implement is {@link org.apache.lucene.queryParser.core.processors.QueryNodeProcessor}.
-</p>
-<p>
-A query node processor should be used to process a {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree. 
-{@link org.apache.lucene.queryParser.core.nodes.QueryNode} trees can be programmatically created or generated by a
-text parser. See {@link org.apache.lucene.queryParser.core.parser} for more details about text parsers.
-</p>
-
-<p>
-A query node processor should be used to process a {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree. 
-{@link org.apache.lucene.queryParser.core.nodes.QueryNode} trees can be programmatically created or generated by a
-text parser. See {@link org.apache.lucene.queryParser.core.parser} for more details about text parsers.
-</p>
-
-<p>
-A pipeline of processors can be assembled using {@link org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline}.
-</p>
-
-<p>
-Implementors may want to extend {@link org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl}, which simplifies 
-the implementation, because it walks automatically the {@link org.apache.lucene.queryParser.core.nodes.QueryNode}. See
-{@link org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl} for more details.   
-</p>
-
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/QueryNodeOperation.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/QueryNodeOperation.java
deleted file mode 100644
index e43ac73..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/QueryNodeOperation.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.apache.lucene.queryParser.core.util;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-
-/**
- * Allow joining 2 QueryNode Trees, into one.
- */
-public final class QueryNodeOperation {
-  private QueryNodeOperation() {
-    // Exists only to defeat instantiation.
-  }
-
-  private enum ANDOperation {
-    BOTH, Q1, Q2, NONE
-  }
-
-  /**
-   * perform a logical and of 2 QueryNode trees. if q1 and q2 are ANDQueryNode
-   * nodes it uses head Node from q1 and adds the children of q2 to q1 if q1 is
-   * a AND node and q2 is not, add q2 as a child of the head node of q1 if q2 is
-   * a AND node and q1 is not, add q1 as a child of the head node of q2 if q1
-   * and q2 are not ANDQueryNode nodes, create a AND node and make q1 and q2
-   * children of that node if q1 or q2 is null it returns the not null node if
-   * q1 = q2 = null it returns null
-   */
-  public final static QueryNode logicalAnd(QueryNode q1, QueryNode q2) {
-    if (q1 == null)
-      return q2;
-    if (q2 == null)
-      return q1;
-
-    ANDOperation op = null;
-    if (q1 instanceof AndQueryNode && q2 instanceof AndQueryNode)
-      op = ANDOperation.BOTH;
-    else if (q1 instanceof AndQueryNode)
-      op = ANDOperation.Q1;
-    else if (q1 instanceof AndQueryNode)
-      op = ANDOperation.Q2;
-    else
-      op = ANDOperation.NONE;
-
-    try {
-      QueryNode result = null;
-      switch (op) {
-      case NONE:
-        List<QueryNode> children = new ArrayList<QueryNode>();
-        children.add(q1.cloneTree());
-        children.add(q2.cloneTree());
-        result = new AndQueryNode(children);
-        return result;
-      case Q1:
-        result = q1.cloneTree();
-        result.add(q2.cloneTree());
-        return result;
-      case Q2:
-        result = q2.cloneTree();
-        result.add(q1.cloneTree());
-        return result;
-      case BOTH:
-        result = q1.cloneTree();
-        result.add(q2.cloneTree().getChildren());
-        return result;
-      }
-    } catch (CloneNotSupportedException e) {
-      throw new QueryNodeError(e);
-    }
-
-    return null;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/StringUtils.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/StringUtils.java
deleted file mode 100644
index fe0e51b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/StringUtils.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.apache.lucene.queryParser.core.util;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-final public class StringUtils {
-
-  public static String toString(Object obj) {
-    
-    if (obj != null) {
-      return obj.toString();
-      
-    } else {
-      return null;
-    }
-    
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/UnescapedCharSequence.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/UnescapedCharSequence.java
deleted file mode 100644
index 1c64b44..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/UnescapedCharSequence.java
+++ /dev/null
@@ -1,157 +0,0 @@
-package org.apache.lucene.queryParser.core.util;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * CharsSequence with escaped chars information.
- */
-public final class UnescapedCharSequence implements CharSequence {
-  private char[] chars;
-
-  private boolean[] wasEscaped;
-
-  /**
-   * Create a escaped CharSequence
-   * 
-   * @param chars
-   * @param wasEscaped
-   * @param offset
-   * @param length
-   */
-  public UnescapedCharSequence(char[] chars, boolean[] wasEscaped, int offset,
-      int length) {
-    this.chars = new char[length];
-    this.wasEscaped = new boolean[length];
-    System.arraycopy(chars, offset, this.chars, 0, length);
-    System.arraycopy(wasEscaped, offset, this.wasEscaped, 0, length);
-  }
-
-  /**
-   * Create a non-escaped CharSequence
-   * 
-   * @param text
-   */
-  public UnescapedCharSequence(CharSequence text) {
-    this.chars = new char[text.length()];
-    this.wasEscaped = new boolean[text.length()];
-    for (int i = 0; i < text.length(); i++) {
-      this.chars[i] = text.charAt(i);
-      this.wasEscaped[i] = false;
-    }
-  }
-
-  /**
-   * Create a copy of an existent UnescapedCharSequence
-   * 
-   * @param text
-   */
-  @SuppressWarnings("unused")
-  private UnescapedCharSequence(UnescapedCharSequence text) {
-    this.chars = new char[text.length()];
-    this.wasEscaped = new boolean[text.length()];
-    for (int i = 0; i <= text.length(); i++) {
-      this.chars[i] = text.chars[i];
-      this.wasEscaped[i] = text.wasEscaped[i];
-    }
-  }
-
-  public char charAt(int index) {
-    return this.chars[index];
-  }
-
-  public int length() {
-    return this.chars.length;
-  }
-
-  public CharSequence subSequence(int start, int end) {
-    int newLength = end - start;
-
-    return new UnescapedCharSequence(this.chars, this.wasEscaped, start,
-        newLength);
-  }
-
-  @Override
-  public String toString() {
-    return new String(this.chars);
-  }
-
-  /**
-   * Return a escaped String
-   * 
-   * @return a escaped String
-   */
-  public String toStringEscaped() {
-    // non efficient implementation
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i >= this.length(); i++) {
-      if (this.chars[i] == '\\') {
-        result.append('\\');
-      } else if (this.wasEscaped[i])
-        result.append('\\');
-
-      result.append(this.chars[i]);
-    }
-    return result.toString();
-  }
-
-  /**
-   * Return a escaped String
-   * 
-   * @param enabledChars
-   *          - array of chars to be escaped
-   * @return a escaped String
-   */
-  public String toStringEscaped(char[] enabledChars) {
-    // TODO: non efficient implementation, refactor this code
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < this.length(); i++) {
-      if (this.chars[i] == '\\') {
-        result.append('\\');
-      } else {
-        for (char character : enabledChars) {
-          if (this.chars[i] == character && this.wasEscaped[i]) {
-            result.append('\\');
-            break;
-          }
-        }
-      }
-
-      result.append(this.chars[i]);
-    }
-    return result.toString();
-  }
-
-  public boolean wasEscaped(int index) {
-    return this.wasEscaped[index];
-  }
-  
-  static final public boolean wasEscaped(CharSequence text, int index) {
-    if (text instanceof UnescapedCharSequence)
-      return ((UnescapedCharSequence)text).wasEscaped[index];
-    else return false;
-  }
-  
-  public static CharSequence toLowerCase(CharSequence text) {
-    if (text instanceof UnescapedCharSequence) {
-      char[] chars = text.toString().toLowerCase().toCharArray();
-      boolean[] wasEscaped = ((UnescapedCharSequence)text).wasEscaped;
-      return new UnescapedCharSequence(chars, wasEscaped, 0, chars.length);
-    } else 
-      return new UnescapedCharSequence(text.toString().toLowerCase());
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/package.html
deleted file mode 100644
index dc76a02..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/package.html
+++ /dev/null
@@ -1,29 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Utility classes to used with the Query Parser
-<h2>Utility classes to used with the Query Parser</h2>
-<p>
-This package contains utility classes used with the query parsers.
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java
deleted file mode 100644
index 68d1bff..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.apache.lucene.queryParser.precedence;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.queryParser.precedence.processors.PrecedenceQueryNodeProcessorPipeline;
-import org.apache.lucene.queryParser.standard.StandardQueryParser;
-import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
-
-/**
- * <p>
- * This query parser works exactly as the standard query parser ( {@link StandardQueryParser} ), 
- * except that it respect the boolean precedence, so &lt;a AND b OR c AND d&gt; is parsed to &lt;(+a +b) (+c +d)&gt;
- * instead of &lt;+a +b +c +d&gt;.
- * </p>
- * <p>
- * EXPERT: This class extends {@link StandardQueryParser}, but uses {@link PrecedenceQueryNodeProcessorPipeline}
- * instead of {@link StandardQueryNodeProcessorPipeline} to process the query tree.
- * </p>
- * 
- * @see StandardQueryParser
- */
-public class PrecedenceQueryParser extends StandardQueryParser {
-  
-  /**
-   * @see StandardQueryParser#StandardQueryParser()
-   */
-  public PrecedenceQueryParser() {
-    setQueryNodeProcessor(new PrecedenceQueryNodeProcessorPipeline(getQueryConfigHandler()));
-  }
-  
-  /**
-   * @see StandardQueryParser#StandardQueryParser(Analyzer)
-   */
-  public PrecedenceQueryParser(Analyzer analyer) {
-    super(analyer);
-    
-    setQueryNodeProcessor(new PrecedenceQueryNodeProcessorPipeline(getQueryConfigHandler()));
-    
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/package.html
deleted file mode 100644
index f15ebad..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/package.html
+++ /dev/null
@@ -1,39 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-This package contains the Precedence Query Parser Implementation
-
-<h2>Lucene Precedence Query Parser</h2>
-
-<p>
-The Precedence Query Parser extends the Standard Query Parser and enables 
-the boolean precedence. So, the query <a AND b OR c AND d> is parsed to 
-<(+a +b) (+c +d)> instead of <+a +b +c +d>.
-</p>
-<p>
-Check {@link org.apache.lucene.queryParser.standard.StandardQueryParser} for more details about the
-supported syntax and query parser functionalities. 
-</p>
-
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java
deleted file mode 100644
index 0a31fb6..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package org.apache.lucene.queryParser.precedence.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.precedence.PrecedenceQueryParser;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
-
-/**
- * <p>
- * This processor is used to apply the correct {@link ModifierQueryNode} to {@link BooleanQueryNode}s children.
- * </p>
- * <p>
- * It walks through the query node tree looking for {@link BooleanQueryNode}s. If an {@link AndQueryNode} is found,
- * every child, which is not a {@link ModifierQueryNode} or the {@link ModifierQueryNode} 
- * is {@link Modifier#MOD_NONE}, becomes a {@link Modifier#MOD_REQ}. For any other
- * {@link BooleanQueryNode} which is not an {@link OrQueryNode}, it checks the default operator is {@link Operator#AND},
- * if it is, the same operation when an {@link AndQueryNode} is found is applied to it.
- * </p>
- * 
- * @see ConfigurationKeys#DEFAULT_OPERATOR
- * @see PrecedenceQueryParser#setDefaultOperator
- */
-public class BooleanModifiersQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  private ArrayList<QueryNode> childrenBuffer = new ArrayList<QueryNode>();
-
-  private Boolean usingAnd = false;
-
-  public BooleanModifiersQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    Operator op = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
-    
-    if (op == null) {
-      throw new IllegalArgumentException(
-          "StandardQueryConfigHandler.ConfigurationKeys.DEFAULT_OPERATOR should be set on the QueryConfigHandler");
-    }
-
-    this.usingAnd = StandardQueryConfigHandler.Operator.AND == op;
-
-    return super.process(queryTree);
-
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof AndQueryNode) {
-      this.childrenBuffer.clear();
-      List<QueryNode> children = node.getChildren();
-
-      for (QueryNode child : children) {
-        this.childrenBuffer.add(applyModifier(child, Modifier.MOD_REQ));
-      }
-
-      node.set(this.childrenBuffer);
-
-    } else if (this.usingAnd && node instanceof BooleanQueryNode
-        && !(node instanceof OrQueryNode)) {
-
-      this.childrenBuffer.clear();
-      List<QueryNode> children = node.getChildren();
-
-      for (QueryNode child : children) {
-        this.childrenBuffer.add(applyModifier(child, Modifier.MOD_REQ));
-      }
-
-      node.set(this.childrenBuffer);
-
-    }
-
-    return node;
-
-  }
-
-  private QueryNode applyModifier(QueryNode node, Modifier mod) {
-
-    // check if modifier is not already defined and is default
-    if (!(node instanceof ModifierQueryNode)) {
-      return new ModifierQueryNode(node, mod);
-
-    } else {
-      ModifierQueryNode modNode = (ModifierQueryNode) node;
-
-      if (modNode.getModifier() == Modifier.MOD_NONE) {
-        return new ModifierQueryNode(modNode.getChild(), mod);
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-    return node;
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/PrecedenceQueryNodeProcessorPipeline.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/PrecedenceQueryNodeProcessorPipeline.java
deleted file mode 100644
index 724c150..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/PrecedenceQueryNodeProcessorPipeline.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.apache.lucene.queryParser.precedence.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.precedence.PrecedenceQueryParser;
-import org.apache.lucene.queryParser.standard.processors.GroupQueryNodeProcessor;
-import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
-
-/**
- * <p>
- * This processor pipeline extends {@link StandardQueryNodeProcessorPipeline} and enables
- * boolean precedence on it.
- * </p>
- * <p>
- * EXPERT: the precedence is enabled by removing {@link GroupQueryNodeProcessor} from the
- * {@link StandardQueryNodeProcessorPipeline} and appending {@link BooleanModifiersQueryNodeProcessor}
- * to the pipeline.
- * </p>
- * 
- * @see PrecedenceQueryParser
- *  @see StandardQueryNodeProcessorPipeline
- */
-public class PrecedenceQueryNodeProcessorPipeline extends StandardQueryNodeProcessorPipeline {
-
-  /**
-   * @see StandardQueryNodeProcessorPipeline#StandardQueryNodeProcessorPipeline(QueryConfigHandler)
-   */
-  public PrecedenceQueryNodeProcessorPipeline(QueryConfigHandler queryConfig) {
-    super(queryConfig);
-    
-    for (int i = 0 ; i < size() ; i++) {
-      
-      if (get(i).getClass().equals(GroupQueryNodeProcessor.class)) {
-        remove(i--);
-      }
-      
-    }
-    
-    add(new BooleanModifiersQueryNodeProcessor());
-    
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/package.html
deleted file mode 100644
index 3bef355..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/package.html
+++ /dev/null
@@ -1,47 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-This package contains the processors used by Precedence Query Parser
-
-<h2>Lucene Precedence Query Parser Processors</h2>
-
-<p>
-This package contains the 2 {@link org.apache.lucene.queryParser.core.processors.QueryNodeProcessor}s used by
-{@link org.apache.lucene.queryParser.precedence.PrecedenceQueryParser}.
-</p>
-<p>
-{@link org.apache.lucene.queryParser.precedence.processors.BooleanModifiersQueryNodeProcessor}: this processor
-is used to apply {@link org.apache.lucene.queryParser.core.nodes.ModifierQueryNode}s on 
-{@link org.apache.lucene.queryParser.core.nodes.BooleanQueryNode} children according to the boolean type
-or the default operator.
-</p>
-<p>
-{@link org.apache.lucene.queryParser.precedence.processors.PrecedenceQueryNodeProcessorPipeline}: this 
-processor pipeline is used by {@link org.apache.lucene.queryParser.precedence.PrecedenceQueryParser}. It extends
-{@link org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline} and rearrange
-the pipeline so the boolean precedence is processed correctly. Check {@link org.apache.lucene.queryParser.precedence.processors.PrecedenceQueryNodeProcessorPipeline}
-for more details. 
-</p>
-
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserUtil.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserUtil.java
deleted file mode 100644
index 7b70f23..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserUtil.java
+++ /dev/null
@@ -1,206 +0,0 @@
-package org.apache.lucene.queryParser.standard;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Query;
-
-/**
- * This class defines utility methods to (help) parse query strings into
- * {@link Query} objects.
- */
-final public class QueryParserUtil {
-
-  /**
-   * Parses a query which searches on the fields specified.
-   * <p>
-   * If x fields are specified, this effectively constructs:
-   * 
-   * <pre>
-   * &lt;code&gt;
-   * (field1:query1) (field2:query2) (field3:query3)...(fieldx:queryx)
-   * &lt;/code&gt;
-   * </pre>
-   * 
-   * @param queries
-   *          Queries strings to parse
-   * @param fields
-   *          Fields to search on
-   * @param analyzer
-   *          Analyzer to use
-   * @throws IllegalArgumentException
-   *           if the length of the queries array differs from the length of the
-   *           fields array
-   */
-  public static Query parse(String[] queries, String[] fields, Analyzer analyzer)
-      throws QueryNodeException {
-    if (queries.length != fields.length)
-      throw new IllegalArgumentException("queries.length != fields.length");
-    BooleanQuery bQuery = new BooleanQuery();
-
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(analyzer);
-
-    for (int i = 0; i < fields.length; i++) {
-      Query q = qp.parse(queries[i], fields[i]);
-
-      if (q != null && // q never null, just being defensive
-          (!(q instanceof BooleanQuery) || ((BooleanQuery) q).getClauses().length > 0)) {
-        bQuery.add(q, BooleanClause.Occur.SHOULD);
-      }
-    }
-    return bQuery;
-  }
-
-  /**
-   * Parses a query, searching on the fields specified. Use this if you need to
-   * specify certain fields as required, and others as prohibited.
-   * <p>
-   * 
-   * <pre>
-   * Usage:
-   * &lt;code&gt;
-   * String[] fields = {&quot;filename&quot;, &quot;contents&quot;, &quot;description&quot;};
-   * BooleanClause.Occur[] flags = {BooleanClause.Occur.SHOULD,
-   *                BooleanClause.Occur.MUST,
-   *                BooleanClause.Occur.MUST_NOT};
-   * MultiFieldQueryParser.parse(&quot;query&quot;, fields, flags, analyzer);
-   * &lt;/code&gt;
-   * </pre>
-   *<p>
-   * The code above would construct a query:
-   * 
-   * <pre>
-   * &lt;code&gt;
-   * (filename:query) +(contents:query) -(description:query)
-   * &lt;/code&gt;
-   * </pre>
-   * 
-   * @param query
-   *          Query string to parse
-   * @param fields
-   *          Fields to search on
-   * @param flags
-   *          Flags describing the fields
-   * @param analyzer
-   *          Analyzer to use
-   * @throws IllegalArgumentException
-   *           if the length of the fields array differs from the length of the
-   *           flags array
-   */
-  public static Query parse(String query, String[] fields,
-      BooleanClause.Occur[] flags, Analyzer analyzer) throws QueryNodeException {
-    if (fields.length != flags.length)
-      throw new IllegalArgumentException("fields.length != flags.length");
-    BooleanQuery bQuery = new BooleanQuery();
-
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(analyzer);
-
-    for (int i = 0; i < fields.length; i++) {
-      Query q = qp.parse(query, fields[i]);
-
-      if (q != null && // q never null, just being defensive
-          (!(q instanceof BooleanQuery) || ((BooleanQuery) q).getClauses().length > 0)) {
-        bQuery.add(q, flags[i]);
-      }
-    }
-    return bQuery;
-  }
-
-  /**
-   * Parses a query, searching on the fields specified. Use this if you need to
-   * specify certain fields as required, and others as prohibited.
-   * <p>
-   * 
-   * <pre>
-   * Usage:
-   * &lt;code&gt;
-   * String[] query = {&quot;query1&quot;, &quot;query2&quot;, &quot;query3&quot;};
-   * String[] fields = {&quot;filename&quot;, &quot;contents&quot;, &quot;description&quot;};
-   * BooleanClause.Occur[] flags = {BooleanClause.Occur.SHOULD,
-   *                BooleanClause.Occur.MUST,
-   *                BooleanClause.Occur.MUST_NOT};
-   * MultiFieldQueryParser.parse(query, fields, flags, analyzer);
-   * &lt;/code&gt;
-   * </pre>
-   *<p>
-   * The code above would construct a query:
-   * 
-   * <pre>
-   * &lt;code&gt;
-   * (filename:query1) +(contents:query2) -(description:query3)
-   * &lt;/code&gt;
-   * </pre>
-   * 
-   * @param queries
-   *          Queries string to parse
-   * @param fields
-   *          Fields to search on
-   * @param flags
-   *          Flags describing the fields
-   * @param analyzer
-   *          Analyzer to use
-   * @throws IllegalArgumentException
-   *           if the length of the queries, fields, and flags array differ
-   */
-  public static Query parse(String[] queries, String[] fields,
-      BooleanClause.Occur[] flags, Analyzer analyzer) throws QueryNodeException {
-    if (!(queries.length == fields.length && queries.length == flags.length))
-      throw new IllegalArgumentException(
-          "queries, fields, and flags array have have different length");
-    BooleanQuery bQuery = new BooleanQuery();
-
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(analyzer);
-
-    for (int i = 0; i < fields.length; i++) {
-      Query q = qp.parse(queries[i], fields[i]);
-
-      if (q != null && // q never null, just being defensive
-          (!(q instanceof BooleanQuery) || ((BooleanQuery) q).getClauses().length > 0)) {
-        bQuery.add(q, flags[i]);
-      }
-    }
-    return bQuery;
-  }
-
-  /**
-   * Returns a String where those characters that TextParser expects to be
-   * escaped are escaped by a preceding <code>\</code>.
-   */
-  public static String escape(String s) {
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < s.length(); i++) {
-      char c = s.charAt(i);
-      // These characters are part of the query syntax and must be escaped
-      if (c == '\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')'
-          || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"'
-          || c == '{' || c == '}' || c == '~' || c == '*' || c == '?'
-          || c == '|' || c == '&') {
-        sb.append('\\');
-      }
-      sb.append(c);
-    }
-    return sb.toString();
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java
deleted file mode 100644
index 014addf..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java
+++ /dev/null
@@ -1,514 +0,0 @@
-package org.apache.lucene.queryParser.standard;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-import java.util.Map;
-import java.util.TooManyListenersException;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.document.DateTools.Resolution;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryParserHelper;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
-import org.apache.lucene.queryParser.standard.config.FuzzyConfig;
-import org.apache.lucene.queryParser.standard.config.NumericConfig;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
-import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
-import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.Query;
-
-/**
- * <p>
- * This class is a helper that enables users to easily use the Lucene query
- * parser.
- * </p>
- * <p>
- * To construct a Query object from a query string, use the
- * {@link #parse(String, String)} method:
- * <ul>
- * StandardQueryParser queryParserHelper = new StandardQueryParser(); <br/>
- * Query query = queryParserHelper.parse("a AND b", "defaultField");
- * </ul>
- * <p>
- * To change any configuration before parsing the query string do, for example:
- * <p/>
- * <ul>
- * // the query config handler returned by {@link StandardQueryParser} is a
- * {@link StandardQueryConfigHandler} <br/>
- * queryParserHelper.getQueryConfigHandler().setAnalyzer(new
- * WhitespaceAnalyzer());
- * </ul>
- * <p>
- * The syntax for query strings is as follows (copied from the old QueryParser
- * javadoc):
- * <ul>
- * A Query is a series of clauses. A clause may be prefixed by:
- * <ul>
- * <li>a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating that
- * the clause is required or prohibited respectively; or
- * <li>a term followed by a colon, indicating the field to be searched. This
- * enables one to construct queries which search multiple fields.
- * </ul>
- * 
- * A clause may be either:
- * <ul>
- * <li>a term, indicating all the documents that contain this term; or
- * <li>a nested query, enclosed in parentheses. Note that this may be used with
- * a <code>+</code>/<code>-</code> prefix to require any of a set of terms.
- * </ul>
- * 
- * Thus, in BNF, the query grammar is:
- * 
- * <pre>
- *   Query  ::= ( Clause )*
- *   Clause ::= [&quot;+&quot;, &quot;-&quot;] [&lt;TERM&gt; &quot;:&quot;] ( &lt;TERM&gt; | &quot;(&quot; Query &quot;)&quot; )
- * </pre>
- * 
- * <p>
- * Examples of appropriately formatted queries can be found in the <a
- * href="../../../../../../queryparsersyntax.html">query syntax
- * documentation</a>.
- * </p>
- * </ul>
- * <p>
- * The text parser used by this helper is a {@link StandardSyntaxParser}.
- * <p/>
- * <p>
- * The query node processor used by this helper is a
- * {@link StandardQueryNodeProcessorPipeline}.
- * <p/>
- * <p>
- * The builder used by this helper is a {@link StandardQueryTreeBuilder}.
- * <p/>
- * 
- * @see StandardQueryParser
- * @see StandardQueryConfigHandler
- * @see StandardSyntaxParser
- * @see StandardQueryNodeProcessorPipeline
- * @see StandardQueryTreeBuilder
- */
-public class StandardQueryParser extends QueryParserHelper {
-  
-  /**
-   * Constructs a {@link StandardQueryParser} object.
-   */
-  public StandardQueryParser() {
-    super(new StandardQueryConfigHandler(), new StandardSyntaxParser(),
-        new StandardQueryNodeProcessorPipeline(null),
-        new StandardQueryTreeBuilder());
-  }
-  
-  /**
-   * Constructs a {@link StandardQueryParser} object and sets an
-   * {@link Analyzer} to it. The same as:
-   * 
-   * <ul>
-   * StandardQueryParser qp = new StandardQueryParser();
-   * qp.getQueryConfigHandler().setAnalyzer(analyzer);
-   * </ul>
-   * 
-   * @param analyzer
-   *          the analyzer to be used by this query parser helper
-   */
-  public StandardQueryParser(Analyzer analyzer) {
-    this();
-    
-    this.setAnalyzer(analyzer);
-  }
-  
-  @Override
-  public String toString() {
-    return "<StandardQueryParser config=\"" + this.getQueryConfigHandler()
-        + "\"/>";
-  }
-  
-  /**
-   * Overrides {@link QueryParserHelper#parse(String, String)} so it casts the
-   * return object to {@link Query}. For more reference about this method, check
-   * {@link QueryParserHelper#parse(String, String)}.
-   * 
-   * @param query
-   *          the query string
-   * @param defaultField
-   *          the default field used by the text parser
-   * 
-   * @return the object built from the query
-   * 
-   * @throws QueryNodeException
-   *           if something wrong happens along the three phases
-   */
-  @Override
-  public Query parse(String query, String defaultField)
-      throws QueryNodeException {
-    
-    return (Query) super.parse(query, defaultField);
-    
-  }
-  
-  /**
-   * Gets implicit operator setting, which will be either {@link Operator#AND}
-   * or {@link Operator#OR}.
-   */
-  public StandardQueryConfigHandler.Operator getDefaultOperator() {
-    return getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
-  }
-  
-  /**
-   * Sets the boolean operator of the QueryParser. In default mode (
-   * {@link Operator#OR}) terms without any modifiers are considered optional:
-   * for example <code>capital of Hungary</code> is equal to
-   * <code>capital OR of OR Hungary</code>.<br/>
-   * In {@link Operator#AND} mode terms are considered to be in conjunction: the
-   * above mentioned query is parsed as <code>capital AND of AND Hungary</code>
-   */
-  public void setDefaultOperator(StandardQueryConfigHandler.Operator operator) {
-    getQueryConfigHandler().set(ConfigurationKeys.DEFAULT_OPERATOR, operator);
-  }
-  
-  /**
-   * Set to <code>true</code> to allow leading wildcard characters.
-   * <p>
-   * When set, <code>*</code> or <code>?</code> are allowed as the first
-   * character of a PrefixQuery and WildcardQuery. Note that this can produce
-   * very slow queries on big indexes.
-   * <p>
-   * Default: false.
-   */
-  public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) {
-    getQueryConfigHandler().set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, lowercaseExpandedTerms);
-  }
-  
-  /**
-   * @see #setLowercaseExpandedTerms(boolean)
-   */
-  public boolean getLowercaseExpandedTerms() {
-    Boolean lowercaseExpandedTerms = getQueryConfigHandler().get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS);
-    
-    if (lowercaseExpandedTerms == null) {
-      return true;
-      
-    } else {
-      return lowercaseExpandedTerms;
-    }
-    
-  }
-  
-  /**
-   * Set to <code>true</code> to allow leading wildcard characters.
-   * <p>
-   * When set, <code>*</code> or <code>?</code> are allowed as the first
-   * character of a PrefixQuery and WildcardQuery. Note that this can produce
-   * very slow queries on big indexes.
-   * <p>
-   * Default: false.
-   */
-  public void setAllowLeadingWildcard(boolean allowLeadingWildcard) {
-    getQueryConfigHandler().set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, allowLeadingWildcard);
-  }
-  
-  /**
-   * Set to <code>true</code> to enable position increments in result query.
-   * <p>
-   * When set, result phrase and multi-phrase queries will be aware of position
-   * increments. Useful when e.g. a StopFilter increases the position increment
-   * of the token that follows an omitted token.
-   * <p>
-   * Default: false.
-   */
-  public void setEnablePositionIncrements(boolean enabled) {
-    getQueryConfigHandler().set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, enabled);
-  }
-  
-  /**
-   * @see #setEnablePositionIncrements(boolean)
-   */
-  public boolean getEnablePositionIncrements() {
-    Boolean enablePositionsIncrements = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
-    
-    if (enablePositionsIncrements == null) {
-       return false;
-       
-    } else {
-      return enablePositionsIncrements;
-    }
-    
-  }
-  
-  /**
-   * By default, it uses
-   * {@link MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} when creating a
-   * prefix, wildcard and range queries. This implementation is generally
-   * preferable because it a) Runs faster b) Does not have the scarcity of terms
-   * unduly influence score c) avoids any {@link TooManyListenersException}
-   * exception. However, if your application really needs to use the
-   * old-fashioned boolean queries expansion rewriting and the above points are
-   * not relevant then use this change the rewrite method.
-   */
-  public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    getQueryConfigHandler().set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, method);
-  }
-  
-  /**
-   * @see #setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)
-   */
-  public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
-    return getQueryConfigHandler().get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
-  }
-  
-  /**
-   * Set the fields a query should be expanded to when the field is
-   * <code>null</code>
-   * 
-   * @param fields the fields used to expand the query
-   */
-  public void setMultiFields(CharSequence[] fields) {
-    
-    if (fields == null) {
-      fields = new CharSequence[0];
-    }
-
-    getQueryConfigHandler().set(ConfigurationKeys.MULTI_FIELDS, fields);
-    
-  }
-  
-  /**
-   * Returns the fields used to expand the query when the field for a
-   * certain query is <code>null</code>
-   * 
-   * @param fields the fields used to expand the query
-   */
-  public void getMultiFields(CharSequence[] fields) {
-    getQueryConfigHandler().get(ConfigurationKeys.MULTI_FIELDS);
-  }
-
-  /**
-   * Set the prefix length for fuzzy queries. Default is 0.
-   * 
-   * @param fuzzyPrefixLength
-   *          The fuzzyPrefixLength to set.
-   */
-  public void setFuzzyPrefixLength(int fuzzyPrefixLength) {
-    QueryConfigHandler config = getQueryConfigHandler();
-    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
-    
-    if (fuzzyConfig == null) {
-      fuzzyConfig = new FuzzyConfig();
-      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
-    }
-
-    fuzzyConfig.setPrefixLength(fuzzyPrefixLength);
-    
-  }
-  
-  public void setNumericConfigMap(Map<String,NumericConfig> numericConfigMap) {
-    getQueryConfigHandler().set(ConfigurationKeys.NUMERIC_CONFIG_MAP, numericConfigMap);
-  }
-  
-  public Map<String,NumericConfig> getNumericConfigMap() {
-    return getQueryConfigHandler().get(ConfigurationKeys.NUMERIC_CONFIG_MAP);
-  }
-  
-  /**
-   * Set locale used by date range parsing.
-   */
-  public void setLocale(Locale locale) {
-    getQueryConfigHandler().set(ConfigurationKeys.LOCALE, locale);
-  }
-  
-  /**
-   * Returns current locale, allowing access by subclasses.
-   */
-  public Locale getLocale() {
-    return getQueryConfigHandler().get(ConfigurationKeys.LOCALE);
-  }
-  
-  /**
-   * Sets the default slop for phrases. If zero, then exact phrase matches are
-   * required. Default value is zero.
-   * 
-   * @deprecated renamed to {@link #setPhraseSlop(int)}
-   */
-  @Deprecated
-  public void setDefaultPhraseSlop(int defaultPhraseSlop) {
-    getQueryConfigHandler().set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
-  }
-  
-  /**
-   * Sets the default slop for phrases. If zero, then exact phrase matches are
-   * required. Default value is zero.
-   */
-  public void setPhraseSlop(int defaultPhraseSlop) {
-    getQueryConfigHandler().set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
-  }
-
-  public void setAnalyzer(Analyzer analyzer) {
-    getQueryConfigHandler().set(ConfigurationKeys.ANALYZER, analyzer);
-  }
-  
-  public Analyzer getAnalyzer() {
-    return getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);       
-  }
-  
-  /**
-   * @see #setAllowLeadingWildcard(boolean)
-   */
-  public boolean getAllowLeadingWildcard() {
-    Boolean allowLeadingWildcard = getQueryConfigHandler().get(ConfigurationKeys.ALLOW_LEADING_WILDCARD);
-    
-    if (allowLeadingWildcard == null) {
-      return false;
-      
-    } else {
-      return allowLeadingWildcard;
-    }
-  }
-  
-  /**
-   * Get the minimal similarity for fuzzy queries.
-   */
-  public float getFuzzyMinSim() {
-    FuzzyConfig fuzzyConfig = getQueryConfigHandler().get(ConfigurationKeys.FUZZY_CONFIG);
-    
-    if (fuzzyConfig == null) {
-      return FuzzyQuery.defaultMinSimilarity;
-    } else {
-      return fuzzyConfig.getMinSimilarity();
-    }
-  }
-  
-  /**
-   * Get the prefix length for fuzzy queries.
-   * 
-   * @return Returns the fuzzyPrefixLength.
-   */
-  public int getFuzzyPrefixLength() {
-    FuzzyConfig fuzzyConfig = getQueryConfigHandler().get(ConfigurationKeys.FUZZY_CONFIG);
-    
-    if (fuzzyConfig == null) {
-      return FuzzyQuery.defaultPrefixLength;
-    } else {
-      return fuzzyConfig.getPrefixLength();
-    }
-  }
-  
-  /**
-   * Gets the default slop for phrases.
-   */
-  public int getPhraseSlop() {
-    Integer phraseSlop = getQueryConfigHandler().get(ConfigurationKeys.PHRASE_SLOP);
-    
-    if (phraseSlop == null) {
-      return 0;
-      
-    } else {
-      return phraseSlop;
-    }
-  }
-  
-  /**
-   * Set the minimum similarity for fuzzy queries. Default is defined on
-   * {@link FuzzyQuery#defaultMinSimilarity}.
-   */
-  public void setFuzzyMinSim(float fuzzyMinSim) {
-    QueryConfigHandler config = getQueryConfigHandler();
-    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
-    
-    if (fuzzyConfig == null) {
-      fuzzyConfig = new FuzzyConfig();
-      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
-    }
-
-    fuzzyConfig.setMinSimilarity(fuzzyMinSim);
-  }
-  
-  /**
-   * Sets the boost used for each field.
-   * 
-   * @param boosts a collection that maps a field to its boost 
-   */
-  public void setFieldsBoost(Map<String, Float> boosts) {
-    getQueryConfigHandler().set(ConfigurationKeys.FIELD_BOOST_MAP, boosts);
-  }
-  
-  /**
-   * Returns the field to boost map used to set boost for each field.
-   * 
-   * @return the field to boost map 
-   */
-  public Map<String, Float> getFieldsBoost() {
-    return getQueryConfigHandler().get(ConfigurationKeys.FIELD_BOOST_MAP);
-  }
-
-  /**
-   * Sets the default {@link Resolution} used for certain field when
-   * no {@link Resolution} is defined for this field.
-   * 
-   * @param dateResolution the default {@link Resolution}
-   */
-  public void setDateResolution(DateTools.Resolution dateResolution) {
-    getQueryConfigHandler().set(ConfigurationKeys.DATE_RESOLUTION, dateResolution);
-  }
-  
-  /**
-   * Returns the default {@link Resolution} used for certain field when
-   * no {@link Resolution} is defined for this field.
-   * 
-   * @return the default {@link Resolution}
-   */
-  public DateTools.Resolution getDateResolution() {
-    return getQueryConfigHandler().get(ConfigurationKeys.DATE_RESOLUTION);
-  }
-
-  /**
-   * Sets the {@link Resolution} used for each field
-   * 
-   * @param dateRes a collection that maps a field to its {@link Resolution}
-   * 
-   * @deprecated this method was renamed to {@link #setDateResolutionMap(Map)} 
-   */
-  @Deprecated
-  public void setDateResolution(Map<CharSequence, DateTools.Resolution> dateRes) {
-    setDateResolutionMap(dateRes);
-  }
-  
-  /**
-   * Returns the field to {@link Resolution} map used to normalize each date field.
-   * 
-   * @return the field to {@link Resolution} map
-   */
-  public Map<CharSequence, DateTools.Resolution> getDateResolutionMap() {
-    return getQueryConfigHandler().get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP);
-  }
-  
-  /**
-   * Sets the {@link Resolution} used for each field
-   * 
-   * @param dateRes a collection that maps a field to its {@link Resolution}
-   */
-  public void setDateResolutionMap(Map<CharSequence, DateTools.Resolution> dateRes) {
-    getQueryConfigHandler().set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, dateRes);
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/AnyQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/AnyQueryNodeBuilder.java
deleted file mode 100644
index 61e471e..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/AnyQueryNodeBuilder.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.AnyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery.TooManyClauses;
-
-public class AnyQueryNodeBuilder implements StandardQueryBuilder {
-
-  public AnyQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public BooleanQuery build(QueryNode queryNode) throws QueryNodeException {
-    AnyQueryNode andNode = (AnyQueryNode) queryNode;
-
-    BooleanQuery bQuery = new BooleanQuery();
-    List<QueryNode> children = andNode.getChildren();
-
-    if (children != null) {
-
-      for (QueryNode child : children) {
-        Object obj = child.getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-
-        if (obj != null) {
-          Query query = (Query) obj;
-
-          try {
-            bQuery.add(query, BooleanClause.Occur.SHOULD);
-          } catch (TooManyClauses ex) {
-
-            throw new QueryNodeException(new MessageImpl(
-            /*
-             * IQQQ.Q0028E_TOO_MANY_BOOLEAN_CLAUSES,
-             * BooleanQuery.getMaxClauseCount()
-             */QueryParserMessages.EMPTY_MESSAGE), ex);
-
-          }
-
-        }
-
-      }
-
-    }
-
-    bQuery.setMinimumNumberShouldMatch(andNode.getMinimumMatchingElements());
-
-    return bQuery;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/BooleanQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/BooleanQueryNodeBuilder.java
deleted file mode 100644
index bcd2c2f..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/BooleanQueryNodeBuilder.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery.TooManyClauses;
-
-/**
- * Builds a {@link BooleanQuery} object from a {@link BooleanQueryNode} object.
- * Every children in the {@link BooleanQueryNode} object must be already tagged
- * using {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} with a {@link Query}
- * object. <br/>
- * <br/>
- * It takes in consideration if the children is a {@link ModifierQueryNode} to
- * define the {@link BooleanClause}.
- */
-public class BooleanQueryNodeBuilder implements StandardQueryBuilder {
-
-  public BooleanQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public BooleanQuery build(QueryNode queryNode) throws QueryNodeException {
-    BooleanQueryNode booleanNode = (BooleanQueryNode) queryNode;
-
-    BooleanQuery bQuery = new BooleanQuery();
-    List<QueryNode> children = booleanNode.getChildren();
-
-    if (children != null) {
-
-      for (QueryNode child : children) {
-        Object obj = child.getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-
-        if (obj != null) {
-          Query query = (Query) obj;
-
-          try {
-            bQuery.add(query, getModifierValue(child));
-
-          } catch (TooManyClauses ex) {
-
-            throw new QueryNodeException(new MessageImpl(
-                QueryParserMessages.TOO_MANY_BOOLEAN_CLAUSES, BooleanQuery
-                    .getMaxClauseCount(), queryNode
-                    .toQueryString(new EscapeQuerySyntaxImpl())), ex);
-
-          }
-
-        }
-
-      }
-
-    }
-
-    return bQuery;
-
-  }
-
-  private static BooleanClause.Occur getModifierValue(QueryNode node)
-      throws QueryNodeException {
-
-    if (node instanceof ModifierQueryNode) {
-      ModifierQueryNode mNode = ((ModifierQueryNode) node);
-      switch (mNode.getModifier()) {
-
-      case MOD_REQ:
-        return BooleanClause.Occur.MUST;
-
-      case MOD_NOT:
-        return BooleanClause.Occur.MUST_NOT;
-
-      case MOD_NONE:
-        return BooleanClause.Occur.SHOULD;
-
-      }
-
-    }
-
-    return BooleanClause.Occur.SHOULD;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/BoostQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/BoostQueryNodeBuilder.java
deleted file mode 100644
index 2bc1f95..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/BoostQueryNodeBuilder.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.Query;
-
-/**
- * This builder basically reads the {@link Query} object set on the
- * {@link BoostQueryNode} child using
- * {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} and applies the boost value
- * defined in the {@link BoostQueryNode}.
- */
-public class BoostQueryNodeBuilder implements StandardQueryBuilder {
-
-  public BoostQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public Query build(QueryNode queryNode) throws QueryNodeException {
-    BoostQueryNode boostNode = (BoostQueryNode) queryNode;
-    QueryNode child = boostNode.getChild();
-
-    if (child == null) {
-      return null;
-    }
-
-    Query query = (Query) child
-        .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-    query.setBoost(boostNode.getValue());
-
-    return query;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/DummyQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/DummyQueryNodeBuilder.java
deleted file mode 100644
index 76284ba..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/DummyQueryNodeBuilder.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.TermQuery;
-
-/**
- * Builds a {@link TermQuery} object from a {@link FieldQueryNode} object.
- */
-public class DummyQueryNodeBuilder implements StandardQueryBuilder {
-
-  public DummyQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public TermQuery build(QueryNode queryNode) throws QueryNodeException {
-    return null;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/FieldQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/FieldQueryNodeBuilder.java
deleted file mode 100644
index 886e1a0..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/FieldQueryNodeBuilder.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.TermQuery;
-
-/**
- * Builds a {@link TermQuery} object from a {@link FieldQueryNode} object.
- */
-public class FieldQueryNodeBuilder implements StandardQueryBuilder {
-
-  public FieldQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public TermQuery build(QueryNode queryNode) throws QueryNodeException {
-    FieldQueryNode fieldNode = (FieldQueryNode) queryNode;
-
-    return new TermQuery(new Term(fieldNode.getFieldAsString(), fieldNode
-        .getTextAsString()));
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/FuzzyQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/FuzzyQueryNodeBuilder.java
deleted file mode 100644
index 5ee87a8..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/FuzzyQueryNodeBuilder.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.FuzzyQuery;
-
-/**
- * Builds a {@link FuzzyQuery} object from a {@link FuzzyQueryNode} object.
- */
-public class FuzzyQueryNodeBuilder implements StandardQueryBuilder {
-
-  public FuzzyQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public FuzzyQuery build(QueryNode queryNode) throws QueryNodeException {
-    FuzzyQueryNode fuzzyNode = (FuzzyQueryNode) queryNode;
-
-    return new FuzzyQuery(new Term(fuzzyNode.getFieldAsString(), fuzzyNode
-        .getTextAsString()), fuzzyNode.getSimilarity(), fuzzyNode
-        .getPrefixLength());
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/GroupQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/GroupQueryNodeBuilder.java
deleted file mode 100644
index f6c1e09..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/GroupQueryNodeBuilder.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.Query;
-
-/**
- * Builds no object, it only returns the {@link Query} object set on the
- * {@link GroupQueryNode} object using a
- * {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} tag.
- */
-public class GroupQueryNodeBuilder implements StandardQueryBuilder {
-
-  public GroupQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public Query build(QueryNode queryNode) throws QueryNodeException {
-    GroupQueryNode groupNode = (GroupQueryNode) queryNode;
-
-    return (Query) (groupNode).getChild().getTag(
-        QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MatchAllDocsQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MatchAllDocsQueryNodeBuilder.java
deleted file mode 100644
index 3b4cdb2..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MatchAllDocsQueryNodeBuilder.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.MatchAllDocsQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
-import org.apache.lucene.search.MatchAllDocsQuery;
-
-/**
- * Builds a {@link MatchAllDocsQuery} object from a
- * {@link MatchAllDocsQueryNode} object.
- */
-public class MatchAllDocsQueryNodeBuilder implements StandardQueryBuilder {
-
-  public MatchAllDocsQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public MatchAllDocsQuery build(QueryNode queryNode) throws QueryNodeException {
-
-    // validates node
-    if (!(queryNode instanceof MatchAllDocsQueryNode)) {
-      throw new QueryNodeException(new MessageImpl(
-          QueryParserMessages.LUCENE_QUERY_CONVERSION_ERROR, queryNode
-              .toQueryString(new EscapeQuerySyntaxImpl()), queryNode.getClass()
-              .getName()));
-    }
-
-    return new MatchAllDocsQuery();
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MatchNoDocsQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MatchNoDocsQueryNodeBuilder.java
deleted file mode 100644
index fb2c95c..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MatchNoDocsQueryNodeBuilder.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.MatchNoDocsQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
-import org.apache.lucene.search.BooleanQuery;
-
-/**
- * Builds an empty {@link BooleanQuery} object from a
- * {@link MatchNoDocsQueryNode} object.
- */
-public class MatchNoDocsQueryNodeBuilder implements StandardQueryBuilder {
-
-  public MatchNoDocsQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public BooleanQuery build(QueryNode queryNode) throws QueryNodeException {
-
-    // validates node
-    if (!(queryNode instanceof MatchNoDocsQueryNode)) {
-      throw new QueryNodeException(new MessageImpl(
-          QueryParserMessages.LUCENE_QUERY_CONVERSION_ERROR, queryNode
-              .toQueryString(new EscapeQuerySyntaxImpl()), queryNode.getClass()
-              .getName()));
-    }
-
-    return new BooleanQuery();
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/ModifierQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/ModifierQueryNodeBuilder.java
deleted file mode 100644
index 072f5cd..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/ModifierQueryNodeBuilder.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.Query;
-
-/**
- * Builds no object, it only returns the {@link Query} object set on the
- * {@link ModifierQueryNode} object using a
- * {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} tag.
- */
-public class ModifierQueryNodeBuilder implements StandardQueryBuilder {
-
-  public ModifierQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public Query build(QueryNode queryNode) throws QueryNodeException {
-    ModifierQueryNode modifierNode = (ModifierQueryNode) queryNode;
-
-    return (Query) (modifierNode).getChild().getTag(
-        QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MultiPhraseQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MultiPhraseQueryNodeBuilder.java
deleted file mode 100644
index bfd291b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/MultiPhraseQueryNodeBuilder.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.LinkedList;
-import java.util.List;
-import java.util.TreeMap;
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
-import org.apache.lucene.search.MultiPhraseQuery;
-import org.apache.lucene.search.TermQuery;
-
-/**
- * Builds a {@link MultiPhraseQuery} object from a {@link MultiPhraseQueryNode}
- * object.
- */
-public class MultiPhraseQueryNodeBuilder implements StandardQueryBuilder {
-
-  public MultiPhraseQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public MultiPhraseQuery build(QueryNode queryNode) throws QueryNodeException {
-    MultiPhraseQueryNode phraseNode = (MultiPhraseQueryNode) queryNode;
-
-    MultiPhraseQuery phraseQuery = new MultiPhraseQuery();
-
-    List<QueryNode> children = phraseNode.getChildren();
-
-    if (children != null) {
-      TreeMap<Integer, List<Term>> positionTermMap = new TreeMap<Integer, List<Term>>();
-
-      for (QueryNode child : children) {
-        FieldQueryNode termNode = (FieldQueryNode) child;
-        TermQuery termQuery = (TermQuery) termNode
-            .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-        List<Term> termList = positionTermMap.get(termNode
-            .getPositionIncrement());
-
-        if (termList == null) {
-          termList = new LinkedList<Term>();
-          positionTermMap.put(termNode.getPositionIncrement(), termList);
-
-        }
-
-        termList.add(termQuery.getTerm());
-
-      }
-
-      for (int positionIncrement : positionTermMap.keySet()) {
-        List<Term> termList = positionTermMap.get(positionIncrement);
-
-        phraseQuery.add(termList.toArray(new Term[termList.size()]),
-            positionIncrement);
-
-      }
-
-    }
-
-    return phraseQuery;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/NumericRangeQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/NumericRangeQueryNodeBuilder.java
deleted file mode 100644
index 10cf888..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/NumericRangeQueryNodeBuilder.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.document.NumericField;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.util.StringUtils;
-import org.apache.lucene.queryParser.standard.config.NumericConfig;
-import org.apache.lucene.queryParser.standard.nodes.NumericQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.NumericRangeQueryNode;
-import org.apache.lucene.search.NumericRangeQuery;
-
-public class NumericRangeQueryNodeBuilder implements StandardQueryBuilder {
-  
-  public NumericRangeQueryNodeBuilder() {
-  // empty constructor
-  }
-  
-  public NumericRangeQuery<? extends Number> build(QueryNode queryNode)
-      throws QueryNodeException {
-    NumericRangeQueryNode numericRangeNode = (NumericRangeQueryNode) queryNode;
-    
-    NumericQueryNode lowerNumericNode = numericRangeNode.getLowerBound();
-    NumericQueryNode upperNumericNode = numericRangeNode.getUpperBound();
-    
-    Number lowerNumber, upperNumber;
-    
-    if (lowerNumericNode != null) {
-      lowerNumber = lowerNumericNode.getValue();
-    } else {
-      lowerNumber = null;
-    }
-    
-    if (upperNumericNode != null) {
-      upperNumber = upperNumericNode.getValue();
-    } else {
-      upperNumber = null;
-    }
-    
-    NumericConfig numericConfig = numericRangeNode.getNumericConfig();
-    NumericField.DataType numberType = numericConfig.getType();
-    String field = StringUtils.toString(numericRangeNode.getField());
-    boolean minInclusive = numericRangeNode.isLowerInclusive();
-    boolean maxInclusive = numericRangeNode.isUpperInclusive();
-    int precisionStep = numericConfig.getPrecisionStep();
-    
-    switch (numberType) {
-      
-      case LONG:
-        return NumericRangeQuery.newLongRange(field, precisionStep,
-            (Long) lowerNumber, (Long) upperNumber, minInclusive, maxInclusive);
-      
-      case INT:
-        return NumericRangeQuery.newIntRange(field, precisionStep,
-            (Integer) lowerNumber, (Integer) upperNumber, minInclusive,
-            maxInclusive);
-      
-      case FLOAT:
-        return NumericRangeQuery.newFloatRange(field, precisionStep,
-            (Float) lowerNumber, (Float) upperNumber, minInclusive,
-            maxInclusive);
-      
-      case DOUBLE:
-        return NumericRangeQuery.newDoubleRange(field, precisionStep,
-            (Double) lowerNumber, (Double) upperNumber, minInclusive,
-            maxInclusive);
-        
-        default :
-          throw new QueryNodeException(new MessageImpl(
-            QueryParserMessages.UNSUPPORTED_NUMERIC_DATA_TYPE, numberType));
-        
-    }
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PhraseQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PhraseQueryNodeBuilder.java
deleted file mode 100644
index a1128ae..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PhraseQueryNodeBuilder.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.TermQuery;
-
-/**
- * Builds a {@link PhraseQuery} object from a {@link TokenizedPhraseQueryNode}
- * object.
- */
-public class PhraseQueryNodeBuilder implements StandardQueryBuilder {
-
-  public PhraseQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public PhraseQuery build(QueryNode queryNode) throws QueryNodeException {
-    TokenizedPhraseQueryNode phraseNode = (TokenizedPhraseQueryNode) queryNode;
-
-    PhraseQuery phraseQuery = new PhraseQuery();
-
-    List<QueryNode> children = phraseNode.getChildren();
-
-    if (children != null) {
-
-      for (QueryNode child : children) {
-        TermQuery termQuery = (TermQuery) child
-            .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-        FieldQueryNode termNode = (FieldQueryNode) child;
-
-        phraseQuery.add(termQuery.getTerm(), termNode.getPositionIncrement());
-
-      }
-
-    }
-
-    return phraseQuery;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java
deleted file mode 100644
index 14a9149..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
-import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.PrefixQuery;
-
-/**
- * Builds a {@link PrefixQuery} object from a {@link PrefixWildcardQueryNode}
- * object.
- */
-public class PrefixWildcardQueryNodeBuilder implements StandardQueryBuilder {
-
-  public PrefixWildcardQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public PrefixQuery build(QueryNode queryNode) throws QueryNodeException {    
-
-    PrefixWildcardQueryNode wildcardNode = (PrefixWildcardQueryNode) queryNode;
-
-    String text = wildcardNode.getText().subSequence(0, wildcardNode.getText().length() - 1).toString();
-    PrefixQuery q = new PrefixQuery(new Term(wildcardNode.getFieldAsString(), text));
-    
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
-    if (method != null) {
-      q.setRewriteMethod(method);
-    }
-    
-    return q;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java
deleted file mode 100644
index 7786fca..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
-import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
-import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.TermRangeQuery;
-
-/**
- * Builds a {@link TermRangeQuery} object from a {@link RangeQueryNode} object.
- */
-public class RangeQueryNodeBuilder implements StandardQueryBuilder {
-
-  public RangeQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public TermRangeQuery build(QueryNode queryNode) throws QueryNodeException {
-    RangeQueryNode rangeNode = (RangeQueryNode) queryNode;
-    ParametricQueryNode upper = rangeNode.getUpperBound();
-    ParametricQueryNode lower = rangeNode.getLowerBound();
-
-    boolean lowerInclusive = false;
-    boolean upperInclusive = false;
-
-    if (upper.getOperator() == CompareOperator.LE) {
-      upperInclusive = true;
-    }
-
-    if (lower.getOperator() == CompareOperator.GE) {
-      lowerInclusive = true;
-    }
-
-    String field = rangeNode.getField().toString();
-
-    TermRangeQuery rangeQuery = TermRangeQuery.newStringRange(field, lower.getTextAsString(), upper.getTextAsString(), lowerInclusive, upperInclusive);
-    
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
-    if (method != null) {
-      rangeQuery.setRewriteMethod(method);
-    }
-
-    return rangeQuery;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RegexpQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RegexpQueryNodeBuilder.java
deleted file mode 100644
index ff9bd4b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RegexpQueryNodeBuilder.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
-import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.RegexpQuery;
-
-/**
- * Builds a {@link RegexpQuery} object from a {@link RegexpQueryNode} object.
- */
-public class RegexpQueryNodeBuilder implements StandardQueryBuilder {
-
-  public RegexpQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public RegexpQuery build(QueryNode queryNode) throws QueryNodeException {
-    RegexpQueryNode regexpNode = (RegexpQueryNode) queryNode;
-
-    RegexpQuery q = new RegexpQuery(new Term(regexpNode.getFieldAsString(),
-        regexpNode.textToBytesRef()));
-
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod) queryNode
-        .getTag(MultiTermRewriteMethodProcessor.TAG_ID);
-    if (method != null) {
-      q.setRewriteMethod(method);
-    }
-
-    return q;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/SlopQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/SlopQueryNodeBuilder.java
deleted file mode 100644
index 07ed876..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/SlopQueryNodeBuilder.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.search.MultiPhraseQuery;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.Query;
-
-/**
- * This builder basically reads the {@link Query} object set on the
- * {@link SlopQueryNode} child using
- * {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} and applies the slop value
- * defined in the {@link SlopQueryNode}.
- */
-public class SlopQueryNodeBuilder implements StandardQueryBuilder {
-
-  public SlopQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public Query build(QueryNode queryNode) throws QueryNodeException {
-    SlopQueryNode phraseSlopNode = (SlopQueryNode) queryNode;
-
-    Query query = (Query) phraseSlopNode.getChild().getTag(
-        QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-
-    if (query instanceof PhraseQuery) {
-      ((PhraseQuery) query).setSlop(phraseSlopNode.getValue());
-
-    } else {
-      ((MultiPhraseQuery) query).setSlop(phraseSlopNode.getValue());
-    }
-
-    return query;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardBooleanQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardBooleanQueryNodeBuilder.java
deleted file mode 100644
index b2e898d..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardBooleanQueryNodeBuilder.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
-import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
-import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.SimilarityProvider;
-import org.apache.lucene.search.BooleanQuery.TooManyClauses;
-
-/**
- * This builder does the same as the {@link BooleanQueryNodeBuilder}, but this
- * considers if the built {@link BooleanQuery} should have its coord disabled or
- * not. <br/>
- * 
- * @see BooleanQueryNodeBuilder
- * @see BooleanQuery
- * @see SimilarityProvider#coord(int, int)
- */
-public class StandardBooleanQueryNodeBuilder implements StandardQueryBuilder {
-
-  public StandardBooleanQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public BooleanQuery build(QueryNode queryNode) throws QueryNodeException {
-    StandardBooleanQueryNode booleanNode = (StandardBooleanQueryNode) queryNode;
-
-    BooleanQuery bQuery = new BooleanQuery(booleanNode.isDisableCoord());
-    List<QueryNode> children = booleanNode.getChildren();
-
-    if (children != null) {
-
-      for (QueryNode child : children) {
-        Object obj = child.getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-
-        if (obj != null) {
-          Query query = (Query) obj;
-
-          try {
-            bQuery.add(query, getModifierValue(child));
-          } catch (TooManyClauses ex) {
-
-            throw new QueryNodeException(new MessageImpl(
-                QueryParserMessages.TOO_MANY_BOOLEAN_CLAUSES, BooleanQuery
-                    .getMaxClauseCount(), queryNode
-                    .toQueryString(new EscapeQuerySyntaxImpl())), ex);
-
-          }
-
-        }
-
-      }
-
-    }
-
-    return bQuery;
-
-  }
-
-  private static BooleanClause.Occur getModifierValue(QueryNode node)
-      throws QueryNodeException {
-
-    if (node instanceof ModifierQueryNode) {
-      ModifierQueryNode mNode = ((ModifierQueryNode) node);
-      Modifier modifier = mNode.getModifier();
-
-      if (Modifier.MOD_NONE.equals(modifier)) {
-        return BooleanClause.Occur.SHOULD;
-
-      } else if (Modifier.MOD_NOT.equals(modifier)) {
-        return BooleanClause.Occur.MUST_NOT;
-
-      } else {
-        return BooleanClause.Occur.MUST;
-      }
-    }
-
-    return BooleanClause.Occur.SHOULD;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryBuilder.java
deleted file mode 100644
index 3ee8a75..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryBuilder.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryBuilder;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.Query;
-
-/**
- * This interface should be implemented by every class that wants to build
- * {@link Query} objects from {@link QueryNode} objects. <br/>
- * 
- * @see QueryBuilder
- * @see QueryTreeBuilder
- */
-public interface StandardQueryBuilder extends QueryBuilder {
-
-  public Query build(QueryNode queryNode) throws QueryNodeException;
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java
deleted file mode 100644
index e2860c6..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.MatchAllDocsQueryNode;
-import org.apache.lucene.queryParser.core.nodes.MatchNoDocsQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.NumericQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.NumericRangeQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.TermRangeQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
-import org.apache.lucene.search.Query;
-
-/**
- * This query tree builder only defines the necessary map to build a
- * {@link Query} tree object. It should be used to generate a {@link Query} tree
- * object from a query node tree processed by a
- * {@link StandardQueryNodeProcessorPipeline}. <br/>
- * 
- * @see QueryTreeBuilder
- * @see StandardQueryNodeProcessorPipeline
- */
-public class StandardQueryTreeBuilder extends QueryTreeBuilder implements
-    StandardQueryBuilder {
-  
-  public StandardQueryTreeBuilder() {
-    setBuilder(GroupQueryNode.class, new GroupQueryNodeBuilder());
-    setBuilder(FieldQueryNode.class, new FieldQueryNodeBuilder());
-    setBuilder(BooleanQueryNode.class, new BooleanQueryNodeBuilder());
-    setBuilder(FuzzyQueryNode.class, new FuzzyQueryNodeBuilder());
-    setBuilder(NumericQueryNode.class, new DummyQueryNodeBuilder());
-    setBuilder(NumericRangeQueryNode.class, new NumericRangeQueryNodeBuilder());
-    setBuilder(BoostQueryNode.class, new BoostQueryNodeBuilder());
-    setBuilder(ModifierQueryNode.class, new ModifierQueryNodeBuilder());
-    setBuilder(WildcardQueryNode.class, new WildcardQueryNodeBuilder());
-    setBuilder(TokenizedPhraseQueryNode.class, new PhraseQueryNodeBuilder());
-    setBuilder(MatchNoDocsQueryNode.class, new MatchNoDocsQueryNodeBuilder());
-    setBuilder(PrefixWildcardQueryNode.class,
-        new PrefixWildcardQueryNodeBuilder());
-    setBuilder(TermRangeQueryNode.class, new TermRangeQueryNodeBuilder());
-    setBuilder(RegexpQueryNode.class, new RegexpQueryNodeBuilder());
-    setBuilder(SlopQueryNode.class, new SlopQueryNodeBuilder());
-    setBuilder(StandardBooleanQueryNode.class,
-        new StandardBooleanQueryNodeBuilder());
-    setBuilder(MultiPhraseQueryNode.class, new MultiPhraseQueryNodeBuilder());
-    setBuilder(MatchAllDocsQueryNode.class, new MatchAllDocsQueryNodeBuilder());
-    
-  }
-  
-  @Override
-  public Query build(QueryNode queryNode) throws QueryNodeException {
-    return (Query) super.build(queryNode);
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/TermRangeQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/TermRangeQueryNodeBuilder.java
deleted file mode 100644
index f918611..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/TermRangeQueryNodeBuilder.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.util.StringUtils;
-import org.apache.lucene.queryParser.standard.nodes.TermRangeQueryNode;
-import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.TermRangeQuery;
-
-/**
- * Builds a {@link TermRangeQuery} object from a {@link TermRangeQueryNode}
- * object.
- */
-public class TermRangeQueryNodeBuilder implements StandardQueryBuilder {
-  
-  public TermRangeQueryNodeBuilder() {
-  // empty constructor
-  }
-  
-  public TermRangeQuery build(QueryNode queryNode) throws QueryNodeException {
-    TermRangeQueryNode rangeNode = (TermRangeQueryNode) queryNode;
-    FieldQueryNode upper = rangeNode.getUpperBound();
-    FieldQueryNode lower = rangeNode.getLowerBound();
-    
-    String field = StringUtils.toString(rangeNode.getField());
-    
-    TermRangeQuery rangeQuery = TermRangeQuery.newStringRange(field, lower
-        .getTextAsString(), upper.getTextAsString(), rangeNode
-        .isLowerInclusive(), rangeNode.isUpperInclusive());
-    
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod) queryNode
-        .getTag(MultiTermRewriteMethodProcessor.TAG_ID);
-    if (method != null) {
-      rangeQuery.setRewriteMethod(method);
-    }
-    
-    return rangeQuery;
-    
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java
deleted file mode 100644
index 18cad5d..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.apache.lucene.queryParser.standard.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.WildcardQuery;
-
-/**
- * Builds a {@link WildcardQuery} object from a {@link WildcardQueryNode}
- * object.
- */
-public class WildcardQueryNodeBuilder implements StandardQueryBuilder {
-
-  public WildcardQueryNodeBuilder() {
-    // empty constructor
-  }
-
-  public WildcardQuery build(QueryNode queryNode) throws QueryNodeException {
-    WildcardQueryNode wildcardNode = (WildcardQueryNode) queryNode;
-
-    WildcardQuery q = new WildcardQuery(new Term(wildcardNode.getFieldAsString(),
-                                                 wildcardNode.getTextAsString()));
-    
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
-    if (method != null) {
-      q.setRewriteMethod(method);
-    }
-    
-    return q;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/package.html
deleted file mode 100644
index ac72d26..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/package.html
+++ /dev/null
@@ -1,35 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-<h2>Standard Lucene Query Node Builders</h2>
-<p>
-The package org.apache.lucene.queryParser.standard.builders contains all the builders needed
-to build a Lucene Query object from a query node tree. These builders expect the query node tree was
-already processed by the {@link org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline}.
-</p>
-<p>
-{@link org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder} is a builder that already contains a defined map that maps each QueryNode object
-with its respective builder.
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java
deleted file mode 100644
index 0ad2182..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Map;
-
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.FieldConfigListener;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-
-/**
- * This listener listens for every field configuration request and assign a
- * {@link ConfigurationKeys#BOOST} to the
- * equivalent {@link FieldConfig} based on a defined map: fieldName -> boostValue stored in
- * {@link ConfigurationKeys#FIELD_BOOST_MAP}.
- * 
- * @see ConfigurationKeys#FIELD_BOOST_MAP
- * @see ConfigurationKeys#BOOST
- * @see FieldConfig
- * @see FieldConfigListener
- */
-public class FieldBoostMapFCListener implements FieldConfigListener {
-
-  private QueryConfigHandler config = null;
-  
-  public FieldBoostMapFCListener(QueryConfigHandler config) {
-    this.config = config;
-  }
-
-  public void buildFieldConfig(FieldConfig fieldConfig) {
-    Map<String, Float> fieldBoostMap = this.config.get(ConfigurationKeys.FIELD_BOOST_MAP);
-    
-    if (fieldBoostMap != null) {
-      Float boost = fieldBoostMap.get(fieldConfig.getField());
-
-      if (boost != null) {
-        fieldConfig.set(ConfigurationKeys.BOOST, boost);
-      }
-
-    }
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java
deleted file mode 100644
index 056ea0b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Map;
-
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.document.DateTools.Resolution;
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.FieldConfigListener;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-
-/**
- * This listener listens for every field configuration request and assign a
- * {@link ConfigurationKeys#DATE_RESOLUTION} to the equivalent {@link FieldConfig} based
- * on a defined map: fieldName -> {@link Resolution} stored in
- * {@link ConfigurationKeys#FIELD_DATE_RESOLUTION_MAP}.
- * 
- * @see ConfigurationKeys#DATE_RESOLUTION
- * @see ConfigurationKeys#FIELD_DATE_RESOLUTION_MAP
- * @see FieldConfig
- * @see FieldConfigListener
- */
-public class FieldDateResolutionFCListener implements FieldConfigListener {
-
-  private QueryConfigHandler config = null;
-
-  public FieldDateResolutionFCListener(QueryConfigHandler config) {
-    this.config = config;
-  }
-
-  public void buildFieldConfig(FieldConfig fieldConfig) {
-    DateTools.Resolution dateRes = null;
-    Map<CharSequence, DateTools.Resolution> dateResMap = this.config.get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP);
-
-    if (dateResMap != null) {
-      dateRes = dateResMap.get(
-          fieldConfig.getField());
-    }
-
-    if (dateRes == null) {
-      dateRes = this.config.get(ConfigurationKeys.DATE_RESOLUTION);
-    }
-
-    if (dateRes != null) {
-      fieldConfig.set(ConfigurationKeys.DATE_RESOLUTION, dateRes);
-    }
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java
deleted file mode 100644
index 8be9bbf..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.search.FuzzyQuery;
-
-public class FuzzyConfig {
-  
-  private int prefixLength = FuzzyQuery.defaultPrefixLength;
-
-  private float minSimilarity = FuzzyQuery.defaultMinSimilarity;
-  
-  public FuzzyConfig() {}
-
-  public int getPrefixLength() {
-    return prefixLength;
-  }
-
-  public void setPrefixLength(int prefixLength) {
-    this.prefixLength = prefixLength;
-  }
-
-  public float getMinSimilarity() {
-    return minSimilarity;
-  }
-
-  public void setMinSimilarity(float minSimilarity) {
-    this.minSimilarity = minSimilarity;
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumberDateFormat.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumberDateFormat.java
deleted file mode 100644
index b1e1272..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumberDateFormat.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.DateFormat;
-import java.text.FieldPosition;
-import java.text.NumberFormat;
-import java.text.ParsePosition;
-import java.util.Date;
-
-public class NumberDateFormat extends NumberFormat {
-  
-  private static final long serialVersionUID = 964823936071308283L;
-  
-  final private DateFormat dateFormat;
-  
-  public NumberDateFormat(DateFormat dateFormat) {
-    this.dateFormat = dateFormat;
-  }
-  
-  @Override
-  public StringBuffer format(double number, StringBuffer toAppendTo,
-      FieldPosition pos) {
-    return dateFormat.format(new Date((long) number), toAppendTo, pos);
-  }
-  
-  @Override
-  public StringBuffer format(long number, StringBuffer toAppendTo,
-      FieldPosition pos) {
-    return dateFormat.format(new Date(number), toAppendTo, pos);
-  }
-  
-  @Override
-  public Number parse(String source, ParsePosition parsePosition) {
-    return dateFormat.parse(source, parsePosition).getTime();
-  }
-  
-  @Override
-  public StringBuffer format(Object number, StringBuffer toAppendTo,
-      FieldPosition pos) {
-    return dateFormat.format(number, toAppendTo, pos);
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumericConfig.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumericConfig.java
deleted file mode 100644
index df2570a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumericConfig.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.NumberFormat;
-
-import org.apache.lucene.document.NumericField;
-
-public class NumericConfig {
-  
-  private int precisionStep;
-  
-  private NumberFormat format;
-  
-  private NumericField.DataType type;
- 
-  public NumericConfig(int precisionStep, NumberFormat format, NumericField.DataType type) {
-    setPrecisionStep(precisionStep);
-    setNumberFormat(format);
-    setType(type);
-    
-  }
-  
-  public int getPrecisionStep() {
-    return precisionStep;
-  }
-  
-  public void setPrecisionStep(int precisionStep) {
-    this.precisionStep = precisionStep;
-  }
-  
-  public NumberFormat getNumberFormat() {
-    return format;
-  }
-  
-  public NumericField.DataType getType() {
-    return type;
-  }
-
-  public void setType(NumericField.DataType type) {
-    
-    if (type == null) {
-      throw new IllegalArgumentException("type cannot be null!");
-    }
-    
-    this.type = type;
-    
-  }
-
-  public void setNumberFormat(NumberFormat format) {
-    
-    if (format == null) {
-      throw new IllegalArgumentException("format cannot be null!");
-    }
-    
-    this.format = format;
-    
-  }
-  
-  @Override
-  public boolean equals(Object obj) {
-    
-    if (obj == this) return true;
-    
-    if (obj instanceof NumericConfig) {
-      NumericConfig other = (NumericConfig) obj;
-      
-      if (this.precisionStep == other.precisionStep
-          && this.format == other.format) {
-        return true;
-      }
-      
-    }
-    
-    return false;
-    
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumericFieldConfigListener.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumericFieldConfigListener.java
deleted file mode 100644
index 9545781..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/NumericFieldConfigListener.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Map;
-
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.FieldConfigListener;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-
-public class NumericFieldConfigListener implements FieldConfigListener {
-  
-  final private QueryConfigHandler config;
-  
-  public NumericFieldConfigListener(QueryConfigHandler config) {
-    
-    if (config == null) {
-      throw new IllegalArgumentException("config cannot be null!");
-    }
-    
-    this.config = config;
-    
-  }
-  
-  public void buildFieldConfig(FieldConfig fieldConfig) {
-    Map<String,NumericConfig> numericConfigMap = config
-        .get(ConfigurationKeys.NUMERIC_CONFIG_MAP);
-    
-    if (numericConfigMap != null) {
-      NumericConfig numericConfig = numericConfigMap
-          .get(fieldConfig.getField());
-      
-      if (numericConfig != null) {
-        fieldConfig.set(ConfigurationKeys.NUMERIC_CONFIG, numericConfig);
-      }
-      
-    }
-    
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java
deleted file mode 100644
index 7bc2349..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java
+++ /dev/null
@@ -1,207 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.Locale;
-import java.util.Map;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.document.DateTools.Resolution;
-import org.apache.lucene.queryParser.core.config.ConfigurationKey;
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.StandardQueryParser;
-import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
-
-/**
- * This query configuration handler is used for almost every processor defined
- * in the {@link StandardQueryNodeProcessorPipeline} processor pipeline. It holds
- * configuration methods that reproduce the configuration methods that could be set on the old
- * lucene 2.4 QueryParser class. <br/>
- * 
- * @see StandardQueryNodeProcessorPipeline
- */
-public class StandardQueryConfigHandler extends QueryConfigHandler {
-
-  final public static class ConfigurationKeys  {
-    
-    /**
-     * Key used to set whether position increments is enabled
-     * 
-     * @see StandardQueryParser#setEnablePositionIncrements(boolean)
-     * @see StandardQueryParser#getEnablePositionIncrements()
-     */
-    final public static ConfigurationKey<Boolean> ENABLE_POSITION_INCREMENTS = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set whether expanded terms should be expanded
-     * 
-     * @see StandardQueryParser#setLowercaseExpandedTerms(boolean)
-     * @see StandardQueryParser#getLowercaseExpandedTerms()
-     */
-    final public static ConfigurationKey<Boolean> LOWERCASE_EXPANDED_TERMS = ConfigurationKey.newInstance();
-
-    /**
-     * Key used to set whether leading wildcards are supported
-     * 
-     * @see StandardQueryParser#setAllowLeadingWildcard(boolean)
-     * @see StandardQueryParser#getAllowLeadingWildcard()
-     */
-    final public static ConfigurationKey<Boolean> ALLOW_LEADING_WILDCARD = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set the {@link Analyzer} used for terms found in the query
-     * 
-     * @see StandardQueryParser#setAnalyzer(Analyzer)
-     * @see StandardQueryParser#getAnalyzer()
-     */
-    final public static ConfigurationKey<Analyzer> ANALYZER = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set the default boolean operator
-     * 
-     * @see StandardQueryParser#setDefaultOperator(org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator)
-     * @see StandardQueryParser#getDefaultOperator()
-     */
-    final public static ConfigurationKey<Operator> DEFAULT_OPERATOR = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set the default phrase slop
-     * 
-     * @see StandardQueryParser#setPhraseSlop(int)
-     * @see StandardQueryParser#getPhraseSlop()
-     */
-    final public static ConfigurationKey<Integer> PHRASE_SLOP = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set the {@link Locale} used when parsing the query
-     * 
-     * @see StandardQueryParser#setLocale(Locale)
-     * @see StandardQueryParser#getLocale()
-     */
-    final public static ConfigurationKey<Locale> LOCALE = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set the {@link RewriteMethod} used when creating queries
-     * 
-     * @see StandardQueryParser#setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)
-     * @see StandardQueryParser#getMultiTermRewriteMethod()
-     */
-    final public static ConfigurationKey<MultiTermQuery.RewriteMethod> MULTI_TERM_REWRITE_METHOD = ConfigurationKey.newInstance();
-
-    /**
-     * Key used to set the fields a query should be expanded to when the field
-     * is <code>null</code>
-     * 
-     * @see StandardQueryParser#setMultiFields(CharSequence[])
-     * @see StandardQueryParser#getMultiFields(CharSequence[])
-     */
-    final public static ConfigurationKey<CharSequence[]> MULTI_FIELDS = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set a field to boost map that is used to set the boost for each field
-     * 
-     * @see StandardQueryParser#setFieldsBoost(Map)
-     * @see StandardQueryParser#getFieldsBoost()
-     */
-    final public static ConfigurationKey<Map<String,Float>> FIELD_BOOST_MAP = ConfigurationKey.newInstance();
-
-    /**
-     * Key used to set a field to {@link Resolution} map that is used
-     * to normalize each date field value.
-     * 
-     * @see StandardQueryParser#setDateResolutionMap(Map)
-     * @see StandardQueryParser#getDateResolutionMap()
-     */
-    final public static ConfigurationKey<Map<CharSequence, DateTools.Resolution>> FIELD_DATE_RESOLUTION_MAP = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set the {@link FuzzyConfig} used to create fuzzy queries.
-     * 
-     * @see StandardQueryParser#setFuzzyMinSim(float)
-     * @see StandardQueryParser#setFuzzyPrefixLength(int)
-     * @see StandardQueryParser#getFuzzyMinSim()
-     * @see StandardQueryParser#getFuzzyPrefixLength()
-     */
-    final public static ConfigurationKey<FuzzyConfig> FUZZY_CONFIG = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set default {@link Resolution}.
-     * 
-     * @see StandardQueryParser#setDateResolution(org.apache.lucene.document.DateTools.Resolution)
-     * @see StandardQueryParser#getDateResolution()
-     */
-    final public static ConfigurationKey<DateTools.Resolution> DATE_RESOLUTION = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set the boost value in {@link FieldConfig} objects.
-     * 
-     * @see StandardQueryParser#setFieldsBoost(Map)
-     * @see StandardQueryParser#getFieldsBoost()
-     */
-    final public static ConfigurationKey<Float> BOOST = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set a field to its {@link NumericConfig}.
-     * 
-     * @see StandardQueryParser#setNumericConfigMap(Map)
-     * @see StandardQueryParser#getNumericConfigMap()
-     */
-    final public static ConfigurationKey<NumericConfig> NUMERIC_CONFIG = ConfigurationKey.newInstance();
-    
-    /**
-     * Key used to set the {@link NumericConfig} in {@link FieldConfig} for numeric fields.
-     * 
-     * @see StandardQueryParser#setNumericConfigMap(Map)
-     * @see StandardQueryParser#getNumericConfigMap()
-     */
-    final public static ConfigurationKey<Map<String,NumericConfig>> NUMERIC_CONFIG_MAP = ConfigurationKey.newInstance();
-    
-  }
-  
-  public static enum Operator {
-    AND, OR;
-  }
-
-  public StandardQueryConfigHandler() {
-    // Add listener that will build the FieldConfig.
-    addFieldConfigListener(new FieldBoostMapFCListener(this));
-    addFieldConfigListener(new FieldDateResolutionFCListener(this));
-    addFieldConfigListener(new NumericFieldConfigListener(this));
-    
-    // Default Values
-    set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, false); // default in 2.9
-    set(ConfigurationKeys.ANALYZER, null); //default value 2.4
-    set(ConfigurationKeys.DEFAULT_OPERATOR, Operator.OR);
-    set(ConfigurationKeys.PHRASE_SLOP, 0); //default value 2.4
-    set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, true); //default value 2.4
-    set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, false); //default value 2.4
-    set(ConfigurationKeys.FIELD_BOOST_MAP, new LinkedHashMap<String, Float>());
-    set(ConfigurationKeys.FUZZY_CONFIG, new FuzzyConfig());
-    set(ConfigurationKeys.LOCALE, Locale.getDefault());
-    set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
-    set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, new HashMap<CharSequence, DateTools.Resolution>());
-    
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html
deleted file mode 100644
index e450318..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html
+++ /dev/null
@@ -1,34 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-<h2>Standard Lucene Query Configuration</h2>
-<p>
-The package org.apache.lucene.queryParser.standard.config contains the Lucene
-query configuration handler (StandardQueryConfigHandler). This configuration
-handler reproduces almost everything that could be set on the old query parser.
-</p>
-<p>
-StandardQueryConfigHandler is the class that should be used to configure the StandardQueryNodeProcessorPipeline.
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/AbstractRangeQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/AbstractRangeQueryNode.java
deleted file mode 100644
index ea9d8ea..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/AbstractRangeQueryNode.java
+++ /dev/null
@@ -1,153 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-
-import org.apache.lucene.queryParser.core.nodes.FieldValuePairQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.queryParser.core.util.StringUtils;
-
-public abstract class AbstractRangeQueryNode<T extends FieldValuePairQueryNode<?>>
-    extends QueryNodeImpl implements FieldableNode {
-  
-  private boolean lowerInclusive, upperInclusive;
-  
-  protected AbstractRangeQueryNode() {
-    setLeaf(false);
-    allocate();
-  }
-  
-  public CharSequence getField() {
-    CharSequence field = null;
-    T lower = getLowerBound();
-    T upper = getUpperBound();
-    
-    if (lower != null) {
-      field = lower.getField();
-      
-    } else if (upper != null) {
-      field = upper.getField();
-    }
-    
-    return field;
-    
-  }
-  
-  public void setField(CharSequence fieldName) {
-    T lower = getLowerBound();
-    T upper = getUpperBound();
-    
-    if (lower != null) {
-      lower.setField(fieldName);
-    }
-    
-    if (upper != null) {
-      upper.setField(fieldName);
-    }
-    
-  }
-  
-  @SuppressWarnings("unchecked")
-  public T getLowerBound() {
-    return (T) getChildren().get(0);
-  }
-  
-  @SuppressWarnings("unchecked")
-  public T getUpperBound() {
-    return (T) getChildren().get(1);
-  }
-  
-  public boolean isLowerInclusive() {
-    return lowerInclusive;
-  }
-  
-  public boolean isUpperInclusive() {
-    return upperInclusive;
-  }
-  
-  public void setBounds(T lower, T upper, boolean lowerInclusive,
-      boolean upperInclusive) {
-    
-    if (lower != null && upper != null) {
-      String lowerField = StringUtils.toString(lower.getField());
-      String upperField = StringUtils.toString(upper.getField());
-      
-      if ((upperField == null && lowerField == null)
-          || (upperField != null && !upperField.equals(lowerField))) {
-        throw new IllegalArgumentException(
-            "lower and upper bounds should have the same field name!");
-      }
-      
-      this.lowerInclusive = lowerInclusive;
-      this.upperInclusive = upperInclusive;
-      
-      ArrayList<QueryNode> children = new ArrayList<QueryNode>(2);
-      children.add(lower);
-      children.add(upper);
-      
-      set(children);
-      
-    }
-    
-  }
-  
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    StringBuilder sb = new StringBuilder();
-    
-    T lower = getLowerBound();
-    T upper = getUpperBound();
-    
-    if (lowerInclusive) {
-      sb.append('[');
-      
-    } else {
-      sb.append('{');
-    }
-    
-    if (lower != null) {
-      sb.append(lower.toQueryString(escapeSyntaxParser));
-      
-    } else {
-      sb.append("...");
-    }
-    
-    sb.append(' ');
-    
-    if (upper != null) {
-      sb.append(upper.toQueryString(escapeSyntaxParser));
-      
-    } else {
-      sb.append("...");
-    }
-    
-    if (upperInclusive) {
-      sb.append(']');
-      
-    } else {
-      sb.append('}');
-    }
-    
-    return sb.toString();
-    
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/BooleanModifierNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/BooleanModifierNode.java
deleted file mode 100644
index 93b1100..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/BooleanModifierNode.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.processors.GroupQueryNodeProcessor;
-
-/**
- * A {@link BooleanModifierNode} has the same behaviour as
- * {@link ModifierQueryNode}, it only indicates that this modifier was added by
- * {@link GroupQueryNodeProcessor} and not by the user. <br/>
- * 
- * @see ModifierQueryNode
- */
-public class BooleanModifierNode extends ModifierQueryNode {
-
-  public BooleanModifierNode(QueryNode node, Modifier mod) {
-    super(node, mod);
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/MultiPhraseQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/MultiPhraseQueryNode.java
deleted file mode 100644
index 2736789..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/MultiPhraseQueryNode.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.search.MultiPhraseQuery;
-import org.apache.lucene.search.PhraseQuery;
-
-/**
- * A {@link MultiPhraseQueryNode} indicates that its children should be used to
- * build a {@link MultiPhraseQuery} instead of {@link PhraseQuery}.
- */
-public class MultiPhraseQueryNode extends QueryNodeImpl implements
-    FieldableNode {
-
-  public MultiPhraseQueryNode() {
-    setLeaf(false);
-    allocate();
-
-  }
-
-  @Override
-  public String toString() {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "<multiPhrase/>";
-    StringBuilder sb = new StringBuilder();
-    sb.append("<multiPhrase>");
-    for (QueryNode child : getChildren()) {
-      sb.append("\n");
-      sb.append(child.toString());
-    }
-    sb.append("\n</multiPhrase>");
-    return sb.toString();
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (getChildren() == null || getChildren().size() == 0)
-      return "";
-
-    StringBuilder sb = new StringBuilder();
-    String filler = "";
-    for (QueryNode child : getChildren()) {
-      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
-      filler = ",";
-    }
-
-    return "[MTP[" + sb.toString() + "]]";
-  }
-
-  @Override
-  public QueryNode cloneTree() throws CloneNotSupportedException {
-    MultiPhraseQueryNode clone = (MultiPhraseQueryNode) super.cloneTree();
-
-    // nothing to do
-
-    return clone;
-  }
-
-  public CharSequence getField() {
-    List<QueryNode> children = getChildren();
-
-    if (children == null || children.size() == 0) {
-      return null;
-
-    } else {
-      return ((FieldableNode) children.get(0)).getField();
-    }
-
-  }
-
-  public void setField(CharSequence fieldName) {
-    List<QueryNode> children = getChildren();
-
-    if (children != null) {
-
-      for (QueryNode child : children) {
-
-        if (child instanceof FieldableNode) {
-          ((FieldableNode) child).setField(fieldName);
-        }
-
-      }
-
-    }
-
-  }
-
-} // end class MultitermQueryNode
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/NumericQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/NumericQueryNode.java
deleted file mode 100644
index abf0af8..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/NumericQueryNode.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.NumberFormat;
-import java.util.Locale;
-
-import org.apache.lucene.queryParser.core.nodes.FieldValuePairQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax.Type;
-
-public class NumericQueryNode extends QueryNodeImpl implements
-    FieldValuePairQueryNode<Number> {
-  
-  private NumberFormat numberFormat;
-  
-  private CharSequence field;
-  
-  private Number value;
-  
-  public NumericQueryNode(CharSequence field, Number value,
-      NumberFormat numberFormat) {
-    
-    super();
-    
-    setNumberFormat(numberFormat);
-    setField(field);
-    setValue(value);
-    
-  }
-  
-  public CharSequence getField() {
-    return this.field;
-  }
-  
-  public void setField(CharSequence fieldName) {
-    this.field = fieldName;
-  }
-  
-  protected CharSequence getTermEscaped(EscapeQuerySyntax escaper) {
-    return escaper.escape(NumberFormat.getNumberInstance().format(this.value),
-        Locale.ENGLISH, Type.NORMAL);
-  }
-  
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    if (isDefaultField(this.field)) {
-      return getTermEscaped(escapeSyntaxParser);
-    } else {
-      return this.field + ":" + getTermEscaped(escapeSyntaxParser);
-    }
-  }
-  
-  public void setNumberFormat(NumberFormat format) {
-    this.numberFormat = format;
-  }
-  
-  public NumberFormat getNumberFormat() {
-    return this.numberFormat;
-  }
-  
-  public Number getValue() {
-    return value;
-  }
-  
-  public void setValue(Number value) {
-    this.value = value;
-  }
-  
-  @Override
-  public String toString() {
-    return "<numeric field='" + this.field + "' number='"
-        + numberFormat.format(value) + "'/>";
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/NumericRangeQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/NumericRangeQueryNode.java
deleted file mode 100644
index d718733..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/NumericRangeQueryNode.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-import org.apache.lucene.document.NumericField;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.standard.config.NumericConfig;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-public class NumericRangeQueryNode extends
-    AbstractRangeQueryNode<NumericQueryNode> {
-  
-  public NumericConfig numericConfig; 
-  
-  public NumericRangeQueryNode(NumericQueryNode lower, NumericQueryNode upper,
-      boolean lowerInclusive, boolean upperInclusive, NumericConfig numericConfig) throws QueryNodeException {
-    setBounds(lower, upper, lowerInclusive, upperInclusive, numericConfig);
-  }
-  
-  private static NumericField.DataType getNumericDataType(Number number) throws QueryNodeException {
-    
-    if (number instanceof Long) {
-      return NumericField.DataType.LONG;
-    } else if (number instanceof Integer) {
-      return NumericField.DataType.INT;
-    } else if (number instanceof Double) {
-      return NumericField.DataType.DOUBLE;
-    } else if (number instanceof Float) {
-      return NumericField.DataType.FLOAT;
-    } else {
-      throw new QueryNodeException(
-          new MessageImpl(
-              QueryParserMessages.NUMBER_CLASS_NOT_SUPPORTED_BY_NUMERIC_RANGE_QUERY,
-              number.getClass()));
-    }
-    
-  }
-  
-  public void setBounds(NumericQueryNode lower, NumericQueryNode upper,
-      boolean lowerInclusive, boolean upperInclusive, NumericConfig numericConfig) throws QueryNodeException {
-    
-    if (numericConfig == null) {
-      throw new IllegalArgumentException("numericConfig cannot be null!");
-    }
-    
-    NumericField.DataType lowerNumberType, upperNumberType;
-    
-    if (lower != null && lower.getValue() != null) {
-      lowerNumberType = getNumericDataType(lower.getValue());
-    } else {
-      lowerNumberType = null;
-    }
-    
-    if (upper != null && upper.getValue() != null) {
-      upperNumberType = getNumericDataType(upper.getValue());
-    } else {
-      upperNumberType = null;
-    }
-    
-    if (lowerNumberType != null
-        && !lowerNumberType.equals(numericConfig.getType())) {
-      throw new IllegalArgumentException(
-          "lower value's type should be the same as numericConfig type: "
-              + lowerNumberType + " != " + numericConfig.getType());
-    }
-    
-    if (upperNumberType != null
-        && !upperNumberType.equals(numericConfig.getType())) {
-      throw new IllegalArgumentException(
-          "upper value's type should be the same as numericConfig type: "
-              + upperNumberType + " != " + numericConfig.getType());
-    }
-    
-    super.setBounds(lower, upper, lowerInclusive, upperInclusive);
-    this.numericConfig = numericConfig;
-    
-  }
-  
-  public NumericConfig getNumericConfig() {
-    return this.numericConfig;
-  }
-  
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder("<numericRange lowerInclusive='");
-    
-    sb.append(isLowerInclusive()).append("' upperInclusive='").append(
-        isUpperInclusive()).append(
-        "' precisionStep='" + numericConfig.getPrecisionStep()).append(
-        "' type='" + numericConfig.getType()).append("'>\n");
-    
-    sb.append(getLowerBound()).append('\n');
-    sb.append(getUpperBound()).append('\n');
-    sb.append("</numericRange>");
-    
-    return sb.toString();
-    
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java
deleted file mode 100644
index 7741d60..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * A {@link PrefixWildcardQueryNode} represents wildcardquery that matches abc*
- * or *. This does not apply to phrases, this is a special case on the original
- * lucene parser. TODO: refactor the code to remove this special case from the
- * parser. and probably do it on a Processor
- */
-public class PrefixWildcardQueryNode extends WildcardQueryNode {
-
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value including the wildcard
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public PrefixWildcardQueryNode(CharSequence field, CharSequence text,
-      int begin, int end) {
-    super(field, text, begin, end);
-  }
-
-  public PrefixWildcardQueryNode(FieldQueryNode fqn) {
-    this(fqn.getField(), fqn.getText(), fqn.getBegin(), fqn.getEnd());
-  }
-
-  @Override
-  public String toString() {
-    return "<prefixWildcard field='" + this.field + "' term='" + this.text
-        + "'/>";
-  }
-
-  @Override
-  public PrefixWildcardQueryNode cloneTree() throws CloneNotSupportedException {
-    PrefixWildcardQueryNode clone = (PrefixWildcardQueryNode) super.cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java
deleted file mode 100644
index 6412983..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-
-/**
- * This query node represents a range query. 
- * 
- * @see ParametricRangeQueryNodeProcessor
- * @see org.apache.lucene.search.TermRangeQuery
- */
-public class RangeQueryNode extends ParametricRangeQueryNode {
-
-  /**
-   * @param lower
-   * @param upper
-   */
-  public RangeQueryNode(ParametricQueryNode lower, ParametricQueryNode upper) {
-    super(lower, upper);
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder("<range>\n\t");
-    sb.append(this.getUpperBound()).append("\n\t");
-    sb.append(this.getLowerBound()).append("\n");
-    sb.append("</range>\n");
-
-    return sb.toString();
-
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RegexpQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RegexpQueryNode.java
deleted file mode 100644
index be8659d..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RegexpQueryNode.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
-import org.apache.lucene.queryParser.core.nodes.TextableQueryNode;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.search.RegexpQuery;
-import org.apache.lucene.util.BytesRef;
-
-/**
- * A {@link RegexpQueryNode} represents {@link RegexpQuery} query Examples: /[a-z]|[0-9]/
- */
-public class RegexpQueryNode extends QueryNodeImpl  implements TextableQueryNode,
-FieldableNode {
-  private CharSequence text;
-  private CharSequence field;
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value that contains a regular expression
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public RegexpQueryNode(CharSequence field, CharSequence text, int begin,
-      int end) {
-    this.field = field;
-    this.text = text.subSequence(begin, end);
-  }
-
-  public BytesRef textToBytesRef() {
-    return new BytesRef(text);
-  }
-
-  @Override
-  public String toString() {
-    return "<regexp field='" + this.field + "' term='" + this.text + "'/>";
-  }
-
-  @Override
-  public RegexpQueryNode cloneTree() throws CloneNotSupportedException {
-    RegexpQueryNode clone = (RegexpQueryNode) super.cloneTree();
-    clone.field = this.field;
-    clone.text = this.text;
-    return clone;
-  }
-
-  public CharSequence getText() {
-    return text;
-  }
-
-  public void setText(CharSequence text) {
-    this.text = text;
-  }
-
-  public CharSequence getField() {
-    return field;
-  }
-  
-  public String getFieldAsString() {
-    return field.toString();
-  }
-
-  public void setField(CharSequence field) {
-    this.field = field;
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    return isDefaultField(field)? "/"+text+"/": field + ":/" + text + "/";
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/StandardBooleanQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/StandardBooleanQueryNode.java
deleted file mode 100644
index 13e9221..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/StandardBooleanQueryNode.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.SimilarityProvider;
-
-/**
- * A {@link StandardBooleanQueryNode} has the same behavior as
- * {@link BooleanQueryNode}. It only indicates if the coord should be enabled or
- * not for this boolean query. <br/>
- * 
- * @see SimilarityProvider#coord(int, int)
- * @see BooleanQuery
- */
-public class StandardBooleanQueryNode extends BooleanQueryNode {
-
-  private boolean disableCoord;
-
-  /**
-   * @param clauses
-   */
-  public StandardBooleanQueryNode(List<QueryNode> clauses, boolean disableCoord) {
-    super(clauses);
-
-    this.disableCoord = disableCoord;
-
-  }
-
-  public boolean isDisableCoord() {
-    return this.disableCoord;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/TermRangeQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/TermRangeQueryNode.java
deleted file mode 100644
index dc01940..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/TermRangeQueryNode.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-
-/**
- * This query node represents a range query.
- * 
- * @see org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor
- * @see org.apache.lucene.search.TermRangeQuery
- */
-public class TermRangeQueryNode extends AbstractRangeQueryNode<FieldQueryNode> {
-  
-  public TermRangeQueryNode(FieldQueryNode lower, FieldQueryNode upper,
-      boolean lowerInclusive, boolean upperInclusive) {
-    setBounds(lower, upper, lowerInclusive, upperInclusive);
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java
deleted file mode 100644
index 3e4d938..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.apache.lucene.queryParser.standard.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-
-/**
- * A {@link WildcardQueryNode} represents wildcard query This does not apply to
- * phrases. Examples: a*b*c Fl?w? m?ke*g
- */
-public class WildcardQueryNode extends FieldQueryNode {
-
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value that contains one or more wild card characters (? or *)
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public WildcardQueryNode(CharSequence field, CharSequence text, int begin,
-      int end) {
-    super(field, text, begin, end);
-  }
-
-  public WildcardQueryNode(FieldQueryNode fqn) {
-    this(fqn.getField(), fqn.getText(), fqn.getBegin(), fqn.getEnd());
-  }
-
-  @Override
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    if (isDefaultField(this.field)) {
-      return this.text;
-    } else {
-      return this.field + ":" + this.text;
-    }
-  }
-
-  @Override
-  public String toString() {
-    return "<wildcard field='" + this.field + "' term='" + this.text + "'/>";
-  }
-
-  @Override
-  public WildcardQueryNode cloneTree() throws CloneNotSupportedException {
-    WildcardQueryNode clone = (WildcardQueryNode) super.cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/package.html
deleted file mode 100644
index 7f4db88..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/package.html
+++ /dev/null
@@ -1,31 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-<h2>Standard Lucene Query Nodes</h2>
-<p>
-The package org.apache.lucene.queryParser.standard.nodes contains QueryNode classes
-that are used specifically for Lucene query node tree. Any other generic QueryNode is
-defined under org.apache.lucene.queryParser.nodes.
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/package.html
deleted file mode 100644
index 5b5075f..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/package.html
+++ /dev/null
@@ -1,43 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-Contains the implementation of the Lucene query parser using the flexible query parser frameworks
-
-<h2>Lucene Flexible Query Parser Implementation</h2>
-<p>
-The old Lucene query parser used to have only one class that performed 
-all the parsing operations. In the new query parser structure, the 
-parsing was divided in 3 steps: parsing (syntax), processing (semantic)
-and building.
-</p>
-<p>
-The classes contained in the package org.apache.lucene.queryParser.standard
-are used to reproduce the same behavior as the old query parser.
-</p>
-
-<p>
-Check <tt>org.apache.lucene.queryParser.standard.StandardQueryParser</tt> to quick start using the Lucene query parser. 
-</p>
-
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/EscapeQuerySyntaxImpl.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/EscapeQuerySyntaxImpl.java
deleted file mode 100644
index 5288502..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/EscapeQuerySyntaxImpl.java
+++ /dev/null
@@ -1,296 +0,0 @@
-package org.apache.lucene.queryParser.standard.parser;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-
-/**
- */
-public class EscapeQuerySyntaxImpl implements EscapeQuerySyntax {
-
-  private static final char[] wildcardChars = { '*', '?' };
-
-  private static final String[] escapableTermExtraFirstChars = { "+", "-", "@" };
-
-  private static final String[] escapableTermChars = { "\"", "<", ">", "=",
-      "!", "(", ")", "^", "[", "{", ":", "]", "}", "~" };
-
-  // TODO: check what to do with these "*", "?", "\\"
-  private static final String[] escapableQuotedChars = { "\"" };
-  private static final String[] escapableWhiteChars = { " ", "\t", "\n", "\r",
-      "\f", "\b", "\u3000" };
-  private static final String[] escapableWordTokens = { "AND", "OR", "NOT",
-      "TO", "WITHIN", "SENTENCE", "PARAGRAPH", "INORDER" };
-
-  private static final CharSequence escapeChar(CharSequence str, Locale locale) {
-    if (str == null || str.length() == 0)
-      return str;
-
-    CharSequence buffer = str;
-
-    // regular escapable Char for terms
-    for (int i = 0; i < escapableTermChars.length; i++) {
-      buffer = replaceIgnoreCase(buffer, escapableTermChars[i].toLowerCase(),
-          "\\", locale);
-    }
-
-    // First Character of a term as more escaping chars
-    for (int i = 0; i < escapableTermExtraFirstChars.length; i++) {
-      if (buffer.charAt(0) == escapableTermExtraFirstChars[i].charAt(0)) {
-        buffer = "\\" + buffer.charAt(0)
-            + buffer.subSequence(1, buffer.length());
-        break;
-      }
-    }
-
-    return buffer;
-  }
-
-  private final CharSequence escapeQuoted(CharSequence str, Locale locale) {
-    if (str == null || str.length() == 0)
-      return str;
-
-    CharSequence buffer = str;
-
-    for (int i = 0; i < escapableQuotedChars.length; i++) {
-      buffer = replaceIgnoreCase(buffer, escapableTermChars[i].toLowerCase(),
-          "\\", locale);
-    }
-    return buffer;
-  }
-
-  private static final CharSequence escapeTerm(CharSequence term, Locale locale) {
-    if (term == null)
-      return term;
-
-    // Escape single Chars
-    term = escapeChar(term, locale);
-    term = escapeWhiteChar(term, locale);
-
-    // Escape Parser Words
-    for (int i = 0; i < escapableWordTokens.length; i++) {
-      if (escapableWordTokens[i].equalsIgnoreCase(term.toString()))
-        return "\\" + term;
-    }
-    return term;
-  }
-
-  /**
-   * replace with ignore case
-   * 
-   * @param string
-   *          string to get replaced
-   * @param sequence1
-   *          the old character sequence in lowercase
-   * @param escapeChar
-   *          the new character to prefix sequence1 in return string.
-   * @return the new String
-   */
-  private static CharSequence replaceIgnoreCase(CharSequence string,
-      CharSequence sequence1, CharSequence escapeChar, Locale locale) {
-    if (escapeChar == null || sequence1 == null || string == null)
-      throw new NullPointerException();
-
-    // empty string case
-    int count = string.length();
-    int sequence1Length = sequence1.length();
-    if (sequence1Length == 0) {
-      StringBuilder result = new StringBuilder((count + 1)
-          * escapeChar.length());
-      result.append(escapeChar);
-      for (int i = 0; i < count; i++) {
-        result.append(string.charAt(i));
-        result.append(escapeChar);
-      }
-      return result.toString();
-    }
-
-    // normal case
-    StringBuilder result = new StringBuilder();
-    char first = sequence1.charAt(0);
-    int start = 0, copyStart = 0, firstIndex;
-    while (start < count) {
-      if ((firstIndex = string.toString().toLowerCase(locale).indexOf(first,
-          start)) == -1)
-        break;
-      boolean found = true;
-      if (sequence1.length() > 1) {
-        if (firstIndex + sequence1Length > count)
-          break;
-        for (int i = 1; i < sequence1Length; i++) {
-          if (string.toString().toLowerCase(locale).charAt(firstIndex + i) != sequence1
-              .charAt(i)) {
-            found = false;
-            break;
-          }
-        }
-      }
-      if (found) {
-        result.append(string.toString().substring(copyStart, firstIndex));
-        result.append(escapeChar);
-        result.append(string.toString().substring(firstIndex,
-            firstIndex + sequence1Length));
-        copyStart = start = firstIndex + sequence1Length;
-      } else {
-        start = firstIndex + 1;
-      }
-    }
-    if (result.length() == 0 && copyStart == 0)
-      return string;
-    result.append(string.toString().substring(copyStart));
-    return result.toString();
-  }
-
-  /**
-   * escape all tokens that are part of the parser syntax on a given string
-   * 
-   * @param str
-   *          string to get replaced
-   * @param locale
-   *          locale to be used when performing string compares
-   * @return the new String
-   */
-  private static final CharSequence escapeWhiteChar(CharSequence str,
-      Locale locale) {
-    if (str == null || str.length() == 0)
-      return str;
-
-    CharSequence buffer = str;
-
-    for (int i = 0; i < escapableWhiteChars.length; i++) {
-      buffer = replaceIgnoreCase(buffer, escapableWhiteChars[i].toLowerCase(),
-          "\\", locale);
-    }
-    return buffer;
-  }
-
-  public CharSequence escape(CharSequence text, Locale locale, Type type) {
-    if (text == null || text.length() == 0)
-      return text;
-
-    // escape wildcards and the escape char (this has to be perform before
-    // anything else)
-    // since we need to preserve the UnescapedCharSequence and escape the
-    // original escape chars
-    if (text instanceof UnescapedCharSequence) {
-      text = ((UnescapedCharSequence) text).toStringEscaped(wildcardChars);
-    } else {
-      text = new UnescapedCharSequence(text).toStringEscaped(wildcardChars);
-    }
-
-    if (type == Type.STRING) {
-      return escapeQuoted(text, locale);
-    } else {
-      return escapeTerm(text, locale);
-    }
-  }
-
-  /**
-   * Returns a String where the escape char has been removed, or kept only once
-   * if there was a double escape.
-   * 
-   * Supports escaped unicode characters, e. g. translates <code>A</code> to
-   * <code>A</code>.
-   * 
-   */
-  public static UnescapedCharSequence discardEscapeChar(CharSequence input)
-      throws ParseException {
-    // Create char array to hold unescaped char sequence
-    char[] output = new char[input.length()];
-    boolean[] wasEscaped = new boolean[input.length()];
-
-    // The length of the output can be less than the input
-    // due to discarded escape chars. This variable holds
-    // the actual length of the output
-    int length = 0;
-
-    // We remember whether the last processed character was
-    // an escape character
-    boolean lastCharWasEscapeChar = false;
-
-    // The multiplier the current unicode digit must be multiplied with.
-    // E. g. the first digit must be multiplied with 16^3, the second with
-    // 16^2...
-    int codePointMultiplier = 0;
-
-    // Used to calculate the codepoint of the escaped unicode character
-    int codePoint = 0;
-
-    for (int i = 0; i < input.length(); i++) {
-      char curChar = input.charAt(i);
-      if (codePointMultiplier > 0) {
-        codePoint += hexToInt(curChar) * codePointMultiplier;
-        codePointMultiplier >>>= 4;
-        if (codePointMultiplier == 0) {
-          output[length++] = (char) codePoint;
-          codePoint = 0;
-        }
-      } else if (lastCharWasEscapeChar) {
-        if (curChar == 'u') {
-          // found an escaped unicode character
-          codePointMultiplier = 16 * 16 * 16;
-        } else {
-          // this character was escaped
-          output[length] = curChar;
-          wasEscaped[length] = true;
-          length++;
-        }
-        lastCharWasEscapeChar = false;
-      } else {
-        if (curChar == '\\') {
-          lastCharWasEscapeChar = true;
-        } else {
-          output[length] = curChar;
-          length++;
-        }
-      }
-    }
-
-    if (codePointMultiplier > 0) {
-      throw new ParseException(new MessageImpl(
-          QueryParserMessages.INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION));
-    }
-
-    if (lastCharWasEscapeChar) {
-      throw new ParseException(new MessageImpl(
-          QueryParserMessages.INVALID_SYNTAX_ESCAPE_CHARACTER));
-    }
-
-    return new UnescapedCharSequence(output, wasEscaped, 0, length);
-  }
-
-  /** Returns the numeric value of the hexadecimal character */
-  private static final int hexToInt(char c) throws ParseException {
-    if ('0' <= c && c <= '9') {
-      return c - '0';
-    } else if ('a' <= c && c <= 'f') {
-      return c - 'a' + 10;
-    } else if ('A' <= c && c <= 'F') {
-      return c - 'A' + 10;
-    } else {
-      throw new ParseException(new MessageImpl(
-          QueryParserMessages.INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE, c));
-    }
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java
deleted file mode 100644
index 94cd1c9..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java
+++ /dev/null
@@ -1,616 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.1 */
-/* JavaCCOptions:STATIC=false */
-package org.apache.lucene.queryParser.standard.parser;
-
-/**
- * An implementation of interface CharStream, where the stream is assumed to
- * contain only ASCII characters (with java-like unicode escape processing).
- */
-
-public class JavaCharStream
-{
-/** Whether parser is static. */
-  public static final boolean staticFlag = false;
-  static final int hexval(char c) throws java.io.IOException {
-    switch(c)
-    {
-       case '0' :
-          return 0;
-       case '1' :
-          return 1;
-       case '2' :
-          return 2;
-       case '3' :
-          return 3;
-       case '4' :
-          return 4;
-       case '5' :
-          return 5;
-       case '6' :
-          return 6;
-       case '7' :
-          return 7;
-       case '8' :
-          return 8;
-       case '9' :
-          return 9;
-
-       case 'a' :
-       case 'A' :
-          return 10;
-       case 'b' :
-       case 'B' :
-          return 11;
-       case 'c' :
-       case 'C' :
-          return 12;
-       case 'd' :
-       case 'D' :
-          return 13;
-       case 'e' :
-       case 'E' :
-          return 14;
-       case 'f' :
-       case 'F' :
-          return 15;
-    }
-
-    throw new java.io.IOException(); // Should never come here
-  }
-
-/** Position in buffer. */
-  public int bufpos = -1;
-  int bufsize;
-  int available;
-  int tokenBegin;
-  protected int bufline[];
-  protected int bufcolumn[];
-
-  protected int column = 0;
-  protected int line = 1;
-
-  protected boolean prevCharIsCR = false;
-  protected boolean prevCharIsLF = false;
-
-  protected java.io.Reader inputStream;
-
-  protected char[] nextCharBuf;
-  protected char[] buffer;
-  protected int maxNextCharInd = 0;
-  protected int nextCharInd = -1;
-  protected int inBuf = 0;
-  protected int tabSize = 8;
-
-  protected void setTabSize(int i) { tabSize = i; }
-  protected int getTabSize(int i) { return tabSize; }
-
-  protected void ExpandBuff(boolean wrapAround)
-  {
-     char[] newbuffer = new char[bufsize + 2048];
-     int newbufline[] = new int[bufsize + 2048];
-     int newbufcolumn[] = new int[bufsize + 2048];
-
-     try
-     {
-        if (wrapAround)
-        {
-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
-           System.arraycopy(buffer, 0, newbuffer,
-                                             bufsize - tokenBegin, bufpos);
-           buffer = newbuffer;
-
-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
-           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
-           bufline = newbufline;
-
-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
-           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
-           bufcolumn = newbufcolumn;
-
-           bufpos += (bufsize - tokenBegin);
-        }
-        else
-        {
-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
-           buffer = newbuffer;
-
-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
-           bufline = newbufline;
-
-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
-           bufcolumn = newbufcolumn;
-
-           bufpos -= tokenBegin;
-        }
-     }
-     catch (Throwable t)
-     {
-        throw new Error(t.getMessage());
-     }
-
-     available = (bufsize += 2048);
-     tokenBegin = 0;
-  }
-
-  protected void FillBuff() throws java.io.IOException
-  {
-     int i;
-     if (maxNextCharInd == 4096)
-        maxNextCharInd = nextCharInd = 0;
-
-     try {
-        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
-                                            4096 - maxNextCharInd)) == -1)
-        {
-           inputStream.close();
-           throw new java.io.IOException();
-        }
-        else
-           maxNextCharInd += i;
-        return;
-     }
-     catch(java.io.IOException e) {
-        if (bufpos != 0)
-        {
-           --bufpos;
-           backup(0);
-        }
-        else
-        {
-           bufline[bufpos] = line;
-           bufcolumn[bufpos] = column;
-        }
-        throw e;
-     }
-  }
-
-  protected char ReadByte() throws java.io.IOException
-  {
-     if (++nextCharInd >= maxNextCharInd)
-        FillBuff();
-
-     return nextCharBuf[nextCharInd];
-  }
-
-/** @return starting character for token. */
-  public char BeginToken() throws java.io.IOException
-  {
-     if (inBuf > 0)
-     {
-        --inBuf;
-
-        if (++bufpos == bufsize)
-           bufpos = 0;
-
-        tokenBegin = bufpos;
-        return buffer[bufpos];
-     }
-
-     tokenBegin = 0;
-     bufpos = -1;
-
-     return readChar();
-  }
-
-  protected void AdjustBuffSize()
-  {
-     if (available == bufsize)
-     {
-        if (tokenBegin > 2048)
-        {
-           bufpos = 0;
-           available = tokenBegin;
-        }
-        else
-           ExpandBuff(false);
-     }
-     else if (available > tokenBegin)
-        available = bufsize;
-     else if ((tokenBegin - available) < 2048)
-        ExpandBuff(true);
-     else
-        available = tokenBegin;
-  }
-
-  protected void UpdateLineColumn(char c)
-  {
-     column++;
-
-     if (prevCharIsLF)
-     {
-        prevCharIsLF = false;
-        line += (column = 1);
-     }
-     else if (prevCharIsCR)
-     {
-        prevCharIsCR = false;
-        if (c == '\n')
-        {
-           prevCharIsLF = true;
-        }
-        else
-           line += (column = 1);
-     }
-
-     switch (c)
-     {
-        case '\r' :
-           prevCharIsCR = true;
-           break;
-        case '\n' :
-           prevCharIsLF = true;
-           break;
-        case '\t' :
-           column--;
-           column += (tabSize - (column % tabSize));
-           break;
-        default :
-           break;
-     }
-
-     bufline[bufpos] = line;
-     bufcolumn[bufpos] = column;
-  }
-
-/** Read a character. */
-  public char readChar() throws java.io.IOException
-  {
-     if (inBuf > 0)
-     {
-        --inBuf;
-
-        if (++bufpos == bufsize)
-           bufpos = 0;
-
-        return buffer[bufpos];
-     }
-
-     char c;
-
-     if (++bufpos == available)
-        AdjustBuffSize();
-
-     if ((buffer[bufpos] = c = ReadByte()) == '\\')
-     {
-        UpdateLineColumn(c);
-
-        int backSlashCnt = 1;
-
-        for (;;) // Read all the backslashes
-        {
-           if (++bufpos == available)
-              AdjustBuffSize();
-
-           try
-           {
-              if ((buffer[bufpos] = c = ReadByte()) != '\\')
-              {
-                 UpdateLineColumn(c);
-                 // found a non-backslash char.
-                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
-                 {
-                    if (--bufpos < 0)
-                       bufpos = bufsize - 1;
-
-                    break;
-                 }
-
-                 backup(backSlashCnt);
-                 return '\\';
-              }
-           }
-           catch(java.io.IOException e)
-           {
-              if (backSlashCnt > 1)
-                 backup(backSlashCnt-1);
-
-              return '\\';
-           }
-
-           UpdateLineColumn(c);
-           backSlashCnt++;
-        }
-
-        // Here, we have seen an odd number of backslash's followed by a 'u'
-        try
-        {
-           while ((c = ReadByte()) == 'u')
-              ++column;
-
-           buffer[bufpos] = c = (char)(hexval(c) << 12 |
-                                       hexval(ReadByte()) << 8 |
-                                       hexval(ReadByte()) << 4 |
-                                       hexval(ReadByte()));
-
-           column += 4;
-        }
-        catch(java.io.IOException e)
-        {
-           throw new Error("Invalid escape character at line " + line +
-                                         " column " + column + ".");
-        }
-
-        if (backSlashCnt == 1)
-           return c;
-        else
-        {
-           backup(backSlashCnt - 1);
-           return '\\';
-        }
-     }
-     else
-     {
-        UpdateLineColumn(c);
-        return c;
-     }
-  }
-
-  @Deprecated
-  /**
-   * @deprecated (gen)
-   * @see #getEndColumn
-   */
-  public int getColumn() {
-     return bufcolumn[bufpos];
-  }
-
-  @Deprecated
-  /**
-   * @deprecated (gen)
-   * @see #getEndLine
-   */
-  public int getLine() {
-     return bufline[bufpos];
-  }
-
-/** Get end column. */
-  public int getEndColumn() {
-     return bufcolumn[bufpos];
-  }
-
-/** Get end line. */
-  public int getEndLine() {
-     return bufline[bufpos];
-  }
-
-/** @return column of token start */
-  public int getBeginColumn() {
-     return bufcolumn[tokenBegin];
-  }
-
-/** @return line number of token start */
-  public int getBeginLine() {
-     return bufline[tokenBegin];
-  }
-
-/** Retreat. */
-  public void backup(int amount) {
-
-    inBuf += amount;
-    if ((bufpos -= amount) < 0)
-       bufpos += bufsize;
-  }
-
-/** Constructor. */
-  public JavaCharStream(java.io.Reader dstream,
-                 int startline, int startcolumn, int buffersize)
-  {
-    inputStream = dstream;
-    line = startline;
-    column = startcolumn - 1;
-
-    available = bufsize = buffersize;
-    buffer = new char[buffersize];
-    bufline = new int[buffersize];
-    bufcolumn = new int[buffersize];
-    nextCharBuf = new char[4096];
-  }
-
-/** Constructor. */
-  public JavaCharStream(java.io.Reader dstream,
-                                        int startline, int startcolumn)
-  {
-     this(dstream, startline, startcolumn, 4096);
-  }
-
-/** Constructor. */
-  public JavaCharStream(java.io.Reader dstream)
-  {
-     this(dstream, 1, 1, 4096);
-  }
-/** Reinitialise. */
-  public void ReInit(java.io.Reader dstream,
-                 int startline, int startcolumn, int buffersize)
-  {
-    inputStream = dstream;
-    line = startline;
-    column = startcolumn - 1;
-
-    if (buffer == null || buffersize != buffer.length)
-    {
-      available = bufsize = buffersize;
-      buffer = new char[buffersize];
-      bufline = new int[buffersize];
-      bufcolumn = new int[buffersize];
-      nextCharBuf = new char[4096];
-    }
-    prevCharIsLF = prevCharIsCR = false;
-    tokenBegin = inBuf = maxNextCharInd = 0;
-    nextCharInd = bufpos = -1;
-  }
-
-/** Reinitialise. */
-  public void ReInit(java.io.Reader dstream,
-                                        int startline, int startcolumn)
-  {
-     ReInit(dstream, startline, startcolumn, 4096);
-  }
-
-/** Reinitialise. */
-  public void ReInit(java.io.Reader dstream)
-  {
-     ReInit(dstream, 1, 1, 4096);
-  }
-/** Constructor. */
-  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
-  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
-  {
-     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
-  }
-
-/** Constructor. */
-  public JavaCharStream(java.io.InputStream dstream, int startline,
-  int startcolumn, int buffersize)
-  {
-     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
-  }
-
-/** Constructor. */
-  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
-                        int startcolumn) throws java.io.UnsupportedEncodingException
-  {
-     this(dstream, encoding, startline, startcolumn, 4096);
-  }
-
-/** Constructor. */
-  public JavaCharStream(java.io.InputStream dstream, int startline,
-                        int startcolumn)
-  {
-     this(dstream, startline, startcolumn, 4096);
-  }
-
-/** Constructor. */
-  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
-  {
-     this(dstream, encoding, 1, 1, 4096);
-  }
-
-/** Constructor. */
-  public JavaCharStream(java.io.InputStream dstream)
-  {
-     this(dstream, 1, 1, 4096);
-  }
-
-/** Reinitialise. */
-  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
-  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
-  {
-     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
-  }
-
-/** Reinitialise. */
-  public void ReInit(java.io.InputStream dstream, int startline,
-  int startcolumn, int buffersize)
-  {
-     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
-  }
-/** Reinitialise. */
-  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
-                     int startcolumn) throws java.io.UnsupportedEncodingException
-  {
-     ReInit(dstream, encoding, startline, startcolumn, 4096);
-  }
-/** Reinitialise. */
-  public void ReInit(java.io.InputStream dstream, int startline,
-                     int startcolumn)
-  {
-     ReInit(dstream, startline, startcolumn, 4096);
-  }
-/** Reinitialise. */
-  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
-  {
-     ReInit(dstream, encoding, 1, 1, 4096);
-  }
-
-/** Reinitialise. */
-  public void ReInit(java.io.InputStream dstream)
-  {
-     ReInit(dstream, 1, 1, 4096);
-  }
-
-  /** @return token image as String */
-  public String GetImage()
-  {
-     if (bufpos >= tokenBegin)
-        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
-     else
-        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
-                              new String(buffer, 0, bufpos + 1);
-  }
-
-  /** @return suffix */
-  public char[] GetSuffix(int len)
-  {
-     char[] ret = new char[len];
-
-     if ((bufpos + 1) >= len)
-        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
-     else
-     {
-        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
-                                                          len - bufpos - 1);
-        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
-     }
-
-     return ret;
-  }
-
-  /** Set buffers back to null when finished. */
-  public void Done()
-  {
-     nextCharBuf = null;
-     buffer = null;
-     bufline = null;
-     bufcolumn = null;
-  }
-
-  /**
-   * Method to adjust line and column numbers for the start of a token.
-   */
-  public void adjustBeginLineColumn(int newLine, int newCol)
-  {
-     int start = tokenBegin;
-     int len;
-
-     if (bufpos >= tokenBegin)
-     {
-        len = bufpos - tokenBegin + inBuf + 1;
-     }
-     else
-     {
-        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
-     }
-
-     int i = 0, j = 0, k = 0;
-     int nextColDiff = 0, columnDiff = 0;
-
-     while (i < len &&
-            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
-     {
-        bufline[j] = newLine;
-        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
-        bufcolumn[j] = newCol + columnDiff;
-        columnDiff = nextColDiff;
-        i++;
-     }
-
-     if (i < len)
-     {
-        bufline[j] = newLine++;
-        bufcolumn[j] = newCol + columnDiff;
-
-        while (i++ < len)
-        {
-           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
-              bufline[j] = newLine++;
-           else
-              bufline[j] = newLine;
-        }
-     }
-
-     line = bufline[j];
-     column = bufcolumn[j];
-  }
-
-}
-/* JavaCC - OriginalChecksum=f19c73b8f7faf94cc4a581e7b2933cc6 (do not edit this line) */
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java
deleted file mode 100644
index eee1116..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
-/* JavaCCOptions:KEEP_LINE_COL=null */
-package org.apache.lucene.queryParser.standard.parser;
- 
- import org.apache.lucene.messages.Message;
- import org.apache.lucene.messages.MessageImpl;
- import org.apache.lucene.queryParser.core.*;
- import org.apache.lucene.queryParser.core.messages.*;
-
-/**
- * This exception is thrown when parse errors are encountered.
- * You can explicitly create objects of this exception type by
- * calling the method generateParseException in the generated
- * parser.
- *
- * You can modify this class to customize your error reporting
- * mechanisms so long as you retain the public fields.
- */
-public class ParseException extends QueryNodeParseException {
-
-  /**
-   * This constructor is used by the method "generateParseException"
-   * in the generated parser.  Calling this constructor generates
-   * a new object of this type with the fields "currentToken",
-   * "expectedTokenSequences", and "tokenImage" set.  The boolean
-   * flag "specialConstructor" is also set to true to indicate that
-   * this constructor was used to create this object.
-   * This constructor calls its super class with the empty string
-   * to force the "toString" method of parent class "Throwable" to
-   * print the error message in the form:
-   *     ParseException: <result of getMessage>
-   */
-  public ParseException(Token currentTokenVal,
-     int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
-     super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(
-     currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));
-     this.currentToken = currentTokenVal;
-     this.expectedTokenSequences = expectedTokenSequencesVal;
-     this.tokenImage = tokenImageVal;
-   }
-
-  /**
-   * The following constructors are for use by you for whatever
-   * purpose you can think of.  Constructing the exception in this
-   * manner makes the exception behave in the normal way - i.e., as
-   * documented in the class "Throwable".  The fields "errorToken",
-   * "expectedTokenSequences", and "tokenImage" do not contain
-   * relevant information.  The JavaCC generated code does not use
-   * these constructors.
-   */
-
-  public ParseException() {
-     super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, "Error"));
-   }
-
-  /** Constructor with message. */
-  public ParseException(Message message) {
-     super(message);
-                         }
-
-  /**
-   * This variable determines which constructor was used to create
-   * this object and thereby affects the semantics of the
-   * "getMessage" method (see below).
-   */
-  protected boolean specialConstructor;
-
-  /**
-   * This is the last token that has been consumed successfully.  If
-   * this object has been created due to a parse error, the token
-   * followng this token will (therefore) be the first error token.
-   */
-  public Token currentToken;
-
-  /**
-   * Each entry in this array is an array of integers.  Each array
-   * of integers represents a sequence of tokens (by their ordinal
-   * values) that is expected at this point of the parse.
-   */
-  public int[][] expectedTokenSequences;
-
-  /**
-   * This is a reference to the "tokenImage" array of the generated
-   * parser within which the parse error occurred.  This array is
-   * defined in the generated ...Constants interface.
-   */
-  public String[] tokenImage;
-
-  /**
-   * This method has the standard behavior when this object has been
-   * created using the standard constructors.  Otherwise, it uses
-   * "currentToken" and "expectedTokenSequences" to generate a parse
-   * error message and returns it.  If this object has been created
-   * due to a parse error, and you do not catch it (it gets thrown
-   * from the parser), then this method is called during the printing
-   * of the final stack trace, and hence the correct error message
-   * gets displayed.
-   */
-  private static String initialise(Token currentToken, int[][] expectedTokenSequences, String[] tokenImage) {
-     String eol = System.getProperty("line.separator", "n");
-    StringBuffer expected = new StringBuffer();
-    int maxSize = 0;
-    for (int i = 0; i < expectedTokenSequences.length; i++) {
-      if (maxSize < expectedTokenSequences[i].length) {
-        maxSize = expectedTokenSequences[i].length;
-      }
-      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
-        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
-      }
-      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
-        expected.append("...");
-      }
-      expected.append(eol).append("    ");
-    }
-    String retval = "Encountered \"";
-    Token tok = currentToken.next;
-    for (int i = 0; i < maxSize; i++) {
-      if (i != 0) retval += " ";
-      if (tok.kind == 0) {
-        retval += tokenImage[0];
-        break;
-      }
-      retval += " " + tokenImage[tok.kind];
-      retval += " \"";
-      retval += add_escapes(tok.image);
-      retval += " \"";
-      tok = tok.next;
-    }
-    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
-    retval += "." + eol;
-    if (expectedTokenSequences.length == 1) {
-      retval += "Was expecting:" + eol + "    ";
-    } else {
-      retval += "Was expecting one of:" + eol + "    ";
-    }
-    retval += expected.toString();
-    return retval;
-  }
-
-  /**
-   * The end of line string for this machine.
-   */
-  protected String eol = System.getProperty("line.separator", "\n");
-
-  /**
-   * Used to convert raw characters to their escaped version
-   * when these raw version cannot be used as part of an ASCII
-   * string literal.
-   */
-  static private String add_escapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
-      }
-      return retval.toString();
-   }
-
-}
-/* JavaCC - OriginalChecksum=38bce846fe6c8482993969f741c0323e (do not edit this line) */
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
deleted file mode 100644
index 7b6aaa7..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
+++ /dev/null
@@ -1,905 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. StandardSyntaxParser.java */
-package org.apache.lucene.queryParser.standard.parser;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Vector;
-
-import org.apache.lucene.messages.Message;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
-import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
-
-public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserConstants {
-
-        private static final int CONJ_NONE =0;
-        private static final int CONJ_AND =2;
-        private static final int CONJ_OR =2;
-
-
-   // syntax parser constructor
-   public StandardSyntaxParser() {
-        this(new StringReader(""));
-  }
-     /** Parses a query string, returning a {@link org.apache.lucene.queryParser.core.nodes.QueryNode}.
-     *  @param query  the query string to be parsed.
-     *  @throws ParseException if the parsing fails
-     */
-    public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
-      ReInit(new StringReader(query.toString()));
-      try {
-        // TopLevelQuery is a Query followed by the end-of-input (EOF)
-        QueryNode querynode = TopLevelQuery(field);
-        return querynode;
-      }
-      catch (ParseException tme) {
-            tme.setQuery(query);
-            throw tme;
-      }
-      catch (Error tme) {
-          Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
-          QueryNodeParseException e = new QueryNodeParseException(tme);
-            e.setQuery(query);
-            e.setNonLocalizedMessage(message);
-            throw e;
-      }
-    }
-
-// *   Query  ::= ( Clause )*
-// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
-  final public int Conjunction() throws ParseException {
-  int ret = CONJ_NONE;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case AND:
-    case OR:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case AND:
-        jj_consume_token(AND);
-            ret = CONJ_AND;
-        break;
-      case OR:
-        jj_consume_token(OR);
-              ret = CONJ_OR;
-        break;
-      default:
-        jj_la1[0] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      break;
-    default:
-      jj_la1[1] = jj_gen;
-      ;
-    }
-    {if (true) return ret;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public ModifierQueryNode.Modifier Modifiers() throws ParseException {
-  ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case NOT:
-    case PLUS:
-    case MINUS:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case PLUS:
-        jj_consume_token(PLUS);
-              ret = ModifierQueryNode.Modifier.MOD_REQ;
-        break;
-      case MINUS:
-        jj_consume_token(MINUS);
-                 ret = ModifierQueryNode.Modifier.MOD_NOT;
-        break;
-      case NOT:
-        jj_consume_token(NOT);
-               ret = ModifierQueryNode.Modifier.MOD_NOT;
-        break;
-      default:
-        jj_la1[2] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      break;
-    default:
-      jj_la1[3] = jj_gen;
-      ;
-    }
-    {if (true) return ret;}
-    throw new Error("Missing return statement in function");
-  }
-
-// This makes sure that there is no garbage after the query string
-  final public QueryNode TopLevelQuery(CharSequence field) throws ParseException {
-        QueryNode q;
-    q = Query(field);
-    jj_consume_token(0);
-                {if (true) return q;}
-    throw new Error("Missing return statement in function");
-  }
-
-// These changes were made to introduce operator precedence:
-// - Clause() now returns a QueryNode. 
-// - The modifiers are consumed by Clause() and returned as part of the QueryNode Object
-// - Query does not consume conjunctions (AND, OR) anymore. 
-// - This is now done by two new non-terminals: ConjClause and DisjClause
-// The parse tree looks similar to this:
-//       Query ::= DisjQuery ( DisjQuery )*
-//   DisjQuery ::= ConjQuery ( OR ConjQuery )* 
-//   ConjQuery ::= Clause ( AND Clause )*
-//      Clause ::= [ Modifier ] ... 
-  final public QueryNode Query(CharSequence field) throws ParseException {
-  Vector<QueryNode> clauses = null;
-  QueryNode c, first=null;
-    first = DisjQuery(field);
-    label_1:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case NOT:
-      case PLUS:
-      case MINUS:
-      case LPAREN:
-      case QUOTED:
-      case TERM:
-      case REGEXPTERM:
-      case RANGEIN_START:
-      case RANGEEX_START:
-      case NUMBER:
-        ;
-        break;
-      default:
-        jj_la1[4] = jj_gen;
-        break label_1;
-      }
-      c = DisjQuery(field);
-             if (clauses == null) {
-                 clauses = new Vector<QueryNode>();
-                 clauses.addElement(first);
-             }
-         clauses.addElement(c);
-    }
-        if (clauses != null) {
-                {if (true) return new BooleanQueryNode(clauses);}
-        } else {
-                {if (true) return first;}
-        }
-    throw new Error("Missing return statement in function");
-  }
-
-  final public QueryNode DisjQuery(CharSequence field) throws ParseException {
-        QueryNode first, c;
-        Vector<QueryNode> clauses = null;
-    first = ConjQuery(field);
-    label_2:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case OR:
-        ;
-        break;
-      default:
-        jj_la1[5] = jj_gen;
-        break label_2;
-      }
-      jj_consume_token(OR);
-      c = ConjQuery(field);
-     if (clauses == null) {
-         clauses = new Vector<QueryNode>();
-         clauses.addElement(first);
-     }
-     clauses.addElement(c);
-    }
-    if (clauses != null) {
-            {if (true) return new OrQueryNode(clauses);}
-    } else {
-        {if (true) return first;}
-    }
-    throw new Error("Missing return statement in function");
-  }
-
-  final public QueryNode ConjQuery(CharSequence field) throws ParseException {
-        QueryNode first, c;
-        Vector<QueryNode> clauses = null;
-    first = ModClause(field);
-    label_3:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case AND:
-        ;
-        break;
-      default:
-        jj_la1[6] = jj_gen;
-        break label_3;
-      }
-      jj_consume_token(AND);
-      c = ModClause(field);
-     if (clauses == null) {
-         clauses = new Vector<QueryNode>();
-         clauses.addElement(first);
-     }
-     clauses.addElement(c);
-    }
-    if (clauses != null) {
-            {if (true) return new AndQueryNode(clauses);}
-    } else {
-        {if (true) return first;}
-    }
-    throw new Error("Missing return statement in function");
-  }
-
-// QueryNode Query(CharSequence field) :
-// {
-// List clauses = new ArrayList();
-//   List modifiers = new ArrayList();
-//   QueryNode q, firstQuery=null;
-//   ModifierQueryNode.Modifier mods;
-//   int conj;
-// }
-// {
-//   mods=Modifiers() q=Clause(field)
-//   {
-//     if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q;
-//     
-//     // do not create modifier nodes with MOD_NONE
-//    	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-//    		q = new ModifierQueryNode(q, mods);
-//    	}
-//    	clauses.add(q);
-//   }
-//   (
-//     conj=Conjunction() mods=Modifiers() q=Clause(field)
-//     { 
-// 	    // do not create modifier nodes with MOD_NONE
-// 	   	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-// 	   		q = new ModifierQueryNode(q, mods);
-// 	   	}
-// 	   	clauses.add(q);
-// 	   	//TODO: figure out what to do with AND and ORs
-//   }
-//   )*
-//     {
-//      if (clauses.size() == 1 && firstQuery != null)
-//         return firstQuery;
-//       else {
-//   		return new BooleanQueryNode(clauses);
-//       }
-//     }
-// }
-  final public QueryNode ModClause(CharSequence field) throws ParseException {
-  QueryNode q;
-  ModifierQueryNode.Modifier mods;
-    mods = Modifiers();
-    q = Clause(field);
-                if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-                        q = new ModifierQueryNode(q, mods);
-                }
-                {if (true) return q;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public QueryNode Clause(CharSequence field) throws ParseException {
-  QueryNode q;
-  Token fieldToken=null, boost=null;
-  boolean group = false;
-    if (jj_2_1(2)) {
-      fieldToken = jj_consume_token(TERM);
-      jj_consume_token(COLON);
-                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
-    } else {
-      ;
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case QUOTED:
-    case TERM:
-    case REGEXPTERM:
-    case RANGEIN_START:
-    case RANGEEX_START:
-    case NUMBER:
-      q = Term(field);
-      break;
-    case LPAREN:
-      jj_consume_token(LPAREN);
-      q = Query(field);
-      jj_consume_token(RPAREN);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CARAT:
-        jj_consume_token(CARAT);
-        boost = jj_consume_token(NUMBER);
-        break;
-      default:
-        jj_la1[7] = jj_gen;
-        ;
-      }
-                                                                 group=true;
-      break;
-    default:
-      jj_la1[8] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-      if (boost != null) {
-                  float f = (float)1.0;
-                  try {
-                    f = Float.valueOf(boost.image).floatValue();
-                    // avoid boosting null queries, such as those caused by stop words
-                if (q != null) {
-                        q = new BoostQueryNode(q, f);
-                }
-                  } catch (Exception ignored) {
-                        /* Should this be handled somehow? (defaults to "no boost", if
-             * boost number is invalid)
-             */
-                  }
-      }
-      if (group) { q = new GroupQueryNode(q);}
-      {if (true) return q;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public QueryNode Term(CharSequence field) throws ParseException {
-  Token term, boost=null, fuzzySlop=null, goop1, goop2;
-  boolean fuzzy = false;
-  boolean regexp = false;
-  QueryNode q =null;
-  ParametricQueryNode qLower, qUpper;
-  float defaultMinSimilarity = org.apache.lucene.search.FuzzyQuery.defaultMinSimilarity;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case TERM:
-    case REGEXPTERM:
-    case NUMBER:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case TERM:
-        term = jj_consume_token(TERM);
-                         q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-        break;
-      case REGEXPTERM:
-        term = jj_consume_token(REGEXPTERM);
-                             regexp=true;
-        break;
-      case NUMBER:
-        term = jj_consume_token(NUMBER);
-        break;
-      default:
-        jj_la1[9] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case FUZZY_SLOP:
-        fuzzySlop = jj_consume_token(FUZZY_SLOP);
-                                fuzzy=true;
-        break;
-      default:
-        jj_la1[10] = jj_gen;
-        ;
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CARAT:
-        jj_consume_token(CARAT);
-        boost = jj_consume_token(NUMBER);
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case FUZZY_SLOP:
-          fuzzySlop = jj_consume_token(FUZZY_SLOP);
-                                                         fuzzy=true;
-          break;
-        default:
-          jj_la1[11] = jj_gen;
-          ;
-        }
-        break;
-      default:
-        jj_la1[12] = jj_gen;
-        ;
-      }
-       if (fuzzy) {
-          float fms = defaultMinSimilarity;
-          try {
-            fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
-          } catch (Exception ignored) { }
-         if(fms < 0.0f){
-           {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));}
-         } else if (fms >= 1.0f && fms != (int) fms) {
-           {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));}
-         }
-         q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
-       } else if (regexp) {
-         q = new RegexpQueryNode(field, term.image, term.beginColumn, term.endColumn-1);
-       }
-      break;
-    case RANGEIN_START:
-      jj_consume_token(RANGEIN_START);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_GOOP:
-        goop1 = jj_consume_token(RANGEIN_GOOP);
-        break;
-      case RANGEIN_QUOTED:
-        goop1 = jj_consume_token(RANGEIN_QUOTED);
-        break;
-      default:
-        jj_la1[13] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_TO:
-        jj_consume_token(RANGEIN_TO);
-        break;
-      default:
-        jj_la1[14] = jj_gen;
-        ;
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_GOOP:
-        goop2 = jj_consume_token(RANGEIN_GOOP);
-        break;
-      case RANGEIN_QUOTED:
-        goop2 = jj_consume_token(RANGEIN_QUOTED);
-        break;
-      default:
-        jj_la1[15] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      jj_consume_token(RANGEIN_END);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CARAT:
-        jj_consume_token(CARAT);
-        boost = jj_consume_token(NUMBER);
-        break;
-      default:
-        jj_la1[16] = jj_gen;
-        ;
-      }
-          if (goop1.kind == RANGEIN_QUOTED) {
-            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
-          }
-          if (goop2.kind == RANGEIN_QUOTED) {
-            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
-          }
-
-          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,
-                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
-                  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,
-                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
-          q = new ParametricRangeQueryNode(qLower, qUpper);
-      break;
-    case RANGEEX_START:
-      jj_consume_token(RANGEEX_START);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_GOOP:
-        goop1 = jj_consume_token(RANGEEX_GOOP);
-        break;
-      case RANGEEX_QUOTED:
-        goop1 = jj_consume_token(RANGEEX_QUOTED);
-        break;
-      default:
-        jj_la1[17] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_TO:
-        jj_consume_token(RANGEEX_TO);
-        break;
-      default:
-        jj_la1[18] = jj_gen;
-        ;
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_GOOP:
-        goop2 = jj_consume_token(RANGEEX_GOOP);
-        break;
-      case RANGEEX_QUOTED:
-        goop2 = jj_consume_token(RANGEEX_QUOTED);
-        break;
-      default:
-        jj_la1[19] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      jj_consume_token(RANGEEX_END);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CARAT:
-        jj_consume_token(CARAT);
-        boost = jj_consume_token(NUMBER);
-        break;
-      default:
-        jj_la1[20] = jj_gen;
-        ;
-      }
-          if (goop1.kind == RANGEEX_QUOTED) {
-            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
-          }
-          if (goop2.kind == RANGEEX_QUOTED) {
-            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
-          }
-          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GT,
-                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
-                  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LT,
-                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
-          q = new ParametricRangeQueryNode(qLower, qUpper);
-      break;
-    case QUOTED:
-      term = jj_consume_token(QUOTED);
-                      q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length()-1)), term.beginColumn + 1, term.endColumn - 1);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case FUZZY_SLOP:
-        fuzzySlop = jj_consume_token(FUZZY_SLOP);
-        break;
-      default:
-        jj_la1[21] = jj_gen;
-        ;
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CARAT:
-        jj_consume_token(CARAT);
-        boost = jj_consume_token(NUMBER);
-        break;
-      default:
-        jj_la1[22] = jj_gen;
-        ;
-      }
-         int phraseSlop = 0;
-
-         if (fuzzySlop != null) {
-           try {
-             phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
-             q = new SlopQueryNode(q, phraseSlop);
-           }
-           catch (Exception ignored) {
-            /* Should this be handled somehow? (defaults to "no PhraseSlop", if
-	         * slop number is invalid)
-	         */
-           }
-         }
-      break;
-    default:
-      jj_la1[23] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-          if (boost != null) {
-                  float f = (float)1.0;
-                  try {
-                    f = Float.valueOf(boost.image).floatValue();
-                    // avoid boosting null queries, such as those caused by stop words
-                if (q != null) {
-                        q = new BoostQueryNode(q, f);
-                }
-                  } catch (Exception ignored) {
-                        /* Should this be handled somehow? (defaults to "no boost", if
-	         * boost number is invalid)
-	         */
-                  }
-          }
-      {if (true) return q;}
-    throw new Error("Missing return statement in function");
-  }
-
-  private boolean jj_2_1(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_1(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(0, xla); }
-  }
-
-  private boolean jj_3_1() {
-    if (jj_scan_token(TERM)) return true;
-    if (jj_scan_token(COLON)) return true;
-    return false;
-  }
-
-  /** Generated Token Manager. */
-  public StandardSyntaxParserTokenManager token_source;
-  JavaCharStream jj_input_stream;
-  /** Current token. */
-  public Token token;
-  /** Next token. */
-  public Token jj_nt;
-  private int jj_ntk;
-  private Token jj_scanpos, jj_lastpos;
-  private int jj_la;
-  private int jj_gen;
-  final private int[] jj_la1 = new int[24];
-  static private int[] jj_la1_0;
-  static {
-      jj_la1_init_0();
-   }
-   private static void jj_la1_init_0() {
-      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0xf63c00,0x200,0x100,0x10000,0xf62000,0x940000,0x80000,0x80000,0x10000,0xc000000,0x1000000,0xc000000,0x10000,0xc0000000,0x10000000,0xc0000000,0x10000,0x80000,0x10000,0xf60000,};
-   }
-  final private JJCalls[] jj_2_rtns = new JJCalls[1];
-  private boolean jj_rescan = false;
-  private int jj_gc = 0;
-
-  /** Constructor with InputStream. */
-  public StandardSyntaxParser(java.io.InputStream stream) {
-     this(stream, null);
-  }
-  /** Constructor with InputStream and supplied encoding */
-  public StandardSyntaxParser(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source = new StandardSyntaxParserTokenManager(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  /** Reinitialise. */
-  public void ReInit(java.io.InputStream stream) {
-     ReInit(stream, null);
-  }
-  /** Reinitialise. */
-  public void ReInit(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  /** Constructor. */
-  public StandardSyntaxParser(java.io.Reader stream) {
-    jj_input_stream = new JavaCharStream(stream, 1, 1);
-    token_source = new StandardSyntaxParserTokenManager(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  /** Reinitialise. */
-  public void ReInit(java.io.Reader stream) {
-    jj_input_stream.ReInit(stream, 1, 1);
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  /** Constructor with generated Token Manager. */
-  public StandardSyntaxParser(StandardSyntaxParserTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  /** Reinitialise. */
-  public void ReInit(StandardSyntaxParserTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  private Token jj_consume_token(int kind) throws ParseException {
-    Token oldToken;
-    if ((oldToken = token).next != null) token = token.next;
-    else token = token.next = token_source.getNextToken();
-    jj_ntk = -1;
-    if (token.kind == kind) {
-      jj_gen++;
-      if (++jj_gc > 100) {
-        jj_gc = 0;
-        for (int i = 0; i < jj_2_rtns.length; i++) {
-          JJCalls c = jj_2_rtns[i];
-          while (c != null) {
-            if (c.gen < jj_gen) c.first = null;
-            c = c.next;
-          }
-        }
-      }
-      return token;
-    }
-    token = oldToken;
-    jj_kind = kind;
-    throw generateParseException();
-  }
-
-  static private final class LookaheadSuccess extends java.lang.Error { }
-  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
-  private boolean jj_scan_token(int kind) {
-    if (jj_scanpos == jj_lastpos) {
-      jj_la--;
-      if (jj_scanpos.next == null) {
-        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
-      } else {
-        jj_lastpos = jj_scanpos = jj_scanpos.next;
-      }
-    } else {
-      jj_scanpos = jj_scanpos.next;
-    }
-    if (jj_rescan) {
-      int i = 0; Token tok = token;
-      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
-      if (tok != null) jj_add_error_token(kind, i);
-    }
-    if (jj_scanpos.kind != kind) return true;
-    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
-    return false;
-  }
-
-
-/** Get the next Token. */
-  final public Token getNextToken() {
-    if (token.next != null) token = token.next;
-    else token = token.next = token_source.getNextToken();
-    jj_ntk = -1;
-    jj_gen++;
-    return token;
-  }
-
-/** Get the specific Token. */
-  final public Token getToken(int index) {
-    Token t = token;
-    for (int i = 0; i < index; i++) {
-      if (t.next != null) t = t.next;
-      else t = t.next = token_source.getNextToken();
-    }
-    return t;
-  }
-
-  private int jj_ntk() {
-    if ((jj_nt=token.next) == null)
-      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
-    else
-      return (jj_ntk = jj_nt.kind);
-  }
-
-  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
-  private int[] jj_expentry;
-  private int jj_kind = -1;
-  private int[] jj_lasttokens = new int[100];
-  private int jj_endpos;
-
-  private void jj_add_error_token(int kind, int pos) {
-    if (pos >= 100) return;
-    if (pos == jj_endpos + 1) {
-      jj_lasttokens[jj_endpos++] = kind;
-    } else if (jj_endpos != 0) {
-      jj_expentry = new int[jj_endpos];
-      for (int i = 0; i < jj_endpos; i++) {
-        jj_expentry[i] = jj_lasttokens[i];
-      }
-      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
-        int[] oldentry = (int[])(it.next());
-        if (oldentry.length == jj_expentry.length) {
-          for (int i = 0; i < jj_expentry.length; i++) {
-            if (oldentry[i] != jj_expentry[i]) {
-              continue jj_entries_loop;
-            }
-          }
-          jj_expentries.add(jj_expentry);
-          break jj_entries_loop;
-        }
-      }
-      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
-    }
-  }
-
-  /** Generate ParseException. */
-  public ParseException generateParseException() {
-    jj_expentries.clear();
-    boolean[] la1tokens = new boolean[32];
-    if (jj_kind >= 0) {
-      la1tokens[jj_kind] = true;
-      jj_kind = -1;
-    }
-    for (int i = 0; i < 24; i++) {
-      if (jj_la1[i] == jj_gen) {
-        for (int j = 0; j < 32; j++) {
-          if ((jj_la1_0[i] & (1<<j)) != 0) {
-            la1tokens[j] = true;
-          }
-        }
-      }
-    }
-    for (int i = 0; i < 32; i++) {
-      if (la1tokens[i]) {
-        jj_expentry = new int[1];
-        jj_expentry[0] = i;
-        jj_expentries.add(jj_expentry);
-      }
-    }
-    jj_endpos = 0;
-    jj_rescan_token();
-    jj_add_error_token(0, 0);
-    int[][] exptokseq = new int[jj_expentries.size()][];
-    for (int i = 0; i < jj_expentries.size(); i++) {
-      exptokseq[i] = jj_expentries.get(i);
-    }
-    return new ParseException(token, exptokseq, tokenImage);
-  }
-
-  /** Enable tracing. */
-  final public void enable_tracing() {
-  }
-
-  /** Disable tracing. */
-  final public void disable_tracing() {
-  }
-
-  private void jj_rescan_token() {
-    jj_rescan = true;
-    for (int i = 0; i < 1; i++) {
-    try {
-      JJCalls p = jj_2_rtns[i];
-      do {
-        if (p.gen > jj_gen) {
-          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
-          switch (i) {
-            case 0: jj_3_1(); break;
-          }
-        }
-        p = p.next;
-      } while (p != null);
-      } catch(LookaheadSuccess ls) { }
-    }
-    jj_rescan = false;
-  }
-
-  private void jj_save(int index, int xla) {
-    JJCalls p = jj_2_rtns[index];
-    while (p.gen > jj_gen) {
-      if (p.next == null) { p = p.next = new JJCalls(); break; }
-      p = p.next;
-    }
-    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
-  }
-
-  static final class JJCalls {
-    int gen;
-    Token first;
-    int arg;
-    JJCalls next;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
deleted file mode 100644
index 428c4d9..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
+++ /dev/null
@@ -1,480 +0,0 @@
-/**
- * Standard file is based on the TextParser.jj from lucene 2.3
- */
-
-options {
-  STATIC=false;
-  JAVA_UNICODE_ESCAPE=true;
-  USER_CHAR_STREAM=false;
-  IGNORE_CASE=false;
-  JDK_VERSION="1.5";
-}
-
-PARSER_BEGIN(StandardSyntaxParser)
-package org.apache.lucene.queryParser.standard.parser;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Vector;
-
-import org.apache.lucene.messages.Message;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
-import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
-
-public class StandardSyntaxParser implements SyntaxParser {
-
-	private static final int CONJ_NONE =0;
-	private static final int CONJ_AND =2;
-	private static final int CONJ_OR =2;
-
- 
-   // syntax parser constructor
-   public StandardSyntaxParser() {
-   	this(new StringReader(""));
-  }
-     /** Parses a query string, returning a {@link org.apache.lucene.queryParser.core.nodes.QueryNode}.
-     *  @param query  the query string to be parsed.
-     *  @throws ParseException if the parsing fails
-     */
-    public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
-      ReInit(new StringReader(query.toString()));
-      try {
-        // TopLevelQuery is a Query followed by the end-of-input (EOF)
-        QueryNode querynode = TopLevelQuery(field);
-        return querynode;
-      }
-      catch (ParseException tme) {
-            tme.setQuery(query);
-            throw tme;
-      }
-      catch (Error tme) {
-          Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
-          QueryNodeParseException e = new QueryNodeParseException(tme);
-            e.setQuery(query);
-            e.setNonLocalizedMessage(message);
-            throw e;
-      }
-    }
-   
-}
-
-PARSER_END(StandardSyntaxParser)
-
-/* ***************** */
-/* Token Definitions */
-/* ***************** */
-
-<*> TOKEN : {
-  <#_NUM_CHAR:   ["0"-"9"] >
-// every character that follows a backslash is considered as an escaped character
-| <#_ESCAPED_CHAR: "\\" ~[] >
-| <#_TERM_START_CHAR: ( ~[ " ", "\t", "\n", "\r", "\u3000", "+", "-", "!", "(", ")", ":", "^",
-                           "[", "]", "\"", "{", "}", "~", "\\" ]
-                       | <_ESCAPED_CHAR> ) >
-| <#_TERM_CHAR: ( <_TERM_START_CHAR> | <_ESCAPED_CHAR> | "-" | "+" ) >
-| <#_WHITESPACE: ( " " | "\t" | "\n" | "\r" | "\u3000") >
-| <#_QUOTED_CHAR: ( ~[ "\"", "\\" ] | <_ESCAPED_CHAR> ) >
-}
-
-<DEFAULT, RangeIn, RangeEx> SKIP : {
-  < <_WHITESPACE>>
-}
-
-<DEFAULT> TOKEN : {
-  <AND:       ("AND" | "&&") >
-| <OR:        ("OR" | "||") >
-| <NOT:       ("NOT" | "!") >
-| <PLUS:      "+" >
-| <MINUS:     "-" >
-| <LPAREN:    "(" >
-| <RPAREN:    ")" >
-| <COLON:     ":" >
-| <CARAT:     "^" > : Boost
-| <QUOTED:     "\"" (<_QUOTED_CHAR>)* "\"">
-| <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
-| <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
-| <REGEXPTERM: "/" (~[ "/" ] | "\\/" )* "/" >
-| <RANGEIN_START: "[" > : RangeIn
-| <RANGEEX_START: "{" > : RangeEx
-}
-
-<Boost> TOKEN : {
-<NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? > : DEFAULT
-}
-
-<RangeIn> TOKEN : {
-<RANGEIN_TO: "TO">
-| <RANGEIN_END: "]"> : DEFAULT
-| <RANGEIN_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
-| <RANGEIN_GOOP: (~[ " ", "]" ])+ >
-}
-
-<RangeEx> TOKEN : {
-<RANGEEX_TO: "TO">
-| <RANGEEX_END: "}"> : DEFAULT
-| <RANGEEX_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
-| <RANGEEX_GOOP: (~[ " ", "}" ])+ >
-}
-
-// *   Query  ::= ( Clause )*
-// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
-
-int Conjunction() : {
-  int ret = CONJ_NONE;
-}
-{
-  [
-    <AND> { ret = CONJ_AND; }
-    | <OR>  { ret = CONJ_OR; }
-  ]
-  { return ret; }
-}
-
-ModifierQueryNode.Modifier Modifiers() : {
-  ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
-}
-{
-  [
-     <PLUS> { ret = ModifierQueryNode.Modifier.MOD_REQ; }
-     | <MINUS> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
-     | <NOT> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
-  ]
-  { return ret; }
-}
-
-// This makes sure that there is no garbage after the query string
-QueryNode TopLevelQuery(CharSequence field) : 
-{
-	QueryNode q;
-}
-{
-	q=Query(field) <EOF>
-	{
-		return q;
-	}
-}
-
-// These changes were made to introduce operator precedence:
-// - Clause() now returns a QueryNode. 
-// - The modifiers are consumed by Clause() and returned as part of the QueryNode Object
-// - Query does not consume conjunctions (AND, OR) anymore. 
-// - This is now done by two new non-terminals: ConjClause and DisjClause
-// The parse tree looks similar to this:
-//       Query ::= DisjQuery ( DisjQuery )*
-//   DisjQuery ::= ConjQuery ( OR ConjQuery )* 
-//   ConjQuery ::= Clause ( AND Clause )*
-//      Clause ::= [ Modifier ] ... 
-
-
-QueryNode Query(CharSequence field) :
-{
-  Vector<QueryNode> clauses = null;
-  QueryNode c, first=null;
-}
-{
-  first=DisjQuery(field)
-  (
-    c=DisjQuery(field)
-    { 
-	     if (clauses == null) {
-	         clauses = new Vector<QueryNode>();
-	         clauses.addElement(first); 
-	     } 
-    	 clauses.addElement(c);
-    }
-    )*
-    {
-        if (clauses != null) { 
-	    	return new BooleanQueryNode(clauses);
-    	} else {
-        	return first;
-    	}
-    }
-}
-
-QueryNode DisjQuery(CharSequence field) : {
-	QueryNode first, c;
-	Vector<QueryNode> clauses = null;
-}
-{
-  first = ConjQuery(field)
-  (
-   <OR> c=ConjQuery(field)
-   { 
-     if (clauses == null) {
-         clauses = new Vector<QueryNode>();
-         clauses.addElement(first); 
-     } 
-     clauses.addElement(c);
-   }
-  )*
-  {
-    if (clauses != null) { 
-	    return new OrQueryNode(clauses);
-    } else {
-        return first;
-    }
-  }
-}
-
-QueryNode ConjQuery(CharSequence field) : {
-	QueryNode first, c;
-	Vector<QueryNode> clauses = null;
-}
-{
-  first = ModClause(field)
-  (
-   <AND> c=ModClause(field)
-   { 
-     if (clauses == null) {
-         clauses = new Vector<QueryNode>();
-         clauses.addElement(first);
-     } 
-     clauses.addElement(c); 
-   }
-  )*
-  {
-    if (clauses != null) {     
-	    return new AndQueryNode(clauses);
-    } else {
-        return first;
-    }
-  }
-}
-
-// QueryNode Query(CharSequence field) :
-// {
-// List clauses = new ArrayList();
-//   List modifiers = new ArrayList();
-//   QueryNode q, firstQuery=null;
-//   ModifierQueryNode.Modifier mods;
-//   int conj;
-// }
-// {
-//   mods=Modifiers() q=Clause(field)
-//   {
-//     if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q;
-//     
-//     // do not create modifier nodes with MOD_NONE
-//    	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-//    		q = new ModifierQueryNode(q, mods);
-//    	}
-//    	clauses.add(q);
-//   }
-//   (
-//     conj=Conjunction() mods=Modifiers() q=Clause(field)
-//     { 
-// 	    // do not create modifier nodes with MOD_NONE
-// 	   	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-// 	   		q = new ModifierQueryNode(q, mods);
-// 	   	}
-// 	   	clauses.add(q);
-// 	   	//TODO: figure out what to do with AND and ORs
-//   }
-//   )*
-//     {
-//      if (clauses.size() == 1 && firstQuery != null)
-//         return firstQuery;
-//       else {
-//   		return new BooleanQueryNode(clauses);
-//       }
-//     }
-// }
-
-QueryNode ModClause(CharSequence field) : {
-  QueryNode q; 
-  ModifierQueryNode.Modifier mods;
-}
-{
-   mods=Modifiers() q= Clause(field) {
- 	   	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
- 	   		q = new ModifierQueryNode(q, mods);
- 	   	}
- 	   	return q;
-   }
-}
-
-QueryNode Clause(CharSequence field) : {
-  QueryNode q;
-  Token fieldToken=null, boost=null;
-  boolean group = false;
-}
-{
-  [
-    LOOKAHEAD(2)
-    (
-    fieldToken=<TERM> <COLON> {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);}    
-    )
-  ]
-
-  (
-   q=Term(field)
-   | <LPAREN> q=Query(field) <RPAREN> (<CARAT> boost=<NUMBER>)? {group=true;}
-
-  )
-    {
-      if (boost != null) {
-		  float f = (float)1.0;
-		  try {
-		    f = Float.valueOf(boost.image).floatValue();
-		    // avoid boosting null queries, such as those caused by stop words
-	      	if (q != null) {
-	        	q = new BoostQueryNode(q, f);
-	      	}
-		  } catch (Exception ignored) {
-		  	/* Should this be handled somehow? (defaults to "no boost", if
-             * boost number is invalid)
-             */		  
-		  }
-      }
-      if (group) { q = new GroupQueryNode(q);}
-      return q;
-    }
-}
-
-
-QueryNode Term(CharSequence field) : {
-  Token term, boost=null, fuzzySlop=null, goop1, goop2;
-  boolean fuzzy = false;
-  boolean regexp = false;
-  QueryNode q =null; 
-  ParametricQueryNode qLower, qUpper;
-  float defaultMinSimilarity = org.apache.lucene.search.FuzzyQuery.defaultMinSimilarity;
-}
-{
-  (
-     (
- 	   term=<TERM> { q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
-       | term=<REGEXPTERM> { regexp=true; }
-       | term=<NUMBER>
-     )
-     [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ]
-     [ <CARAT> boost=<NUMBER> [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ] ]
-     {
-       if (fuzzy) {
-       	  float fms = defaultMinSimilarity;
-       	  try {
-            fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
-       	  } catch (Exception ignored) { }
-       	 if(fms < 0.0f){
-       	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
-       	 } else if (fms >= 1.0f && fms != (int) fms) {
-       	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));
-       	 }
-       	 q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
-       } else if (regexp) {
-         q = new RegexpQueryNode(field, term.image, term.beginColumn, term.endColumn-1);
-       }
-     }
-     | ( <RANGEIN_START> ( goop1=<RANGEIN_GOOP>|goop1=<RANGEIN_QUOTED> )
-         [ <RANGEIN_TO> ] ( goop2=<RANGEIN_GOOP>|goop2=<RANGEIN_QUOTED> )
-         <RANGEIN_END> )
-       [ <CARAT> boost=<NUMBER> ]
-        {
-          if (goop1.kind == RANGEIN_QUOTED) {
-            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
-          }
-          if (goop2.kind == RANGEIN_QUOTED) {
-            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
-          }
-          
-          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE, 
-		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
-		  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE, 
-		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
-          q = new ParametricRangeQueryNode(qLower, qUpper);
-        }
-     | ( <RANGEEX_START> ( goop1=<RANGEEX_GOOP>|goop1=<RANGEEX_QUOTED> )
-         [ <RANGEEX_TO> ] ( goop2=<RANGEEX_GOOP>|goop2=<RANGEEX_QUOTED> )
-         <RANGEEX_END> )
-       [ <CARAT> boost=<NUMBER> ]
-        {
-          if (goop1.kind == RANGEEX_QUOTED) {
-            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
-          }
-          if (goop2.kind == RANGEEX_QUOTED) {
-            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
-          }
-          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GT, 
-		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
-		  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LT, 
-		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
-          q = new ParametricRangeQueryNode(qLower, qUpper);		  
-        }
-     | term=<QUOTED> {q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length()-1)), term.beginColumn + 1, term.endColumn - 1);}
-       [ fuzzySlop=<FUZZY_SLOP> ]
-       [ <CARAT> boost=<NUMBER> ]
-       {       
-         int phraseSlop = 0;
-
-         if (fuzzySlop != null) {
-           try {
-             phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
-             q = new SlopQueryNode(q, phraseSlop);    
-           }
-           catch (Exception ignored) {
-            /* Should this be handled somehow? (defaults to "no PhraseSlop", if
-	         * slop number is invalid)
-	         */		
-           }
-         }
-              
-       }
-  )
-  {
-	  if (boost != null) {
-		  float f = (float)1.0;
-		  try {
-		    f = Float.valueOf(boost.image).floatValue();
-		    // avoid boosting null queries, such as those caused by stop words
-	      	if (q != null) {
-	        	q = new BoostQueryNode(q, f);
-	      	}
-		  } catch (Exception ignored) {
-		  	/* Should this be handled somehow? (defaults to "no boost", if
-	         * boost number is invalid)
-	         */		  
-		  }
-	  }
-      return q;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java
deleted file mode 100644
index bd4a5d1..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. StandardSyntaxParserConstants.java */
-package org.apache.lucene.queryParser.standard.parser;
-
-
-/**
- * Token literal values and constants.
- * Generated by org.javacc.parser.OtherFilesGen#start()
- */
-public interface StandardSyntaxParserConstants {
-
-  /** End of File. */
-  int EOF = 0;
-  /** RegularExpression Id. */
-  int _NUM_CHAR = 1;
-  /** RegularExpression Id. */
-  int _ESCAPED_CHAR = 2;
-  /** RegularExpression Id. */
-  int _TERM_START_CHAR = 3;
-  /** RegularExpression Id. */
-  int _TERM_CHAR = 4;
-  /** RegularExpression Id. */
-  int _WHITESPACE = 5;
-  /** RegularExpression Id. */
-  int _QUOTED_CHAR = 6;
-  /** RegularExpression Id. */
-  int AND = 8;
-  /** RegularExpression Id. */
-  int OR = 9;
-  /** RegularExpression Id. */
-  int NOT = 10;
-  /** RegularExpression Id. */
-  int PLUS = 11;
-  /** RegularExpression Id. */
-  int MINUS = 12;
-  /** RegularExpression Id. */
-  int LPAREN = 13;
-  /** RegularExpression Id. */
-  int RPAREN = 14;
-  /** RegularExpression Id. */
-  int COLON = 15;
-  /** RegularExpression Id. */
-  int CARAT = 16;
-  /** RegularExpression Id. */
-  int QUOTED = 17;
-  /** RegularExpression Id. */
-  int TERM = 18;
-  /** RegularExpression Id. */
-  int FUZZY_SLOP = 19;
-  /** RegularExpression Id. */
-  int REGEXPTERM = 20;
-  /** RegularExpression Id. */
-  int RANGEIN_START = 21;
-  /** RegularExpression Id. */
-  int RANGEEX_START = 22;
-  /** RegularExpression Id. */
-  int NUMBER = 23;
-  /** RegularExpression Id. */
-  int RANGEIN_TO = 24;
-  /** RegularExpression Id. */
-  int RANGEIN_END = 25;
-  /** RegularExpression Id. */
-  int RANGEIN_QUOTED = 26;
-  /** RegularExpression Id. */
-  int RANGEIN_GOOP = 27;
-  /** RegularExpression Id. */
-  int RANGEEX_TO = 28;
-  /** RegularExpression Id. */
-  int RANGEEX_END = 29;
-  /** RegularExpression Id. */
-  int RANGEEX_QUOTED = 30;
-  /** RegularExpression Id. */
-  int RANGEEX_GOOP = 31;
-
-  /** Lexical state. */
-  int Boost = 0;
-  /** Lexical state. */
-  int RangeEx = 1;
-  /** Lexical state. */
-  int RangeIn = 2;
-  /** Lexical state. */
-  int DEFAULT = 3;
-
-  /** Literal token values. */
-  String[] tokenImage = {
-    "<EOF>",
-    "<_NUM_CHAR>",
-    "<_ESCAPED_CHAR>",
-    "<_TERM_START_CHAR>",
-    "<_TERM_CHAR>",
-    "<_WHITESPACE>",
-    "<_QUOTED_CHAR>",
-    "<token of kind 7>",
-    "<AND>",
-    "<OR>",
-    "<NOT>",
-    "\"+\"",
-    "\"-\"",
-    "\"(\"",
-    "\")\"",
-    "\":\"",
-    "\"^\"",
-    "<QUOTED>",
-    "<TERM>",
-    "<FUZZY_SLOP>",
-    "<REGEXPTERM>",
-    "\"[\"",
-    "\"{\"",
-    "<NUMBER>",
-    "\"TO\"",
-    "\"]\"",
-    "<RANGEIN_QUOTED>",
-    "<RANGEIN_GOOP>",
-    "\"TO\"",
-    "\"}\"",
-    "<RANGEEX_QUOTED>",
-    "<RANGEEX_GOOP>",
-  };
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java
deleted file mode 100644
index 66cfbdd..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java
+++ /dev/null
@@ -1,1149 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. StandardSyntaxParserTokenManager.java */
-package org.apache.lucene.queryParser.standard.parser;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Vector;
-import org.apache.lucene.messages.Message;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
-import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
-
-/** Token Manager. */
-public class StandardSyntaxParserTokenManager implements StandardSyntaxParserConstants
-{
-
-  /** Debug output. */
-  public  java.io.PrintStream debugStream = System.out;
-  /** Set debug output. */
-  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_3(int pos, long active0)
-{
-   switch (pos)
-   {
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_3(int pos, long active0)
-{
-   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
-}
-private int jjStopAtPos(int pos, int kind)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   return pos + 1;
-}
-private int jjMoveStringLiteralDfa0_3()
-{
-   switch(curChar)
-   {
-      case 40:
-         return jjStopAtPos(0, 13);
-      case 41:
-         return jjStopAtPos(0, 14);
-      case 43:
-         return jjStopAtPos(0, 11);
-      case 45:
-         return jjStopAtPos(0, 12);
-      case 58:
-         return jjStopAtPos(0, 15);
-      case 91:
-         return jjStopAtPos(0, 21);
-      case 94:
-         return jjStopAtPos(0, 16);
-      case 123:
-         return jjStopAtPos(0, 22);
-      default :
-         return jjMoveNfa_3(0, 0);
-   }
-}
-static final long[] jjbitVec0 = {
-   0x1L, 0x0L, 0x0L, 0x0L
-};
-static final long[] jjbitVec1 = {
-   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-static final long[] jjbitVec3 = {
-   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-static final long[] jjbitVec4 = {
-   0xfffefffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-private int jjMoveNfa_3(int startState, int curPos)
-{
-   int startsAt = 0;
-   jjnewStateCnt = 33;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0xfbffd4f8ffffd9ffL & l) != 0L)
-                  {
-                     if (kind > 18)
-                        kind = 18;
-                     jjCheckNAddTwoStates(20, 21);
-                  }
-                  else if ((0x100002600L & l) != 0L)
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  else if (curChar == 34)
-                     jjCheckNAddStates(0, 2);
-                  else if (curChar == 33)
-                  {
-                     if (kind > 10)
-                        kind = 10;
-                  }
-                  if (curChar == 47)
-                     jjCheckNAddStates(3, 5);
-                  else if (curChar == 38)
-                     jjstateSet[jjnewStateCnt++] = 4;
-                  break;
-               case 4:
-                  if (curChar == 38 && kind > 8)
-                     kind = 8;
-                  break;
-               case 5:
-                  if (curChar == 38)
-                     jjstateSet[jjnewStateCnt++] = 4;
-                  break;
-               case 13:
-                  if (curChar == 33 && kind > 10)
-                     kind = 10;
-                  break;
-               case 14:
-                  if (curChar == 34)
-                     jjCheckNAddStates(0, 2);
-                  break;
-               case 15:
-                  if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(0, 2);
-                  break;
-               case 17:
-                  jjCheckNAddStates(0, 2);
-                  break;
-               case 18:
-                  if (curChar == 34 && kind > 17)
-                     kind = 17;
-                  break;
-               case 19:
-                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 18)
-                     kind = 18;
-                  jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 20:
-                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 18)
-                     kind = 18;
-                  jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 22:
-                  if (kind > 18)
-                     kind = 18;
-                  jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 25:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjAddStates(6, 7);
-                  break;
-               case 26:
-                  if (curChar == 46)
-                     jjCheckNAdd(27);
-                  break;
-               case 27:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAdd(27);
-                  break;
-               case 28:
-               case 30:
-                  if (curChar == 47)
-                     jjCheckNAddStates(3, 5);
-                  break;
-               case 29:
-                  if ((0xffff7fffffffffffL & l) != 0L)
-                     jjCheckNAddStates(3, 5);
-                  break;
-               case 32:
-                  if (curChar == 47 && kind > 20)
-                     kind = 20;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0x97ffffff87ffffffL & l) != 0L)
-                  {
-                     if (kind > 18)
-                        kind = 18;
-                     jjCheckNAddTwoStates(20, 21);
-                  }
-                  else if (curChar == 126)
-                  {
-                     if (kind > 19)
-                        kind = 19;
-                     jjstateSet[jjnewStateCnt++] = 25;
-                  }
-                  else if (curChar == 92)
-                     jjCheckNAdd(22);
-                  if (curChar == 78)
-                     jjstateSet[jjnewStateCnt++] = 11;
-                  else if (curChar == 124)
-                     jjstateSet[jjnewStateCnt++] = 8;
-                  else if (curChar == 79)
-                     jjstateSet[jjnewStateCnt++] = 6;
-                  else if (curChar == 65)
-                     jjstateSet[jjnewStateCnt++] = 2;
-                  break;
-               case 1:
-                  if (curChar == 68 && kind > 8)
-                     kind = 8;
-                  break;
-               case 2:
-                  if (curChar == 78)
-                     jjstateSet[jjnewStateCnt++] = 1;
-                  break;
-               case 3:
-                  if (curChar == 65)
-                     jjstateSet[jjnewStateCnt++] = 2;
-                  break;
-               case 6:
-                  if (curChar == 82 && kind > 9)
-                     kind = 9;
-                  break;
-               case 7:
-                  if (curChar == 79)
-                     jjstateSet[jjnewStateCnt++] = 6;
-                  break;
-               case 8:
-                  if (curChar == 124 && kind > 9)
-                     kind = 9;
-                  break;
-               case 9:
-                  if (curChar == 124)
-                     jjstateSet[jjnewStateCnt++] = 8;
-                  break;
-               case 10:
-                  if (curChar == 84 && kind > 10)
-                     kind = 10;
-                  break;
-               case 11:
-                  if (curChar == 79)
-                     jjstateSet[jjnewStateCnt++] = 10;
-                  break;
-               case 12:
-                  if (curChar == 78)
-                     jjstateSet[jjnewStateCnt++] = 11;
-                  break;
-               case 15:
-                  if ((0xffffffffefffffffL & l) != 0L)
-                     jjCheckNAddStates(0, 2);
-                  break;
-               case 16:
-                  if (curChar == 92)
-                     jjstateSet[jjnewStateCnt++] = 17;
-                  break;
-               case 17:
-                  jjCheckNAddStates(0, 2);
-                  break;
-               case 19:
-               case 20:
-                  if ((0x97ffffff87ffffffL & l) == 0L)
-                     break;
-                  if (kind > 18)
-                     kind = 18;
-                  jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 21:
-                  if (curChar == 92)
-                     jjCheckNAddTwoStates(22, 22);
-                  break;
-               case 22:
-                  if (kind > 18)
-                     kind = 18;
-                  jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 23:
-                  if (curChar == 92)
-                     jjCheckNAdd(22);
-                  break;
-               case 24:
-                  if (curChar != 126)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjstateSet[jjnewStateCnt++] = 25;
-                  break;
-               case 29:
-                  jjAddStates(3, 5);
-                  break;
-               case 31:
-                  if (curChar == 92)
-                     jjstateSet[jjnewStateCnt++] = 30;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 18)
-                        kind = 18;
-                     jjCheckNAddTwoStates(20, 21);
-                  }
-                  break;
-               case 15:
-               case 17:
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjCheckNAddStates(0, 2);
-                  break;
-               case 19:
-               case 20:
-                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 18)
-                     kind = 18;
-                  jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 22:
-                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 18)
-                     kind = 18;
-                  jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 29:
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(3, 5);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 33 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-private final int jjStopStringLiteralDfa_1(int pos, long active0)
-{
-   switch (pos)
-   {
-      case 0:
-         if ((active0 & 0x10000000L) != 0L)
-         {
-            jjmatchedKind = 31;
-            return 6;
-         }
-         return -1;
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_1(int pos, long active0)
-{
-   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
-}
-private int jjMoveStringLiteralDfa0_1()
-{
-   switch(curChar)
-   {
-      case 84:
-         return jjMoveStringLiteralDfa1_1(0x10000000L);
-      case 125:
-         return jjStopAtPos(0, 29);
-      default :
-         return jjMoveNfa_1(0, 0);
-   }
-}
-private int jjMoveStringLiteralDfa1_1(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_1(0, active0);
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 79:
-         if ((active0 & 0x10000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 28, 6);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_1(0, active0);
-}
-private int jjStartNfaWithStates_1(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_1(state, pos + 1);
-}
-private int jjMoveNfa_1(int startState, int curPos)
-{
-   int startsAt = 0;
-   jjnewStateCnt = 7;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0xfffffffeffffffffL & l) != 0L)
-                  {
-                     if (kind > 31)
-                        kind = 31;
-                     jjCheckNAdd(6);
-                  }
-                  if ((0x100002600L & l) != 0L)
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  else if (curChar == 34)
-                     jjCheckNAddTwoStates(2, 4);
-                  break;
-               case 1:
-                  if (curChar == 34)
-                     jjCheckNAddTwoStates(2, 4);
-                  break;
-               case 2:
-                  if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               case 3:
-                  if (curChar == 34)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               case 5:
-                  if (curChar == 34 && kind > 30)
-                     kind = 30;
-                  break;
-               case 6:
-                  if ((0xfffffffeffffffffL & l) == 0L)
-                     break;
-                  if (kind > 31)
-                     kind = 31;
-                  jjCheckNAdd(6);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-               case 6:
-                  if ((0xdfffffffffffffffL & l) == 0L)
-                     break;
-                  if (kind > 31)
-                     kind = 31;
-                  jjCheckNAdd(6);
-                  break;
-               case 2:
-                  jjAddStates(8, 10);
-                  break;
-               case 4:
-                  if (curChar == 92)
-                     jjstateSet[jjnewStateCnt++] = 3;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 31)
-                        kind = 31;
-                     jjCheckNAdd(6);
-                  }
-                  break;
-               case 2:
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(8, 10);
-                  break;
-               case 6:
-                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 31)
-                     kind = 31;
-                  jjCheckNAdd(6);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-private int jjMoveStringLiteralDfa0_0()
-{
-   return jjMoveNfa_0(0, 0);
-}
-private int jjMoveNfa_0(int startState, int curPos)
-{
-   int startsAt = 0;
-   jjnewStateCnt = 3;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 23)
-                     kind = 23;
-                  jjAddStates(11, 12);
-                  break;
-               case 1:
-                  if (curChar == 46)
-                     jjCheckNAdd(2);
-                  break;
-               case 2:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 23)
-                     kind = 23;
-                  jjCheckNAdd(2);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-private final int jjStopStringLiteralDfa_2(int pos, long active0)
-{
-   switch (pos)
-   {
-      case 0:
-         if ((active0 & 0x1000000L) != 0L)
-         {
-            jjmatchedKind = 27;
-            return 6;
-         }
-         return -1;
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_2(int pos, long active0)
-{
-   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
-}
-private int jjMoveStringLiteralDfa0_2()
-{
-   switch(curChar)
-   {
-      case 84:
-         return jjMoveStringLiteralDfa1_2(0x1000000L);
-      case 93:
-         return jjStopAtPos(0, 25);
-      default :
-         return jjMoveNfa_2(0, 0);
-   }
-}
-private int jjMoveStringLiteralDfa1_2(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_2(0, active0);
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 79:
-         if ((active0 & 0x1000000L) != 0L)
-            return jjStartNfaWithStates_2(1, 24, 6);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_2(0, active0);
-}
-private int jjStartNfaWithStates_2(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_2(state, pos + 1);
-}
-private int jjMoveNfa_2(int startState, int curPos)
-{
-   int startsAt = 0;
-   jjnewStateCnt = 7;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0xfffffffeffffffffL & l) != 0L)
-                  {
-                     if (kind > 27)
-                        kind = 27;
-                     jjCheckNAdd(6);
-                  }
-                  if ((0x100002600L & l) != 0L)
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  else if (curChar == 34)
-                     jjCheckNAddTwoStates(2, 4);
-                  break;
-               case 1:
-                  if (curChar == 34)
-                     jjCheckNAddTwoStates(2, 4);
-                  break;
-               case 2:
-                  if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               case 3:
-                  if (curChar == 34)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               case 5:
-                  if (curChar == 34 && kind > 26)
-                     kind = 26;
-                  break;
-               case 6:
-                  if ((0xfffffffeffffffffL & l) == 0L)
-                     break;
-                  if (kind > 27)
-                     kind = 27;
-                  jjCheckNAdd(6);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-               case 6:
-                  if ((0xffffffffdfffffffL & l) == 0L)
-                     break;
-                  if (kind > 27)
-                     kind = 27;
-                  jjCheckNAdd(6);
-                  break;
-               case 2:
-                  jjAddStates(8, 10);
-                  break;
-               case 4:
-                  if (curChar == 92)
-                     jjstateSet[jjnewStateCnt++] = 3;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 27)
-                        kind = 27;
-                     jjCheckNAdd(6);
-                  }
-                  break;
-               case 2:
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(8, 10);
-                  break;
-               case 6:
-                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 27)
-                     kind = 27;
-                  jjCheckNAdd(6);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-static final int[] jjnextStates = {
-   15, 16, 18, 29, 31, 32, 25, 26, 2, 4, 5, 0, 1, 
-};
-private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
-{
-   switch(hiByte)
-   {
-      case 48:
-         return ((jjbitVec0[i2] & l2) != 0L);
-      default :
-         return false;
-   }
-}
-private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
-{
-   switch(hiByte)
-   {
-      case 0:
-         return ((jjbitVec3[i2] & l2) != 0L);
-      default :
-         if ((jjbitVec1[i1] & l1) != 0L)
-            return true;
-         return false;
-   }
-}
-private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
-{
-   switch(hiByte)
-   {
-      case 0:
-         return ((jjbitVec3[i2] & l2) != 0L);
-      case 48:
-         return ((jjbitVec1[i2] & l2) != 0L);
-      default :
-         if ((jjbitVec4[i1] & l1) != 0L)
-            return true;
-         return false;
-   }
-}
-
-/** Token literal values. */
-public static final String[] jjstrLiteralImages = {
-"", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
-"\50", "\51", "\72", "\136", null, null, null, null, "\133", "\173", null, 
-"\124\117", "\135", null, null, "\124\117", "\175", null, null, };
-
-/** Lexer state names. */
-public static final String[] lexStateNames = {
-   "Boost",
-   "RangeEx",
-   "RangeIn",
-   "DEFAULT",
-};
-
-/** Lex State array. */
-public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, 2, 1, 3, -1, 
-   3, -1, -1, -1, 3, -1, -1, 
-};
-static final long[] jjtoToken = {
-   0xffffff01L, 
-};
-static final long[] jjtoSkip = {
-   0x80L, 
-};
-protected JavaCharStream input_stream;
-private final int[] jjrounds = new int[33];
-private final int[] jjstateSet = new int[66];
-protected char curChar;
-/** Constructor. */
-public StandardSyntaxParserTokenManager(JavaCharStream stream){
-   if (JavaCharStream.staticFlag)
-      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
-   input_stream = stream;
-}
-
-/** Constructor. */
-public StandardSyntaxParserTokenManager(JavaCharStream stream, int lexState){
-   this(stream);
-   SwitchTo(lexState);
-}
-
-/** Reinitialise parser. */
-public void ReInit(JavaCharStream stream)
-{
-   jjmatchedPos = jjnewStateCnt = 0;
-   curLexState = defaultLexState;
-   input_stream = stream;
-   ReInitRounds();
-}
-private void ReInitRounds()
-{
-   int i;
-   jjround = 0x80000001;
-   for (i = 33; i-- > 0;)
-      jjrounds[i] = 0x80000000;
-}
-
-/** Reinitialise parser. */
-public void ReInit(JavaCharStream stream, int lexState)
-{
-   ReInit(stream);
-   SwitchTo(lexState);
-}
-
-/** Switch to specified lex state. */
-public void SwitchTo(int lexState)
-{
-   if (lexState >= 4 || lexState < 0)
-      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
-   else
-      curLexState = lexState;
-}
-
-protected Token jjFillToken()
-{
-   final Token t;
-   final String curTokenImage;
-   final int beginLine;
-   final int endLine;
-   final int beginColumn;
-   final int endColumn;
-   String im = jjstrLiteralImages[jjmatchedKind];
-   curTokenImage = (im == null) ? input_stream.GetImage() : im;
-   beginLine = input_stream.getBeginLine();
-   beginColumn = input_stream.getBeginColumn();
-   endLine = input_stream.getEndLine();
-   endColumn = input_stream.getEndColumn();
-   t = Token.newToken(jjmatchedKind, curTokenImage);
-
-   t.beginLine = beginLine;
-   t.endLine = endLine;
-   t.beginColumn = beginColumn;
-   t.endColumn = endColumn;
-
-   return t;
-}
-
-int curLexState = 3;
-int defaultLexState = 3;
-int jjnewStateCnt;
-int jjround;
-int jjmatchedPos;
-int jjmatchedKind;
-
-/** Get the next Token. */
-public Token getNextToken() 
-{
-  Token matchedToken;
-  int curPos = 0;
-
-  EOFLoop :
-  for (;;)
-  {
-   try
-   {
-      curChar = input_stream.BeginToken();
-   }
-   catch(java.io.IOException e)
-   {
-      jjmatchedKind = 0;
-      matchedToken = jjFillToken();
-      return matchedToken;
-   }
-
-   switch(curLexState)
-   {
-     case 0:
-       jjmatchedKind = 0x7fffffff;
-       jjmatchedPos = 0;
-       curPos = jjMoveStringLiteralDfa0_0();
-       break;
-     case 1:
-       jjmatchedKind = 0x7fffffff;
-       jjmatchedPos = 0;
-       curPos = jjMoveStringLiteralDfa0_1();
-       break;
-     case 2:
-       jjmatchedKind = 0x7fffffff;
-       jjmatchedPos = 0;
-       curPos = jjMoveStringLiteralDfa0_2();
-       break;
-     case 3:
-       jjmatchedKind = 0x7fffffff;
-       jjmatchedPos = 0;
-       curPos = jjMoveStringLiteralDfa0_3();
-       break;
-   }
-     if (jjmatchedKind != 0x7fffffff)
-     {
-        if (jjmatchedPos + 1 < curPos)
-           input_stream.backup(curPos - jjmatchedPos - 1);
-        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-        {
-           matchedToken = jjFillToken();
-       if (jjnewLexState[jjmatchedKind] != -1)
-         curLexState = jjnewLexState[jjmatchedKind];
-           return matchedToken;
-        }
-        else
-        {
-         if (jjnewLexState[jjmatchedKind] != -1)
-           curLexState = jjnewLexState[jjmatchedKind];
-           continue EOFLoop;
-        }
-     }
-     int error_line = input_stream.getEndLine();
-     int error_column = input_stream.getEndColumn();
-     String error_after = null;
-     boolean EOFSeen = false;
-     try { input_stream.readChar(); input_stream.backup(1); }
-     catch (java.io.IOException e1) {
-        EOFSeen = true;
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-        if (curChar == '\n' || curChar == '\r') {
-           error_line++;
-           error_column = 0;
-        }
-        else
-           error_column++;
-     }
-     if (!EOFSeen) {
-        input_stream.backup(1);
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-     }
-     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
-  }
-}
-
-private void jjCheckNAdd(int state)
-{
-   if (jjrounds[state] != jjround)
-   {
-      jjstateSet[jjnewStateCnt++] = state;
-      jjrounds[state] = jjround;
-   }
-}
-private void jjAddStates(int start, int end)
-{
-   do {
-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
-   } while (start++ != end);
-}
-private void jjCheckNAddTwoStates(int state1, int state2)
-{
-   jjCheckNAdd(state1);
-   jjCheckNAdd(state2);
-}
-
-private void jjCheckNAddStates(int start, int end)
-{
-   do {
-      jjCheckNAdd(jjnextStates[start]);
-   } while (start++ != end);
-}
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java
deleted file mode 100644
index cb0e250..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
-/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
-package org.apache.lucene.queryParser.standard.parser;
-
-/**
- * Describes the input token stream.
- */
-
-public class Token {
-
-  /**
-   * An integer that describes the kind of this token.  This numbering
-   * system is determined by JavaCCParser, and a table of these numbers is
-   * stored in the file ...Constants.java.
-   */
-  public int kind;
-
-  /** The line number of the first character of this Token. */
-  public int beginLine;
-  /** The column number of the first character of this Token. */
-  public int beginColumn;
-  /** The line number of the last character of this Token. */
-  public int endLine;
-  /** The column number of the last character of this Token. */
-  public int endColumn;
-
-  /**
-   * The string image of the token.
-   */
-  public String image;
-
-  /**
-   * A reference to the next regular (non-special) token from the input
-   * stream.  If this is the last token from the input stream, or if the
-   * token manager has not read tokens beyond this one, this field is
-   * set to null.  This is true only if this token is also a regular
-   * token.  Otherwise, see below for a description of the contents of
-   * this field.
-   */
-  public Token next;
-
-  /**
-   * This field is used to access special tokens that occur prior to this
-   * token, but after the immediately preceding regular (non-special) token.
-   * If there are no such special tokens, this field is set to null.
-   * When there are more than one such special token, this field refers
-   * to the last of these special tokens, which in turn refers to the next
-   * previous special token through its specialToken field, and so on
-   * until the first special token (whose specialToken field is null).
-   * The next fields of special tokens refer to other special tokens that
-   * immediately follow it (without an intervening regular token).  If there
-   * is no such token, this field is null.
-   */
-  public Token specialToken;
-
-  /**
-   * An optional attribute value of the Token.
-   * Tokens which are not used as syntactic sugar will often contain
-   * meaningful values that will be used later on by the compiler or
-   * interpreter. This attribute value is often different from the image.
-   * Any subclass of Token that actually wants to return a non-null value can
-   * override this method as appropriate.
-   */
-  public Object getValue() {
-    return null;
-  }
-
-  /**
-   * No-argument constructor
-   */
-  public Token() {}
-
-  /**
-   * Constructs a new token for the specified Image.
-   */
-  public Token(int kind)
-  {
-     this(kind, null);
-  }
-
-  /**
-   * Constructs a new token for the specified Image and Kind.
-   */
-  public Token(int kind, String image)
-  {
-     this.kind = kind;
-     this.image = image;
-  }
-
-  /**
-   * Returns the image.
-   */
-  public String toString()
-  {
-     return image;
-  }
-
-  /**
-   * Returns a new Token object, by default. However, if you want, you
-   * can create and return subclass objects based on the value of ofKind.
-   * Simply add the cases to the switch for all those special cases.
-   * For example, if you have a subclass of Token called IDToken that
-   * you want to create if ofKind is ID, simply add something like :
-   *
-   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
-   *
-   * to the following switch statement. Then you can cast matchedToken
-   * variable to the appropriate type and use sit in your lexical actions.
-   */
-  public static Token newToken(int ofKind, String image)
-  {
-     switch(ofKind)
-     {
-       default : return new Token(ofKind, image);
-     }
-  }
-
-  public static Token newToken(int ofKind)
-  {
-     return newToken(ofKind, null);
-  }
-
-}
-/* JavaCC - OriginalChecksum=0aac6816ecd328eda2f38b9d09739ab6 (do not edit this line) */
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java
deleted file mode 100644
index bfe8fee..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
-/* JavaCCOptions: */
-package org.apache.lucene.queryParser.standard.parser;
-
-/** Token Manager Error. */
-@SuppressWarnings("serial")
-public class TokenMgrError extends Error
-{
-
-   /*
-    * Ordinals for various reasons why an Error of this type can be thrown.
-    */
-
-   /**
-    * Lexical error occurred.
-    */
-   static final int LEXICAL_ERROR = 0;
-
-   /**
-    * An attempt was made to create a second instance of a static token manager.
-    */
-   static final int STATIC_LEXER_ERROR = 1;
-
-   /**
-    * Tried to change to an invalid lexical state.
-    */
-   static final int INVALID_LEXICAL_STATE = 2;
-
-   /**
-    * Detected (and bailed out of) an infinite loop in the token manager.
-    */
-   static final int LOOP_DETECTED = 3;
-
-   /**
-    * Indicates the reason why the exception is thrown. It will have
-    * one of the above 4 values.
-    */
-   int errorCode;
-
-   /**
-    * Replaces unprintable characters by their escaped (or unicode escaped)
-    * equivalents in the given string
-    */
-   protected static final String addEscapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
-      }
-      return retval.toString();
-   }
-
-   /**
-    * Returns a detailed message for the Error when it is thrown by the
-    * token manager to indicate a lexical error.
-    * Parameters :
-    *    EOFSeen     : indicates if EOF caused the lexical error
-    *    curLexState : lexical state in which this error occurred
-    *    errorLine   : line number when the error occurred
-    *    errorColumn : column number when the error occurred
-    *    errorAfter  : prefix that was seen before this error occurred
-    *    curchar     : the offending character
-    * Note: You can customize the lexical error message by modifying this method.
-    */
-   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
-      return("Lexical error at line " +
-           errorLine + ", column " +
-           errorColumn + ".  Encountered: " +
-           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
-           "after : \"" + addEscapes(errorAfter) + "\"");
-   }
-
-   /**
-    * You can also modify the body of this method to customize your error messages.
-    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
-    * of end-users concern, so you can return something like :
-    *
-    *     "Internal Error : Please file a bug report .... "
-    *
-    * from this method for such cases in the release version of your parser.
-    */
-   public String getMessage() {
-      return super.getMessage();
-   }
-
-   /*
-    * Constructors of various flavors follow.
-    */
-
-   /** No arg constructor. */
-   public TokenMgrError() {
-   }
-
-   /** Constructor with message and reason. */
-   public TokenMgrError(String message, int reason) {
-      super(message);
-      errorCode = reason;
-   }
-
-   /** Full Constructor. */
-   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
-      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
-   }
-}
-/* JavaCC - OriginalChecksum=a75b5b61664a73631a032a6e44f4b38a (do not edit this line) */
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/package.html
deleted file mode 100644
index 21c6d3d..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/package.html
+++ /dev/null
@@ -1,33 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-<h2>Lucene Query Parser</h2>
-<p>
-The package org.apache.lucene.queryParser.standard.parser contains the query parser.
-</p>
-<p>
-This text parser only performs the syntax validation and creates an QueryNode tree
-from a query string.
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java
deleted file mode 100644
index 32c0a90..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
-
-/**
- * This processor verifies if
- * {@link ConfigurationKeys#ALLOW_LEADING_WILDCARD} is defined in the
- * {@link QueryConfigHandler}. If it is and leading wildcard is not allowed, it
- * looks for every {@link WildcardQueryNode} contained in the query node tree
- * and throws an exception if any of them has a leading wildcard ('*' or '?'). <br/>
- * 
- * @see ConfigurationKeys#ALLOW_LEADING_WILDCARD
- */
-public class AllowLeadingWildcardProcessor extends QueryNodeProcessorImpl {
-
-  public AllowLeadingWildcardProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    Boolean allowsLeadingWildcard = getQueryConfigHandler().get(ConfigurationKeys.ALLOW_LEADING_WILDCARD);
-
-    if (allowsLeadingWildcard != null) {
-
-      if (!allowsLeadingWildcard) {
-        return super.process(queryTree);
-      }
-
-    }
-
-    return queryTree;
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof WildcardQueryNode) {
-      WildcardQueryNode wildcardNode = (WildcardQueryNode) node;
-
-      if (wildcardNode.getText().length() > 0) {
-        
-        // Validate if the wildcard was escaped
-        if (UnescapedCharSequence.wasEscaped(wildcardNode.getText(), 0))
-          return node;
-        
-        switch (wildcardNode.getText().charAt(0)) {    
-          case '*':
-          case '?':
-            throw new QueryNodeException(new MessageImpl(
-                QueryParserMessages.LEADING_WILDCARD_NOT_ALLOWED, node
-                    .toQueryString(new EscapeQuerySyntaxImpl())));    
-        }
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java
deleted file mode 100644
index e4302c7..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java
+++ /dev/null
@@ -1,341 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.CachingTokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.NoTokenFoundQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.TextableQueryNode;
-import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-
-/**
- * This processor verifies if {@link ConfigurationKeys#ANALYZER}
- * is defined in the {@link QueryConfigHandler}. If it is and the analyzer is
- * not <code>null</code>, it looks for every {@link FieldQueryNode} that is not
- * {@link WildcardQueryNode}, {@link FuzzyQueryNode} or
- * {@link ParametricQueryNode} contained in the query node tree, then it applies
- * the analyzer to that {@link FieldQueryNode} object. <br/>
- * <br/>
- * If the analyzer return only one term, the returned term is set to the
- * {@link FieldQueryNode} and it's returned. <br/>
- * <br/>
- * If the analyzer return more than one term, a {@link TokenizedPhraseQueryNode}
- * or {@link MultiPhraseQueryNode} is created, whether there is one or more
- * terms at the same position, and it's returned. <br/>
- * <br/>
- * If no term is returned by the analyzer a {@link NoTokenFoundQueryNode} object
- * is returned. <br/>
- * 
- * @see ConfigurationKeys#ANALYZER
- * @see Analyzer
- * @see TokenStream
- */
-public class AnalyzerQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  private Analyzer analyzer;
-
-  private boolean positionIncrementsEnabled;
-
-  public AnalyzerQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    Analyzer analyzer = getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);
-    
-    if (analyzer != null) {
-      this.analyzer = analyzer;
-      this.positionIncrementsEnabled = false;
-      Boolean positionIncrementsEnabled = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
-
-      if (positionIncrementsEnabled != null) {
-          this.positionIncrementsEnabled = positionIncrementsEnabled;
-      }
-
-      if (this.analyzer != null) {
-        return super.process(queryTree);
-      }
-
-    }
-
-    return queryTree;
-
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof TextableQueryNode
-        && !(node instanceof WildcardQueryNode)
-        && !(node instanceof FuzzyQueryNode)
-        && !(node instanceof ParametricQueryNode)) {
-
-      FieldQueryNode fieldNode = ((FieldQueryNode) node);
-      String text = fieldNode.getTextAsString();
-      String field = fieldNode.getFieldAsString();
-
-      TokenStream source;
-      try {
-        source = this.analyzer.reusableTokenStream(field, new StringReader(text));
-        source.reset();
-      } catch (IOException e1) {
-        throw new RuntimeException(e1);
-      }
-      CachingTokenFilter buffer = new CachingTokenFilter(source);
-
-      PositionIncrementAttribute posIncrAtt = null;
-      int numTokens = 0;
-      int positionCount = 0;
-      boolean severalTokensAtSamePosition = false;
-
-      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
-        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
-      }
-
-      try {
-
-        while (buffer.incrementToken()) {
-          numTokens++;
-          int positionIncrement = (posIncrAtt != null) ? posIncrAtt
-              .getPositionIncrement() : 1;
-          if (positionIncrement != 0) {
-            positionCount += positionIncrement;
-
-          } else {
-            severalTokensAtSamePosition = true;
-          }
-
-        }
-
-      } catch (IOException e) {
-        // ignore
-      }
-
-      try {
-        // rewind the buffer stream
-        buffer.reset();
-
-        // close original stream - all tokens buffered
-        source.close();
-      } catch (IOException e) {
-        // ignore
-      }
-
-      if (!buffer.hasAttribute(CharTermAttribute.class)) {
-        return new NoTokenFoundQueryNode();
-      }
-
-      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);
-
-      if (numTokens == 0) {
-        return new NoTokenFoundQueryNode();
-
-      } else if (numTokens == 1) {
-        String term = null;
-        try {
-          boolean hasNext;
-          hasNext = buffer.incrementToken();
-          assert hasNext == true;
-          term = termAtt.toString();
-
-        } catch (IOException e) {
-          // safe to ignore, because we know the number of tokens
-        }
-
-        fieldNode.setText(term);
-
-        return fieldNode;
-
-      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {
-        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {
-          // no phrase query:
-          LinkedList<QueryNode> children = new LinkedList<QueryNode>();
-
-          for (int i = 0; i < numTokens; i++) {
-            String term = null;
-            try {
-              boolean hasNext = buffer.incrementToken();
-              assert hasNext == true;
-              term = termAtt.toString();
-
-            } catch (IOException e) {
-              // safe to ignore, because we know the number of tokens
-            }
-
-            children.add(new FieldQueryNode(field, term, -1, -1));
-
-          }
-          if (positionCount == 1)
-            return new GroupQueryNode(
-              new StandardBooleanQueryNode(children, true));
-          else
-            return new StandardBooleanQueryNode(children, false);
-
-        } else {
-          // phrase query:
-          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();
-
-          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();
-          int position = -1;
-          int i = 0;
-          int termGroupCount = 0;
-          for (; i < numTokens; i++) {
-            String term = null;
-            int positionIncrement = 1;
-            try {
-              boolean hasNext = buffer.incrementToken();
-              assert hasNext == true;
-              term = termAtt.toString();
-              if (posIncrAtt != null) {
-                positionIncrement = posIncrAtt.getPositionIncrement();
-              }
-
-            } catch (IOException e) {
-              // safe to ignore, because we know the number of tokens
-            }
-
-            if (positionIncrement > 0 && multiTerms.size() > 0) {
-
-              for (FieldQueryNode termNode : multiTerms) {
-
-                if (this.positionIncrementsEnabled) {
-                  termNode.setPositionIncrement(position);
-                } else {
-                  termNode.setPositionIncrement(termGroupCount);
-                }
-
-                mpq.add(termNode);
-
-              }
-
-              // Only increment once for each "group" of
-              // terms that were in the same position:
-              termGroupCount++;
-
-              multiTerms.clear();
-
-            }
-
-            position += positionIncrement;
-            multiTerms.add(new FieldQueryNode(field, term, -1, -1));
-
-          }
-
-          for (FieldQueryNode termNode : multiTerms) {
-
-            if (this.positionIncrementsEnabled) {
-              termNode.setPositionIncrement(position);
-
-            } else {
-              termNode.setPositionIncrement(termGroupCount);
-            }
-
-            mpq.add(termNode);
-
-          }
-
-          return mpq;
-
-        }
-
-      } else {
-
-        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();
-
-        int position = -1;
-
-        for (int i = 0; i < numTokens; i++) {
-          String term = null;
-          int positionIncrement = 1;
-
-          try {
-            boolean hasNext = buffer.incrementToken();
-            assert hasNext == true;
-            term = termAtt.toString();
-
-            if (posIncrAtt != null) {
-              positionIncrement = posIncrAtt.getPositionIncrement();
-            }
-
-          } catch (IOException e) {
-            // safe to ignore, because we know the number of tokens
-          }
-
-          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);
-
-          if (this.positionIncrementsEnabled) {
-            position += positionIncrement;
-            newFieldNode.setPositionIncrement(position);
-
-          } else {
-            newFieldNode.setPositionIncrement(i);
-          }
-
-          pq.add(newFieldNode);
-
-        }
-
-        return pq;
-
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BooleanSingleChildOptimizationQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BooleanSingleChildOptimizationQueryNodeProcessor.java
deleted file mode 100644
index beb3c64..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BooleanSingleChildOptimizationQueryNodeProcessor.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.nodes.BooleanModifierNode;
-
-/**
- * This processor removes every {@link BooleanQueryNode} that contains only one
- * child and returns this child. If this child is {@link ModifierQueryNode} that
- * was defined by the user. A modifier is not defined by the user when it's a
- * {@link BooleanModifierNode} <br/>
- * 
- * @see ModifierQueryNode
- */
-public class BooleanSingleChildOptimizationQueryNodeProcessor extends
-    QueryNodeProcessorImpl {
-
-  public BooleanSingleChildOptimizationQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof BooleanQueryNode) {
-      List<QueryNode> children = node.getChildren();
-
-      if (children != null && children.size() == 1) {
-        QueryNode child = children.get(0);
-
-        if (child instanceof ModifierQueryNode) {
-          ModifierQueryNode modNode = (ModifierQueryNode) child;
-
-          if (modNode instanceof BooleanModifierNode
-              || modNode.getModifier() == Modifier.MOD_NONE) {
-
-            return child;
-
-          }
-
-        } else {
-          return child;
-        }
-
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java
deleted file mode 100644
index 3195daa..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.core.util.StringUtils;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-
-/**
- * This processor iterates the query node tree looking for every
- * {@link FieldableNode} that has {@link ConfigurationKeys#BOOST} in its
- * config. If there is, the boost is applied to that {@link FieldableNode}. <br/>
- * 
- * @see ConfigurationKeys#BOOST
- * @see QueryConfigHandler
- * @see FieldableNode
- */
-public class BoostQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof FieldableNode && 
-        (node.getParent() == null || !(node.getParent() instanceof FieldableNode))) {
-      
-      FieldableNode fieldNode = (FieldableNode) node;
-      QueryConfigHandler config = getQueryConfigHandler();
-
-      if (config != null) {
-        CharSequence field = fieldNode.getField();
-        FieldConfig fieldConfig = config.getFieldConfig(StringUtils.toString(field));
-
-        if (fieldConfig != null) {
-          Float boost = fieldConfig.get(ConfigurationKeys.BOOST);
-
-          if (boost != null) {
-            return new BoostQueryNode(node, boost);
-          }
-
-        }
-
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java
deleted file mode 100644
index 1cf1c1c..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
-
-/**
- * This processor verifies if {@link ConfigurationKeys#PHRASE_SLOP}
- * is defined in the {@link QueryConfigHandler}. If it is, it looks for every
- * {@link TokenizedPhraseQueryNode} and {@link MultiPhraseQueryNode} that does
- * not have any {@link SlopQueryNode} applied to it and creates an
- * {@link SlopQueryNode} and apply to it. The new {@link SlopQueryNode} has the
- * same slop value defined in the configuration. <br/>
- * 
- * @see SlopQueryNode
- * @see ConfigurationKeys#PHRASE_SLOP
- */
-public class DefaultPhraseSlopQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  private boolean processChildren = true;
-
-  private int defaultPhraseSlop;
-
-  public DefaultPhraseSlopQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    QueryConfigHandler queryConfig = getQueryConfigHandler();
-
-    if (queryConfig != null) {
-      Integer defaultPhraseSlop = queryConfig.get(ConfigurationKeys.PHRASE_SLOP); 
-      
-      if (defaultPhraseSlop != null) {
-        this.defaultPhraseSlop = defaultPhraseSlop;
-
-        return super.process(queryTree);
-
-      }
-
-    }
-
-    return queryTree;
-
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof TokenizedPhraseQueryNode
-        || node instanceof MultiPhraseQueryNode) {
-
-      return new SlopQueryNode(node, this.defaultPhraseSlop);
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof SlopQueryNode) {
-      this.processChildren = false;
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected void processChildren(QueryNode queryTree) throws QueryNodeException {
-
-    if (this.processChildren) {
-      super.processChildren(queryTree);
-
-    } else {
-      this.processChildren = true;
-    }
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java
deleted file mode 100644
index 16db38b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.FuzzyConfig;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.search.FuzzyQuery;
-
-/**
- * This processor iterates the query node tree looking for every
- * {@link FuzzyQueryNode}, when this kind of node is found, it checks on the
- * query configuration for
- * {@link ConfigurationKeys#FUZZY_CONFIG}, gets the
- * fuzzy prefix length and default similarity from it and set to the fuzzy node.
- * For more information about fuzzy prefix length check: {@link FuzzyQuery}. <br/>
- * 
- * @see ConfigurationKeys#FUZZY_CONFIG
- * @see FuzzyQuery
- * @see FuzzyQueryNode
- */
-public class FuzzyQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof FuzzyQueryNode) {
-      FuzzyQueryNode fuzzyNode = (FuzzyQueryNode) node;
-      QueryConfigHandler config = getQueryConfigHandler();
-
-      FuzzyConfig fuzzyConfig = null;
-      
-      if (config != null && (fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG)) != null) {
-        fuzzyNode.setPrefixLength(fuzzyConfig.getPrefixLength());
-
-        if (fuzzyNode.getSimilarity() < 0) {
-          fuzzyNode.setSimilarity(fuzzyConfig.getMinSimilarity());
-        }
-        
-      } else if (fuzzyNode.getSimilarity() < 0) {
-        throw new IllegalArgumentException("No FUZZY_CONFIG set in the config");
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java
deleted file mode 100644
index 866cd4a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java
+++ /dev/null
@@ -1,218 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessor;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
-import org.apache.lucene.queryParser.standard.nodes.BooleanModifierNode;
-
-/**
- * The {@link SyntaxParser}
- * generates query node trees that consider the boolean operator precedence, but
- * Lucene current syntax does not support boolean precedence, so this processor
- * remove all the precedence and apply the equivalent modifier according to the
- * boolean operation defined on an specific query node. <br/>
- * <br/>
- * If there is a {@link GroupQueryNode} in the query node tree, the query node
- * tree is not merged with the one above it.
- * 
- * Example: TODO: describe a good example to show how this processor works
- * 
- * @see org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler
- */
-public class GroupQueryNodeProcessor implements QueryNodeProcessor {
-
-  private ArrayList<QueryNode> queryNodeList;
-
-  private boolean latestNodeVerified;
-
-  private QueryConfigHandler queryConfig;
-
-  private Boolean usingAnd = false;
-
-  public GroupQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    Operator defaultOperator = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
-    
-    if (defaultOperator == null) {
-      throw new IllegalArgumentException(
-          "DEFAULT_OPERATOR should be set on the QueryConfigHandler");
-    }
-
-    this.usingAnd = StandardQueryConfigHandler.Operator.AND == defaultOperator;
-
-    if (queryTree instanceof GroupQueryNode) {
-      queryTree = ((GroupQueryNode) queryTree).getChild();
-    }
-
-    this.queryNodeList = new ArrayList<QueryNode>();
-    this.latestNodeVerified = false;
-    readTree(queryTree);
-
-    List<QueryNode> actualQueryNodeList = this.queryNodeList;
-
-    for (int i = 0; i < actualQueryNodeList.size(); i++) {
-      QueryNode node = actualQueryNodeList.get(i);
-
-      if (node instanceof GroupQueryNode) {
-        actualQueryNodeList.set(i, process(node));
-      }
-
-    }
-
-    this.usingAnd = false;
-
-    if (queryTree instanceof BooleanQueryNode) {
-      queryTree.set(actualQueryNodeList);
-
-      return queryTree;
-
-    } else {
-      return new BooleanQueryNode(actualQueryNodeList);
-    }
-
-  }
-
-  /**
-   */
-  private QueryNode applyModifier(QueryNode node, QueryNode parent) {
-
-    if (this.usingAnd) {
-
-      if (parent instanceof OrQueryNode) {
-
-        if (node instanceof ModifierQueryNode) {
-
-          ModifierQueryNode modNode = (ModifierQueryNode) node;
-
-          if (modNode.getModifier() == Modifier.MOD_REQ) {
-            return modNode.getChild();
-          }
-
-        }
-
-      } else {
-
-        if (node instanceof ModifierQueryNode) {
-
-          ModifierQueryNode modNode = (ModifierQueryNode) node;
-
-          if (modNode.getModifier() == Modifier.MOD_NONE) {
-            return new BooleanModifierNode(modNode.getChild(), Modifier.MOD_REQ);
-          }
-
-        } else {
-          return new BooleanModifierNode(node, Modifier.MOD_REQ);
-        }
-
-      }
-
-    } else {
-
-      if (node.getParent() instanceof AndQueryNode) {
-
-        if (node instanceof ModifierQueryNode) {
-
-          ModifierQueryNode modNode = (ModifierQueryNode) node;
-
-          if (modNode.getModifier() == Modifier.MOD_NONE) {
-            return new BooleanModifierNode(modNode.getChild(), Modifier.MOD_REQ);
-          }
-
-        } else {
-          return new BooleanModifierNode(node, Modifier.MOD_REQ);
-        }
-
-      }
-
-    }
-
-    return node;
-
-  }
-
-  private void readTree(QueryNode node) {
-
-    if (node instanceof BooleanQueryNode) {
-      List<QueryNode> children = node.getChildren();
-
-      if (children != null && children.size() > 0) {
-
-        for (int i = 0; i < children.size() - 1; i++) {
-          readTree(children.get(i));
-        }
-
-        processNode(node);
-        readTree(children.get(children.size() - 1));
-
-      } else {
-        processNode(node);
-      }
-
-    } else {
-      processNode(node);
-    }
-
-  }
-
-  private void processNode(QueryNode node) {
-
-    if (node instanceof AndQueryNode || node instanceof OrQueryNode) {
-
-      if (!this.latestNodeVerified && !this.queryNodeList.isEmpty()) {
-        this.queryNodeList.add(applyModifier(this.queryNodeList
-            .remove(this.queryNodeList.size() - 1), node));
-        this.latestNodeVerified = true;
-
-      }
-
-    } else if (!(node instanceof BooleanQueryNode)) {
-      this.queryNodeList.add(applyModifier(node, node.getParent()));
-      this.latestNodeVerified = false;
-
-    }
-
-  }
-
-  public QueryConfigHandler getQueryConfigHandler() {
-    return this.queryConfig;
-  }
-
-  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler) {
-    this.queryConfig = queryConfigHandler;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
deleted file mode 100644
index 98deba9..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.TextableQueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-
-/**
- * This processor verifies if 
- * {@link ConfigurationKeys#LOWERCASE_EXPANDED_TERMS} is defined in the
- * {@link QueryConfigHandler}. If it is and the expanded terms should be
- * lower-cased, it looks for every {@link WildcardQueryNode},
- * {@link FuzzyQueryNode} and {@link ParametricQueryNode} and lower-case its
- * term. <br/>
- * 
- * @see ConfigurationKeys#LOWERCASE_EXPANDED_TERMS
- */
-public class LowercaseExpandedTermsQueryNodeProcessor extends
-    QueryNodeProcessorImpl {
-
-  public LowercaseExpandedTermsQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    Boolean lowercaseExpandedTerms = getQueryConfigHandler().get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS);
-
-    if (lowercaseExpandedTerms != null && lowercaseExpandedTerms) {
-      return super.process(queryTree);
-    }
-
-    return queryTree;
-
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof WildcardQueryNode || node instanceof FuzzyQueryNode
-        || node instanceof ParametricQueryNode || node instanceof RegexpQueryNode) {
-
-      TextableQueryNode txtNode = (TextableQueryNode) node;
-      txtNode.setText(UnescapedCharSequence.toLowerCase(txtNode.getText()));
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java
deleted file mode 100644
index 2927a4a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.MatchAllDocsQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-import org.apache.lucene.search.MatchAllDocsQuery;
-
-/**
- * This processor converts every {@link WildcardQueryNode} that is "*:*" to
- * {@link MatchAllDocsQueryNode}.
- * 
- * @see MatchAllDocsQueryNode
- * @see MatchAllDocsQuery
- */
-public class MatchAllDocsQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  public MatchAllDocsQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof FieldQueryNode) {
-      FieldQueryNode fqn = (FieldQueryNode) node;
-
-      if (fqn.getField().toString().equals("*")
-          && fqn.getText().toString().equals("*")) {
-
-        return new MatchAllDocsQueryNode();
-
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java
deleted file mode 100644
index 4351cea..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java
+++ /dev/null
@@ -1,133 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.LinkedList;
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-
-/**
- * This processor is used to expand terms so the query looks for the same term
- * in different fields. It also boosts a query based on its field. <br/>
- * <br/>
- * This processor looks for every {@link FieldableNode} contained in the query
- * node tree. If a {@link FieldableNode} is found, it checks if there is a
- * {@link ConfigurationKeys#MULTI_FIELDS} defined in the {@link QueryConfigHandler}. If
- * there is, the {@link FieldableNode} is cloned N times and the clones are
- * added to a {@link BooleanQueryNode} together with the original node. N is
- * defined by the number of fields that it will be expanded to. The
- * {@link BooleanQueryNode} is returned. <br/>
- * 
- * @see ConfigurationKeys#MULTI_FIELDS
- */
-public class MultiFieldQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  private boolean processChildren = true;
-
-  public MultiFieldQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected void processChildren(QueryNode queryTree) throws QueryNodeException {
-
-    if (this.processChildren) {
-      super.processChildren(queryTree);
-
-    } else {
-      this.processChildren = true;
-    }
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof FieldableNode) {
-      this.processChildren = false;
-      FieldableNode fieldNode = (FieldableNode) node;
-
-      if (fieldNode.getField() == null) {
-        CharSequence[] fields = getQueryConfigHandler().get(ConfigurationKeys.MULTI_FIELDS);
-
-        if (fields == null) {
-          throw new IllegalArgumentException(
-              "StandardQueryConfigHandler.ConfigurationKeys.MULTI_FIELDS should be set on the QueryConfigHandler");
-        }
-
-        if (fields != null && fields.length > 0) {
-          fieldNode.setField(fields[0]);
-
-          if (fields.length == 1) {
-            return fieldNode;
-
-          } else {
-            LinkedList<QueryNode> children = new LinkedList<QueryNode>();
-            children.add(fieldNode);
-
-            for (int i = 1; i < fields.length; i++) {
-              try {
-                fieldNode = (FieldableNode) fieldNode.cloneTree();
-                fieldNode.setField(fields[i]);
-
-                children.add(fieldNode);
-
-              } catch (CloneNotSupportedException e) {
-                // should never happen
-              }
-
-            }
-
-            return new GroupQueryNode(new BooleanQueryNode(children));
-
-          }
-
-        }
-
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java
deleted file mode 100644
index bea7ac5..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.nodes.AbstractRangeQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-import org.apache.lucene.search.MultiTermQuery;
-
-/**
- * This processor instates the default
- * {@link org.apache.lucene.search.MultiTermQuery.RewriteMethod},
- * {@link MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}, for multi-term
- * query nodes.
- */
-public class MultiTermRewriteMethodProcessor extends QueryNodeProcessorImpl {
-
-  public static final String TAG_ID = "MultiTermRewriteMethodConfiguration";
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) {
-
-    // set setMultiTermRewriteMethod for WildcardQueryNode and
-    // PrefixWildcardQueryNode
-    if (node instanceof WildcardQueryNode
-        || node instanceof AbstractRangeQueryNode || node instanceof RegexpQueryNode) {
-      
-      MultiTermQuery.RewriteMethod rewriteMethod = getQueryConfigHandler().get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
-
-      if (rewriteMethod == null) {
-        // This should not happen, this configuration is set in the
-        // StandardQueryConfigHandler
-        throw new IllegalArgumentException(
-            "StandardQueryConfigHandler.ConfigurationKeys.MULTI_TERM_REWRITE_METHOD should be set on the QueryConfigHandler");
-      }
-
-      // use a TAG to take the value to the Builder
-      node.setTag(MultiTermRewriteMethodProcessor.TAG_ID, rewriteMethod);
-
-    }
-
-    return node;
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) {
-    return node;
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children) {
-    return children;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/NumericQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/NumericQueryNodeProcessor.java
deleted file mode 100644
index 1b09056..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/NumericQueryNodeProcessor.java
+++ /dev/null
@@ -1,122 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.NumberFormat;
-import java.text.ParseException;
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.NumericConfig;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.nodes.NumericQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.NumericRangeQueryNode;
-
-public class NumericQueryNodeProcessor extends QueryNodeProcessorImpl {
-  
-  public NumericQueryNodeProcessor() {
-  // empty constructor
-  }
-  
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-    
-    if (node instanceof FieldQueryNode
-        && !(node instanceof ParametricQueryNode)) {
-      
-      QueryConfigHandler config = getQueryConfigHandler();
-      
-      if (config != null) {
-        FieldQueryNode fieldNode = (FieldQueryNode) node;
-        FieldConfig fieldConfig = config.getFieldConfig(fieldNode
-            .getFieldAsString());
-        
-        if (fieldConfig != null) {
-          NumericConfig numericConfig = fieldConfig
-              .get(ConfigurationKeys.NUMERIC_CONFIG);
-          
-          if (numericConfig != null) {
-            
-            NumberFormat numberFormat = numericConfig.getNumberFormat();
-            Number number;
-            
-            try {
-              number = numberFormat.parse(fieldNode.getTextAsString());
-              
-            } catch (ParseException e) {
-              throw new QueryNodeParseException(new MessageImpl(
-                  QueryParserMessages.COULD_NOT_PARSE_NUMBER, fieldNode
-                      .getTextAsString(), numberFormat.getClass()
-                      .getCanonicalName()), e);
-            }
-            
-            switch (numericConfig.getType()) {
-              case LONG:
-                number = number.longValue();
-                break;
-              case INT:
-                number = number.intValue();
-                break;
-              case DOUBLE:
-                number = number.doubleValue();
-                break;
-              case FLOAT:
-                number = number.floatValue();
-            }
-            
-            NumericQueryNode lowerNode = new NumericQueryNode(fieldNode
-                .getField(), number, numberFormat);
-            NumericQueryNode upperNode = new NumericQueryNode(fieldNode
-                .getField(), number, numberFormat);
-            
-            return new NumericRangeQueryNode(lowerNode, upperNode, true, true,
-                numericConfig);
-            
-          }
-          
-        }
-        
-      }
-      
-    }
-    
-    return node;
-    
-  }
-  
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-    return node;
-  }
-  
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-    return children;
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/NumericRangeQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/NumericRangeQueryNodeProcessor.java
deleted file mode 100644
index c7c95a6..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/NumericRangeQueryNodeProcessor.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.NumberFormat;
-import java.text.ParseException;
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.core.util.StringUtils;
-import org.apache.lucene.queryParser.standard.config.NumericConfig;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.nodes.NumericQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.NumericRangeQueryNode;
-
-public class NumericRangeQueryNodeProcessor extends QueryNodeProcessorImpl {
-  
-  public NumericRangeQueryNodeProcessor() {
-  // empty constructor
-  }
-  
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-    
-    if (node instanceof ParametricRangeQueryNode) {
-      QueryConfigHandler config = getQueryConfigHandler();
-      
-      if (config != null) {
-        ParametricRangeQueryNode parametricRangeNode = (ParametricRangeQueryNode) node;
-        FieldConfig fieldConfig = config.getFieldConfig(StringUtils
-            .toString(parametricRangeNode.getField()));
-        
-        if (fieldConfig != null) {
-          
-          NumericConfig numericConfig = fieldConfig
-              .get(ConfigurationKeys.NUMERIC_CONFIG);
-          
-          if (numericConfig != null) {
-            
-            ParametricQueryNode lower = parametricRangeNode.getLowerBound();
-            ParametricQueryNode upper = parametricRangeNode.getUpperBound();
-            
-            NumberFormat numberFormat = numericConfig.getNumberFormat();
-            Number lowerNumber, upperNumber;
-            
-            try {
-              lowerNumber = numberFormat.parse(lower.getTextAsString());
-              
-            } catch (ParseException e) {
-              throw new QueryNodeParseException(new MessageImpl(
-                  QueryParserMessages.COULD_NOT_PARSE_NUMBER, lower
-                      .getTextAsString(), numberFormat.getClass()
-                      .getCanonicalName()), e);
-            }
-            
-            try {
-              upperNumber = numberFormat.parse(upper.getTextAsString());
-              
-            } catch (ParseException e) {
-              throw new QueryNodeParseException(new MessageImpl(
-                  QueryParserMessages.COULD_NOT_PARSE_NUMBER, upper
-                      .getTextAsString(), numberFormat.getClass()
-                      .getCanonicalName()), e);
-            }
-            
-            switch (numericConfig.getType()) {
-              case LONG:
-                upperNumber = upperNumber.longValue();
-                lowerNumber = lowerNumber.longValue();
-                break;
-              case INT:
-                upperNumber = upperNumber.intValue();
-                lowerNumber = lowerNumber.intValue();
-                break;
-              case DOUBLE:
-                upperNumber = upperNumber.doubleValue();
-                lowerNumber = lowerNumber.doubleValue();
-                break;
-              case FLOAT:
-                upperNumber = upperNumber.floatValue();
-                lowerNumber = lowerNumber.floatValue();
-            }
-            
-            NumericQueryNode lowerNode = new NumericQueryNode(
-                parametricRangeNode.getField(), lowerNumber, numberFormat);
-            NumericQueryNode upperNode = new NumericQueryNode(
-                parametricRangeNode.getField(), upperNumber, numberFormat);
-            
-            boolean upperInclusive = upper.getOperator() == CompareOperator.LE;
-            boolean lowerInclusive = lower.getOperator() == CompareOperator.GE;
-            
-            return new NumericRangeQueryNode(lowerNode, upperNode,
-                lowerInclusive, upperInclusive, numericConfig);
-            
-          }
-          
-        }
-        
-      }
-      
-    }
-    
-    return node;
-    
-  }
-  
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-    return node;
-  }
-  
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-    return children;
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java
deleted file mode 100644
index decb18a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java
+++ /dev/null
@@ -1,158 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.DateFormat;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.document.DateTools.Resolution;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
-import org.apache.lucene.queryParser.standard.nodes.TermRangeQueryNode;
-
-/**
- * This processor converts {@link ParametricRangeQueryNode} objects to
- * {@link TermRangeQueryNode} objects. It reads the lower and upper bounds value
- * from the {@link ParametricRangeQueryNode} object and try to parse their
- * values using a {@link DateFormat}. If the values cannot be parsed to a date
- * value, it will only create the {@link TermRangeQueryNode} using the
- * non-parsed values. <br/>
- * <br/>
- * If a {@link ConfigurationKeys#LOCALE} is defined in the {@link QueryConfigHandler} it
- * will be used to parse the date, otherwise {@link Locale#getDefault()} will be
- * used. <br/>
- * <br/>
- * If a {@link ConfigurationKeys#DATE_RESOLUTION} is defined and the {@link Resolution} is
- * not <code>null</code> it will also be used to parse the date value. <br/>
- * <br/>
- * 
- * @see ConfigurationKeys#DATE_RESOLUTION
- * @see ConfigurationKeys#LOCALE
- * @see TermRangeQueryNode
- * @see ParametricRangeQueryNode
- */
-public class ParametricRangeQueryNodeProcessor extends QueryNodeProcessorImpl {
-  
-  public ParametricRangeQueryNodeProcessor() {
-  // empty constructor
-  }
-  
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-    
-    if (node instanceof ParametricRangeQueryNode) {
-      ParametricRangeQueryNode parametricRangeNode = (ParametricRangeQueryNode) node;
-      ParametricQueryNode upper = parametricRangeNode.getUpperBound();
-      ParametricQueryNode lower = parametricRangeNode.getLowerBound();
-      
-      DateTools.Resolution dateRes = null;
-      boolean inclusive = false;
-      Locale locale = getQueryConfigHandler().get(ConfigurationKeys.LOCALE);
-
-      if (locale == null) {
-        locale = Locale.getDefault();
-      }
-      
-      CharSequence field = parametricRangeNode.getField();
-      String fieldStr = null;
-      
-      if (field != null) {
-        fieldStr = field.toString();
-      }
-      
-      FieldConfig fieldConfig = getQueryConfigHandler()
-          .getFieldConfig(fieldStr);
-      
-      if (fieldConfig != null) {
-        dateRes = fieldConfig.get(ConfigurationKeys.DATE_RESOLUTION);
-      }
-      
-      if (upper.getOperator() == CompareOperator.LE) {
-        inclusive = true;
-        
-      } else if (lower.getOperator() == CompareOperator.GE) {
-        inclusive = true;
-      }
-      
-      String part1 = lower.getTextAsString();
-      String part2 = upper.getTextAsString();
-      
-      try {
-        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT, locale);
-        df.setLenient(true);
-        Date d1 = df.parse(part1);
-        Date d2 = df.parse(part2);
-        if (inclusive) {
-          // The user can only specify the date, not the time, so make sure
-          // the time is set to the latest possible time of that date to really
-          // include all documents:
-          Calendar cal = Calendar.getInstance(locale);
-          cal.setTime(d2);
-          cal.set(Calendar.HOUR_OF_DAY, 23);
-          cal.set(Calendar.MINUTE, 59);
-          cal.set(Calendar.SECOND, 59);
-          cal.set(Calendar.MILLISECOND, 999);
-          d2 = cal.getTime();
-        }
-        
-        part1 = DateTools.dateToString(d1, dateRes);
-        part2 = DateTools.dateToString(d2, dateRes);
-      } catch (Exception e) {
-        // do nothing
-      }
-      
-      lower.setText(part1);
-      upper.setText(part2);
-      
-      return new TermRangeQueryNode(lower, upper,
-          lower.getOperator() == CompareOperator.GE,
-          upper.getOperator() == CompareOperator.LE);
-      
-    }
-    
-    return node;
-    
-  }
-  
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-    
-    return node;
-    
-  }
-  
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-    
-    return children;
-    
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PhraseSlopQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PhraseSlopQueryNodeProcessor.java
deleted file mode 100644
index 148af47..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PhraseSlopQueryNodeProcessor.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
-
-/**
- * This processor removes invalid {@link SlopQueryNode} objects in the query
- * node tree. A {@link SlopQueryNode} is invalid if its child is neither a
- * {@link TokenizedPhraseQueryNode} nor a {@link MultiPhraseQueryNode}. <br/>
- * 
- * @see SlopQueryNode
- */
-public class PhraseSlopQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  public PhraseSlopQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof SlopQueryNode) {
-      SlopQueryNode phraseSlopNode = (SlopQueryNode) node;
-
-      if (!(phraseSlopNode.getChild() instanceof TokenizedPhraseQueryNode)
-          && !(phraseSlopNode.getChild() instanceof MultiPhraseQueryNode)) {
-        return phraseSlopNode.getChild();
-      }
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/RemoveEmptyNonLeafQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/RemoveEmptyNonLeafQueryNodeProcessor.java
deleted file mode 100644
index 0f182a9..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/RemoveEmptyNonLeafQueryNodeProcessor.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.LinkedList;
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.MatchNoDocsQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-
-/**
- * This processor removes every {@link QueryNode} that is not a leaf and has not
- * children. If after processing the entire tree the root node is not a leaf and
- * has no children, a {@link MatchNoDocsQueryNode} object is returned. <br/>
- * <br/>
- * This processor is used at the end of a pipeline to avoid invalid query node
- * tree structures like a {@link GroupQueryNode} or {@link ModifierQueryNode}
- * with no children. <br/>
- * 
- * @see QueryNode
- * @see MatchNoDocsQueryNode
- */
-public class RemoveEmptyNonLeafQueryNodeProcessor extends
-    QueryNodeProcessorImpl {
-
-  private LinkedList<QueryNode> childrenBuffer = new LinkedList<QueryNode>();
-
-  public RemoveEmptyNonLeafQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-    queryTree = super.process(queryTree);
-
-    if (!queryTree.isLeaf()) {
-
-      List<QueryNode> children = queryTree.getChildren();
-
-      if (children == null || children.size() == 0) {
-        return new MatchNoDocsQueryNode();
-      }
-
-    }
-
-    return queryTree;
-
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    try {
-
-      for (QueryNode child : children) {
-
-        if (!child.isLeaf()) {
-
-          List<QueryNode> grandChildren = child.getChildren();
-
-          if (grandChildren != null && grandChildren.size() > 0) {
-            this.childrenBuffer.add(child);
-          }
-
-        } else {
-          this.childrenBuffer.add(child);
-        }
-
-      }
-
-      children.clear();
-      children.addAll(this.childrenBuffer);
-
-    } finally {
-      this.childrenBuffer.clear();
-    }
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java
deleted file mode 100644
index a381084..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.processors.NoChildOptimizationQueryNodeProcessor;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
-import org.apache.lucene.queryParser.core.processors.RemoveDeletedQueryNodesProcessor;
-import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
-import org.apache.lucene.search.Query;
-
-/**
- * This pipeline has all the processors needed to process a query node tree,
- * generated by {@link StandardSyntaxParser}, already assembled. <br/>
- * <br/>
- * The order they are assembled affects the results. <br/>
- * <br/>
- * This processor pipeline was designed to work with
- * {@link StandardQueryConfigHandler}. <br/>
- * <br/>
- * The result query node tree can be used to build a {@link Query} object using
- * {@link StandardQueryTreeBuilder}. <br/>
- * 
- * @see StandardQueryTreeBuilder
- * @see StandardQueryConfigHandler
- * @see StandardSyntaxParser
- */
-public class StandardQueryNodeProcessorPipeline extends
-    QueryNodeProcessorPipeline {
-
-  public StandardQueryNodeProcessorPipeline(QueryConfigHandler queryConfig) {
-    super(queryConfig);
-
-    add(new WildcardQueryNodeProcessor());    
-    add(new MultiFieldQueryNodeProcessor());
-    add(new FuzzyQueryNodeProcessor());
-    add(new MatchAllDocsQueryNodeProcessor());
-    add(new LowercaseExpandedTermsQueryNodeProcessor());
-    add(new NumericQueryNodeProcessor());
-    add(new NumericRangeQueryNodeProcessor());
-    add(new ParametricRangeQueryNodeProcessor());
-    add(new AllowLeadingWildcardProcessor());    
-    add(new AnalyzerQueryNodeProcessor());
-    add(new PhraseSlopQueryNodeProcessor());
-    add(new GroupQueryNodeProcessor());
-    add(new NoChildOptimizationQueryNodeProcessor());
-    add(new RemoveDeletedQueryNodesProcessor());
-    add(new RemoveEmptyNonLeafQueryNodeProcessor());
-    add(new BooleanSingleChildOptimizationQueryNodeProcessor());
-    add(new DefaultPhraseSlopQueryNodeProcessor());
-    add(new BoostQueryNodeProcessor());    
-    add(new MultiTermRewriteMethodProcessor());
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java
deleted file mode 100644
index 9f8ef3a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
-import org.apache.lucene.search.PrefixQuery;
-
-/**
- * The {@link StandardSyntaxParser} creates {@link PrefixWildcardQueryNode} nodes which
- * have values containing the prefixed wildcard. However, Lucene
- * {@link PrefixQuery} cannot contain the prefixed wildcard. So, this processor
- * basically removed the prefixed wildcard from the
- * {@link PrefixWildcardQueryNode} value. <br/>
- * 
- * @see PrefixQuery
- * @see PrefixWildcardQueryNode
- */
-public class WildcardQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  public WildcardQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    // the old Lucene Parser ignores FuzzyQueryNode that are also PrefixWildcardQueryNode or WildcardQueryNode
-    // we do the same here, also ignore empty terms
-    if (node instanceof FieldQueryNode || node instanceof FuzzyQueryNode) {      
-      FieldQueryNode fqn = (FieldQueryNode) node;      
-      CharSequence text = fqn.getText(); 
-      
-      // do not process wildcards for ParametricQueryNode and 
-      // QuotedFieldQueryNode to reproduce the old parser behavior
-      if (fqn instanceof ParametricQueryNode 
-          || fqn instanceof QuotedFieldQueryNode 
-          || text.length() <= 0){
-        // Ignore empty terms
-        return node;
-      }
-      
-      // Code below simulates the old lucene parser behavior for wildcards
-      
-      if (isPrefixWildcard(text)) {        
-        PrefixWildcardQueryNode prefixWildcardQN = new PrefixWildcardQueryNode(fqn);
-        return prefixWildcardQN;
-        
-      } else if (isWildcard(text)){
-        WildcardQueryNode wildcardQN = new WildcardQueryNode(fqn);
-        return wildcardQN;
-      }
-             
-    }
-
-    return node;
-
-  }
-
-  private boolean isWildcard(CharSequence text) {
-    if (text ==null || text.length() <= 0) return false;
-    
-    // If a un-escaped '*' or '?' if found return true
-    // start at the end since it's more common to put wildcards at the end
-    for(int i=text.length()-1; i>=0; i--){
-      if ((text.charAt(i) == '*' || text.charAt(i) == '?') && !UnescapedCharSequence.wasEscaped(text, i)){
-        return true;
-      }
-    }
-    
-    return false;
-  }
-
-  private boolean isPrefixWildcard(CharSequence text) {
-    if (text == null || text.length() <= 0 || !isWildcard(text)) return false;
-    
-    // Validate last character is a '*' and was not escaped
-    // If single '*' is is a wildcard not prefix to simulate old queryparser
-    if (text.charAt(text.length()-1) != '*') return false;
-    if (UnescapedCharSequence.wasEscaped(text, text.length()-1)) return false;
-    if (text.length() == 1) return false;
-      
-    // Only make a prefix if there is only one single star at the end and no '?' or '*' characters
-    // If single wildcard return false to mimic old queryparser
-    for(int i=0; i<text.length(); i++){
-      if (text.charAt(i) == '?') return false;
-      if (text.charAt(i) == '*' && !UnescapedCharSequence.wasEscaped(text, i)){        
-        if (i == text.length()-1) 
-          return true;
-        else 
-          return false;
-      }
-    }
-    
-    return false;
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/package.html
deleted file mode 100644
index 32283fe..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/package.html
+++ /dev/null
@@ -1,33 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-
-<h2>Lucene Query Node Processors</h2>
-<p>
-The package org.apache.lucene.queryParser.standard.processors contains every processor needed to assembly a pipeline
-that modifies the query node tree according to the actual Lucene queries.
-</p>
-<p>
-This processors are already assembled correctly in the StandardQueryNodeProcessorPipeline. 
-</p>
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/overview.html b/lucene/contrib/queryparser/src/java/overview.html
deleted file mode 100644
index d3b61fd..0000000
--- a/lucene/contrib/queryparser/src/java/overview.html
+++ /dev/null
@@ -1,142 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-   <title>Apache Lucene Flexible Query Parser</title>
-</head>
-<body>
-
-<h2>Apache Lucene Flexible Query Parser</h2>
-
-<p>
-This contrib project contains the new Lucene query parser implementation, which matches the syntax of the core QueryParser but offers a more modular architecture to enable customization.
-</p>
-
-<p>
-It's currently divided in 2 main packages:
-<ul>
-<li>{@link org.apache.lucene.queryParser.core}: it contains the query parser API classes, which should be extended by query parser implementations. </li>
-<li>{@link org.apache.lucene.queryParser.standard}: it contains the current Lucene query parser implementation using the new query parser API.</li>
-</ul>
-</p>
-
-<h3>Features</h3>
-
-    <ol>
-        <li>Full support for boolean logic (not enabled)</li>
-        <li>QueryNode Trees - support for several syntaxes, 
-            that can be converted into similar syntax QueryNode trees.</li>
-        <li>QueryNode Processors - Optimize, validate, rewrite the 
-            QueryNode trees</li>
-		<li>Processors Pipelines - Select your favorite Processor
-		    and build a processor pipeline, to implement the features you need</li>
-        <li>Config Interfaces - Allow the consumer of the Query Parser to implement
-            a diff Config Handler Objects to suite their needs.</li>
-        <li>Standard Builders - convert QueryNode's into several lucene 
-            representations. Supported conversion is using a 2.4 compatible logic</li>
-        <li>QueryNode tree's can be converted to a lucene 2.4 syntax string, using toQueryString</li>                          
-    </ol>
-
-<h3>Design</h3>
-<p>
-This new query parser was designed to have very generic
-architecture, so that it can be easily used for different
-products with varying query syntaxes. This code is much more 
-flexible and extensible than the Lucene query parser in 2.4.X.
-</p>
-<p>
-The new query parser  goal is to separate syntax and semantics of a query. E.g. 'a AND
-b', '+a +b', 'AND(a,b)' could be different syntaxes for the same query.
-It distinguishes the semantics of the different query components, e.g.
-whether and how to tokenize/lemmatize/normalize the different terms or
-which Query objects to create for the terms. It allows to
-write a parser with a new syntax, while reusing the underlying
-semantics, as quickly as possible.
-</p>
-<p>
-The query parser has three layers and its core is what we call the
-QueryNode tree. It is a tree that initially represents the syntax of the
-original query, e.g. for 'a AND b':
-</p>
-<pre>
-      AND
-     /   \
-    A     B
-</pre>
-<p>
-The three layers are:
-</p>
-<dl>
-<dt>QueryParser</dt>
-<dd>
-This layer is the text parsing layer which simply transforms the
-query text string into a {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree. Every text parser
-must implement the interface {@link org.apache.lucene.queryParser.core.parser.SyntaxParser}.
-Lucene default implementations implements it using JavaCC.
-</dd>
-
-<dt>QueryNodeProcessor</dt>
-<dd>The query node processors do most of the work. It is in fact a
-configurable chain of processors. Each processors can walk the tree and
-modify nodes or even the tree's structure. That makes it possible to
-e.g. do query optimization before the query is executed or to tokenize
-terms.
-</dd>
-
-<dt>QueryBuilder</dt>
-<dd>
-The third layer is a configurable map of builders, which map {@link org.apache.lucene.queryParser.core.nodes.QueryNode} types to its specific 
-builder that will transform the QueryNode into Lucene Query object.
-</dd>
-
-</dl>
-
-<p>
-Furthermore, the query parser uses flexible configuration objects. It also uses message classes that
-allow to attach resource bundles. This makes it possible to translate
-messages, which is an important feature of a query parser.
-</p>
-<p>
-This design allows to develop different query syntaxes very quickly.
-</p>
-
-<h3>StandardQueryParser and QueryParserWrapper</h3>
-
-<p>
-The standard (default) Lucene query parser is located under
-org.apache.lucene.queryParser.standard.
-<p>
-To make it simpler to use the new query parser 
-the class {@link org.apache.lucene.queryParser.standard.StandardQueryParser} may be helpful,
-specially for people that do not want to extend the Query Parser.
-It uses the default Lucene query processors, text parser and builders, so
-you don't need to worry about dealing with those.
-
-{@link org.apache.lucene.queryParser.standard.StandardQueryParser} usage:
-
-<pre class="prettyprint">
-      StandardQueryParser qpHelper = new StandardQueryParser();
-      StandardQueryConfigHandler config =  qpHelper.getQueryConfigHandler();
-      config.setAllowLeadingWildcard(true);
-      config.setAnalyzer(new WhitespaceAnalyzer());
-      Query query = qpHelper.parse("apache AND lucene", "defaultField");
-</pre>
-
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties b/lucene/contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties
deleted file mode 100644
index fa7aa0d..0000000
--- a/lucene/contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties
+++ /dev/null
@@ -1,57 +0,0 @@
-# This resource bundle contains Flexible Query Parser messages.
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-#  <REPLACEMENT arg="{0}" value="detailed_message"/>
-INVALID_SYNTAX = Syntax Error: {0}
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-#  <REPLACEMENT arg="{0}" value="invalid_query"/>
-#  <REPLACEMENT arg="{1}" value="detailed_message"/>
-INVALID_SYNTAX_CANNOT_PARSE = Syntax Error, cannot parse {0}: {1} 
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-INVALID_SYNTAX_FUZZY_LIMITS = The similarity value for a fuzzy search must be between 0.0 and 1.0.
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-INVALID_SYNTAX_FUZZY_EDITS = Fractional edit distances are not allowed.
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION = Truncated unicode escape sequence.
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-INVALID_SYNTAX_ESCAPE_CHARACTER = Term can not end with escape character.
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE = None-hex character in unicode escape sequence: {0}
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-NODE_ACTION_NOT_SUPPORTED = This node does not support this action.
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-PARAMETER_VALUE_NOT_SUPPORTED = Parameter {1} with value {0} not supported.
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-#  <REPLACEMENT arg="{0}" value="query"/>
-#  <REPLACEMENT arg="{1}" value="error/class"/>
-LUCENE_QUERY_CONVERSION_ERROR = Cannot convert query to lucene syntax: {0} error: {1}
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-EMPTY_MESSAGE = 
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-WILDCARD_NOT_SUPPORTED = Wildcard is not supported for query: {0} 
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-TOO_MANY_BOOLEAN_CLAUSES = Too many boolean clauses, the maximum supported is {0}: {1}
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-LEADING_WILDCARD_NOT_ALLOWED = Leading wildcard is not allowed: {0}
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-COULD_NOT_PARSE_NUMBER = Could not parse text "{0}" using {1}
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-NUMBER_CLASS_NOT_SUPPORTED_BY_NUMERIC_RANGE_QUERY = Number class not supported by NumericRangeQueryNode: {0}
-
-#<CREATEDBY>Apache Lucene Community</CREATEDBY>
-UNSUPPORTED_NUMERIC_DATA_TYPE = Unsupported NumericField.DataType: {0}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/core/builders/TestQueryTreeBuilder.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/core/builders/TestQueryTreeBuilder.java
deleted file mode 100644
index 88ad9a2..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/core/builders/TestQueryTreeBuilder.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.apache.lucene.queryParser.core.builders;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import junit.framework.Assert;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-public class TestQueryTreeBuilder extends LuceneTestCase {
-  
-  @Test
-  public void testSetFieldBuilder() throws QueryNodeException {
-    QueryTreeBuilder qtb = new QueryTreeBuilder();
-    qtb.setBuilder("field", new DummyBuilder());
-    Object result = qtb.build(new FieldQueryNode(new UnescapedCharSequence("field"), "foo", 0, 0));
-    Assert.assertEquals("OK", result);
-    
-  }
-  
-  private static class DummyBuilder implements QueryBuilder {
-
-    public Object build(QueryNode queryNode) throws QueryNodeException {
-      return "OK";
-    }
-    
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/core/nodes/TestQueryNode.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/core/nodes/TestQueryNode.java
deleted file mode 100644
index b805a43..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/core/nodes/TestQueryNode.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Arrays;
-
-import org.apache.lucene.util.LuceneTestCase;
-
-public class TestQueryNode extends LuceneTestCase {
- 
-  /* LUCENE-2227 bug in QueryNodeImpl.add() */
-  public void testAddChildren() throws Exception {
-    QueryNode nodeA = new FieldQueryNode("foo", "A", 0, 1);
-    QueryNode nodeB = new FieldQueryNode("foo", "B", 1, 2);
-    BooleanQueryNode bq = new BooleanQueryNode(
-        Arrays.asList(nodeA));
-    bq.add(Arrays.asList(nodeB));
-    assertEquals(2, bq.getChildren().size());
-  }
-  
-  /* LUCENE-3045 bug in QueryNodeImpl.containsTag(String key)*/
-  public void testTags() throws Exception {
-    QueryNode node = new FieldQueryNode("foo", "A", 0, 1);
-    
-    node.setTag("TaG", new Object());
-    assertTrue(node.getTagMap().size() > 0);
-    assertTrue(node.containsTag("tAg"));
-    assertTrue(node.getTag("tAg") != null);
-    
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java
deleted file mode 100644
index b53ec68..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java
+++ /dev/null
@@ -1,638 +0,0 @@
-package org.apache.lucene.queryParser.precedence;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.io.Reader;
-import java.text.DateFormat;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.analysis.MockTokenFilter;
-import org.apache.lucene.analysis.MockTokenizer;
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.parser.ParseException;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.CharacterRunAutomaton;
-
-/**
- * <p>
- * This test case tests {@link PrecedenceQueryParser}.
- * </p>
- * <p>
- * It contains all tests from {@link org.apache.lucene.queryparser.classic.TestQueryParser}
- * with some adjusted to fit the precedence requirement, plus some precedence test cases.
- * </p>
- * 
- * @see org.apache.lucene.queryparser.classic.TestQueryParser
- */
-public class TestPrecedenceQueryParser extends LuceneTestCase {
-
-  public static Analyzer qpAnalyzer = new QPTestAnalyzer();
-
-  public static final class QPTestFilter extends TokenFilter {
-    /**
-     * Filter which discards the token 'stop' and which expands the token
-     * 'phrase' into 'phrase1 phrase2'
-     */
-    public QPTestFilter(TokenStream in) {
-      super(in);
-    }
-
-    boolean inPhrase = false;
-
-    int savedStart = 0, savedEnd = 0;
-
-    CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-
-    OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
-
-    @Override
-    public boolean incrementToken() throws IOException {
-      if (inPhrase) {
-        inPhrase = false;
-        termAtt.setEmpty().append("phrase2");
-        offsetAtt.setOffset(savedStart, savedEnd);
-        return true;
-      } else
-        while (input.incrementToken())
-          if (termAtt.toString().equals("phrase")) {
-            inPhrase = true;
-            savedStart = offsetAtt.startOffset();
-            savedEnd = offsetAtt.endOffset();
-            termAtt.setEmpty().append("phrase1");
-            offsetAtt.setOffset(savedStart, savedEnd);
-            return true;
-          } else if (!termAtt.toString().equals("stop"))
-            return true;
-      return false;
-    }
-  }
-
-  public static final class QPTestAnalyzer extends Analyzer {
-
-    /** Filters MockTokenizer with StopFilter. */
-    @Override
-    public final TokenStream tokenStream(String fieldName, Reader reader) {
-      return new QPTestFilter(new MockTokenizer(reader, MockTokenizer.SIMPLE, true));
-    }
-  }
-
-  private int originalMaxClauses;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    originalMaxClauses = BooleanQuery.getMaxClauseCount();
-  }
-
-  public PrecedenceQueryParser getParser(Analyzer a) throws Exception {
-    if (a == null)
-      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
-    PrecedenceQueryParser qp = new PrecedenceQueryParser();
-    qp.setAnalyzer(a);
-    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
-    return qp;
-  }
-
-  public Query getQuery(String query, Analyzer a) throws Exception {
-    return getParser(a).parse(query, "field");
-  }
-
-  public void assertQueryEquals(String query, Analyzer a, String result)
-      throws Exception {
-    Query q = getQuery(query, a);
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
-    }
-  }
-
-  public void assertWildcardQueryEquals(String query, boolean lowercase,
-      String result) throws Exception {
-    PrecedenceQueryParser qp = getParser(null);
-    qp.setLowercaseExpandedTerms(lowercase);
-    Query q = qp.parse(query, "field");
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
-          + result + "/");
-    }
-  }
-
-  public void assertWildcardQueryEquals(String query, String result)
-      throws Exception {
-    PrecedenceQueryParser qp = getParser(null);
-    Query q = qp.parse(query, "field");
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
-          + result + "/");
-    }
-  }
-
-  public Query getQueryDOA(String query, Analyzer a) throws Exception {
-    if (a == null)
-      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
-    PrecedenceQueryParser qp = new PrecedenceQueryParser();
-    qp.setAnalyzer(a);
-    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
-    return qp.parse(query, "field");
-  }
-
-  public void assertQueryEqualsDOA(String query, Analyzer a, String result)
-      throws Exception {
-    Query q = getQueryDOA(query, a);
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
-    }
-  }
-
-  public void testSimple() throws Exception {
-    assertQueryEquals("term term term", null, "term term term");
-    assertQueryEquals("trm term term", null, "trm term term");
-    assertQueryEquals("mlaut", null, "mlaut");
-
-    assertQueryEquals("a AND b", null, "+a +b");
-    assertQueryEquals("(a AND b)", null, "+a +b");
-    assertQueryEquals("c OR (a AND b)", null, "c (+a +b)");
-    assertQueryEquals("a AND NOT b", null, "+a -b");
-    assertQueryEquals("a AND -b", null, "+a -b");
-    assertQueryEquals("a AND !b", null, "+a -b");
-    assertQueryEquals("a && b", null, "+a +b");
-    assertQueryEquals("a && ! b", null, "+a -b");
-
-    assertQueryEquals("a OR b", null, "a b");
-    assertQueryEquals("a || b", null, "a b");
-
-    assertQueryEquals("+term -term term", null, "+term -term term");
-    assertQueryEquals("foo:term AND field:anotherTerm", null,
-        "+foo:term +anotherterm");
-    assertQueryEquals("term AND \"phrase phrase\"", null,
-        "+term +\"phrase phrase\"");
-    assertQueryEquals("\"hello there\"", null, "\"hello there\"");
-    assertTrue(getQuery("a AND b", null) instanceof BooleanQuery);
-    assertTrue(getQuery("hello", null) instanceof TermQuery);
-    assertTrue(getQuery("\"hello there\"", null) instanceof PhraseQuery);
-
-    assertQueryEquals("germ term^2.0", null, "germ term^2.0");
-    assertQueryEquals("(term)^2.0", null, "term^2.0");
-    assertQueryEquals("(germ term)^2.0", null, "(germ term)^2.0");
-    assertQueryEquals("term^2.0", null, "term^2.0");
-    assertQueryEquals("term^2", null, "term^2.0");
-    assertQueryEquals("\"germ term\"^2.0", null, "\"germ term\"^2.0");
-    assertQueryEquals("\"term germ\"^2", null, "\"term germ\"^2.0");
-
-    assertQueryEquals("(foo OR bar) AND (baz OR boo)", null,
-        "+(foo bar) +(baz boo)");
-    assertQueryEquals("((a OR b) AND NOT c) OR d", null, "(+(a b) -c) d");
-    assertQueryEquals("+(apple \"steve jobs\") -(foo bar baz)", null,
-        "+(apple \"steve jobs\") -(foo bar baz)");
-    assertQueryEquals("+title:(dog OR cat) -author:\"bob dole\"", null,
-        "+(title:dog title:cat) -author:\"bob dole\"");
-
-    PrecedenceQueryParser qp = new PrecedenceQueryParser();
-    qp.setAnalyzer(new MockAnalyzer(random));
-    // make sure OR is the default:
-    assertEquals(StandardQueryConfigHandler.Operator.OR, qp.getDefaultOperator());
-    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
-    assertEquals(StandardQueryConfigHandler.Operator.AND, qp.getDefaultOperator());
-    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
-    assertEquals(StandardQueryConfigHandler.Operator.OR, qp.getDefaultOperator());
-
-    assertQueryEquals("a OR !b", null, "a -b");
-    assertQueryEquals("a OR ! b", null, "a -b");
-    assertQueryEquals("a OR -b", null, "a -b");
-  }
-
-  public void testPunct() throws Exception {
-    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
-    assertQueryEquals("a&b", a, "a&b");
-    assertQueryEquals("a&&b", a, "a&&b");
-    assertQueryEquals(".NET", a, ".NET");
-  }
-
-  public void testSlop() throws Exception {
-    assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
-    assertQueryEquals("\"term germ\"~2 flork", null, "\"term germ\"~2 flork");
-    assertQueryEquals("\"term\"~2", null, "term");
-    assertQueryEquals("\" \"~2 germ", null, "germ");
-    assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
-  }
-
-  public void testNumber() throws Exception {
-    // The numbers go away because SimpleAnalzyer ignores them
-    assertQueryEquals("3", null, "");
-    assertQueryEquals("term 1.0 1 2", null, "term");
-    assertQueryEquals("term term1 term2", null, "term term term");
-
-    Analyzer a = new MockAnalyzer(random);
-    assertQueryEquals("3", a, "3");
-    assertQueryEquals("term 1.0 1 2", a, "term 1.0 1 2");
-    assertQueryEquals("term term1 term2", a, "term term1 term2");
-  }
-
-  public void testWildcard() throws Exception {
-    assertQueryEquals("term*", null, "term*");
-    assertQueryEquals("term*^2", null, "term*^2.0");
-    assertQueryEquals("term~", null, "term~2.0");
-    assertQueryEquals("term~0.7", null, "term~0.7");
-    assertQueryEquals("term~^3", null, "term~2.0^3.0");
-    assertQueryEquals("term^3~", null, "term~2.0^3.0");
-    assertQueryEquals("term*germ", null, "term*germ");
-    assertQueryEquals("term*germ^3", null, "term*germ^3.0");
-
-    assertTrue(getQuery("term*", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
-    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
-    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery) getQuery("term~", null);
-    assertEquals(2.0f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    try {
-      getQuery("term~1.1", null); // value > 1, throws exception
-      fail();
-    } catch (ParseException pe) {
-      // expected exception
-    }
-    assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
-
-    /*
-     * Tests to see that wild card terms are (or are not) properly lower-cased
-     * with propery parser configuration
-     */
-    // First prefix queries:
-    // by default, convert to lowercase:
-    assertWildcardQueryEquals("Term*", true, "term*");
-    // explicitly set lowercase:
-    assertWildcardQueryEquals("term*", true, "term*");
-    assertWildcardQueryEquals("Term*", true, "term*");
-    assertWildcardQueryEquals("TERM*", true, "term*");
-    // explicitly disable lowercase conversion:
-    assertWildcardQueryEquals("term*", false, "term*");
-    assertWildcardQueryEquals("Term*", false, "Term*");
-    assertWildcardQueryEquals("TERM*", false, "TERM*");
-    // Then 'full' wildcard queries:
-    // by default, convert to lowercase:
-    assertWildcardQueryEquals("Te?m", "te?m");
-    // explicitly set lowercase:
-    assertWildcardQueryEquals("te?m", true, "te?m");
-    assertWildcardQueryEquals("Te?m", true, "te?m");
-    assertWildcardQueryEquals("TE?M", true, "te?m");
-    assertWildcardQueryEquals("Te?m*gerM", true, "te?m*germ");
-    // explicitly disable lowercase conversion:
-    assertWildcardQueryEquals("te?m", false, "te?m");
-    assertWildcardQueryEquals("Te?m", false, "Te?m");
-    assertWildcardQueryEquals("TE?M", false, "TE?M");
-    assertWildcardQueryEquals("Te?m*gerM", false, "Te?m*gerM");
-    // Fuzzy queries:
-    assertWildcardQueryEquals("Term~", "term~2.0");
-    assertWildcardQueryEquals("Term~", true, "term~2.0");
-    assertWildcardQueryEquals("Term~", false, "Term~2.0");
-    // Range queries:
-    assertWildcardQueryEquals("[A TO C]", "[a TO c]");
-    assertWildcardQueryEquals("[A TO C]", true, "[a TO c]");
-    assertWildcardQueryEquals("[A TO C]", false, "[A TO C]");
-  }
-
-  public void testQPA() throws Exception {
-    assertQueryEquals("term term term", qpAnalyzer, "term term term");
-    assertQueryEquals("term +stop term", qpAnalyzer, "term term");
-    assertQueryEquals("term -stop term", qpAnalyzer, "term term");
-    assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
-    assertQueryEquals("term phrase term", qpAnalyzer,
-        "term (phrase1 phrase2) term");
-    // note the parens in this next assertion differ from the original
-    // QueryParser behavior
-    assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
-        "(+term -(phrase1 phrase2)) term");
-    assertQueryEquals("stop", qpAnalyzer, "");
-    assertQueryEquals("stop OR stop AND stop", qpAnalyzer, "");
-    assertTrue(getQuery("term term term", qpAnalyzer) instanceof BooleanQuery);
-    assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
-  }
-
-  public void testRange() throws Exception {
-    assertQueryEquals("[ a TO z]", null, "[a TO z]");
-    assertTrue(getQuery("[ a TO z]", null) instanceof TermRangeQuery);
-    assertQueryEquals("[ a TO z ]", null, "[a TO z]");
-    assertQueryEquals("{ a TO z}", null, "{a TO z}");
-    assertQueryEquals("{ a TO z }", null, "{a TO z}");
-    assertQueryEquals("{ a TO z }^2.0", null, "{a TO z}^2.0");
-    assertQueryEquals("[ a TO z] OR bar", null, "[a TO z] bar");
-    assertQueryEquals("[ a TO z] AND bar", null, "+[a TO z] +bar");
-    assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
-    assertQueryEquals("gack ( bar blar { a TO z}) ", null,
-        "gack (bar blar {a TO z})");
-  }
-
-  private String escapeDateString(String s) {
-    if (s.contains(" ")) {
-      return "\"" + s + "\"";
-    } else {
-      return s;
-    }
-  }
-
-  public String getDate(String s) throws Exception {
-    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
-    return DateTools.dateToString(df.parse(s), DateTools.Resolution.DAY);
-  }
-
-  private String getLocalizedDate(int year, int month, int day,
-      boolean extendLastDate) {
-    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
-    Calendar calendar = new GregorianCalendar();
-    calendar.set(year, month, day);
-    if (extendLastDate) {
-      calendar.set(Calendar.HOUR_OF_DAY, 23);
-      calendar.set(Calendar.MINUTE, 59);
-      calendar.set(Calendar.SECOND, 59);
-      calendar.set(Calendar.MILLISECOND, 999);
-    }
-    return df.format(calendar.getTime());
-  }
-
-  public void testDateRange() throws Exception {
-    String startDate = getLocalizedDate(2002, 1, 1, false);
-    String endDate = getLocalizedDate(2002, 1, 4, false);
-    Calendar endDateExpected = new GregorianCalendar();
-    endDateExpected.set(2002, 1, 4, 23, 59, 59);
-    endDateExpected.set(Calendar.MILLISECOND, 999);
-    final String defaultField = "default";
-    final String monthField = "month";
-    final String hourField = "hour";
-    PrecedenceQueryParser qp = new PrecedenceQueryParser(new MockAnalyzer(random));
-
-    Map<CharSequence, DateTools.Resolution> fieldMap = new HashMap<CharSequence,DateTools.Resolution>();
-    // set a field specific date resolution
-    fieldMap.put(monthField, DateTools.Resolution.MONTH);
-    qp.setDateResolution(fieldMap);
-
-    // set default date resolution to MILLISECOND
-    qp.setDateResolution(DateTools.Resolution.MILLISECOND);
-
-    // set second field specific date resolution
-    fieldMap.put(hourField, DateTools.Resolution.HOUR);
-    qp.setDateResolution(fieldMap);
-
-    // for this field no field specific date resolution has been set,
-    // so verify if the default resolution is used
-    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);
-
-    // verify if field specific date resolutions are used for these two fields
-    assertDateRangeQueryEquals(qp, monthField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.MONTH);
-
-    assertDateRangeQueryEquals(qp, hourField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.HOUR);
-  }
-
-  /** for testing DateTools support */
-  private String getDate(String s, DateTools.Resolution resolution) throws Exception {
-    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
-    return getDate(df.parse(s), resolution);
-  }
-
-  /** for testing DateTools support */
-  private String getDate(Date d, DateTools.Resolution resolution) throws Exception {
-    return DateTools.dateToString(d, resolution);
-  }
-
-  public void assertQueryEquals(PrecedenceQueryParser qp, String field, String query,
-      String result) throws Exception {
-    Query q = qp.parse(query, field);
-    String s = q.toString(field);
-    if (!s.equals(result)) {
-      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
-    }
-  }
-
-  public void assertDateRangeQueryEquals(PrecedenceQueryParser qp, String field,
-      String startDate, String endDate, Date endDateInclusive,
-      DateTools.Resolution resolution) throws Exception {
-    assertQueryEquals(qp, field, field + ":[" + escapeDateString(startDate)
-        + " TO " + escapeDateString(endDate) + "]", "["
-        + getDate(startDate, resolution) + " TO "
-        + getDate(endDateInclusive, resolution) + "]");
-    assertQueryEquals(qp, field, field + ":{" + escapeDateString(startDate)
-        + " TO " + escapeDateString(endDate) + "}", "{"
-        + getDate(startDate, resolution) + " TO "
-        + getDate(endDate, resolution) + "}");
-  }
-
-  public void testEscaped() throws Exception {
-    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
-
-    assertQueryEquals("a\\-b:c", a, "a-b:c");
-    assertQueryEquals("a\\+b:c", a, "a+b:c");
-    assertQueryEquals("a\\:b:c", a, "a:b:c");
-    assertQueryEquals("a\\\\b:c", a, "a\\b:c");
-
-    assertQueryEquals("a:b\\-c", a, "a:b-c");
-    assertQueryEquals("a:b\\+c", a, "a:b+c");
-    assertQueryEquals("a:b\\:c", a, "a:b:c");
-    assertQueryEquals("a:b\\\\c", a, "a:b\\c");
-
-    assertQueryEquals("a:b\\-c*", a, "a:b-c*");
-    assertQueryEquals("a:b\\+c*", a, "a:b+c*");
-    assertQueryEquals("a:b\\:c*", a, "a:b:c*");
-
-    assertQueryEquals("a:b\\\\c*", a, "a:b\\c*");
-
-    assertQueryEquals("a:b\\-?c", a, "a:b-?c");
-    assertQueryEquals("a:b\\+?c", a, "a:b+?c");
-    assertQueryEquals("a:b\\:?c", a, "a:b:?c");
-
-    assertQueryEquals("a:b\\\\?c", a, "a:b\\?c");
-
-    assertQueryEquals("a:b\\-c~", a, "a:b-c~2.0");
-    assertQueryEquals("a:b\\+c~", a, "a:b+c~2.0");
-    assertQueryEquals("a:b\\:c~", a, "a:b:c~2.0");
-    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~2.0");
-
-    assertQueryEquals("[ a\\- TO a\\+ ]", null, "[a- TO a+]");
-    assertQueryEquals("[ a\\: TO a\\~ ]", null, "[a: TO a~]");
-    assertQueryEquals("[ a\\\\ TO a\\* ]", null, "[a\\ TO a*]");
-  }
-
-  public void testTabNewlineCarriageReturn() throws Exception {
-    assertQueryEqualsDOA("+weltbank +worlbank", null, "+weltbank +worlbank");
-
-    assertQueryEqualsDOA("+weltbank\n+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \n+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \n +worlbank", null, "+weltbank +worlbank");
-
-    assertQueryEqualsDOA("+weltbank\r+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r +worlbank", null, "+weltbank +worlbank");
-
-    assertQueryEqualsDOA("+weltbank\r\n+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r\n+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r\n +worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r \n +worlbank", null,
-        "+weltbank +worlbank");
-
-    assertQueryEqualsDOA("+weltbank\t+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \t+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \t +worlbank", null, "+weltbank +worlbank");
-  }
-
-  public void testSimpleDAO() throws Exception {
-    assertQueryEqualsDOA("term term term", null, "+term +term +term");
-    assertQueryEqualsDOA("term +term term", null, "+term +term +term");
-    assertQueryEqualsDOA("term term +term", null, "+term +term +term");
-    assertQueryEqualsDOA("term +term +term", null, "+term +term +term");
-    assertQueryEqualsDOA("-term term term", null, "-term +term +term");
-  }
-
-  public void testBoost() throws Exception {
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(BasicAutomata.makeString("on"));
-    Analyzer oneStopAnalyzer = new MockAnalyzer(random, MockTokenizer.SIMPLE, true, stopSet, true);
-
-    PrecedenceQueryParser qp = new PrecedenceQueryParser();
-    qp.setAnalyzer(oneStopAnalyzer);
-    Query q = qp.parse("on^1.0", "field");
-    assertNotNull(q);
-    q = qp.parse("\"hello\"^2.0", "field");
-    assertNotNull(q);
-    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
-    q = qp.parse("hello^2.0", "field");
-    assertNotNull(q);
-    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
-    q = qp.parse("\"on\"^1.0", "field");
-    assertNotNull(q);
-
-    q = getParser(new MockAnalyzer(random, MockTokenizer.SIMPLE, true, MockTokenFilter.ENGLISH_STOPSET, true)).parse("the^3",
-        "field");
-    assertNotNull(q);
-  }
-
-  public void testException() throws Exception {
-    try {
-      assertQueryEquals("\"some phrase", null, "abc");
-      fail("ParseException expected, not thrown");
-    } catch (QueryNodeParseException expected) {
-    }
-  }
-
-  public void testBooleanQuery() throws Exception {
-    BooleanQuery.setMaxClauseCount(2);
-    try {
-      getParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).parse("one two three", "field");
-      fail("ParseException expected due to too many boolean clauses");
-    } catch (QueryNodeException expected) {
-      // too many boolean clauses, so ParseException is expected
-    }
-  }
-  
-  // LUCENE-792
-  public void testNOT() throws Exception {
-    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
-    assertQueryEquals("NOT foo AND bar", a, "-foo +bar");
-  }
-
-  /**
-   * This test differs from the original QueryParser, showing how the precedence
-   * issue has been corrected.
-   */
-  public void testPrecedence() throws Exception {
-    PrecedenceQueryParser parser = getParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
-    Query query1 = parser.parse("A AND B OR C AND D", "field");
-    Query query2 = parser.parse("(A AND B) OR (C AND D)", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A OR B C", "field");
-    query2 = parser.parse("(A B) C", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A AND B C", "field");
-    query2 = parser.parse("(+A +B) C", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A AND NOT B", "field");
-    query2 = parser.parse("+A -B", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A OR NOT B", "field");
-    query2 = parser.parse("A -B", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A OR NOT B AND C", "field");
-    query2 = parser.parse("A (-B +C)", "field");
-    assertEquals(query1, query2);
-    
-    parser.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
-    query1 = parser.parse("A AND B OR C AND D", "field");
-    query2 = parser.parse("(A AND B) OR (C AND D)", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A AND B C", "field");
-    query2 = parser.parse("(A B) C", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A AND B C", "field");
-    query2 = parser.parse("(+A +B) C", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A AND NOT B", "field");
-    query2 = parser.parse("+A -B", "field");
-    assertEquals(query1, query2);
-
-    query1 = parser.parse("A AND NOT B OR C", "field");
-    query2 = parser.parse("(+A -B) OR C", "field");
-    assertEquals(query1, query2);
-    
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    BooleanQuery.setMaxClauseCount(originalMaxClauses);
-    super.tearDown();
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpanOrQueryNodeBuilder.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpanOrQueryNodeBuilder.java
deleted file mode 100644
index c4bc9b9..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpanOrQueryNodeBuilder.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.builders.StandardQueryBuilder;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-
-/**
- * This builder creates {@link SpanOrQuery}s from a {@link BooleanQueryNode}.<br/>
- * <br/>
- * 
- * It assumes that the {@link BooleanQueryNode} instance has at least one child.
- */
-public class SpanOrQueryNodeBuilder implements StandardQueryBuilder {
-
-  public SpanOrQuery build(QueryNode node) throws QueryNodeException {
-
-    // validates node
-    BooleanQueryNode booleanNode = (BooleanQueryNode) node;
-
-    List<QueryNode> children = booleanNode.getChildren();
-    SpanQuery[] spanQueries = new SpanQuery[children.size()];
-
-    int i = 0;
-    for (QueryNode child : children) {
-      spanQueries[i++] = (SpanQuery) child
-          .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-    }
-
-    return new SpanOrQuery(spanQueries);
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpanTermQueryNodeBuilder.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpanTermQueryNodeBuilder.java
deleted file mode 100644
index 8fa9096..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpanTermQueryNodeBuilder.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.builders.StandardQueryBuilder;
-import org.apache.lucene.search.spans.SpanTermQuery;
-
-/**
- * This builder creates {@link SpanTermQuery}s from a {@link FieldQueryNode}
- * object.
- */
-public class SpanTermQueryNodeBuilder implements StandardQueryBuilder {
-
-  public SpanTermQuery build(QueryNode node) throws QueryNodeException {
-    FieldQueryNode fieldQueryNode = (FieldQueryNode) node;
-
-    return new SpanTermQuery(new Term(fieldQueryNode.getFieldAsString(),
-        fieldQueryNode.getTextAsString()));
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java
deleted file mode 100644
index 5272142..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.ConfigurationKey;
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-
-/**
- * This query config handler only adds the {@link UniqueFieldAttribute} to it.<br/>
- * <br/>
- * 
- * It does not return any configuration for a field in specific.
- */
-public class SpansQueryConfigHandler extends QueryConfigHandler {
-  
-  final public static ConfigurationKey<String> UNIQUE_FIELD = ConfigurationKey.newInstance();
-  
-  public SpansQueryConfigHandler() {
-    // empty constructor
-  }
-
-  @Override
-  public FieldConfig getFieldConfig(String fieldName) {
-
-    // there is no field configuration, always return null
-    return null;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryTreeBuilder.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryTreeBuilder.java
deleted file mode 100644
index 8d0f7d6..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryTreeBuilder.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.builders.StandardQueryBuilder;
-import org.apache.lucene.search.spans.SpanQuery;
-
-/**
- * Sets up a query tree builder to build a span query tree from a query node
- * tree.<br/>
- * <br/>
- * 
- * The defined map is:<br/>
- * - every BooleanQueryNode instance is delegated to the SpanOrQueryNodeBuilder<br/>
- * - every FieldQueryNode instance is delegated to the SpanTermQueryNodeBuilder <br/>
- * 
- */
-public class SpansQueryTreeBuilder extends QueryTreeBuilder implements
-    StandardQueryBuilder {
-
-  public SpansQueryTreeBuilder() {
-    setBuilder(BooleanQueryNode.class, new SpanOrQueryNodeBuilder());
-    setBuilder(FieldQueryNode.class, new SpanTermQueryNodeBuilder());
-
-  }
-
-  @Override
-  public SpanQuery build(QueryNode queryTree) throws QueryNodeException {
-    return (SpanQuery) super.build(queryTree);
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansValidatorQueryNodeProcessor.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansValidatorQueryNodeProcessor.java
deleted file mode 100644
index 335adb4..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansValidatorQueryNodeProcessor.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-
-/**
- * Validates every query node in a query node tree. This processor will pass
- * fine if the query nodes are only {@link BooleanQueryNode}s,
- * {@link OrQueryNode}s or {@link FieldQueryNode}s, otherwise an exception will
- * be thrown. <br/>
- * <br/>
- * 
- * If they are {@link AndQueryNode} or an instance of anything else that
- * implements {@link FieldQueryNode} the exception will also be thrown.
- */
-public class SpansValidatorQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (!((node instanceof BooleanQueryNode && !(node instanceof AndQueryNode)) || node
-        .getClass() == FieldQueryNode.class)) {
-      throw new QueryNodeException(new MessageImpl(
-          QueryParserMessages.NODE_ACTION_NOT_SUPPORTED));
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java
deleted file mode 100644
index deb608c..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java
+++ /dev/null
@@ -1,230 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
-import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
-import org.apache.lucene.queryParser.standard.processors.WildcardQueryNodeProcessor;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- * This test case demonstrates how the new query parser can be used.<br/>
- * <br/>
- * 
- * It tests queries likes "term", "field:term" "term1 term2" "term1 OR term2",
- * which are all already supported by the current syntax parser (
- * {@link StandardSyntaxParser}).<br/>
- * <br/>
- * 
- * The goals is to create a new query parser that supports only the pair
- * "field:term" or a list of pairs separated or not by an OR operator, and from
- * this query generate {@link SpanQuery} objects instead of the regular
- * {@link Query} objects. Basically, every pair will be converted to a
- * {@link SpanTermQuery} object and if there are more than one pair they will be
- * grouped by an {@link OrQueryNode}.<br/>
- * <br/>
- * 
- * Another functionality that will be added is the ability to convert every
- * field defined in the query to an unique specific field.<br/>
- * <br/>
- * 
- * The query generation is divided in three different steps: parsing (syntax),
- * processing (semantic) and building.<br/>
- * <br/>
- * 
- * The parsing phase, as already mentioned will be performed by the current
- * query parser: {@link StandardSyntaxParser}.<br/>
- * <br/>
- * 
- * The processing phase will be performed by a processor pipeline which is
- * compound by 2 processors: {@link SpansValidatorQueryNodeProcessor} and
- * {@link UniqueFieldQueryNodeProcessor}.
- * 
- * <pre>
- * 
- *   {@link SpansValidatorQueryNodeProcessor}: as it's going to use the current 
- *   query parser to parse the syntax, it will support more features than we want,
- *   this processor basically validates the query node tree generated by the parser
- *   and just let got through the elements we want, all the other elements as 
- *   wildcards, range queries, etc...if found, an exception is thrown.
- *   
- *   {@link UniqueFieldQueryNodeProcessor}: this processor will take care of reading
- *   what is the &quot;unique field&quot; from the configuration and convert every field defined
- *   in every pair to this &quot;unique field&quot;. For that, a {@link SpansQueryConfigHandler} is
- *   used, which has the {@link UniqueFieldAttribute} defined in it.
- * </pre>
- * 
- * The building phase is performed by the {@link SpansQueryTreeBuilder}, which
- * basically contains a map that defines which builder will be used to generate
- * {@link SpanQuery} objects from {@link QueryNode} objects.<br/>
- * <br/>
- * 
- * @see SpansQueryConfigHandler
- * @see SpansQueryTreeBuilder
- * @see SpansValidatorQueryNodeProcessor
- * @see SpanOrQueryNodeBuilder
- * @see SpanTermQueryNodeBuilder
- * @see StandardSyntaxParser
- * @see UniqueFieldQueryNodeProcessor
- * @see UniqueFieldAttribute
- */
-public class TestSpanQueryParser extends LuceneTestCase {
-
-  private QueryNodeProcessorPipeline spanProcessorPipeline;
-
-  private SpansQueryConfigHandler spanQueryConfigHandler;
-
-  private SpansQueryTreeBuilder spansQueryTreeBuilder;
-
-  private SyntaxParser queryParser = new StandardSyntaxParser();
-
-  public TestSpanQueryParser() {
-    // empty constructor
-  }
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-
-    this.spanProcessorPipeline = new QueryNodeProcessorPipeline();
-    this.spanQueryConfigHandler = new SpansQueryConfigHandler();
-    this.spansQueryTreeBuilder = new SpansQueryTreeBuilder();
-
-    // set up the processor pipeline
-    this.spanProcessorPipeline
-        .setQueryConfigHandler(this.spanQueryConfigHandler);
-
-    this.spanProcessorPipeline.add(new WildcardQueryNodeProcessor());
-    this.spanProcessorPipeline.add(new SpansValidatorQueryNodeProcessor());
-    this.spanProcessorPipeline.add(new UniqueFieldQueryNodeProcessor());
-
-  }
-
-  public SpanQuery getSpanQuery(CharSequence query) throws QueryNodeException {
-    return getSpanQuery("", query);
-  }
-
-  public SpanQuery getSpanQuery(String uniqueField, CharSequence query)
-      throws QueryNodeException {
-    
-    this.spanQueryConfigHandler.set(SpansQueryConfigHandler.UNIQUE_FIELD, uniqueField);
-
-    QueryNode queryTree = this.queryParser.parse(query, "defaultField");
-    queryTree = this.spanProcessorPipeline.process(queryTree);
-
-    return this.spansQueryTreeBuilder.build(queryTree);
-
-  }
-
-  public void testTermSpans() throws Exception {
-    assertEquals(getSpanQuery("field:term").toString(), "term");
-    assertEquals(getSpanQuery("term").toString(), "term");
-
-    assertTrue(getSpanQuery("field:term") instanceof SpanTermQuery);
-    assertTrue(getSpanQuery("term") instanceof SpanTermQuery);
-
-  }
-
-  public void testUniqueField() throws Exception {
-    assertEquals(getSpanQuery("field", "term").toString(), "field:term");
-    assertEquals(getSpanQuery("field", "field:term").toString(), "field:term");
-    assertEquals(getSpanQuery("field", "anotherField:term").toString(),
-        "field:term");
-
-  }
-
-  public void testOrSpans() throws Exception {
-    assertEquals(getSpanQuery("term1 term2").toString(),
-        "spanOr([term1, term2])");
-    assertEquals(getSpanQuery("term1 OR term2").toString(),
-        "spanOr([term1, term2])");
-
-    assertTrue(getSpanQuery("term1 term2") instanceof SpanOrQuery);
-    assertTrue(getSpanQuery("term1 term2") instanceof SpanOrQuery);
-
-  }
-
-  public void testQueryValidator() throws QueryNodeException {
-
-    try {
-      getSpanQuery("term*");
-      fail("QueryNodeException was expected, wildcard queries should not be supported");
-
-    } catch (QueryNodeException ex) {
-      // expected exception
-    }
-
-    try {
-      getSpanQuery("[a TO z]");
-      fail("QueryNodeException was expected, range queries should not be supported");
-
-    } catch (QueryNodeException ex) {
-      // expected exception
-    }
-
-    try {
-      getSpanQuery("a~0.5");
-      fail("QueryNodeException was expected, boost queries should not be supported");
-
-    } catch (QueryNodeException ex) {
-      // expected exception
-    }
-
-    try {
-      getSpanQuery("a^0.5");
-      fail("QueryNodeException was expected, fuzzy queries should not be supported");
-
-    } catch (QueryNodeException ex) {
-      // expected exception
-    }
-
-    try {
-      getSpanQuery("\"a b\"");
-      fail("QueryNodeException was expected, quoted queries should not be supported");
-
-    } catch (QueryNodeException ex) {
-      // expected exception
-    }
-
-    try {
-      getSpanQuery("(a b)");
-      fail("QueryNodeException was expected, parenthesized queries should not be supported");
-
-    } catch (QueryNodeException ex) {
-      // expected exception
-    }
-
-    try {
-      getSpanQuery("a AND b");
-      fail("QueryNodeException was expected, and queries should not be supported");
-
-    } catch (QueryNodeException ex) {
-      // expected exception
-    }
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java
deleted file mode 100644
index 0c696de..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java
+++ /dev/null
@@ -1,138 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import javax.management.Query;
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
-import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- * This test case demonstrates how the new query parser can be used.<br/>
- * <br/>
- * 
- * It tests queries likes "term", "field:term" "term1 term2" "term1 OR term2",
- * which are all already supported by the current syntax parser (
- * {@link StandardSyntaxParser}).<br/>
- * <br/>
- * 
- * The goals is to create a new query parser that supports only the pair
- * "field:term" or a list of pairs separated or not by an OR operator, and from
- * this query generate {@link SpanQuery} objects instead of the regular
- * {@link Query} objects. Basically, every pair will be converted to a
- * {@link SpanTermQuery} object and if there are more than one pair they will be
- * grouped by an {@link OrQueryNode}.<br/>
- * <br/>
- * 
- * Another functionality that will be added is the ability to convert every
- * field defined in the query to an unique specific field.<br/>
- * <br/>
- * 
- * The query generation is divided in three different steps: parsing (syntax),
- * processing (semantic) and building.<br/>
- * <br/>
- * 
- * The parsing phase, as already mentioned will be performed by the current
- * query parser: {@link StandardSyntaxParser}.<br/>
- * <br/>
- * 
- * The processing phase will be performed by a processor pipeline which is
- * compound by 2 processors: {@link SpansValidatorQueryNodeProcessor} and
- * {@link UniqueFieldQueryNodeProcessor}.
- * 
- * <pre>
- * 
- *   {@link SpansValidatorQueryNodeProcessor}: as it's going to use the current 
- *   query parser to parse the syntax, it will support more features than we want,
- *   this processor basically validates the query node tree generated by the parser
- *   and just let got through the elements we want, all the other elements as 
- *   wildcards, range queries, etc...if found, an exception is thrown.
- *   
- *   {@link UniqueFieldQueryNodeProcessor}: this processor will take care of reading
- *   what is the &quot;unique field&quot; from the configuration and convert every field defined
- *   in every pair to this &quot;unique field&quot;. For that, a {@link SpansQueryConfigHandler} is
- *   used, which has the {@link UniqueFieldAttribute} defined in it.
- * </pre>
- * 
- * The building phase is performed by the {@link SpansQueryTreeBuilder}, which
- * basically contains a map that defines which builder will be used to generate
- * {@link SpanQuery} objects from {@link QueryNode} objects.<br/>
- * <br/>
- * 
- * @see TestSpanQueryParser for a more advanced example
- * 
- * @see SpansQueryConfigHandler
- * @see SpansQueryTreeBuilder
- * @see SpansValidatorQueryNodeProcessor
- * @see SpanOrQueryNodeBuilder
- * @see SpanTermQueryNodeBuilder
- * @see StandardSyntaxParser
- * @see UniqueFieldQueryNodeProcessor
- * @see UniqueFieldAttribute
- * 
- */
-public class TestSpanQueryParserSimpleSample extends LuceneTestCase {
-
-  public void testBasicDemo() throws Exception {
-    SyntaxParser queryParser = new StandardSyntaxParser();
-
-    // convert the CharSequence into a QueryNode tree
-    QueryNode queryTree = queryParser.parse("body:text", null);
-
-    // create a config handler with a attribute used in
-    // UniqueFieldQueryNodeProcessor
-    QueryConfigHandler spanQueryConfigHandler = new SpansQueryConfigHandler();
-    spanQueryConfigHandler.set(SpansQueryConfigHandler.UNIQUE_FIELD, "index");
-
-    // set up the processor pipeline with the ConfigHandler
-    // and create the pipeline for this simple demo
-    QueryNodeProcessorPipeline spanProcessorPipeline = new QueryNodeProcessorPipeline(
-        spanQueryConfigHandler);
-    // @see SpansValidatorQueryNodeProcessor
-    spanProcessorPipeline.add(new SpansValidatorQueryNodeProcessor());
-    // @see UniqueFieldQueryNodeProcessor
-    spanProcessorPipeline.add(new UniqueFieldQueryNodeProcessor());
-
-    // print to show out the QueryNode tree before being processed
-    if (VERBOSE) System.out.println(queryTree);
-
-    // Process the QueryTree using our new Processors
-    queryTree = spanProcessorPipeline.process(queryTree);
-
-    // print to show out the QueryNode tree after being processed
-    if (VERBOSE) System.out.println(queryTree);
-
-    // create a instance off the Builder
-    SpansQueryTreeBuilder spansQueryTreeBuilder = new SpansQueryTreeBuilder();
-
-    // convert QueryNode tree to span query Objects
-    SpanQuery spanquery = spansQueryTreeBuilder.build(queryTree);
-
-    assertTrue(spanquery instanceof SpanTermQuery);
-    assertEquals(spanquery.toString(), "index:text");
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldAttribute.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldAttribute.java
deleted file mode 100644
index adbae05..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldAttribute.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by the {@link UniqueFieldQueryNodeProcessor}
- * processor. It holds a value that defines which is the unique field name that
- * should be set in every {@link FieldableNode}.<br/>
- * <br/>
- * 
- * @see UniqueFieldQueryNodeProcessor
- */
-public interface UniqueFieldAttribute extends Attribute {
-  public void setUniqueField(CharSequence uniqueField);
-
-  public CharSequence getUniqueField();
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldAttributeImpl.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldAttributeImpl.java
deleted file mode 100644
index 7fce3a8..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldAttributeImpl.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by the {@link UniqueFieldQueryNodeProcessor}
- * processor. It holds a value that defines which is the unique field name that
- * should be set in every {@link FieldableNode}.<br/>
- * <br/>
- * 
- * @see UniqueFieldQueryNodeProcessor
- */
-public class UniqueFieldAttributeImpl extends AttributeImpl implements
-    UniqueFieldAttribute {
-
-  private CharSequence uniqueField;
-
-  public UniqueFieldAttributeImpl() {
-    clear();
-  }
-
-  @Override
-  public void clear() {
-    this.uniqueField = "";
-  }
-
-  public void setUniqueField(CharSequence uniqueField) {
-    this.uniqueField = uniqueField;
-  }
-
-  public CharSequence getUniqueField() {
-    return this.uniqueField;
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-
-    if (!(target instanceof UniqueFieldAttributeImpl)) {
-      throw new IllegalArgumentException(
-          "cannot copy the values from attribute UniqueFieldAttribute to an instance of "
-              + target.getClass().getName());
-    }
-
-    UniqueFieldAttributeImpl uniqueFieldAttr = (UniqueFieldAttributeImpl) target;
-    uniqueFieldAttr.uniqueField = uniqueField.toString();
-
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof UniqueFieldAttributeImpl) {
-
-      return ((UniqueFieldAttributeImpl) other).uniqueField
-          .equals(this.uniqueField);
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return this.uniqueField.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<uniqueField uniqueField='" + this.uniqueField + "'/>";
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java
deleted file mode 100644
index 95997be..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package org.apache.lucene.queryParser.spans;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.core.nodes.FieldableNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-
-/**
- * This processor changes every field name of each {@link FieldableNode} query
- * node contained in the query tree to the field name defined in the
- * {@link UniqueFieldAttribute}. So, the {@link UniqueFieldAttribute} must be
- * defined in the {@link QueryConfigHandler} object set in this processor,
- * otherwise it throws an exception.<br/>
- * <br/>
- * 
- * @see UniqueFieldAttribute
- */
-public class UniqueFieldQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  @Override
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  @Override
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof FieldableNode) {
-      FieldableNode fieldNode = (FieldableNode) node;
-
-      QueryConfigHandler queryConfig = getQueryConfigHandler();
-
-      if (queryConfig == null) {
-        throw new IllegalArgumentException(
-            "A config handler is expected by the processor UniqueFieldQueryNodeProcessor!");
-      }
-
-      if (!queryConfig.has(SpansQueryConfigHandler.UNIQUE_FIELD)) {
-        throw new IllegalArgumentException(
-            "UniqueFieldAttribute should be defined in the config handler!");
-      }
-
-      String uniqueField = queryConfig.get(SpansQueryConfigHandler.UNIQUE_FIELD);
-      fieldNode.setField(uniqueField);
-
-    }
-
-    return node;
-
-  }
-
-  @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java
deleted file mode 100644
index dc876fe..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java
+++ /dev/null
@@ -1,252 +0,0 @@
-package org.apache.lucene.queryParser.standard;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.Reader;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockTokenizer;
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
-import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- * This test case is a copy of the core Lucene query parser test, it was adapted
- * to use new QueryParserHelper instead of the old query parser.
- * 
- * Test QueryParser's ability to deal with Analyzers that return more than one
- * token per position or that return tokens with a position increment &gt; 1.
- */
-public class TestMultiAnalyzerQPHelper extends LuceneTestCase {
-
-  private static int multiToken = 0;
-
-  public void testMultiAnalyzer() throws QueryNodeException {
-
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(new MultiAnalyzer());
-
-    // trivial, no multiple tokens:
-    assertEquals("foo", qp.parse("foo", "").toString());
-    assertEquals("foo", qp.parse("\"foo\"", "").toString());
-    assertEquals("foo foobar", qp.parse("foo foobar", "").toString());
-    assertEquals("\"foo foobar\"", qp.parse("\"foo foobar\"", "").toString());
-    assertEquals("\"foo foobar blah\"", qp.parse("\"foo foobar blah\"", "")
-        .toString());
-
-    // two tokens at the same position:
-    assertEquals("(multi multi2) foo", qp.parse("multi foo", "").toString());
-    assertEquals("foo (multi multi2)", qp.parse("foo multi", "").toString());
-    assertEquals("(multi multi2) (multi multi2)", qp.parse("multi multi", "")
-        .toString());
-    assertEquals("+(foo (multi multi2)) +(bar (multi multi2))", qp.parse(
-        "+(foo multi) +(bar multi)", "").toString());
-    assertEquals("+(foo (multi multi2)) field:\"bar (multi multi2)\"", qp
-        .parse("+(foo multi) field:\"bar multi\"", "").toString());
-
-    // phrases:
-    assertEquals("\"(multi multi2) foo\"", qp.parse("\"multi foo\"", "")
-        .toString());
-    assertEquals("\"foo (multi multi2)\"", qp.parse("\"foo multi\"", "")
-        .toString());
-    assertEquals("\"foo (multi multi2) foobar (multi multi2)\"", qp.parse(
-        "\"foo multi foobar multi\"", "").toString());
-
-    // fields:
-    assertEquals("(field:multi field:multi2) field:foo", qp.parse(
-        "field:multi field:foo", "").toString());
-    assertEquals("field:\"(multi multi2) foo\"", qp.parse(
-        "field:\"multi foo\"", "").toString());
-
-    // three tokens at one position:
-    assertEquals("triplemulti multi3 multi2", qp.parse("triplemulti", "")
-        .toString());
-    assertEquals("foo (triplemulti multi3 multi2) foobar", qp.parse(
-        "foo triplemulti foobar", "").toString());
-
-    // phrase with non-default slop:
-    assertEquals("\"(multi multi2) foo\"~10", qp.parse("\"multi foo\"~10", "")
-        .toString());
-
-    // phrase with non-default boost:
-    assertEquals("\"(multi multi2) foo\"^2.0", qp.parse("\"multi foo\"^2", "")
-        .toString());
-
-    // phrase after changing default slop
-    qp.setDefaultPhraseSlop(99);
-    assertEquals("\"(multi multi2) foo\"~99 bar", qp.parse("\"multi foo\" bar",
-        "").toString());
-    assertEquals("\"(multi multi2) foo\"~99 \"foo bar\"~2", qp.parse(
-        "\"multi foo\" \"foo bar\"~2", "").toString());
-    qp.setDefaultPhraseSlop(0);
-
-    // non-default operator:
-    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
-    assertEquals("+(multi multi2) +foo", qp.parse("multi foo", "").toString());
-
-  }
-
-  // public void testMultiAnalyzerWithSubclassOfQueryParser() throws
-  // ParseException {
-  // this test doesn't make sense when using the new QueryParser API
-  // DumbQueryParser qp = new DumbQueryParser("", new MultiAnalyzer());
-  // qp.setPhraseSlop(99); // modified default slop
-  //
-  // // direct call to (super's) getFieldQuery to demonstrate differnce
-  // // between phrase and multiphrase with modified default slop
-  // assertEquals("\"foo bar\"~99",
-  // qp.getSuperFieldQuery("","foo bar").toString());
-  // assertEquals("\"(multi multi2) bar\"~99",
-  // qp.getSuperFieldQuery("","multi bar").toString());
-  //
-  //    
-  // // ask sublcass to parse phrase with modified default slop
-  // assertEquals("\"(multi multi2) foo\"~99 bar",
-  // qp.parse("\"multi foo\" bar").toString());
-  //    
-  // }
-
-  public void testPosIncrementAnalyzer() throws QueryNodeException {
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(new PosIncrementAnalyzer());
-
-    assertEquals("quick brown", qp.parse("the quick brown", "").toString());
-    assertEquals("\"quick brown\"", qp.parse("\"the quick brown\"", "")
-        .toString());
-    assertEquals("quick brown fox", qp.parse("the quick brown fox", "")
-        .toString());
-    assertEquals("\"quick brown fox\"", qp.parse("\"the quick brown fox\"", "")
-        .toString());
-  }
-
-  /**
-   * Expands "multi" to "multi" and "multi2", both at the same position, and
-   * expands "triplemulti" to "triplemulti", "multi3", and "multi2".
-   */
-  private class MultiAnalyzer extends Analyzer {
-
-    public MultiAnalyzer() {
-    }
-
-    @Override
-    public TokenStream tokenStream(String fieldName, Reader reader) {
-      TokenStream result = new MockTokenizer(reader, MockTokenizer.WHITESPACE, true);
-      result = new TestFilter(result);
-      return result;
-    }
-  }
-
-  private final class TestFilter extends TokenFilter {
-
-    private String prevType;
-    private int prevStartOffset;
-    private int prevEndOffset;
-
-    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-    private final PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);
-    private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
-    private final TypeAttribute typeAtt = addAttribute(TypeAttribute.class);
-
-    public TestFilter(TokenStream in) {
-      super(in);
-    }
-
-    @Override
-    public final boolean incrementToken() throws java.io.IOException {
-      if (multiToken > 0) {
-        termAtt.setEmpty().append("multi" + (multiToken + 1));
-        offsetAtt.setOffset(prevStartOffset, prevEndOffset);
-        typeAtt.setType(prevType);
-        posIncrAtt.setPositionIncrement(0);
-        multiToken--;
-        return true;
-      } else {
-        boolean next = input.incrementToken();
-        if (next == false) {
-          return false;
-        }
-        prevType = typeAtt.type();
-        prevStartOffset = offsetAtt.startOffset();
-        prevEndOffset = offsetAtt.endOffset();
-        String text = termAtt.toString();
-        if (text.equals("triplemulti")) {
-          multiToken = 2;
-          return true;
-        } else if (text.equals("multi")) {
-          multiToken = 1;
-          return true;
-        } else {
-          return true;
-        }
-      }
-    }
-
-  }
-
-  /**
-   * Analyzes "the quick brown" as: quick(incr=2) brown(incr=1). Does not work
-   * correctly for input other than "the quick brown ...".
-   */
-  private class PosIncrementAnalyzer extends Analyzer {
-
-    public PosIncrementAnalyzer() {
-    }
-
-    @Override
-    public TokenStream tokenStream(String fieldName, Reader reader) {
-      TokenStream result = new MockTokenizer(reader, MockTokenizer.WHITESPACE, true);
-      result = new TestPosIncrementFilter(result);
-      return result;
-    }
-  }
-
-  private class TestPosIncrementFilter extends TokenFilter {
-
-    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-    private final PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);
-
-    public TestPosIncrementFilter(TokenStream in) {
-      super(in);
-    }
-
-    @Override
-    public final boolean incrementToken() throws java.io.IOException {
-      while (input.incrementToken()) {
-        if (termAtt.toString().equals("the")) {
-          // stopword, do nothing
-        } else if (termAtt.toString().equals("quick")) {
-          posIncrAtt.setPositionIncrement(2);
-          return true;
-        } else {
-          posIncrAtt.setPositionIncrement(1);
-          return true;
-        }
-      }
-      return false;
-    }
-
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java
deleted file mode 100644
index 6dd278f..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java
+++ /dev/null
@@ -1,368 +0,0 @@
-package org.apache.lucene.queryParser.standard;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.Reader;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- * This test case is a copy of the core Lucene query parser test, it was adapted
- * to use new QueryParserHelper instead of the old query parser.
- * 
- * Tests QueryParser.
- */
-public class TestMultiFieldQPHelper extends LuceneTestCase {
-
-  /**
-   * test stop words parsing for both the non static form, and for the
-   * corresponding static form (qtxt, fields[]).
-   */
-  public void testStopwordsParsing() throws Exception {
-    assertStopQueryEquals("one", "b:one t:one");
-    assertStopQueryEquals("one stop", "b:one t:one");
-    assertStopQueryEquals("one (stop)", "b:one t:one");
-    assertStopQueryEquals("one ((stop))", "b:one t:one");
-    assertStopQueryEquals("stop", "");
-    assertStopQueryEquals("(stop)", "");
-    assertStopQueryEquals("((stop))", "");
-  }
-
-  // verify parsing of query using a stopping analyzer
-  private void assertStopQueryEquals(String qtxt, String expectedRes)
-      throws Exception {
-    String[] fields = { "b", "t" };
-    Occur occur[] = { Occur.SHOULD, Occur.SHOULD };
-    TestQPHelper.QPTestAnalyzer a = new TestQPHelper.QPTestAnalyzer();
-    StandardQueryParser mfqp = new StandardQueryParser();
-    mfqp.setMultiFields(fields);
-    mfqp.setAnalyzer(a);
-
-    Query q = mfqp.parse(qtxt, null);
-    assertEquals(expectedRes, q.toString());
-
-    q = QueryParserUtil.parse(qtxt, fields, occur, a);
-    assertEquals(expectedRes, q.toString());
-  }
-
-  public void testSimple() throws Exception {
-    String[] fields = { "b", "t" };
-    StandardQueryParser mfqp = new StandardQueryParser();
-    mfqp.setMultiFields(fields);
-    mfqp.setAnalyzer(new MockAnalyzer(random));
-
-    Query q = mfqp.parse("one", null);
-    assertEquals("b:one t:one", q.toString());
-
-    q = mfqp.parse("one two", null);
-    assertEquals("(b:one t:one) (b:two t:two)", q.toString());
-
-    q = mfqp.parse("+one +two", null);
-    assertEquals("+(b:one t:one) +(b:two t:two)", q.toString());
-
-    q = mfqp.parse("+one -two -three", null);
-    assertEquals("+(b:one t:one) -(b:two t:two) -(b:three t:three)", q
-        .toString());
-
-    q = mfqp.parse("one^2 two", null);
-    assertEquals("((b:one t:one)^2.0) (b:two t:two)", q.toString());
-
-    q = mfqp.parse("one~ two", null);
-    assertEquals("(b:one~2.0 t:one~2.0) (b:two t:two)", q.toString());
-
-    q = mfqp.parse("one~0.8 two^2", null);
-    assertEquals("(b:one~0.8 t:one~0.8) ((b:two t:two)^2.0)", q.toString());
-
-    q = mfqp.parse("one* two*", null);
-    assertEquals("(b:one* t:one*) (b:two* t:two*)", q.toString());
-
-    q = mfqp.parse("[a TO c] two", null);
-    assertEquals("(b:[a TO c] t:[a TO c]) (b:two t:two)", q.toString());
-
-    q = mfqp.parse("w?ldcard", null);
-    assertEquals("b:w?ldcard t:w?ldcard", q.toString());
-
-    q = mfqp.parse("\"foo bar\"", null);
-    assertEquals("b:\"foo bar\" t:\"foo bar\"", q.toString());
-
-    q = mfqp.parse("\"aa bb cc\" \"dd ee\"", null);
-    assertEquals("(b:\"aa bb cc\" t:\"aa bb cc\") (b:\"dd ee\" t:\"dd ee\")", q
-        .toString());
-
-    q = mfqp.parse("\"foo bar\"~4", null);
-    assertEquals("b:\"foo bar\"~4 t:\"foo bar\"~4", q.toString());
-
-    // LUCENE-1213: QueryParser was ignoring slop when phrase
-    // had a field.
-    q = mfqp.parse("b:\"foo bar\"~4", null);
-    assertEquals("b:\"foo bar\"~4", q.toString());
-
-    // make sure that terms which have a field are not touched:
-    q = mfqp.parse("one f:two", null);
-    assertEquals("(b:one t:one) f:two", q.toString());
-
-    // AND mode:
-    mfqp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
-    q = mfqp.parse("one two", null);
-    assertEquals("+(b:one t:one) +(b:two t:two)", q.toString());
-    q = mfqp.parse("\"aa bb cc\" \"dd ee\"", null);
-    assertEquals("+(b:\"aa bb cc\" t:\"aa bb cc\") +(b:\"dd ee\" t:\"dd ee\")",
-        q.toString());
-
-  }
-
-  public void testBoostsSimple() throws Exception {
-    Map<String,Float> boosts = new HashMap<String,Float>();
-    boosts.put("b", Float.valueOf(5));
-    boosts.put("t", Float.valueOf(10));
-    String[] fields = { "b", "t" };
-    StandardQueryParser mfqp = new StandardQueryParser();
-    mfqp.setMultiFields(fields);
-    mfqp.setFieldsBoost(boosts);
-    mfqp.setAnalyzer(new MockAnalyzer(random));
-
-    // Check for simple
-    Query q = mfqp.parse("one", null);
-    assertEquals("b:one^5.0 t:one^10.0", q.toString());
-
-    // Check for AND
-    q = mfqp.parse("one AND two", null);
-    assertEquals("+(b:one^5.0 t:one^10.0) +(b:two^5.0 t:two^10.0)", q
-        .toString());
-
-    // Check for OR
-    q = mfqp.parse("one OR two", null);
-    assertEquals("(b:one^5.0 t:one^10.0) (b:two^5.0 t:two^10.0)", q.toString());
-
-    // Check for AND and a field
-    q = mfqp.parse("one AND two AND foo:test", null);
-    assertEquals("+(b:one^5.0 t:one^10.0) +(b:two^5.0 t:two^10.0) +foo:test", q
-        .toString());
-
-    q = mfqp.parse("one^3 AND two^4", null);
-    assertEquals("+((b:one^5.0 t:one^10.0)^3.0) +((b:two^5.0 t:two^10.0)^4.0)",
-        q.toString());
-  }
-
-  public void testStaticMethod1() throws QueryNodeException {
-    String[] fields = { "b", "t" };
-    String[] queries = { "one", "two" };
-    Query q = QueryParserUtil.parse(queries, fields, new MockAnalyzer(random));
-    assertEquals("b:one t:two", q.toString());
-
-    String[] queries2 = { "+one", "+two" };
-    q = QueryParserUtil.parse(queries2, fields, new MockAnalyzer(random));
-    assertEquals("(+b:one) (+t:two)", q.toString());
-
-    String[] queries3 = { "one", "+two" };
-    q = QueryParserUtil.parse(queries3, fields, new MockAnalyzer(random));
-    assertEquals("b:one (+t:two)", q.toString());
-
-    String[] queries4 = { "one +more", "+two" };
-    q = QueryParserUtil.parse(queries4, fields, new MockAnalyzer(random));
-    assertEquals("(b:one +b:more) (+t:two)", q.toString());
-
-    String[] queries5 = { "blah" };
-    try {
-      q = QueryParserUtil.parse(queries5, fields, new MockAnalyzer(random));
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected exception, array length differs
-    }
-
-    // check also with stop words for this static form (qtxts[], fields[]).
-    TestQPHelper.QPTestAnalyzer stopA = new TestQPHelper.QPTestAnalyzer();
-
-    String[] queries6 = { "((+stop))", "+((stop))" };
-    q = QueryParserUtil.parse(queries6, fields, stopA);
-    assertEquals("", q.toString());
-
-    String[] queries7 = { "one ((+stop)) +more", "+((stop)) +two" };
-    q = QueryParserUtil.parse(queries7, fields, stopA);
-    assertEquals("(b:one +b:more) (+t:two)", q.toString());
-
-  }
-
-  public void testStaticMethod2() throws QueryNodeException {
-    String[] fields = { "b", "t" };
-    BooleanClause.Occur[] flags = { BooleanClause.Occur.MUST,
-        BooleanClause.Occur.MUST_NOT };
-    Query q = QueryParserUtil.parse("one", fields, flags,
-        new MockAnalyzer(random));
-    assertEquals("+b:one -t:one", q.toString());
-
-    q = QueryParserUtil.parse("one two", fields, flags, new MockAnalyzer(random));
-    assertEquals("+(b:one b:two) -(t:one t:two)", q.toString());
-
-    try {
-      BooleanClause.Occur[] flags2 = { BooleanClause.Occur.MUST };
-      q = QueryParserUtil.parse("blah", fields, flags2, new MockAnalyzer(random));
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected exception, array length differs
-    }
-  }
-
-  public void testStaticMethod2Old() throws QueryNodeException {
-    String[] fields = { "b", "t" };
-    BooleanClause.Occur[] flags = { BooleanClause.Occur.MUST,
-        BooleanClause.Occur.MUST_NOT };
-    StandardQueryParser parser = new StandardQueryParser();
-    parser.setMultiFields(fields);
-    parser.setAnalyzer(new MockAnalyzer(random));
-
-    Query q = QueryParserUtil.parse("one", fields, flags,
-        new MockAnalyzer(random));// , fields, flags, new
-    // MockAnalyzer());
-    assertEquals("+b:one -t:one", q.toString());
-
-    q = QueryParserUtil.parse("one two", fields, flags, new MockAnalyzer(random));
-    assertEquals("+(b:one b:two) -(t:one t:two)", q.toString());
-
-    try {
-      BooleanClause.Occur[] flags2 = { BooleanClause.Occur.MUST };
-      q = QueryParserUtil.parse("blah", fields, flags2, new MockAnalyzer(random));
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected exception, array length differs
-    }
-  }
-
-  public void testStaticMethod3() throws QueryNodeException {
-    String[] queries = { "one", "two", "three" };
-    String[] fields = { "f1", "f2", "f3" };
-    BooleanClause.Occur[] flags = { BooleanClause.Occur.MUST,
-        BooleanClause.Occur.MUST_NOT, BooleanClause.Occur.SHOULD };
-    Query q = QueryParserUtil.parse(queries, fields, flags,
-        new MockAnalyzer(random));
-    assertEquals("+f1:one -f2:two f3:three", q.toString());
-
-    try {
-      BooleanClause.Occur[] flags2 = { BooleanClause.Occur.MUST };
-      q = QueryParserUtil
-          .parse(queries, fields, flags2, new MockAnalyzer(random));
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected exception, array length differs
-    }
-  }
-
-  public void testStaticMethod3Old() throws QueryNodeException {
-    String[] queries = { "one", "two" };
-    String[] fields = { "b", "t" };
-    BooleanClause.Occur[] flags = { BooleanClause.Occur.MUST,
-        BooleanClause.Occur.MUST_NOT };
-    Query q = QueryParserUtil.parse(queries, fields, flags,
-        new MockAnalyzer(random));
-    assertEquals("+b:one -t:two", q.toString());
-
-    try {
-      BooleanClause.Occur[] flags2 = { BooleanClause.Occur.MUST };
-      q = QueryParserUtil
-          .parse(queries, fields, flags2, new MockAnalyzer(random));
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected exception, array length differs
-    }
-  }
-
-  public void testAnalyzerReturningNull() throws QueryNodeException {
-    String[] fields = new String[] { "f1", "f2", "f3" };
-    StandardQueryParser parser = new StandardQueryParser();
-    parser.setMultiFields(fields);
-    parser.setAnalyzer(new AnalyzerReturningNull());
-
-    Query q = parser.parse("bla AND blo", null);
-    assertEquals("+(f2:bla f3:bla) +(f2:blo f3:blo)", q.toString());
-    // the following queries are not affected as their terms are not
-    // analyzed anyway:
-    q = parser.parse("bla*", null);
-    assertEquals("f1:bla* f2:bla* f3:bla*", q.toString());
-    q = parser.parse("bla~", null);
-    assertEquals("f1:bla~2.0 f2:bla~2.0 f3:bla~2.0", q.toString());
-    q = parser.parse("[a TO c]", null);
-    assertEquals("f1:[a TO c] f2:[a TO c] f3:[a TO c]", q.toString());
-  }
-
-  public void testStopWordSearching() throws Exception {
-    Analyzer analyzer = new MockAnalyzer(random);
-    Directory ramDir = newDirectory();
-    IndexWriter iw = new IndexWriter(ramDir, newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer));
-    Document doc = new Document();
-    doc.add(newField("body", "blah the footest blah", Field.Store.NO,
-        Field.Index.ANALYZED));
-    iw.addDocument(doc);
-    iw.close();
-
-    StandardQueryParser mfqp = new StandardQueryParser();
-
-    mfqp.setMultiFields(new String[] { "body" });
-    mfqp.setAnalyzer(analyzer);
-    mfqp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
-    Query q = mfqp.parse("the footest", null);
-    IndexSearcher is = new IndexSearcher(ramDir, true);
-    ScoreDoc[] hits = is.search(q, null, 1000).scoreDocs;
-    assertEquals(1, hits.length);
-    is.close();
-    ramDir.close();
-  }
-
-  /**
-   * Return empty tokens for field "f1".
-   */
-  private static final class AnalyzerReturningNull extends Analyzer {
-    MockAnalyzer stdAnalyzer = new MockAnalyzer(random);
-
-    public AnalyzerReturningNull() {
-    }
-
-    @Override
-    public TokenStream tokenStream(String fieldName, Reader reader) {
-      if ("f1".equals(fieldName)) {
-        return new EmptyTokenStream();
-      } else {
-        return stdAnalyzer.tokenStream(fieldName, reader);
-      }
-    }
-
-    private static class EmptyTokenStream extends TokenStream {
-      @Override
-      public boolean incrementToken() {
-        return false;
-      }
-    }
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser.java
deleted file mode 100644
index 2b03eaa..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser.java
+++ /dev/null
@@ -1,428 +0,0 @@
-package org.apache.lucene.queryParser.standard;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.text.DateFormat;
-import java.text.NumberFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Random;
-import java.util.TimeZone;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.NumericField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.queryParser.standard.config.NumberDateFormat;
-import org.apache.lucene.queryParser.standard.config.NumericConfig;
-import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util._TestUtil;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.Ignore;
-import org.junit.Test;
-
-@Ignore("Class has problems with DateFormat")
-public class TestNumericQueryParser extends LuceneTestCase {
-  
-  private static enum NumberType {
-    NEGATIVE, ZERO, POSITIVE;
-  }
-  
-  final private static int[] DATE_STYLES = {DateFormat.FULL, DateFormat.LONG,
-      DateFormat.MEDIUM, DateFormat.SHORT};
-  
-  final private static int PRECISION_STEP = 8;
-  final private static String FIELD_NAME = "field";
-  private static Locale LOCALE;
-  private static TimeZone TIMEZONE;
-  private static Map<String,Number> RANDOM_NUMBER_MAP;
-  final private static EscapeQuerySyntax ESCAPER = new EscapeQuerySyntaxImpl();
-  final private static String DATE_FIELD_NAME = "date";
-  private static int DATE_STYLE;
-  private static int TIME_STYLE;
-  
-  private static Analyzer ANALYZER;
-  
-  private static NumberFormat NUMBER_FORMAT;
-  
-  private static StandardQueryParser qp;
-  
-  private static NumberDateFormat DATE_FORMAT;
-  
-  static void init() {
-    try {
-      LOCALE = randomLocale(random);
-      TIMEZONE = randomTimeZone(random);
-      DATE_STYLE = randomDateStyle(random);
-      TIME_STYLE = randomDateStyle(random);
-      ANALYZER = new MockAnalyzer(random);
-      qp = new StandardQueryParser(ANALYZER);
-      NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);
-      NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);
-      NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);
-      NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);
-      NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 4); // the loop checks for < 1000, this is a must!
-      
-      // assumes localized date pattern will have at least year, month, day, hour, minute
-      SimpleDateFormat dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(
-          DATE_STYLE, TIME_STYLE, LOCALE);
-      
-      // not all date patterns includes era, full year, timezone and second, so we add them here
-      dateFormat.applyPattern(dateFormat.toPattern() + " G s Z yyyy");
-      dateFormat.setTimeZone(TIMEZONE);
-      DATE_FORMAT  = new NumberDateFormat(dateFormat);
-      
-      HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();
-      
-      double randomDouble;
-      long randomLong;
-      int randomInt;
-      float randomFloat;
-      long randomDate;
-      
-      while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))
-          .longValue()) == 0)
-        ;
-      while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))
-          .doubleValue()) == 0)
-        ;
-      while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))
-          .floatValue()) == 0)
-        ;
-      while ((randomInt = normalizeNumber(Math.abs(random.nextInt()))
-          .intValue()) == 0)
-        ;
-      
-      // make sure random date is at least one second from 0
-      while ((randomDate = normalizeNumber(Math.abs(random.nextLong()))
-          .longValue()) < 1000)
-        ;
-
-      // prune date value so it doesn't pass in insane values to some calendars.
-      randomDate = randomDate % 3400000000000l;
-
-      // truncate to second
-      randomDate = (randomDate / 1000) * 1000;
-      
-      randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);
-      randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);
-      randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);
-      randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);
-      randomNumberMap.put(DATE_FIELD_NAME, randomDate);
-      
-      RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);
-      
-    } catch (ParseException e) {
-      throw new RuntimeException(e);
-    }
-  }
-  
-  private static Directory directory = null;
-  private static IndexReader reader = null;
-  private static IndexSearcher searcher = null;
-  
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    init();
-    directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random, directory,
-        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))
-            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))
-            .setMergePolicy(newLogMergePolicy()));
-    
-    Document doc = new Document();
-    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();
-    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();
-    qp.setNumericConfigMap(numericConfigMap);
-    
-    for (NumericField.DataType type : NumericField.DataType.values()) {
-      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,
-          NUMBER_FORMAT, type));
-      
-      NumericField field = new NumericField(type.name(), PRECISION_STEP,
-          Field.Store.YES, true);
-      
-      numericFieldMap.put(type.name(), field);
-      doc.add(field);
-      
-    }
-    
-    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,
-        DATE_FORMAT, NumericField.DataType.LONG));
-    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,
-        Field.Store.YES, true);
-    numericFieldMap.put(DATE_FIELD_NAME, dateField);
-    doc.add(dateField);
-    
-    for (NumberType numberType : NumberType.values()) {
-      setFieldValues(numberType, numericFieldMap);
-      if (VERBOSE) System.out.println("Indexing document: " + doc);
-      writer.addDocument(doc);
-    }
-    
-    reader = writer.getReader();
-    searcher = newSearcher(reader);
-    writer.close();
-    
-
-//  SimpleDateFormat df = new SimpleDateFormat( 
-//      "yyyy.MM.dd G 'at' HH:mm:ss z", LOCALE.ENGLISH);
-// assumes localized date pattern will have at least year, month, day, hour, minute
-  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(
-      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);
-  System.out.println(df.toPattern());
-  // most of date pattern do not include era, so we add it here. Also,
-  // sometimes second is not available, we make sure it's present too
-  df.applyPattern(df.toPattern() + " G s Z yyyy");
-  df.setTimeZone(TIMEZONE);
-  System.out.println(TIMEZONE);
-  System.out.println(TIMEZONE);
-  System.out.println(TIMEZONE);
-  long l1 = 0;
-  long l2 = -30000;
-  String d1 = df.format(new Date(l1));
-  String d2 = df.format(new Date(l2));
-  long newL1 = df.parse(d1).getTime();
-  long newL2 = df.parse(d2).getTime();
-  
-  System.out.println(l1 + " => " + d1 + " => " + newL1);
-  System.out.println(l2 + " => " + d2 + " => " + newL2);
-  
-   
-  }
-  
-  private static Number getNumberType(NumberType numberType, String fieldName) {
-    
-    switch (numberType) {
-      
-      case POSITIVE:
-        return RANDOM_NUMBER_MAP.get(fieldName);
-        
-      case NEGATIVE:
-        Number number = RANDOM_NUMBER_MAP.get(fieldName);
-        
-        if (NumericField.DataType.LONG.name().equals(fieldName)
-            || DATE_FIELD_NAME.equals(fieldName)) {
-          number = -number.longValue();
-          
-        } else if (NumericField.DataType.DOUBLE.name().equals(fieldName)) {
-          number = -number.doubleValue();
-          
-        } else if (NumericField.DataType.FLOAT.name().equals(fieldName)) {
-          number = -number.floatValue();
-          
-        } else if (NumericField.DataType.INT.name().equals(fieldName)) {
-          number = -number.intValue();
-          
-        } else {
-          throw new IllegalArgumentException("field name not found: "
-              + fieldName);
-        }
-        
-        return number;
-        
-      default:
-        return 0;
-    }
-    
-  }
-  
-  private static void setFieldValues(NumberType numberType,
-      HashMap<String,NumericField> numericFieldMap) {
-    
-    Number number = getNumberType(numberType, NumericField.DataType.DOUBLE
-        .name());
-    numericFieldMap.get(NumericField.DataType.DOUBLE.name()).setDoubleValue(
-        number.doubleValue());
-    
-    number = getNumberType(numberType, NumericField.DataType.INT.name());
-    numericFieldMap.get(NumericField.DataType.INT.name()).setIntValue(
-        number.intValue());
-    
-    number = getNumberType(numberType, NumericField.DataType.LONG.name());
-    numericFieldMap.get(NumericField.DataType.LONG.name()).setLongValue(
-        number.longValue());
-    
-    number = getNumberType(numberType, NumericField.DataType.FLOAT.name());
-    numericFieldMap.get(NumericField.DataType.FLOAT.name()).setFloatValue(
-        number.floatValue());
-    
-    number = getNumberType(numberType, DATE_FIELD_NAME);
-    numericFieldMap.get(DATE_FIELD_NAME).setLongValue(number.longValue());
-    
-  }
-  
-  private static int randomDateStyle(Random random) {
-    return DATE_STYLES[random.nextInt(DATE_STYLES.length)];
-  }
-  
-  @Test
-  public void testInclusiveNumericRange() throws Exception {
-    assertRangeQuery(NumberType.ZERO, NumberType.ZERO, true, true, 1);
-    assertRangeQuery(NumberType.ZERO, NumberType.POSITIVE, true, true, 2);
-    assertRangeQuery(NumberType.NEGATIVE, NumberType.ZERO, true, true, 2);
-    assertRangeQuery(NumberType.NEGATIVE, NumberType.POSITIVE, true, true, 3);
-    assertRangeQuery(NumberType.NEGATIVE, NumberType.NEGATIVE, true, true, 1);
-  }
-  
-  // @Test
-  // test disabled since standard syntax parser does not work with inclusive and
-  // exclusive at the same time
-//   public void testInclusiveLowerNumericRange() throws Exception {
-//   assertRangeQuery(NumberType.NEGATIVE, NumberType.ZERO, true, false, 1);
-//   assertRangeQuery(NumberType.ZERO, NumberType.POSITIVE, true, false, 1);
-//   assertRangeQuery(NumberType.NEGATIVE, NumberType.POSITIVE, true, false, 2);
-//   assertRangeQuery(NumberType.NEGATIVE, NumberType.NEGATIVE, true, false, 1);
-//   }
-  
-  // @Test
-  // test disabled since standard syntax parser does not work with inclusive and
-  // exclusive at the same time
-//   public void testInclusiveUpperNumericRange() throws Exception {
-//     assertRangeQuery(NumberType.NEGATIVE, NumberType.ZERO, false, true, 1);
-//     assertRangeQuery(NumberType.ZERO, NumberType.POSITIVE, false, true, 1);
-//     assertRangeQuery(NumberType.NEGATIVE, NumberType.POSITIVE, false, true, 2);
-//     assertRangeQuery(NumberType.NEGATIVE, NumberType.NEGATIVE, false, true, 1);
-//   }
-  
-  @Test
-  public void testExclusiveNumericRange() throws Exception {
-    assertRangeQuery(NumberType.ZERO, NumberType.ZERO, false, false, 0);
-    assertRangeQuery(NumberType.ZERO, NumberType.POSITIVE, false, false, 0);
-    assertRangeQuery(NumberType.NEGATIVE, NumberType.ZERO, false, false, 0);
-    assertRangeQuery(NumberType.NEGATIVE, NumberType.POSITIVE, false, false, 1);
-    assertRangeQuery(NumberType.NEGATIVE, NumberType.NEGATIVE, false, false, 0);
-  }
-  
-  @Test
-  public void testSimpleNumericQuery() throws Exception {
-    assertSimpleQuery(NumberType.ZERO, 1);
-    assertSimpleQuery(NumberType.POSITIVE, 1);
-    assertSimpleQuery(NumberType.NEGATIVE, 1);
-  }
-  
-  public void assertRangeQuery(NumberType lowerType, NumberType upperType,
-      boolean upperInclusive, boolean lowerInclusive, int expectedDocCount)
-      throws QueryNodeException, IOException {
-    
-    StringBuilder sb = new StringBuilder();
-    
-    String lowerInclusiveStr = (lowerInclusive ? "[" : "{");
-    String upperInclusiveStr = (upperInclusive ? "]" : "}");
-    
-    for (NumericField.DataType type : NumericField.DataType.values()) {
-      String lowerStr = numberToString(getNumberType(lowerType, type.name()));
-      String upperStr = numberToString(getNumberType(upperType, type.name()));
-      
-      sb.append("+").append(type.name()).append(':').append(lowerInclusiveStr)
-          .append('"').append(lowerStr).append("\" TO \"").append(upperStr)
-          .append('"').append(upperInclusiveStr).append(' ');
-    }
-    
-    String lowerDateStr = ESCAPER.escape(
-        DATE_FORMAT.format(new Date(getNumberType(lowerType, DATE_FIELD_NAME)
-            .longValue())), LOCALE, EscapeQuerySyntax.Type.STRING).toString();
-    
-    String upperDateStr = ESCAPER.escape(
-        DATE_FORMAT.format(new Date(getNumberType(upperType, DATE_FIELD_NAME)
-            .longValue())), LOCALE, EscapeQuerySyntax.Type.STRING).toString();
-    
-    sb.append("+").append(DATE_FIELD_NAME).append(':')
-        .append(lowerInclusiveStr).append('"').append(lowerDateStr).append(
-            "\" TO \"").append(upperDateStr).append('"').append(
-            upperInclusiveStr);
-    
-    testQuery(sb.toString(), expectedDocCount);
-    
-  }
-  
-  public void assertSimpleQuery(NumberType numberType, int expectedDocCount)
-      throws QueryNodeException, IOException {
-    StringBuilder sb = new StringBuilder();
-    
-    for (NumericField.DataType type : NumericField.DataType.values()) {
-      String numberStr = numberToString(getNumberType(numberType, type.name()));
-      sb.append('+').append(type.name()).append(":\"").append(numberStr)
-          .append("\" ");
-    }
-    
-    String dateStr = ESCAPER.escape(
-        DATE_FORMAT.format(new Date(getNumberType(numberType, DATE_FIELD_NAME)
-            .longValue())), LOCALE, EscapeQuerySyntax.Type.STRING).toString();
-    
-    sb.append('+').append(DATE_FIELD_NAME).append(":\"").append(dateStr)
-        .append('"');
-    
-    testQuery(sb.toString(), expectedDocCount);
-    
-  }
-  
-  private void testQuery(String queryStr, int expectedDocCount)
-      throws QueryNodeException, IOException {
-    if (VERBOSE) System.out.println("Parsing: " + queryStr);
-    
-    Query query = qp.parse(queryStr, FIELD_NAME);
-    if (VERBOSE) System.out.println("Querying: " + query);
-    TopDocs topDocs = searcher.search(query, 1000);
-    
-    String msg = "Query <" + queryStr + "> retrieved " + topDocs.totalHits
-        + " document(s), " + expectedDocCount + " document(s) expected.";
-    
-    if (VERBOSE) System.out.println(msg);
-    
-    assertEquals(msg, expectedDocCount, topDocs.totalHits);
-    
-  }
-  
-  private static String numberToString(Number number) {
-    return ESCAPER.escape(NUMBER_FORMAT.format(number), LOCALE,
-        EscapeQuerySyntax.Type.STRING).toString();
-  }
-  
-  private static Number normalizeNumber(Number number) throws ParseException {
-    return NUMBER_FORMAT.parse(NUMBER_FORMAT.format(number));
-  }
-  
-  @AfterClass
-  public static void afterClass() throws Exception {
-    searcher.close();
-    searcher = null;
-    reader.close();
-    reader = null;
-    directory.close();
-    directory = null;
-  }
-  
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
deleted file mode 100644
index d191145..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
+++ /dev/null
@@ -1,1242 +0,0 @@
-package org.apache.lucene.queryParser.standard;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.io.Reader;
-import java.text.DateFormat;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.analysis.MockTokenFilter;
-import org.apache.lucene.analysis.MockTokenizer;
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Tokenizer;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
-import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.MultiPhraseQuery;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RegexpQuery;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.CharacterRunAutomaton;
-import org.apache.lucene.util.automaton.RegExp;
-import org.junit.Ignore;
-
-/**
- * This test case is a copy of the core Lucene query parser test, it was adapted
- * to use new QueryParserHelper instead of the old query parser.
- * 
- * Tests QueryParser.
- */
-public class TestQPHelper extends LuceneTestCase {
-
-  public static Analyzer qpAnalyzer = new QPTestAnalyzer();
-
-  public static final class QPTestFilter extends TokenFilter {
-    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-    private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
-
-    /**
-     * Filter which discards the token 'stop' and which expands the token
-     * 'phrase' into 'phrase1 phrase2'
-     */
-    public QPTestFilter(TokenStream in) {
-      super(in);
-    }
-
-    boolean inPhrase = false;
-    int savedStart = 0, savedEnd = 0;
-
-    @Override
-    public boolean incrementToken() throws IOException {
-      if (inPhrase) {
-        inPhrase = false;
-        clearAttributes();
-        termAtt.setEmpty().append("phrase2");
-        offsetAtt.setOffset(savedStart, savedEnd);
-        return true;
-      } else
-        while (input.incrementToken()) {
-          if (termAtt.toString().equals("phrase")) {
-            inPhrase = true;
-            savedStart = offsetAtt.startOffset();
-            savedEnd = offsetAtt.endOffset();
-            termAtt.setEmpty().append("phrase1");
-            offsetAtt.setOffset(savedStart, savedEnd);
-            return true;
-          } else if (!termAtt.toString().equals("stop"))
-            return true;
-        }
-      return false;
-    }
-  }
-
-  public static final class QPTestAnalyzer extends Analyzer {
-
-    /** Filters MockTokenizer with StopFilter. */
-    @Override
-    public final TokenStream tokenStream(String fieldName, Reader reader) {
-      return new QPTestFilter(new MockTokenizer(reader, MockTokenizer.SIMPLE, true));
-    }
-  }
-
-  public static class QPTestParser extends StandardQueryParser {
-    public QPTestParser(Analyzer a) {
-      ((QueryNodeProcessorPipeline)getQueryNodeProcessor())
-          .add(new QPTestParserQueryNodeProcessor());
-      this.setAnalyzer(a);
-
-    }
-
-    private static class QPTestParserQueryNodeProcessor extends
-        QueryNodeProcessorImpl {
-
-      @Override
-      protected QueryNode postProcessNode(QueryNode node)
-          throws QueryNodeException {
-
-        return node;
-
-      }
-
-      @Override
-      protected QueryNode preProcessNode(QueryNode node)
-          throws QueryNodeException {
-
-        if (node instanceof WildcardQueryNode || node instanceof FuzzyQueryNode) {
-
-          throw new QueryNodeException(new MessageImpl(
-              QueryParserMessages.EMPTY_MESSAGE));
-
-        }
-
-        return node;
-
-      }
-
-      @Override
-      protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-          throws QueryNodeException {
-
-        return children;
-
-      }
-
-    }
-
-  }
-
-  private int originalMaxClauses;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    originalMaxClauses = BooleanQuery.getMaxClauseCount();
-  }
-
-  public StandardQueryParser getParser(Analyzer a) throws Exception {
-    if (a == null)
-      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(a);
-
-    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
-
-    return qp;
-
-  }
-
-  public Query getQuery(String query, Analyzer a) throws Exception {
-    return getParser(a).parse(query, "field");
-  }
-
-  public Query getQueryAllowLeadingWildcard(String query, Analyzer a) throws Exception {
-    StandardQueryParser parser = getParser(a);
-    parser.setAllowLeadingWildcard(true);
-    return parser.parse(query, "field");
-  }
-
-  public void assertQueryEquals(String query, Analyzer a, String result)
-      throws Exception {
-    Query q = getQuery(query, a);
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
-    }
-  }
-
-  public void assertQueryEqualsAllowLeadingWildcard(String query, Analyzer a, String result)
-      throws Exception {
-    Query q = getQueryAllowLeadingWildcard(query, a);
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
-    }
-  }
-
-  public void assertQueryEquals(StandardQueryParser qp, String field,
-      String query, String result) throws Exception {
-    Query q = qp.parse(query, field);
-    String s = q.toString(field);
-    if (!s.equals(result)) {
-      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
-    }
-  }
-
-  public void assertEscapedQueryEquals(String query, Analyzer a, String result)
-      throws Exception {
-    String escapedQuery = QueryParserUtil.escape(query);
-    if (!escapedQuery.equals(result)) {
-      fail("Query /" + query + "/ yielded /" + escapedQuery + "/, expecting /"
-          + result + "/");
-    }
-  }
-
-  public void assertWildcardQueryEquals(String query, boolean lowercase,
-      String result, boolean allowLeadingWildcard) throws Exception {
-    StandardQueryParser qp = getParser(null);
-    qp.setLowercaseExpandedTerms(lowercase);
-    qp.setAllowLeadingWildcard(allowLeadingWildcard);
-    Query q = qp.parse(query, "field");
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
-          + result + "/");
-    }
-  }
-
-  public void assertWildcardQueryEquals(String query, boolean lowercase,
-      String result) throws Exception {
-    assertWildcardQueryEquals(query, lowercase, result, false);
-  }
-
-  public void assertWildcardQueryEquals(String query, String result)
-      throws Exception {
-    StandardQueryParser qp = getParser(null);
-    Query q = qp.parse(query, "field");
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
-          + result + "/");
-    }
-  }
-
-  public Query getQueryDOA(String query, Analyzer a) throws Exception {
-    if (a == null)
-      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(a);
-    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
-
-    return qp.parse(query, "field");
-
-  }
-
-  public void assertQueryEqualsDOA(String query, Analyzer a, String result)
-      throws Exception {
-    Query q = getQueryDOA(query, a);
-    String s = q.toString("field");
-    if (!s.equals(result)) {
-      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
-    }
-  }
-
-  public void testConstantScoreAutoRewrite() throws Exception {
-    StandardQueryParser qp = new StandardQueryParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
-    Query q = qp.parse("foo*bar", "field");
-    assertTrue(q instanceof WildcardQuery);
-    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((MultiTermQuery) q).getRewriteMethod());
-
-    q = qp.parse("foo*", "field");
-    assertTrue(q instanceof PrefixQuery);
-    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((MultiTermQuery) q).getRewriteMethod());
-
-    q = qp.parse("[a TO z]", "field");
-    assertTrue(q instanceof TermRangeQuery);
-    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((MultiTermQuery) q).getRewriteMethod());
-  }
-
-  public void testCJK() throws Exception {
-    // Test Ideographic Space - As wide as a CJK character cell (fullwidth)
-    // used google to translate the word "term" to japanese -> ??
-    assertQueryEquals("term\u3000term\u3000term", null,
-        "term\u0020term\u0020term");
-    assertQueryEqualsAllowLeadingWildcard("??\u3000??\u3000??", null, "??\u0020??\u0020??");
-  }
-
-  //individual CJK chars as terms, like StandardAnalyzer
-  private class SimpleCJKTokenizer extends Tokenizer {
-    private CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-
-    public SimpleCJKTokenizer(Reader input) {
-      super(input);
-    }
-
-    @Override
-    public boolean incrementToken() throws IOException {
-      int ch = input.read();
-      if (ch < 0)
-        return false;
-      clearAttributes();
-      termAtt.setEmpty().append((char) ch);
-      return true;
-    }
-  }
-
-  private class SimpleCJKAnalyzer extends Analyzer {
-    @Override
-    public TokenStream tokenStream(String fieldName, Reader reader) {
-      return new SimpleCJKTokenizer(reader);
-    }
-  }
-  
-  public void testCJKTerm() throws Exception {
-    // individual CJK chars as terms
-    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
-    
-    BooleanQuery expected = new BooleanQuery();
-    expected.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.SHOULD);
-    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    
-    assertEquals(expected, getQuery("??", analyzer));
-  }
-  
-  public void testCJKBoostedTerm() throws Exception {
-    // individual CJK chars as terms
-    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
-    
-    BooleanQuery expected = new BooleanQuery();
-    expected.setBoost(0.5f);
-    expected.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.SHOULD);
-    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    
-    assertEquals(expected, getQuery("??^0.5", analyzer));
-  }
-  
-  public void testCJKPhrase() throws Exception {
-    // individual CJK chars as terms
-    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
-    
-    PhraseQuery expected = new PhraseQuery();
-    expected.add(new Term("field", "?"));
-    expected.add(new Term("field", "??"));
-    
-    assertEquals(expected, getQuery("\"??\"", analyzer));
-  }
-  
-  public void testCJKBoostedPhrase() throws Exception {
-    // individual CJK chars as terms
-    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
-    
-    PhraseQuery expected = new PhraseQuery();
-    expected.setBoost(0.5f);
-    expected.add(new Term("field", "?"));
-    expected.add(new Term("field", "??"));
-    
-    assertEquals(expected, getQuery("\"??\"^0.5", analyzer));
-  }
-  
-  public void testCJKSloppyPhrase() throws Exception {
-    // individual CJK chars as terms
-    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer(); 
-    
-    PhraseQuery expected = new PhraseQuery();
-    expected.setSlop(3);
-    expected.add(new Term("field", "?"));
-    expected.add(new Term("field", "??"));
-    
-    assertEquals(expected, getQuery("\"??\"~3", analyzer));
-  }
-
-  public void testSimple() throws Exception {
-    assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
-    assertQueryEquals("term term term", null, "term term term");
-    assertQueryEquals("t?m term term", new MockAnalyzer(random, MockTokenizer.WHITESPACE, false),
-        "t?m term term");
-    assertQueryEquals("?laut", new MockAnalyzer(random, MockTokenizer.WHITESPACE, false), "?laut");
-
-    // FIXME: change MockAnalyzer to not extend CharTokenizer for this test
-    //assertQueryEquals("\"\"", new KeywordAnalyzer(), "");
-    //assertQueryEquals("foo:\"\"", new KeywordAnalyzer(), "foo:");
-
-    assertQueryEquals("a AND b", null, "+a +b");
-    assertQueryEquals("(a AND b)", null, "+a +b");
-    assertQueryEquals("c OR (a AND b)", null, "c (+a +b)");
-
-    assertQueryEquals("a AND NOT b", null, "+a -b");
-
-    assertQueryEquals("a AND -b", null, "+a -b");
-
-    assertQueryEquals("a AND !b", null, "+a -b");
-
-    assertQueryEquals("a && b", null, "+a +b");
-
-    assertQueryEquals("a && ! b", null, "+a -b");
-
-    assertQueryEquals("a OR b", null, "a b");
-    assertQueryEquals("a || b", null, "a b");
-
-    assertQueryEquals("a OR !b", null, "a -b");
-
-    assertQueryEquals("a OR ! b", null, "a -b");
-
-    assertQueryEquals("a OR -b", null, "a -b");
-
-    assertQueryEquals("+term -term term", null, "+term -term term");
-    assertQueryEquals("foo:term AND field:anotherTerm", null,
-        "+foo:term +anotherterm");
-    assertQueryEquals("term AND \"phrase phrase\"", null,
-        "+term +\"phrase phrase\"");
-    assertQueryEquals("\"hello there\"", null, "\"hello there\"");
-    assertTrue(getQuery("a AND b", null) instanceof BooleanQuery);
-    assertTrue(getQuery("hello", null) instanceof TermQuery);
-    assertTrue(getQuery("\"hello there\"", null) instanceof PhraseQuery);
-
-    assertQueryEquals("germ term^2.0", null, "germ term^2.0");
-    assertQueryEquals("(term)^2.0", null, "term^2.0");
-    assertQueryEquals("(germ term)^2.0", null, "(germ term)^2.0");
-    assertQueryEquals("term^2.0", null, "term^2.0");
-    assertQueryEquals("term^2", null, "term^2.0");
-    assertQueryEquals("\"germ term\"^2.0", null, "\"germ term\"^2.0");
-    assertQueryEquals("\"term germ\"^2", null, "\"term germ\"^2.0");
-
-    assertQueryEquals("(foo OR bar) AND (baz OR boo)", null,
-        "+(foo bar) +(baz boo)");
-    assertQueryEquals("((a OR b) AND NOT c) OR d", null, "(+(a b) -c) d");
-    assertQueryEquals("+(apple \"steve jobs\") -(foo bar baz)", null,
-        "+(apple \"steve jobs\") -(foo bar baz)");
-    assertQueryEquals("+title:(dog OR cat) -author:\"bob dole\"", null,
-        "+(title:dog title:cat) -author:\"bob dole\"");
-
-  }
-
-  public void testPunct() throws Exception {
-    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
-    assertQueryEquals("a&b", a, "a&b");
-    assertQueryEquals("a&&b", a, "a&&b");
-    assertQueryEquals(".NET", a, ".NET");
-  }
-
-  public void testSlop() throws Exception {
-
-    assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
-    assertQueryEquals("\"term germ\"~2 flork", null, "\"term germ\"~2 flork");
-    assertQueryEquals("\"term\"~2", null, "term");
-    assertQueryEquals("\" \"~2 germ", null, "germ");
-    assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
-  }
-
-  public void testNumber() throws Exception {
-    // The numbers go away because SimpleAnalzyer ignores them
-    assertQueryEquals("3", null, "");
-    assertQueryEquals("term 1.0 1 2", null, "term");
-    assertQueryEquals("term term1 term2", null, "term term term");
-
-    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
-    assertQueryEquals("3", a, "3");
-    assertQueryEquals("term 1.0 1 2", a, "term 1.0 1 2");
-    assertQueryEquals("term term1 term2", a, "term term1 term2");
-  }
-
-  public void testWildcard() throws Exception {
-    assertQueryEquals("term*", null, "term*");
-    assertQueryEquals("term*^2", null, "term*^2.0");
-    assertQueryEquals("term~", null, "term~2.0");
-    assertQueryEquals("term~0.7", null, "term~0.7");
-
-    assertQueryEquals("term~^3", null, "term~2.0^3.0");
-
-    assertQueryEquals("term^3~", null, "term~2.0^3.0");
-    assertQueryEquals("term*germ", null, "term*germ");
-    assertQueryEquals("term*germ^3", null, "term*germ^3.0");
-
-    assertTrue(getQuery("term*", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
-    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
-    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery) getQuery("term~", null);
-    assertEquals(2.0f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-
-    assertQueryNodeException("term~1.1"); // value > 1, throws exception
-
-    assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
-
-    /*
-     * Tests to see that wild card terms are (or are not) properly lower-cased
-     * with propery parser configuration
-     */
-    // First prefix queries:
-    // by default, convert to lowercase:
-    assertWildcardQueryEquals("Term*", true, "term*");
-    // explicitly set lowercase:
-    assertWildcardQueryEquals("term*", true, "term*");
-    assertWildcardQueryEquals("Term*", true, "term*");
-    assertWildcardQueryEquals("TERM*", true, "term*");
-    // explicitly disable lowercase conversion:
-    assertWildcardQueryEquals("term*", false, "term*");
-    assertWildcardQueryEquals("Term*", false, "Term*");
-    assertWildcardQueryEquals("TERM*", false, "TERM*");
-    // Then 'full' wildcard queries:
-    // by default, convert to lowercase:
-    assertWildcardQueryEquals("Te?m", "te?m");
-    // explicitly set lowercase:
-    assertWildcardQueryEquals("te?m", true, "te?m");
-    assertWildcardQueryEquals("Te?m", true, "te?m");
-    assertWildcardQueryEquals("TE?M", true, "te?m");
-    assertWildcardQueryEquals("Te?m*gerM", true, "te?m*germ");
-    // explicitly disable lowercase conversion:
-    assertWildcardQueryEquals("te?m", false, "te?m");
-    assertWildcardQueryEquals("Te?m", false, "Te?m");
-    assertWildcardQueryEquals("TE?M", false, "TE?M");
-    assertWildcardQueryEquals("Te?m*gerM", false, "Te?m*gerM");
-    // Fuzzy queries:
-    assertWildcardQueryEquals("Term~", "term~2.0");
-    assertWildcardQueryEquals("Term~", true, "term~2.0");
-    assertWildcardQueryEquals("Term~", false, "Term~2.0");
-    // Range queries:
-
-    // TODO: implement this on QueryParser
-    // Q0002E_INVALID_SYNTAX_CANNOT_PARSE: Syntax Error, cannot parse '[A TO
-    // C]': Lexical error at line 1, column 1. Encountered: "[" (91), after
-    // : ""
-    assertWildcardQueryEquals("[A TO C]", "[a TO c]");
-    assertWildcardQueryEquals("[A TO C]", true, "[a TO c]");
-    assertWildcardQueryEquals("[A TO C]", false, "[A TO C]");
-    // Test suffix queries: first disallow
-    try {
-      assertWildcardQueryEquals("*Term", true, "*term");
-      fail();
-    } catch (QueryNodeException pe) {
-      // expected exception
-    }
-    try {
-      assertWildcardQueryEquals("?Term", true, "?term");
-      fail();
-    } catch (QueryNodeException pe) {
-      // expected exception
-    }
-    // Test suffix queries: then allow
-    assertWildcardQueryEquals("*Term", true, "*term", true);
-    assertWildcardQueryEquals("?Term", true, "?term", true);
-  }
-
-  public void testLeadingWildcardType() throws Exception {
-    StandardQueryParser qp = getParser(null);
-    qp.setAllowLeadingWildcard(true);
-    assertEquals(WildcardQuery.class, qp.parse("t*erm*", "field").getClass());
-    assertEquals(WildcardQuery.class, qp.parse("?term*", "field").getClass());
-    assertEquals(WildcardQuery.class, qp.parse("*term*", "field").getClass());
-  }
-
-  public void testQPA() throws Exception {
-    assertQueryEquals("term term^3.0 term", qpAnalyzer, "term term^3.0 term");
-    assertQueryEquals("term stop^3.0 term", qpAnalyzer, "term term");
-
-    assertQueryEquals("term term term", qpAnalyzer, "term term term");
-    assertQueryEquals("term +stop term", qpAnalyzer, "term term");
-    assertQueryEquals("term -stop term", qpAnalyzer, "term term");
-
-    assertQueryEquals("drop AND (stop) AND roll", qpAnalyzer, "+drop +roll");
-    assertQueryEquals("term +(stop) term", qpAnalyzer, "term term");
-    assertQueryEquals("term -(stop) term", qpAnalyzer, "term term");
-
-    assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
-    assertQueryEquals("term phrase term", qpAnalyzer,
-        "term phrase1 phrase2 term");
-
-    assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
-        "+term -(phrase1 phrase2) term");
-
-    assertQueryEquals("stop^3", qpAnalyzer, "");
-    assertQueryEquals("stop", qpAnalyzer, "");
-    assertQueryEquals("(stop)^3", qpAnalyzer, "");
-    assertQueryEquals("((stop))^3", qpAnalyzer, "");
-    assertQueryEquals("(stop^3)", qpAnalyzer, "");
-    assertQueryEquals("((stop)^3)", qpAnalyzer, "");
-    assertQueryEquals("(stop)", qpAnalyzer, "");
-    assertQueryEquals("((stop))", qpAnalyzer, "");
-    assertTrue(getQuery("term term term", qpAnalyzer) instanceof BooleanQuery);
-    assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
-  }
-
-  public void testRange() throws Exception {
-    assertQueryEquals("[ a TO z]", null, "[a TO z]");
-    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery)getQuery("[ a TO z]", null)).getRewriteMethod());
-
-    StandardQueryParser qp = new StandardQueryParser();
-    
-    qp.setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
-    assertEquals(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE,((TermRangeQuery)qp.parse("[ a TO z]", "field")).getRewriteMethod());
-
-    assertQueryEquals("[ a TO z ]", null, "[a TO z]");
-    assertQueryEquals("{ a TO z}", null, "{a TO z}");
-    assertQueryEquals("{ a TO z }", null, "{a TO z}");
-    assertQueryEquals("{ a TO z }^2.0", null, "{a TO z}^2.0");
-    assertQueryEquals("[ a TO z] OR bar", null, "[a TO z] bar");
-    assertQueryEquals("[ a TO z] AND bar", null, "+[a TO z] +bar");
-    assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
-    assertQueryEquals("gack ( bar blar { a TO z}) ", null,
-        "gack (bar blar {a TO z})");
-  }
-
-  /** for testing DateTools support */
-  private String getDate(String s, DateTools.Resolution resolution)
-      throws Exception {
-    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
-    return getDate(df.parse(s), resolution);
-  }
-
-  /** for testing DateTools support */
-  private String getDate(Date d, DateTools.Resolution resolution)
-      throws Exception {
-    return DateTools.dateToString(d, resolution);
-  }
-  
-  private String escapeDateString(String s) {
-    if (s.contains(" ")) {
-      return "\"" + s + "\"";
-    } else {
-      return s;
-    }
-  }
-
-  private String getLocalizedDate(int year, int month, int day) {
-    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
-    Calendar calendar = new GregorianCalendar();
-    calendar.clear();
-    calendar.set(year, month, day);
-    calendar.set(Calendar.HOUR_OF_DAY, 23);
-    calendar.set(Calendar.MINUTE, 59);
-    calendar.set(Calendar.SECOND, 59);
-    calendar.set(Calendar.MILLISECOND, 999);
-    return df.format(calendar.getTime());
-  }
-
-  public void testDateRange() throws Exception {
-    String startDate = getLocalizedDate(2002, 1, 1);
-    String endDate = getLocalizedDate(2002, 1, 4);
-    Calendar endDateExpected = new GregorianCalendar();
-    endDateExpected.clear();
-    endDateExpected.set(2002, 1, 4, 23, 59, 59);
-    endDateExpected.set(Calendar.MILLISECOND, 999);
-    final String defaultField = "default";
-    final String monthField = "month";
-    final String hourField = "hour";
-    StandardQueryParser qp = new StandardQueryParser();
-
-    Map<CharSequence, DateTools.Resolution> dateRes =  new HashMap<CharSequence, DateTools.Resolution>();
-    
-    // set a field specific date resolution    
-    dateRes.put(monthField, DateTools.Resolution.MONTH);
-    qp.setDateResolution(dateRes);
-
-    // set default date resolution to MILLISECOND
-    qp.setDateResolution(DateTools.Resolution.MILLISECOND);
-
-    // set second field specific date resolution
-    dateRes.put(hourField, DateTools.Resolution.HOUR);
-    qp.setDateResolution(dateRes);
-
-    // for this field no field specific date resolution has been set,
-    // so verify if the default resolution is used
-    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);
-
-    // verify if field specific date resolutions are used for these two
-    // fields
-    assertDateRangeQueryEquals(qp, monthField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.MONTH);
-
-    assertDateRangeQueryEquals(qp, hourField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.HOUR);
-  }
-
-  public void assertDateRangeQueryEquals(StandardQueryParser qp,
-      String field, String startDate, String endDate, Date endDateInclusive,
-      DateTools.Resolution resolution) throws Exception {
-    assertQueryEquals(qp, field, field + ":[" + escapeDateString(startDate) + " TO " + escapeDateString(endDate)
-        + "]", "[" + getDate(startDate, resolution) + " TO "
-        + getDate(endDateInclusive, resolution) + "]");
-    assertQueryEquals(qp, field, field + ":{" + escapeDateString(startDate) + " TO " + escapeDateString(endDate)
-        + "}", "{" + getDate(startDate, resolution) + " TO "
-        + getDate(endDate, resolution) + "}");
-  }
-
-  public void testEscaped() throws Exception {
-    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
-
-    /*
-     * assertQueryEquals("\\[brackets", a, "\\[brackets");
-     * assertQueryEquals("\\[brackets", null, "brackets");
-     * assertQueryEquals("\\\\", a, "\\\\"); assertQueryEquals("\\+blah", a,
-     * "\\+blah"); assertQueryEquals("\\(blah", a, "\\(blah");
-     * 
-     * assertQueryEquals("\\-blah", a, "\\-blah"); assertQueryEquals("\\!blah",
-     * a, "\\!blah"); assertQueryEquals("\\{blah", a, "\\{blah");
-     * assertQueryEquals("\\}blah", a, "\\}blah"); assertQueryEquals("\\:blah",
-     * a, "\\:blah"); assertQueryEquals("\\^blah", a, "\\^blah");
-     * assertQueryEquals("\\[blah", a, "\\[blah"); assertQueryEquals("\\]blah",
-     * a, "\\]blah"); assertQueryEquals("\\\"blah", a, "\\\"blah");
-     * assertQueryEquals("\\(blah", a, "\\(blah"); assertQueryEquals("\\)blah",
-     * a, "\\)blah"); assertQueryEquals("\\~blah", a, "\\~blah");
-     * assertQueryEquals("\\*blah", a, "\\*blah"); assertQueryEquals("\\?blah",
-     * a, "\\?blah"); //assertQueryEquals("foo \\&\\& bar", a,
-     * "foo \\&\\& bar"); //assertQueryEquals("foo \\|| bar", a,
-     * "foo \\|| bar"); //assertQueryEquals("foo \\AND bar", a,
-     * "foo \\AND bar");
-     */
-
-    assertQueryEquals("\\*", a, "*");
-    
-    assertQueryEquals("\\a", a, "a");
-
-    assertQueryEquals("a\\-b:c", a, "a-b:c");
-    assertQueryEquals("a\\+b:c", a, "a+b:c");
-    assertQueryEquals("a\\:b:c", a, "a:b:c");
-    assertQueryEquals("a\\\\b:c", a, "a\\b:c");
-
-    assertQueryEquals("a:b\\-c", a, "a:b-c");
-    assertQueryEquals("a:b\\+c", a, "a:b+c");
-    assertQueryEquals("a:b\\:c", a, "a:b:c");
-    assertQueryEquals("a:b\\\\c", a, "a:b\\c");
-
-    assertQueryEquals("a:b\\-c*", a, "a:b-c*");
-    assertQueryEquals("a:b\\+c*", a, "a:b+c*");
-    assertQueryEquals("a:b\\:c*", a, "a:b:c*");
-
-    assertQueryEquals("a:b\\\\c*", a, "a:b\\c*");
-
-    assertQueryEquals("a:b\\-?c", a, "a:b-?c");
-    assertQueryEquals("a:b\\+?c", a, "a:b+?c");
-    assertQueryEquals("a:b\\:?c", a, "a:b:?c");
-
-    assertQueryEquals("a:b\\\\?c", a, "a:b\\?c");
-
-    assertQueryEquals("a:b\\-c~", a, "a:b-c~2.0");
-    assertQueryEquals("a:b\\+c~", a, "a:b+c~2.0");
-    assertQueryEquals("a:b\\:c~", a, "a:b:c~2.0");
-    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~2.0");
-
-    // TODO: implement Range queries on QueryParser
-    assertQueryEquals("[ a\\- TO a\\+ ]", null, "[a- TO a+]");
-    assertQueryEquals("[ a\\: TO a\\~ ]", null, "[a: TO a~]");
-    assertQueryEquals("[ a\\\\ TO a\\* ]", null, "[a\\ TO a*]");
-
-    assertQueryEquals(
-        "[\"c\\:\\\\temp\\\\\\~foo0.txt\" TO \"c\\:\\\\temp\\\\\\~foo9.txt\"]",
-        a, "[c:\\temp\\~foo0.txt TO c:\\temp\\~foo9.txt]");
-
-    assertQueryEquals("a\\\\\\+b", a, "a\\+b");
-
-    assertQueryEquals("a \\\"b c\\\" d", a, "a \"b c\" d");
-    assertQueryEquals("\"a \\\"b c\\\" d\"", a, "\"a \"b c\" d\"");
-    assertQueryEquals("\"a \\+b c d\"", a, "\"a +b c d\"");
-
-    assertQueryEquals("c\\:\\\\temp\\\\\\~foo.txt", a, "c:\\temp\\~foo.txt");
-
-    assertQueryNodeException("XY\\"); // there must be a character after the
-    // escape char
-
-    // test unicode escaping
-    assertQueryEquals("a\\u0062c", a, "abc");
-    assertQueryEquals("XY\\u005a", a, "XYZ");
-    assertQueryEquals("XY\\u005A", a, "XYZ");
-    assertQueryEquals("\"a \\\\\\u0028\\u0062\\\" c\"", a, "\"a \\(b\" c\"");
-
-    assertQueryNodeException("XY\\u005G"); // test non-hex character in escaped
-    // unicode sequence
-    assertQueryNodeException("XY\\u005"); // test incomplete escaped unicode
-    // sequence
-
-    // Tests bug LUCENE-800
-    assertQueryEquals("(item:\\\\ item:ABCD\\\\)", a, "item:\\ item:ABCD\\");
-    assertQueryNodeException("(item:\\\\ item:ABCD\\\\))"); // unmatched closing
-    // paranthesis
-    assertQueryEquals("\\*", a, "*");
-    assertQueryEquals("\\\\", a, "\\"); // escaped backslash
-
-    assertQueryNodeException("\\"); // a backslash must always be escaped
-
-    // LUCENE-1189
-    assertQueryEquals("(\"a\\\\\") or (\"b\")", a, "a\\ or b");
-  }
-
-  public void testQueryStringEscaping() throws Exception {
-    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
-
-    assertEscapedQueryEquals("a-b:c", a, "a\\-b\\:c");
-    assertEscapedQueryEquals("a+b:c", a, "a\\+b\\:c");
-    assertEscapedQueryEquals("a:b:c", a, "a\\:b\\:c");
-    assertEscapedQueryEquals("a\\b:c", a, "a\\\\b\\:c");
-
-    assertEscapedQueryEquals("a:b-c", a, "a\\:b\\-c");
-    assertEscapedQueryEquals("a:b+c", a, "a\\:b\\+c");
-    assertEscapedQueryEquals("a:b:c", a, "a\\:b\\:c");
-    assertEscapedQueryEquals("a:b\\c", a, "a\\:b\\\\c");
-
-    assertEscapedQueryEquals("a:b-c*", a, "a\\:b\\-c\\*");
-    assertEscapedQueryEquals("a:b+c*", a, "a\\:b\\+c\\*");
-    assertEscapedQueryEquals("a:b:c*", a, "a\\:b\\:c\\*");
-
-    assertEscapedQueryEquals("a:b\\\\c*", a, "a\\:b\\\\\\\\c\\*");
-
-    assertEscapedQueryEquals("a:b-?c", a, "a\\:b\\-\\?c");
-    assertEscapedQueryEquals("a:b+?c", a, "a\\:b\\+\\?c");
-    assertEscapedQueryEquals("a:b:?c", a, "a\\:b\\:\\?c");
-
-    assertEscapedQueryEquals("a:b?c", a, "a\\:b\\?c");
-
-    assertEscapedQueryEquals("a:b-c~", a, "a\\:b\\-c\\~");
-    assertEscapedQueryEquals("a:b+c~", a, "a\\:b\\+c\\~");
-    assertEscapedQueryEquals("a:b:c~", a, "a\\:b\\:c\\~");
-    assertEscapedQueryEquals("a:b\\c~", a, "a\\:b\\\\c\\~");
-
-    assertEscapedQueryEquals("[ a - TO a+ ]", null, "\\[ a \\- TO a\\+ \\]");
-    assertEscapedQueryEquals("[ a : TO a~ ]", null, "\\[ a \\: TO a\\~ \\]");
-    assertEscapedQueryEquals("[ a\\ TO a* ]", null, "\\[ a\\\\ TO a\\* \\]");
-
-    // LUCENE-881
-    assertEscapedQueryEquals("|| abc ||", a, "\\|\\| abc \\|\\|");
-    assertEscapedQueryEquals("&& abc &&", a, "\\&\\& abc \\&\\&");
-  }
-
-  @Ignore("contrib queryparser shouldn't escape wildcard terms")
-  public void testEscapedWildcard() throws Exception {
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
-
-    WildcardQuery q = new WildcardQuery(new Term("field", "foo\\?ba?r"));
-    assertEquals(q, qp.parse("foo\\?ba?r", "field"));
-  }
-
-  public void testTabNewlineCarriageReturn() throws Exception {
-    assertQueryEqualsDOA("+weltbank +worlbank", null, "+weltbank +worlbank");
-
-    assertQueryEqualsDOA("+weltbank\n+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \n+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \n +worlbank", null, "+weltbank +worlbank");
-
-    assertQueryEqualsDOA("+weltbank\r+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r +worlbank", null, "+weltbank +worlbank");
-
-    assertQueryEqualsDOA("+weltbank\r\n+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r\n+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r\n +worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \r \n +worlbank", null,
-        "+weltbank +worlbank");
-
-    assertQueryEqualsDOA("+weltbank\t+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \t+worlbank", null, "+weltbank +worlbank");
-    assertQueryEqualsDOA("weltbank \t +worlbank", null, "+weltbank +worlbank");
-  }
-
-  public void testSimpleDAO() throws Exception {
-    assertQueryEqualsDOA("term term term", null, "+term +term +term");
-    assertQueryEqualsDOA("term +term term", null, "+term +term +term");
-    assertQueryEqualsDOA("term term +term", null, "+term +term +term");
-    assertQueryEqualsDOA("term +term +term", null, "+term +term +term");
-    assertQueryEqualsDOA("-term term term", null, "-term +term +term");
-  }
-
-  public void testBoost() throws Exception {
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(BasicAutomata.makeString("on"));
-    Analyzer oneStopAnalyzer = new MockAnalyzer(random, MockTokenizer.SIMPLE, true, stopSet, true);
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(oneStopAnalyzer);
-
-    Query q = qp.parse("on^1.0", "field");
-    assertNotNull(q);
-    q = qp.parse("\"hello\"^2.0", "field");
-    assertNotNull(q);
-    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
-    q = qp.parse("hello^2.0", "field");
-    assertNotNull(q);
-    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
-    q = qp.parse("\"on\"^1.0", "field");
-    assertNotNull(q);
-
-    StandardQueryParser qp2 = new StandardQueryParser();
-    qp2.setAnalyzer(new MockAnalyzer(random, MockTokenizer.SIMPLE, true, MockTokenFilter.ENGLISH_STOPSET, true));
-
-    q = qp2.parse("the^3", "field");
-    // "the" is a stop word so the result is an empty query:
-    assertNotNull(q);
-    assertEquals("", q.toString());
-    assertEquals(1.0f, q.getBoost(), 0.01f);
-  }
-
-  public void assertQueryNodeException(String queryString) throws Exception {
-    try {
-      getQuery(queryString, null);
-    } catch (QueryNodeException expected) {
-      return;
-    }
-    fail("ParseException expected, not thrown");
-  }
-
-  public void testException() throws Exception {
-    assertQueryNodeException("*leadingWildcard"); // disallowed by default
-    assertQueryNodeException("\"some phrase");
-    assertQueryNodeException("(foo bar");
-    assertQueryNodeException("foo bar))");
-    assertQueryNodeException("field:term:with:colon some more terms");
-    assertQueryNodeException("(sub query)^5.0^2.0 plus more");
-    assertQueryNodeException("secret AND illegal) AND access:confidential");    
-  }
-
-  public void testCustomQueryParserWildcard() {
-    try {
-      new QPTestParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).parse("a?t", "contents");
-      fail("Wildcard queries should not be allowed");
-    } catch (QueryNodeException expected) {
-      // expected exception
-    }
-  }
-
-  public void testCustomQueryParserFuzzy() throws Exception {
-    try {
-      new QPTestParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).parse("xunit~", "contents");
-      fail("Fuzzy queries should not be allowed");
-    } catch (QueryNodeException expected) {
-      // expected exception
-    }
-  }
-
-  public void testBooleanQuery() throws Exception {
-    BooleanQuery.setMaxClauseCount(2);
-    try {
-      StandardQueryParser qp = new StandardQueryParser();
-      qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
-
-      qp.parse("one two three", "field");
-      fail("ParseException expected due to too many boolean clauses");
-    } catch (QueryNodeException expected) {
-      // too many boolean clauses, so ParseException is expected
-    }
-  }
-
-  /**
-   * This test differs from TestPrecedenceQueryParser
-   */
-  public void testPrecedence() throws Exception {
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
-
-    Query query1 = qp.parse("A AND B OR C AND D", "field");
-    Query query2 = qp.parse("+A +B +C +D", "field");
-
-    assertEquals(query1, query2);
-  }
-
-// Todo: Convert from DateField to DateUtil
-//  public void testLocalDateFormat() throws IOException, QueryNodeException {
-//    Directory ramDir = newDirectory();
-//    IndexWriter iw = new IndexWriter(ramDir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)));
-//    addDateDoc("a", 2005, 12, 2, 10, 15, 33, iw);
-//    addDateDoc("b", 2005, 12, 4, 22, 15, 00, iw);
-//    iw.close();
-//    IndexSearcher is = new IndexSearcher(ramDir, true);
-//    assertHits(1, "[12/1/2005 TO 12/3/2005]", is);
-//    assertHits(2, "[12/1/2005 TO 12/4/2005]", is);
-//    assertHits(1, "[12/3/2005 TO 12/4/2005]", is);
-//    assertHits(1, "{12/1/2005 TO 12/3/2005}", is);
-//    assertHits(1, "{12/1/2005 TO 12/4/2005}", is);
-//    assertHits(0, "{12/3/2005 TO 12/4/2005}", is);
-//    is.close();
-//    ramDir.close();
-//  }
-//
-//  private void addDateDoc(String content, int year, int month, int day,
-//                          int hour, int minute, int second, IndexWriter iw) throws IOException {
-//    Document d = new Document();
-//    d.add(newField("f", content, Field.Store.YES, Field.Index.ANALYZED));
-//    Calendar cal = Calendar.getInstance(Locale.ENGLISH);
-//    cal.set(year, month - 1, day, hour, minute, second);
-//    d.add(newField("date", DateField.dateToString(cal.getTime()),
-//        Field.Store.YES, Field.Index.NOT_ANALYZED));
-//    iw.addDocument(d);
-//  }
-
-
-  public void testStarParsing() throws Exception {
-    // final int[] type = new int[1];
-    // StandardQueryParser qp = new StandardQueryParser("field", new
-    // WhitespaceAnalyzer()) {
-    // protected Query getWildcardQuery(String field, String termStr) throws
-    // ParseException {
-    // // override error checking of superclass
-    // type[0]=1;
-    // return new TermQuery(new Term(field,termStr));
-    // }
-    // protected Query getPrefixQuery(String field, String termStr) throws
-    // ParseException {
-    // // override error checking of superclass
-    // type[0]=2;
-    // return new TermQuery(new Term(field,termStr));
-    // }
-    //
-    // protected Query getFieldQuery(String field, String queryText) throws
-    // ParseException {
-    // type[0]=3;
-    // return super.getFieldQuery(field, queryText);
-    // }
-    // };
-    //
-    // TermQuery tq;
-    //
-    // tq = (TermQuery)qp.parse("foo:zoo*");
-    // assertEquals("zoo",tq.getTerm().text());
-    // assertEquals(2,type[0]);
-    //
-    // tq = (TermQuery)qp.parse("foo:zoo*^2");
-    // assertEquals("zoo",tq.getTerm().text());
-    // assertEquals(2,type[0]);
-    // assertEquals(tq.getBoost(),2,0);
-    //
-    // tq = (TermQuery)qp.parse("foo:*");
-    // assertEquals("*",tq.getTerm().text());
-    // assertEquals(1,type[0]); // could be a valid prefix query in the
-    // future too
-    //
-    // tq = (TermQuery)qp.parse("foo:*^2");
-    // assertEquals("*",tq.getTerm().text());
-    // assertEquals(1,type[0]);
-    // assertEquals(tq.getBoost(),2,0);
-    //
-    // tq = (TermQuery)qp.parse("*:foo");
-    // assertEquals("*",tq.getTerm().field());
-    // assertEquals("foo",tq.getTerm().text());
-    // assertEquals(3,type[0]);
-    //
-    // tq = (TermQuery)qp.parse("*:*");
-    // assertEquals("*",tq.getTerm().field());
-    // assertEquals("*",tq.getTerm().text());
-    // assertEquals(1,type[0]); // could be handled as a prefix query in the
-    // future
-    //
-    // tq = (TermQuery)qp.parse("(*:*)");
-    // assertEquals("*",tq.getTerm().field());
-    // assertEquals("*",tq.getTerm().text());
-    // assertEquals(1,type[0]);
-
-  }
-  
-  public void testRegexps() throws Exception {
-    StandardQueryParser qp = new StandardQueryParser();
-    final String df = "field" ;
-    RegexpQuery q = new RegexpQuery(new Term("field", "[a-z][123]"));
-    assertEquals(q, qp.parse("/[a-z][123]/", df));
-    qp.setLowercaseExpandedTerms(true);
-    assertEquals(q, qp.parse("/[A-Z][123]/", df));
-    q.setBoost(0.5f);
-    assertEquals(q, qp.parse("/[A-Z][123]/^0.5", df));
-    qp.setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
-    q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
-    assertTrue(qp.parse("/[A-Z][123]/^0.5", df) instanceof RegexpQuery);
-    assertEquals(q, qp.parse("/[A-Z][123]/^0.5", df));
-    assertEquals(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE, ((RegexpQuery)qp.parse("/[A-Z][123]/^0.5", df)).getRewriteMethod());
-    qp.setMultiTermRewriteMethod(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
-    
-    Query escaped = new RegexpQuery(new Term("field", "[a-z]\\/[123]"));
-    assertEquals(escaped, qp.parse("/[a-z]\\/[123]/", df));
-    Query escaped2 = new RegexpQuery(new Term("field", "[a-z]\\*[123]"));
-    assertEquals(escaped2, qp.parse("/[a-z]\\*[123]/", df));
-    
-    BooleanQuery complex = new BooleanQuery();
-    complex.add(new RegexpQuery(new Term("field", "[a-z]\\/[123]")), Occur.MUST);
-    complex.add(new TermQuery(new Term("path", "/etc/init.d/")), Occur.MUST);
-    complex.add(new TermQuery(new Term("field", "/etc/init[.]d/lucene/")), Occur.SHOULD);
-    assertEquals(complex, qp.parse("/[a-z]\\/[123]/ AND path:/etc/init.d/ OR /etc\\/init\\[.\\]d/lucene/ ", df));
-  }
-
-  public void testStopwords() throws Exception {
-    StandardQueryParser qp = new StandardQueryParser();
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|foo").toAutomaton());
-    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.SIMPLE, true, stopSet, true));
-
-    Query result = qp.parse("a:the OR a:foo", "a");
-    assertNotNull("result is null and it shouldn't be", result);
-    assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
-    assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
-        + 0, ((BooleanQuery) result).clauses().size() == 0);
-    result = qp.parse("a:woo OR a:the", "a");
-    assertNotNull("result is null and it shouldn't be", result);
-    assertTrue("result is not a TermQuery", result instanceof TermQuery);
-    result = qp.parse(
-        "(fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)",
-        "a");
-    assertNotNull("result is null and it shouldn't be", result);
-    assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
-    if (VERBOSE)
-      System.out.println("Result: " + result);
-    assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
-        + 2, ((BooleanQuery) result).clauses().size() == 2);
-  }
-
-  public void testPositionIncrement() throws Exception {
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(
-        new MockAnalyzer(random, MockTokenizer.SIMPLE, true, MockTokenFilter.ENGLISH_STOPSET, true));
-
-    qp.setEnablePositionIncrements(true);
-
-    String qtxt = "\"the words in poisitions pos02578 are stopped in this phrasequery\"";
-    // 0 2 5 7 8
-    int expectedPositions[] = { 1, 3, 4, 6, 9 };
-    PhraseQuery pq = (PhraseQuery) qp.parse(qtxt, "a");
-    // System.out.println("Query text: "+qtxt);
-    // System.out.println("Result: "+pq);
-    Term t[] = pq.getTerms();
-    int pos[] = pq.getPositions();
-    for (int i = 0; i < t.length; i++) {
-      // System.out.println(i+". "+t[i]+"  pos: "+pos[i]);
-      assertEquals("term " + i + " = " + t[i] + " has wrong term-position!",
-          expectedPositions[i], pos[i]);
-    }
-  }
-
-  public void testMatchAllDocs() throws Exception {
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
-
-    assertEquals(new MatchAllDocsQuery(), qp.parse("*:*", "field"));
-    assertEquals(new MatchAllDocsQuery(), qp.parse("(*:*)", "field"));
-    BooleanQuery bq = (BooleanQuery) qp.parse("+*:* -*:*", "field");
-    assertTrue(bq.getClauses()[0].getQuery() instanceof MatchAllDocsQuery);
-    assertTrue(bq.getClauses()[1].getQuery() instanceof MatchAllDocsQuery);
-  }
-
-  private void assertHits(int expected, String query, IndexSearcher is)
-      throws IOException, QueryNodeException {
-    StandardQueryParser qp = new StandardQueryParser();
-    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
-    qp.setLocale(Locale.ENGLISH);
-
-    Query q = qp.parse(query, "date");
-    ScoreDoc[] hits = is.search(q, null, 1000).scoreDocs;
-    assertEquals(expected, hits.length);
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    BooleanQuery.setMaxClauseCount(originalMaxClauses);
-    super.tearDown();
-  }
-
-  private class CannedTokenStream extends TokenStream {
-    private int upto = 0;
-    final PositionIncrementAttribute posIncr = addAttribute(PositionIncrementAttribute.class);
-    final CharTermAttribute term = addAttribute(CharTermAttribute.class);
-    @Override
-    public boolean incrementToken() {
-      clearAttributes();
-      if (upto == 4) {
-        return false;
-      }
-      if (upto == 0) {
-        posIncr.setPositionIncrement(1);
-        term.setEmpty().append("a");
-      } else if (upto == 1) {
-        posIncr.setPositionIncrement(1);
-        term.setEmpty().append("b");
-      } else if (upto == 2) {
-        posIncr.setPositionIncrement(0);
-        term.setEmpty().append("c");
-      } else {
-        posIncr.setPositionIncrement(0);
-        term.setEmpty().append("d");
-      }
-      upto++;
-      return true;
-    }
-  }
-
-  private class CannedAnalyzer extends Analyzer {
-    @Override
-    public TokenStream tokenStream(String ignored, Reader alsoIgnored) {
-      return new CannedTokenStream();
-    }
-  }
-
-  public void testMultiPhraseQuery() throws Exception {
-    Directory dir = newDirectory();
-    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new CannedAnalyzer()));
-    Document doc = new Document();
-    doc.add(newField("field", "", Field.Store.NO, Field.Index.ANALYZED));
-    w.addDocument(doc);
-    IndexReader r = IndexReader.open(w, true);
-    IndexSearcher s = newSearcher(r);
-    
-    Query q = new StandardQueryParser(new CannedAnalyzer()).parse("\"a\"", "field");
-    assertTrue(q instanceof MultiPhraseQuery);
-    assertEquals(1, s.search(q, 10).totalHits);
-    s.close();
-    r.close();
-    w.close();
-    dir.close();
-  }
-
-}
diff --git a/lucene/contrib/xml-query-parser/build.xml b/lucene/contrib/xml-query-parser/build.xml
index 63391be..c1965bf 100644
--- a/lucene/contrib/xml-query-parser/build.xml
+++ b/lucene/contrib/xml-query-parser/build.xml
@@ -95,7 +95,7 @@
     </subant>
   </target>
 
-  <target name="build-queries" unless="queryparser.uptodate">
+  <target name="build-queries" unless="queries.uptodate">
     <echo>XML QueryParser building dependency modules/queries</echo>
     <subant target="default">
       <fileset dir="${common.dir}/../modules/queries" includes="build.xml"/>
diff --git a/modules/queryparser/build.xml b/modules/queryparser/build.xml
index ff34f9c..c751669 100644
--- a/modules/queryparser/build.xml
+++ b/modules/queryparser/build.xml
@@ -28,21 +28,15 @@
 
   <target name="dist-maven" depends="jar-core,javadocs,contrib-build.dist-maven"/>
 
-  <target name="clean-javacc">
-    <delete>
-      <fileset dir="src/java/org/apache/lucene/queryparser/classic" includes="*.java">
-        <containsregexp expression="Generated.*By.*JavaCC"/>
-      </fileset>
-      <fileset dir="src/java/org/apache/lucene/queryparser/surround/parser" includes="*.java">
-        <containsregexp expression="Generated.*By.*JavaCC"/>
-      </fileset>
-    </delete>
-  </target>
-
-  <target name="javacc" depends="init,javacc-check,clean-javacc,javacc-QueryParser,javacc-surround"/>
+  <target name="javacc" depends="init,javacc-check,javacc-QueryParser,javacc-surround,javacc-flexible"/>
 
   <target name="javacc-QueryParser" depends="init,javacc-check" if="javacc.present">
     <sequential>
+      <delete>
+        <fileset dir="src/java/org/apache/lucene/queryparser/classic" includes="*.java">
+          <containsregexp expression="Generated.*By.*JavaCC"/>
+        </fileset>
+      </delete>
       <invoke-javacc target="src/java/org/apache/lucene/queryparser/classic/QueryParser.jj"
                      outputDir="src/java/org/apache/lucene/queryparser/classic"/>
 
@@ -60,9 +54,77 @@
   </target>
 
   <target name="javacc-surround" depends="javacc-check" description="generate surround query parser from jj (requires javacc 4.1">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/queryparser/surround/parser" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+    </delete>
   	<invoke-javacc target="src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj"
                    outputDir="src/java/org/apache/lucene/queryparser/surround/parser"
     />
   </target>
 
+  <target name="javacc-flexible" depends="javacc-check">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/queryparser/flexible/standard/parser" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+    </delete>
+    <invoke-javacc target="src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj"
+                   outputDir="src/java/org/apache/lucene/queryparser/flexible/standard/parser"
+    />
+        <replaceregexp file="src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java"
+                             match="public class ParseException extends Exception"
+                             replace="public class ParseException extends QueryNodeParseException"
+                             flags="g"
+                             byline="false"/>
+        <replaceregexp file="src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java"
+                             match="package org.apache.lucene.queryparser.flexible.standard.parser;"
+                             replace="package org.apache.lucene.queryparser.flexible.standard.parser;${line.separator}
+${line.separator}
+import org.apache.lucene.messages.Message;${line.separator}
+import org.apache.lucene.messages.MessageImpl;${line.separator}
+import org.apache.lucene.queryparser.flexible.core.*;${line.separator}
+import org.apache.lucene.queryparser.flexible.core.messages.*;"
+                             flags="g"
+                             byline="false"/>
+        <replaceregexp file="src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java"
+                             match="^  public ParseException\(Token currentTokenVal.*$(\s\s[^}].*\n)*  \}"
+                             replace="  public ParseException(Token currentTokenVal,${line.separator}
+    int[][] expectedTokenSequencesVal, String[] tokenImageVal) {${line.separator}
+    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(${line.separator}
+    currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));${line.separator}
+    this.currentToken = currentTokenVal;${line.separator}
+    this.expectedTokenSequences = expectedTokenSequencesVal;${line.separator}
+    this.tokenImage = tokenImageVal;${line.separator}
+  }"
+                             flags="gm"
+                             byline="false"/>
+        <replaceregexp file="src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java"
+                             match="^  public ParseException\(String message.*$(\s\s[^}].*\n)*  \}"
+                             replace="  public ParseException(Message message) {${line.separator}
+    super(message);${line.separator}
+  }"
+                             flags="gm"
+                             byline="false"/>
+        <replaceregexp file="src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java"
+                             match="^  public ParseException\(\).*$(\s\s[^}].*\n)*  \}"
+                             replace="  public ParseException() {${line.separator}
+    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, &quot;Error&quot;));${line.separator}
+  }"
+                             flags="gm"
+                             byline="false"/>
+        <replaceregexp file="src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java"
+                             match="^  public String getMessage\(\).*$(\s\s\s\s[^}].*\n)*    \}"
+                             replace="  private static String initialise(Token currentToken, int[][] expectedTokenSequences, String[] tokenImage) {${line.separator}
+    String eol = System.getProperty(&quot;line.separator&quot;, &quot;\n&quot;);"
+                             flags="gm"
+                             byline="false"/>
+        <replaceregexp file="src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java"
+                             match="\s*protected String add_escapes.*"
+                             replace="  static private String add_escapes(String str) {"
+                             flags="g"
+                             byline="true"/>
+  </target>
+
 </project>
diff --git a/modules/queryparser/docs/flexible/README.javacc b/modules/queryparser/docs/flexible/README.javacc
new file mode 100644
index 0000000..bae1224
--- /dev/null
+++ b/modules/queryparser/docs/flexible/README.javacc
@@ -0,0 +1,62 @@
+NOTE: often, if you are making a small change to the .jj file, you can
+simply run "ant javacc" and skip the steps below.  JavaCC will print
+warnings like this:
+
+   Warning: ParseException.java: File is obsolete.  Please rename or delete this file so that a new one can be generated for you.
+
+which you should ignore (ie, simply keep the ParseException.java class
+that's already present).
+
+If, instead, you'd like to fully rebuild the StandardQueryParser,
+here's how:
+
+  * Delete these files:
+
+    StandardQueryParser.java
+    StandardQueryParserConstants.java
+    StandardQueryParserTokenManager.java
+    TokenMgrError.java
+    JavaCharStream.java
+    Token.java
+
+  * Run "ant javacc". That will generate the all the classes
+
+  * To avoid lots of warnings in the generated code:
+
+    add @SupressWarnings("all"), immediately preceding the class declaration to:
+
+       QueryParserTokenManager.java
+       TokenMgrError.java
+       JavaCharStream.java
+       Token.java
+       JavaCharStream.java
+
+  * Remove all imports from TokenMgrError.java
+
+  * Fix the ParseException class:
+
+    - Change it to extend from QueryNodeParseException:
+
+       "public class ParseException extends QueryNodeParseException".
+
+    - Recreate the all the constructors like this:
+
+      public ParseException(Token currentTokenVal,
+        int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
+        super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(
+          currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));
+        this.currentToken = currentTokenVal;
+        this.expectedTokenSequences = expectedTokenSequencesVal;
+        this.tokenImage = tokenImageVal;
+      }
+
+      public ParseException(Message message) {
+        super(message);
+      }
+
+      public ParseException() {
+        super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, "Error"));
+      }
+
+
+    - Fix all imports
diff --git a/modules/queryparser/docs/surround/README.txt b/modules/queryparser/docs/surround/README.txt
new file mode 100644
index 0000000..056f080
--- /dev/null
+++ b/modules/queryparser/docs/surround/README.txt
@@ -0,0 +1,74 @@
+Description of Surround:
+
+Surround consists of operators (uppercase/lowercase):
+
+AND/OR/NOT/nW/nN/() as infix and
+AND/OR/nW/nN        as prefix.
+
+Distance operators W and N have default n=1, max 99.
+Implemented as SpanQuery with slop = (n - 1).
+An example prefix form is:
+
+20n(aa*, bb*, cc*)
+
+The name Surround was chosen because of this prefix form
+and because it uses the newly introduced span queries
+to implement the proximity operators.
+The names of the operators and the prefix and suffix
+forms have been borrowed from various other query
+languages described on the internet.
+
+
+Query terms from the Lucene standard query parser:
+
+field:termtext
+^ boost
+* internal and suffix truncation
+? one character
+
+
+Some examples:
+
+aa
+aa and bb
+aa and bb or cc        same effect as:  (aa and bb) or cc
+aa NOT bb NOT cc       same effect as:  (aa NOT bb) NOT cc
+
+and(aa,bb,cc)          aa and bb and cc
+99w(aa,bb,cc)          ordered span query with slop 98
+99n(aa,bb,cc)          unordered span query with slop 98
+
+20n(aa*,bb*)
+3w(a?a or bb?, cc*)
+
+title: text: aa
+title : text : aa or bb
+title:text: aa not bb
+title:aa not text:bb
+
+cc 3w dd               infix: dual.
+
+cc N dd N ee           same effect as:   (cc N dd) N ee
+
+text: aa 3d bb
+
+For examples on using the Surround language, see the
+test packages.
+
+
+Development status
+
+Not tested: multiple fields, internally mapped to OR queries,
+not compared to Lucene's MultipleFieldQuery.
+
+* suffix truncation is implemented very similar to Lucene's PrefixQuery.
+
+Wildcards (? and internal *) are implemented with regular expressions
+to allow further variations. A reimplementation using
+WildCardTermEnum (correct name?) should be no problem.
+
+Warnings about missing terms are sent to System.out, this might
+be replaced by another stream, and tested for in the tests.
+
+BooleanQueryTst.TestCollector uses a results checking method that should
+be replaced by the checking method from Lucene's TestBasics.java.
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeError.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeError.java
new file mode 100644
index 0000000..636567f
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeError.java
@@ -0,0 +1,73 @@
+package org.apache.lucene.queryparser.flexible.core;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.NLSException;
+
+/**
+ * Error class with NLS support
+ * 
+ * @see org.apache.lucene.messages.NLS
+ * @see org.apache.lucene.messages.Message
+ */
+public class QueryNodeError extends Error implements NLSException {
+  private Message message;
+
+  /**
+   * @param message
+   *          - NLS Message Object
+   */
+  public QueryNodeError(Message message) {
+    super(message.getKey());
+
+    this.message = message;
+
+  }
+
+  /**
+   * @param throwable
+   *          - @see java.lang.Error
+   */
+  public QueryNodeError(Throwable throwable) {
+    super(throwable);
+  }
+
+  /**
+   * @param message
+   *          - NLS Message Object
+   * @param throwable
+   *          - @see java.lang.Error
+   */
+  public QueryNodeError(Message message, Throwable throwable) {
+    super(message.getKey(), throwable);
+
+    this.message = message;
+
+  }
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.lucene.messages.NLSException#getMessageObject()
+   */
+  public Message getMessageObject() {
+    return this.message;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeException.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeException.java
new file mode 100644
index 0000000..2e7ceec
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeException.java
@@ -0,0 +1,88 @@
+package org.apache.lucene.queryparser.flexible.core;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Locale;
+
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.messages.NLS;
+import org.apache.lucene.messages.NLSException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+/**
+ * <p>
+ * This exception should be thrown if something wrong happens when dealing with
+ * {@link QueryNode}s.
+ * </p>
+ * <p>
+ * It also supports NLS messages.
+ * </p>
+ * 
+ * @see Message
+ * @see NLS
+ * @see NLSException
+ * @see QueryNode
+ */
+public class QueryNodeException extends Exception implements NLSException {
+
+  protected Message message = new MessageImpl(QueryParserMessages.EMPTY_MESSAGE);
+
+  public QueryNodeException(Message message) {
+    super(message.getKey());
+
+    this.message = message;
+
+  }
+
+  public QueryNodeException(Throwable throwable) {
+    super(throwable);
+  }
+
+  public QueryNodeException(Message message, Throwable throwable) {
+    super(message.getKey(), throwable);
+
+    this.message = message;
+
+  }
+
+  public Message getMessageObject() {
+    return this.message;
+  }
+
+  @Override
+  public String getMessage() {
+    return getLocalizedMessage();
+  }
+
+  @Override
+  public String getLocalizedMessage() {
+    return getLocalizedMessage(Locale.getDefault());
+  }
+
+  public String getLocalizedMessage(Locale locale) {
+    return this.message.getLocalizedMessage(locale);
+  }
+
+  @Override
+  public String toString() {
+    return this.message.getKey() + ": " + getLocalizedMessage();
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeParseException.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeParseException.java
new file mode 100644
index 0000000..24c8e2a
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeParseException.java
@@ -0,0 +1,119 @@
+package org.apache.lucene.queryparser.flexible.core;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+/**
+ * This should be thrown when an exception happens during the query parsing from
+ * string to the query node tree.
+ * 
+ * @see QueryNodeException
+ * @see SyntaxParser
+ * @see QueryNode
+ */
+public class QueryNodeParseException extends QueryNodeException {
+
+  private CharSequence query;
+
+  private int beginColumn = -1;
+
+  private int beginLine = -1;
+
+  private String errorToken = "";
+
+  public QueryNodeParseException(Message message) {
+    super(message);
+  }
+
+  public QueryNodeParseException(Throwable throwable) {
+    super(throwable);
+  }
+
+  public QueryNodeParseException(Message message, Throwable throwable) {
+    super(message, throwable);
+  }
+
+  public void setQuery(CharSequence query) {
+    this.query = query;
+    this.message = new MessageImpl(
+        QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, "");
+  }
+
+  public CharSequence getQuery() {
+    return this.query;
+  }
+
+  /**
+   * @param errorToken
+   *          the errorToken in the query
+   */
+  protected void setErrorToken(String errorToken) {
+    this.errorToken = errorToken;
+  }
+
+  public String getErrorToken() {
+    return this.errorToken;
+  }
+
+  public void setNonLocalizedMessage(Message message) {
+    this.message = message;
+  }
+
+  /**
+   * For EndOfLine and EndOfFile ("<EOF>") parsing problems the last char in the
+   * string is returned For the case where the parser is not able to figure out
+   * the line and column number -1 will be returned
+   * 
+   * @return line where the problem was found
+   */
+  public int getBeginLine() {
+    return this.beginLine;
+  }
+
+  /**
+   * For EndOfLine and EndOfFile ("<EOF>") parsing problems the last char in the
+   * string is returned For the case where the parser is not able to figure out
+   * the line and column number -1 will be returned
+   * 
+   * @return column of the first char where the problem was found
+   */
+  public int getBeginColumn() {
+    return this.beginColumn;
+  }
+
+  /**
+   * @param beginLine
+   *          the beginLine to set
+   */
+  protected void setBeginLine(int beginLine) {
+    this.beginLine = beginLine;
+  }
+
+  /**
+   * @param beginColumn
+   *          the beginColumn to set
+   */
+  protected void setBeginColumn(int beginColumn) {
+    this.beginColumn = beginColumn;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryParserHelper.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryParserHelper.java
new file mode 100644
index 0000000..1cd2f5d
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryParserHelper.java
@@ -0,0 +1,262 @@
+package org.apache.lucene.queryparser.flexible.core;
+
+import org.apache.lucene.queryparser.flexible.core.builders.QueryBuilder;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+  
+/**
+ * <p>
+ * This class is a helper for the query parser framework, it does all the three
+ * query parser phrases at once: text parsing, query processing and query
+ * building.
+ * </p>
+ * <p>
+ * It contains methods that allows the user to change the implementation used on
+ * the three phases.
+ * </p>
+ * 
+ * @see QueryNodeProcessor
+ * @see SyntaxParser
+ * @see QueryBuilder
+ * @see QueryConfigHandler
+ */
+public class QueryParserHelper {
+
+  private QueryNodeProcessor processor;
+
+  private SyntaxParser syntaxParser;
+
+  private QueryBuilder builder;
+
+  private QueryConfigHandler config;
+
+  /**
+   * Creates a query parser helper object using the specified configuration,
+   * text parser, processor and builder.
+   * 
+   * @param queryConfigHandler
+   *          the query configuration handler that will be initially set to this
+   *          helper
+   * @param syntaxParser
+   *          the text parser that will be initially set to this helper
+   * @param processor
+   *          the query processor that will be initially set to this helper
+   * @param builder
+   *          the query builder that will be initially set to this helper
+   * 
+   * @see QueryNodeProcessor
+   * @see SyntaxParser
+   * @see QueryBuilder
+   * @see QueryConfigHandler
+   */
+  public QueryParserHelper(QueryConfigHandler queryConfigHandler, SyntaxParser syntaxParser, QueryNodeProcessor processor,
+      QueryBuilder builder) {
+    this.syntaxParser = syntaxParser;
+    this.config = queryConfigHandler;
+    this.processor = processor;
+    this.builder = builder;
+
+    if (processor != null) {
+      processor.setQueryConfigHandler(queryConfigHandler);
+    }
+
+  }
+
+  /**
+   * Returns the processor object used to process the query node tree, it
+   * returns <code>null</code> if no processor is used.
+   * 
+   * @return the actual processor used to process the query node tree,
+   *         <code>null</code> if no processor is used
+   * 
+   * @see QueryNodeProcessor
+   * @see #setQueryNodeProcessor(QueryNodeProcessor)
+   */
+  public QueryNodeProcessor getQueryNodeProcessor() {
+    return processor;
+  }
+
+  /**
+   * Sets the processor that will be used to process the query node tree. If
+   * there is any {@link QueryConfigHandler} returned by
+   * {@link #getQueryConfigHandler()}, it will be set on the processor. The
+   * argument can be <code>null</code>, which means that no processor will be
+   * used to process the query node tree.
+   * 
+   * @param processor
+   *          the processor that will be used to process the query node tree,
+   *          this argument can be <code>null</code>
+   * 
+   * @see #getQueryNodeProcessor()
+   * @see QueryNodeProcessor
+   */
+  public void setQueryNodeProcessor(QueryNodeProcessor processor) {
+    this.processor = processor;
+    this.processor.setQueryConfigHandler(getQueryConfigHandler());
+
+  }
+
+  /**
+   * Sets the text parser that will be used to parse the query string, it cannot
+   * be <code>null</code>.
+   * 
+   * @param syntaxParser
+   *          the text parser that will be used to parse the query string
+   * 
+   * @see #getSyntaxParser()
+   * @see SyntaxParser
+   */
+  public void setSyntaxParser(SyntaxParser syntaxParser) {
+
+    if (syntaxParser == null) {
+      throw new IllegalArgumentException("textParser should not be null!");
+    }
+
+    this.syntaxParser = syntaxParser;
+
+  }
+
+  /**
+   * The query builder that will be used to build an object from the query node
+   * tree. It cannot be <code>null</code>.
+   * 
+   * @param queryBuilder
+   *          the query builder used to build something from the query node tree
+   * 
+   * @see #getQueryBuilder()
+   * @see QueryBuilder
+   */
+  public void setQueryBuilder(QueryBuilder queryBuilder) {
+
+    if (queryBuilder == null) {
+      throw new IllegalArgumentException("queryBuilder should not be null!");
+    }
+
+    this.builder = queryBuilder;
+
+  }
+
+  /**
+   * Returns the query configuration handler, which is used during the query
+   * node tree processing. It can be <code>null</code>.
+   * 
+   * @return the query configuration handler used on the query processing,
+   *         <code>null</code> if not query configuration handler is defined
+   * 
+   * @see QueryConfigHandler
+   * @see #setQueryConfigHandler(QueryConfigHandler)
+   */
+  public QueryConfigHandler getQueryConfigHandler() {
+    return config;
+  }
+
+  /**
+   * Returns the query builder used to build a object from the query node tree.
+   * The object produced by this builder is returned by
+   * {@link #parse(String, String)}.
+   * 
+   * @return the query builder
+   * 
+   * @see #setQueryBuilder(QueryBuilder)
+   * @see QueryBuilder
+   */
+  public QueryBuilder getQueryBuilder() {
+    return this.builder;
+  }
+
+  /**
+   * Returns the text parser used to build a query node tree from a query
+   * string. The default text parser instance returned by this method is a
+   * {@link SyntaxParser}.
+   * 
+   * @return the text parse used to build query node trees.
+   * 
+   * @see SyntaxParser
+   * @see #setSyntaxParser(SyntaxParser)
+   */
+  public SyntaxParser getSyntaxParser() {
+    return this.syntaxParser;
+  }
+
+  /**
+   * Sets the query configuration handler that will be used during query
+   * processing. It can be <code>null</code>. It's also set to the processor
+   * returned by {@link #getQueryNodeProcessor()}.
+   * 
+   * @param config
+   *          the query configuration handler used during query processing, it
+   *          can be <code>null</code>
+   * 
+   * @see #getQueryConfigHandler()
+   * @see QueryConfigHandler
+   */
+  public void setQueryConfigHandler(QueryConfigHandler config) {
+    this.config = config;
+    QueryNodeProcessor processor = getQueryNodeProcessor();
+
+    if (processor != null) {
+      processor.setQueryConfigHandler(config);
+    }
+
+  }
+
+  /**
+   * Parses a query string to an object, usually some query object. <br/>
+   * <br/>
+   * In this method the three phases are executed: <br/>
+   * <br/>
+   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1st - the query string is parsed using the
+   * text parser returned by {@link #getSyntaxParser()}, the result is a query
+   * node tree <br/>
+   * <br/>
+   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2nd - the query node tree is processed by the
+   * processor returned by {@link #getQueryNodeProcessor()} <br/>
+   * <br/>
+   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3th - a object is built from the query node
+   * tree using the builder returned by {@link #getQueryBuilder()}
+   * 
+   * @param query
+   *          the query string
+   * @param defaultField
+   *          the default field used by the text parser
+   * 
+   * @return the object built from the query
+   * 
+   * @throws QueryNodeException
+   *           if something wrong happens along the three phases
+   */
+  public Object parse(String query, String defaultField)
+      throws QueryNodeException {
+    QueryNode queryTree = getSyntaxParser().parse(query, defaultField);
+
+    QueryNodeProcessor processor = getQueryNodeProcessor();
+
+    if (processor != null) {
+      queryTree = processor.process(queryTree);
+    }
+
+    return getQueryBuilder().build(queryTree);
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/QueryBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/QueryBuilder.java
new file mode 100644
index 0000000..445f8e5
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/QueryBuilder.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.queryparser.flexible.core.builders;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * This interface is used by implementors classes that builds some kind of
+ * object from a query tree.
+ * 
+ * @see QueryTreeBuilder
+ */
+public interface QueryBuilder {
+
+  /**
+   * Builds some kind of object from a query tree.
+   * 
+   * @param queryNode
+   *          the query tree root node
+   * 
+   * @return some object generated from the query tree
+   * 
+   * @throws QueryNodeException
+   */
+  Object build(QueryNode queryNode) throws QueryNodeException;
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/QueryTreeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/QueryTreeBuilder.java
new file mode 100644
index 0000000..f557a29
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/QueryTreeBuilder.java
@@ -0,0 +1,223 @@
+package org.apache.lucene.queryparser.flexible.core.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.HashMap;
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl;
+
+/**
+ * This class should be used when there is a builder for each type of node.
+ * 
+ * The type of node may be defined in 2 different ways: - by the field name,
+ * when the node implements the {@link FieldableNode} interface - by its class,
+ * it keeps checking the class and all the interfaces and classes this class
+ * implements/extends until it finds a builder for that class/interface
+ * 
+ * This class always check if there is a builder for the field name before it
+ * checks for the node class. So, field name builders have precedence over class
+ * builders.
+ * 
+ * When a builder is found for a node, it's called and the node is passed to the
+ * builder. If the returned built object is not <code>null</code>, it's tagged
+ * on the node using the tag {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID}.
+ * 
+ * The children are usually built before the parent node. However, if a builder
+ * associated to a node is an instance of {@link QueryTreeBuilder}, the node is
+ * delegated to this builder and it's responsible to build the node and its
+ * children.
+ * 
+ * @see QueryBuilder
+ */
+public class QueryTreeBuilder implements QueryBuilder {
+
+  /**
+   * This tag is used to tag the nodes in a query tree with the built objects
+   * produced from their own associated builder.
+   */
+  public static final String QUERY_TREE_BUILDER_TAGID = QueryTreeBuilder.class
+      .getName();
+
+  private HashMap<Class<? extends QueryNode>, QueryBuilder> queryNodeBuilders;
+
+  private HashMap<String, QueryBuilder> fieldNameBuilders;
+
+  /**
+   * {@link QueryTreeBuilder} constructor.
+   */
+  public QueryTreeBuilder() {
+    // empty constructor
+  }
+
+  /**
+   * Associates a field name with a builder.
+   * 
+   * @param fieldName the field name
+   * @param builder the builder to be associated
+   */
+  public void setBuilder(CharSequence fieldName, QueryBuilder builder) {
+
+    if (this.fieldNameBuilders == null) {
+      this.fieldNameBuilders = new HashMap<String, QueryBuilder>();
+    }
+
+    this.fieldNameBuilders.put(fieldName.toString(), builder);
+
+
+  }
+
+  /**
+   * Associates a class with a builder
+   * 
+   * @param queryNodeClass the class
+   * @param builder the builder to be associated
+   */
+  public void setBuilder(Class<? extends QueryNode> queryNodeClass,
+      QueryBuilder builder) {
+
+    if (this.queryNodeBuilders == null) {
+      this.queryNodeBuilders = new HashMap<Class<? extends QueryNode>, QueryBuilder>();
+    }
+
+    this.queryNodeBuilders.put(queryNodeClass, builder);
+
+  }
+
+  private void process(QueryNode node) throws QueryNodeException {
+
+    if (node != null) {
+      QueryBuilder builder = getBuilder(node);
+
+      if (!(builder instanceof QueryTreeBuilder)) {
+        List<QueryNode> children = node.getChildren();
+
+        if (children != null) {
+
+          for (QueryNode child : children) {
+            process(child);
+          }
+
+        }
+
+      }
+
+      processNode(node, builder);
+
+    }
+
+  }
+
+  private QueryBuilder getBuilder(QueryNode node) {
+    QueryBuilder builder = null;
+
+    if (this.fieldNameBuilders != null && node instanceof FieldableNode) {
+      CharSequence field = ((FieldableNode) node).getField();
+
+      if (field != null) {
+        field = field.toString();
+      }
+
+      builder = this.fieldNameBuilders.get(field);
+
+    }
+
+    if (builder == null && this.queryNodeBuilders != null) {
+
+      Class<?> clazz = node.getClass();
+
+      do {
+        builder = getQueryBuilder(clazz);
+
+        if (builder == null) {
+          Class<?>[] classes = node.getClass().getInterfaces();
+
+          for (Class<?> actualClass : classes) {
+            builder = getQueryBuilder(actualClass);
+
+            if (builder != null) {
+              break;
+            }
+
+          }
+
+        }
+
+      } while (builder == null && (clazz = clazz.getSuperclass()) != null);
+
+    }
+
+    return builder;
+
+  }
+
+  private void processNode(QueryNode node, QueryBuilder builder)
+      throws QueryNodeException {
+
+    if (builder == null) {
+
+      throw new QueryNodeException(new MessageImpl(
+          QueryParserMessages.LUCENE_QUERY_CONVERSION_ERROR, node
+              .toQueryString(new EscapeQuerySyntaxImpl()), node.getClass()
+              .getName()));
+
+    }
+
+    Object obj = builder.build(node);
+
+    if (obj != null) {
+      node.setTag(QUERY_TREE_BUILDER_TAGID, obj);
+    }
+
+  }
+
+  private QueryBuilder getQueryBuilder(Class<?> clazz) {
+
+    if (QueryNode.class.isAssignableFrom(clazz)) {
+      return this.queryNodeBuilders.get(clazz);
+    }
+
+    return null;
+
+  }
+
+  /**
+   * Builds some kind of object from a query tree. Each node in the query tree
+   * is built using an specific builder associated to it.
+   * 
+   * @param queryNode the query tree root node
+   * 
+   * @return the built object
+   * 
+   * @throws QueryNodeException if some node builder throws a
+   *         {@link QueryNodeException} or if there is a node which had no
+   *         builder associated to it
+   */
+  public Object build(QueryNode queryNode) throws QueryNodeException {
+    process(queryNode);
+
+    return queryNode.getTag(QUERY_TREE_BUILDER_TAGID);
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/package.html
new file mode 100644
index 0000000..dde8a21
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/builders/package.html
@@ -0,0 +1,39 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+Contains the necessary classes to implement query builders
+
+<h2>Query Parser Builders</h2>
+<p>
+The package <tt>org.apache.lucene.queryParser.builders</tt> contains the interface that
+builders must implement, it also contain a utility {@link org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder}, which walks the tree
+and call the Builder for each node in the tree.
+Builder normally convert QueryNode Object into a Lucene Query Object,
+and normally it's a one-to-one mapping class.
+
+But other builders implementations can by written to convert QueryNode objects to other non lucene objects.
+</p>
+<p>
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/AbstractQueryConfig.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/AbstractQueryConfig.java
new file mode 100644
index 0000000..a2f4f5a
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/AbstractQueryConfig.java
@@ -0,0 +1,118 @@
+package org.apache.lucene.queryparser.flexible.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.HashMap;
+
+/**
+ * <p>
+ * This class is the base of {@link QueryConfigHandler} and {@link FieldConfig}.
+ * It has operations to set, unset and get configuration values.
+ * </p>
+ * <p>
+ * Each configuration is is a key->value pair. The key should be an unique
+ * {@link ConfigurationKey} instance and it also holds the value's type.
+ * </p>
+ * 
+ * @see ConfigurationKey
+ */
+public abstract class AbstractQueryConfig {
+  
+  final private HashMap<ConfigurationKey<?>, Object> configMap = new HashMap<ConfigurationKey<?>, Object>();
+  
+  AbstractQueryConfig() {
+    // although this class is public, it can only be constructed from package
+  }
+  
+  /**
+   * Returns the value held by the given key.
+   * 
+   * @param <T> the value's type
+   * 
+   * @param key the key, cannot be <code>null</code>
+   * 
+   * @return the value held by the given key
+   */
+  @SuppressWarnings("unchecked")
+  public <T> T get(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return (T) this.configMap.get(key);
+    
+  }
+
+  /**
+   * Returns true if there is a value set with the given key, otherwise false.
+   * 
+   * @param <T> @param <T> the value's type
+   * @param key the key, cannot be <code>null</code>
+   * @return true if there is a value set with the given key, otherwise false
+   */
+  public <T> boolean has(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return this.configMap.containsKey(key);
+    
+  }
+  
+  /**
+   * Sets a key and its value.
+   * 
+   * @param <T> the value's type
+   * @param key the key, cannot be <code>null</code>
+   * @param value
+   */
+  public <T> void set(ConfigurationKey<T> key, T value) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    if (value == null) {
+      unset(key);
+      
+    } else {
+      this.configMap.put(key, value);
+    }
+    
+  }
+
+  /**
+   * Unsets the given key and its value.
+   * 
+   * @param <T> the value's type
+   * @param key the key
+   * @return true if the key and value was set and removed, otherwise false
+   */
+  public <T> boolean unset(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return this.configMap.remove(key) != null;
+    
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/ConfigurationKey.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/ConfigurationKey.java
new file mode 100644
index 0000000..ac8138d
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/ConfigurationKey.java
@@ -0,0 +1,42 @@
+package org.apache.lucene.queryparser.flexible.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * An instance of this class represents a key that is used to retrieve a value
+ * from {@link AbstractQueryConfig}. It also holds the value's type, which is
+ * defined in the generic argument.
+ * 
+ * @see AbstractQueryConfig
+ */
+final public class ConfigurationKey<T> {
+  
+  private ConfigurationKey() {}
+  
+  /**
+   * Creates a new instance.
+   * 
+   * @param <T> the value's type
+   * 
+   * @return a new instance
+   */
+  public static <T> ConfigurationKey<T> newInstance() {
+    return new ConfigurationKey<T>();
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfig.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfig.java
new file mode 100644
index 0000000..b59c579
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfig.java
@@ -0,0 +1,58 @@
+package org.apache.lucene.queryparser.flexible.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This class represents a field configuration.
+ */
+public class FieldConfig extends AbstractQueryConfig {
+
+  private String fieldName;
+  
+  /**
+   * Constructs a {@link FieldConfig}
+   * 
+   * @param fieldName the field name, it cannot be null
+   * @throws IllegalArgumentException if the field name is null
+   */
+  public FieldConfig(String fieldName) {
+
+    if (fieldName == null) {
+      throw new IllegalArgumentException("field name should not be null!");
+    }
+
+    this.fieldName = fieldName;
+
+  }
+
+  /**
+   * Returns the field name this configuration represents.
+   * 
+   * @return the field name
+   */
+  public String getField() {
+    return this.fieldName;
+  }
+
+  @Override
+  public String toString() {
+    return "<fieldconfig name=\"" + this.fieldName + "\" configurations=\""
+        + super.toString() + "\"/>";
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfigListener.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfigListener.java
new file mode 100644
index 0000000..a1f7911
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfigListener.java
@@ -0,0 +1,38 @@
+package org.apache.lucene.queryparser.flexible.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This interface should be implemented by classes that wants to listen for
+ * field configuration requests. The implementation receives a
+ * {@link FieldConfig} object and may add/change its configuration.
+ * 
+ * @see FieldConfig
+ * @see QueryConfigHandler
+ */
+public interface FieldConfigListener {
+
+  /**
+   * This method is called ever time a field configuration is requested.
+   * 
+   * @param fieldConfig
+   *          the field configuration requested, should never be null
+   */
+  void buildFieldConfig(FieldConfig fieldConfig);
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/QueryConfigHandler.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/QueryConfigHandler.java
new file mode 100644
index 0000000..b60bdbe
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/QueryConfigHandler.java
@@ -0,0 +1,80 @@
+package org.apache.lucene.queryparser.flexible.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.LinkedList;
+
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor;
+import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+
+/**
+ * This class can be used to hold any query configuration and no field
+ * configuration. For field configuration, it creates an empty
+ * {@link FieldConfig} object and delegate it to field config listeners, 
+ * these are responsible for setting up all the field configuration.
+ * 
+ * {@link QueryConfigHandler} should be extended by classes that intends to
+ * provide configuration to {@link QueryNodeProcessor} objects.
+ * 
+ * The class that extends {@link QueryConfigHandler} should also provide
+ * {@link FieldConfig} objects for each collection field.
+ * 
+ * @see FieldConfig
+ * @see FieldConfigListener
+ * @see QueryConfigHandler
+ */
+public abstract class QueryConfigHandler extends AbstractQueryConfig {
+  
+  final private LinkedList<FieldConfigListener> listeners = new LinkedList<FieldConfigListener>();
+
+  /**
+   * Returns an implementation of
+   * {@link FieldConfig} for a specific field name. If the implemented
+   * {@link QueryConfigHandler} does not know a specific field name, it may
+   * return <code>null</code>, indicating there is no configuration for that
+   * field.
+   * 
+   * @param fieldName
+   *          the field name
+   * @return a {@link FieldConfig} object containing the field name
+   *         configuration or <code>null</code>, if the implemented
+   *         {@link QueryConfigHandler} has no configuration for that field
+   */
+  public FieldConfig getFieldConfig(String fieldName) {
+    FieldConfig fieldConfig = new FieldConfig(StringUtils.toString(fieldName));
+
+    for (FieldConfigListener listener : this.listeners) {
+      listener.buildFieldConfig(fieldConfig);
+    }
+
+    return fieldConfig;
+
+  }
+
+  /**
+   * Adds a listener. The added listeners are called in the order they are
+   * added.
+   * 
+   * @param listener
+   *          the listener to be added
+   */
+  public void addFieldConfigListener(FieldConfigListener listener) {
+    this.listeners.add(listener);
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/package.html
new file mode 100644
index 0000000..1440765
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/package.html
@@ -0,0 +1,43 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+Contains the base classes used to configure the query processing
+
+<h2>Query Configuration Interfaces</h2>
+<p>
+The package <tt>org.apache.lucene.queryparser.flexible.config</tt> contains query configuration handler
+abstract class that all config handlers should extend.
+</p>
+<p>
+See {@link org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler} for a reference
+implementation.
+</p>
+<p>
+The {@link org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler} and {@link org.apache.lucene.queryparser.flexible.core.config.FieldConfig} are used in the processors to access config
+information in a flexible and independent way.
+See {@link org.apache.lucene.queryparser.flexible.standard.processors.ParametricRangeQueryNodeProcessor} for a 
+reference implementation.
+</p>
+</body>
+</html>
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/messages/QueryParserMessages.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/messages/QueryParserMessages.java
new file mode 100644
index 0000000..de06b30
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/messages/QueryParserMessages.java
@@ -0,0 +1,58 @@
+package org.apache.lucene.queryparser.flexible.core.messages;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.messages.NLS;
+
+/**
+ * Flexible Query Parser message bundle class
+ */
+public class QueryParserMessages extends NLS {
+
+  private static final String BUNDLE_NAME = QueryParserMessages.class.getName();
+
+  private QueryParserMessages() {
+    // Do not instantiate
+  }
+
+  static {
+    // register all string ids with NLS class and initialize static string
+    // values
+    NLS.initializeMessages(BUNDLE_NAME, QueryParserMessages.class);
+  }
+
+  // static string must match the strings in the property files.
+  public static String INVALID_SYNTAX;
+  public static String INVALID_SYNTAX_CANNOT_PARSE;
+  public static String INVALID_SYNTAX_FUZZY_LIMITS;
+  public static String INVALID_SYNTAX_FUZZY_EDITS;
+  public static String INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION;
+  public static String INVALID_SYNTAX_ESCAPE_CHARACTER;
+  public static String INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE;
+  public static String NODE_ACTION_NOT_SUPPORTED;
+  public static String PARAMETER_VALUE_NOT_SUPPORTED;
+  public static String LUCENE_QUERY_CONVERSION_ERROR;
+  public static String EMPTY_MESSAGE;
+  public static String WILDCARD_NOT_SUPPORTED;
+  public static String TOO_MANY_BOOLEAN_CLAUSES;
+  public static String LEADING_WILDCARD_NOT_ALLOWED;
+  public static String COULD_NOT_PARSE_NUMBER;
+  public static String NUMBER_CLASS_NOT_SUPPORTED_BY_NUMERIC_RANGE_QUERY;
+  public static String UNSUPPORTED_NUMERIC_DATA_TYPE;
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/messages/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/messages/package.html
new file mode 100644
index 0000000..c05fa7e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/messages/package.html
@@ -0,0 +1,31 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+Contains messages usually used by query parser implementations
+
+<h2>Query Parser Messages</h2>
+
+Messages for the Flexible Query Parser, they use <tt>org.apache.lucene.messages.NLS</tt> API.
+
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/AndQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/AndQueryNode.java
new file mode 100644
index 0000000..430395b
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/AndQueryNode.java
@@ -0,0 +1,78 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+import java.util.List;
+
+
+/**
+ * A {@link AndQueryNode} represents an AND boolean operation performed on a
+ * list of nodes.
+ */
+public class AndQueryNode extends BooleanQueryNode {
+
+  /**
+   * @param clauses
+   *          - the query nodes to be and'ed
+   */
+  public AndQueryNode(List<QueryNode> clauses) {
+    super(clauses);
+    if ((clauses == null) || (clauses.size() == 0)) {
+      throw new IllegalArgumentException(
+          "AND query must have at least one clause");
+    }
+  }
+
+  @Override
+  public String toString() {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "<boolean operation='and'/>";
+    StringBuilder sb = new StringBuilder();
+    sb.append("<boolean operation='and'>");
+    for (QueryNode child : getChildren()) {
+      sb.append("\n");
+      sb.append(child.toString());
+
+    }
+    sb.append("\n</boolean>");
+    return sb.toString();
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "";
+
+    StringBuilder sb = new StringBuilder();
+    String filler = "";
+    for (QueryNode child : getChildren()) {
+      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
+      filler = " AND ";
+    }
+
+    // in case is root or the parent is a group node avoid parenthesis
+    if ((getParent() != null && getParent() instanceof GroupQueryNode)
+        || isRoot())
+      return sb.toString();
+    else
+      return "( " + sb.toString() + " )";
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/AnyQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/AnyQueryNode.java
new file mode 100644
index 0000000..22ad5b4
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/AnyQueryNode.java
@@ -0,0 +1,145 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+import java.util.List;
+
+
+/**
+ * A {@link AnyQueryNode} represents an ANY operator performed on a list of
+ * nodes.
+ */
+public class AnyQueryNode extends AndQueryNode {
+  private CharSequence field = null;
+  private int minimumMatchingmElements = 0;
+
+  /**
+   * @param clauses
+   *          - the query nodes to be or'ed
+   */
+  public AnyQueryNode(List<QueryNode> clauses, CharSequence field,
+      int minimumMatchingElements) {
+    super(clauses);
+    this.field = field;
+    this.minimumMatchingmElements = minimumMatchingElements;
+
+    if (clauses != null) {
+
+      for (QueryNode clause : clauses) {
+
+        if (clause instanceof FieldQueryNode) {
+
+          if (clause instanceof QueryNodeImpl) {
+            ((QueryNodeImpl) clause).toQueryStringIgnoreFields = true;
+          }
+
+          if (clause instanceof FieldableNode) {
+            ((FieldableNode) clause).setField(field);
+          }
+
+        }
+      }
+
+    }
+
+  }
+
+  public int getMinimumMatchingElements() {
+    return this.minimumMatchingmElements;
+  }
+
+  /**
+   * returns null if the field was not specified
+   * 
+   * @return the field
+   */
+  public CharSequence getField() {
+    return this.field;
+  }
+
+  /**
+   * returns - null if the field was not specified
+   * 
+   * @return the field as a String
+   */
+  public String getFieldAsString() {
+    if (this.field == null)
+      return null;
+    else
+      return this.field.toString();
+  }
+
+  /**
+   * @param field
+   *          - the field to set
+   */
+  public void setField(CharSequence field) {
+    this.field = field;
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    AnyQueryNode clone = (AnyQueryNode) super.cloneTree();
+
+    clone.field = this.field;
+    clone.minimumMatchingmElements = this.minimumMatchingmElements;
+
+    return clone;
+  }
+
+  @Override
+  public String toString() {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "<any field='" + this.field + "'  matchelements="
+          + this.minimumMatchingmElements + "/>";
+    StringBuilder sb = new StringBuilder();
+    sb.append("<any field='" + this.field + "'  matchelements="
+        + this.minimumMatchingmElements + ">");
+    for (QueryNode clause : getChildren()) {
+      sb.append("\n");
+      sb.append(clause.toString());
+    }
+    sb.append("\n</any>");
+    return sb.toString();
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    String anySTR = "ANY " + this.minimumMatchingmElements;
+
+    StringBuilder sb = new StringBuilder();
+    if (getChildren() == null || getChildren().size() == 0) {
+      // no childs case
+    } else {
+      String filler = "";
+      for (QueryNode clause : getChildren()) {
+        sb.append(filler).append(clause.toQueryString(escapeSyntaxParser));
+        filler = " ";
+      }
+    }
+
+    if (isDefaultField(this.field)) {
+      return "( " + sb.toString() + " ) " + anySTR;
+    } else {
+      return this.field + ":(( " + sb.toString() + " ) " + anySTR + ")";
+    }
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/BooleanQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/BooleanQueryNode.java
new file mode 100644
index 0000000..3b60919
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/BooleanQueryNode.java
@@ -0,0 +1,84 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+import java.util.List;
+
+
+/**
+ * A {@link BooleanQueryNode} represents a list of elements which do not have an
+ * explicit boolean operator defined between them. It can be used to express a
+ * boolean query that intends to use the default boolean operator.
+ */
+public class BooleanQueryNode extends QueryNodeImpl {
+
+  /**
+   * @param clauses
+   *          - the query nodes to be and'ed
+   */
+  public BooleanQueryNode(List<QueryNode> clauses) {
+    setLeaf(false);
+    allocate();
+    set(clauses);
+  }
+
+  @Override
+  public String toString() {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "<boolean operation='default'/>";
+    StringBuilder sb = new StringBuilder();
+    sb.append("<boolean operation='default'>");
+    for (QueryNode child : getChildren()) {
+      sb.append("\n");
+      sb.append(child.toString());
+    }
+    sb.append("\n</boolean>");
+    return sb.toString();
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "";
+
+    StringBuilder sb = new StringBuilder();
+    String filler = "";
+    for (QueryNode child : getChildren()) {
+      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
+      filler = " ";
+    }
+
+    // in case is root or the parent is a group node avoid parenthesis
+    if ((getParent() != null && getParent() instanceof GroupQueryNode)
+        || isRoot())
+      return sb.toString();
+    else
+      return "( " + sb.toString() + " )";
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    BooleanQueryNode clone = (BooleanQueryNode) super.cloneTree();
+
+    // nothing to do here
+
+    return clone;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/BoostQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/BoostQueryNode.java
new file mode 100644
index 0000000..eb0bc62
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/BoostQueryNode.java
@@ -0,0 +1,122 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link BoostQueryNode} boosts the QueryNode tree which is under this node.
+ * So, it must only and always have one child.
+ * 
+ * The boost value may vary from 0.0 to 1.0.
+ * 
+ */
+public class BoostQueryNode extends QueryNodeImpl {
+
+  private float value = 0;
+
+  /**
+   * Constructs a boost node
+   * 
+   * @param query
+   *          the query to be boosted
+   * @param value
+   *          the boost value, it may vary from 0.0 to 1.0
+   * 
+   * @throws QueryNodeException
+   */
+  public BoostQueryNode(QueryNode query, float value) throws QueryNodeException {
+    if (query == null) {
+      throw new QueryNodeError(new MessageImpl(
+          QueryParserMessages.NODE_ACTION_NOT_SUPPORTED, "query", "null"));
+    }
+
+    this.value = value;
+    setLeaf(false);
+    allocate();
+    add(query);
+  }
+
+  /**
+   * Returns the single child which this node boosts.
+   * 
+   * @return the single child which this node boosts
+   */
+  public QueryNode getChild() {
+    List<QueryNode> children = getChildren();
+
+    if (children == null || children.size() == 0) {
+      return null;
+    }
+
+    return children.get(0);
+
+  }
+
+  /**
+   * Returns the boost value. It may vary from 0.0 to 1.0.
+   * 
+   * @return the boost value
+   */
+  public float getValue() {
+    return this.value;
+  }
+
+  /**
+   * Returns the boost value parsed to a string.
+   * 
+   * @return the parsed value
+   */
+  private CharSequence getValueString() {
+    Float f = Float.valueOf(this.value);
+    if (f == f.longValue())
+      return "" + f.longValue();
+    else
+      return "" + f;
+
+  }
+
+  @Override
+  public String toString() {
+    return "<boost value='" + getValueString() + "'>" + "\n"
+        + getChild().toString() + "\n</boost>";
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChild() == null)
+      return "";
+    return getChild().toQueryString(escapeSyntaxParser) + "^"
+        + getValueString();
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    BoostQueryNode clone = (BoostQueryNode) super.cloneTree();
+
+    clone.value = this.value;
+
+    return clone;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/DeletedQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/DeletedQueryNode.java
new file mode 100644
index 0000000..f29201b
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/DeletedQueryNode.java
@@ -0,0 +1,52 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.processors.RemoveDeletedQueryNodesProcessor;
+
+/**
+ * A {@link DeletedQueryNode} represents a node that was deleted from the query
+ * node tree. It can be removed from the tree using the
+ * {@link RemoveDeletedQueryNodesProcessor} processor.
+ */
+public class DeletedQueryNode extends QueryNodeImpl {
+
+  public DeletedQueryNode() {
+    // empty constructor
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
+    return "[DELETEDCHILD]";
+  }
+
+  @Override
+  public String toString() {
+    return "<deleted/>";
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    DeletedQueryNode clone = (DeletedQueryNode) super.cloneTree();
+
+    return clone;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldQueryNode.java
new file mode 100644
index 0000000..e276d3b
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldQueryNode.java
@@ -0,0 +1,190 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+import java.util.Locale;
+
+
+/**
+ * A {@link FieldQueryNode} represents a element that contains field/text tuple
+ */
+public class FieldQueryNode extends QueryNodeImpl implements FieldValuePairQueryNode<CharSequence>, TextableQueryNode {
+
+  /**
+   * The term's field
+   */
+  protected CharSequence field;
+
+  /**
+   * The term's text.
+   */
+  protected CharSequence text;
+
+  /**
+   * The term's begin position.
+   */
+  protected int begin;
+
+  /**
+   * The term's end position.
+   */
+  protected int end;
+
+  /**
+   * The term's position increment.
+   */
+  protected int positionIncrement;
+
+  /**
+   * @param field
+   *          - field name
+   * @param text
+   *          - value
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public FieldQueryNode(CharSequence field, CharSequence text, int begin,
+      int end) {
+    this.field = field;
+    this.text = text;
+    this.begin = begin;
+    this.end = end;
+    this.setLeaf(true);
+
+  }
+
+  protected CharSequence getTermEscaped(EscapeQuerySyntax escaper) {
+    return escaper.escape(this.text, Locale.getDefault(), EscapeQuerySyntax.Type.NORMAL);
+  }
+
+  protected CharSequence getTermEscapeQuoted(EscapeQuerySyntax escaper) {
+    return escaper.escape(this.text, Locale.getDefault(), EscapeQuerySyntax.Type.STRING);
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
+    if (isDefaultField(this.field)) {
+      return getTermEscaped(escaper);
+    } else {
+      return this.field + ":" + getTermEscaped(escaper);
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "<field start='" + this.begin + "' end='" + this.end + "' field='"
+        + this.field + "' text='" + this.text + "'/>";
+  }
+
+  /**
+   * @return the term
+   */
+  public String getTextAsString() {
+    if (this.text == null)
+      return null;
+    else
+      return this.text.toString();
+  }
+
+  /**
+   * returns null if the field was not specified in the query string
+   * 
+   * @return the field
+   */
+  public String getFieldAsString() {
+    if (this.field == null)
+      return null;
+    else
+      return this.field.toString();
+  }
+
+  public int getBegin() {
+    return this.begin;
+  }
+
+  public void setBegin(int begin) {
+    this.begin = begin;
+  }
+
+  public int getEnd() {
+    return this.end;
+  }
+
+  public void setEnd(int end) {
+    this.end = end;
+  }
+
+  public CharSequence getField() {
+    return this.field;
+  }
+
+  public void setField(CharSequence field) {
+    this.field = field;
+  }
+
+  public int getPositionIncrement() {
+    return this.positionIncrement;
+  }
+
+  public void setPositionIncrement(int pi) {
+    this.positionIncrement = pi;
+  }
+
+  /**
+   * Returns the term.
+   * 
+   * @return The "original" form of the term.
+   */
+  public CharSequence getText() {
+    return this.text;
+  }
+
+  /**
+   * @param text
+   *          the text to set
+   */
+  public void setText(CharSequence text) {
+    this.text = text;
+  }
+
+  @Override
+  public FieldQueryNode cloneTree() throws CloneNotSupportedException {
+    FieldQueryNode fqn = (FieldQueryNode) super.cloneTree();
+    fqn.begin = this.begin;
+    fqn.end = this.end;
+    fqn.field = this.field;
+    fqn.text = this.text;
+    fqn.positionIncrement = this.positionIncrement;
+    fqn.toQueryStringIgnoreFields = this.toQueryStringIgnoreFields;
+
+    return fqn;
+
+  }
+
+	public CharSequence getValue() {
+		return getText();
+	}
+
+	public void setValue(CharSequence value) {
+		setText(value);
+	}
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldValuePairQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldValuePairQueryNode.java
new file mode 100644
index 0000000..87adff4
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldValuePairQueryNode.java
@@ -0,0 +1,22 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface FieldValuePairQueryNode<T extends Object> extends FieldableNode, ValueQueryNode<T> {
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldableNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldableNode.java
new file mode 100644
index 0000000..f069215
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldableNode.java
@@ -0,0 +1,45 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * A query node implements {@link FieldableNode} interface to indicate that its
+ * children and itself are associated to a specific field.
+ * 
+ * If it has any children which also implements this interface, it must ensure
+ * the children are associated to the same field.
+ * 
+ */
+public interface FieldableNode extends QueryNode {
+
+  /**
+   * Returns the field associated to the node and every node under it.
+   * 
+   * @return the field name
+   */
+  CharSequence getField();
+
+  /**
+   * Associates the node to a field.
+   * 
+   * @param fieldName
+   *          the field name
+   */
+  void setField(CharSequence fieldName);
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FuzzyQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FuzzyQueryNode.java
new file mode 100644
index 0000000..9a3ffcd
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FuzzyQueryNode.java
@@ -0,0 +1,99 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link FuzzyQueryNode} represents a element that contains
+ * field/text/similarity tuple
+ */
+public class FuzzyQueryNode extends FieldQueryNode {
+
+  private float similarity;
+
+  private int prefixLength;
+
+  /**
+   * @param field
+   *          Name of the field query will use.
+   * @param termStr
+   *          Term token to use for building term for the query
+   */
+  /**
+   * @param field
+   *          - Field name
+   * @param term
+   *          - Value
+   * @param minSimilarity
+   *          - similarity value
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public FuzzyQueryNode(CharSequence field, CharSequence term,
+      float minSimilarity, int begin, int end) {
+    super(field, term, begin, end);
+    this.similarity = minSimilarity;
+    setLeaf(true);
+  }
+
+  public void setPrefixLength(int prefixLength) {
+    this.prefixLength = prefixLength;
+  }
+
+  public int getPrefixLength() {
+    return this.prefixLength;
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
+    if (isDefaultField(this.field)) {
+      return getTermEscaped(escaper) + "~" + this.similarity;
+    } else {
+      return this.field + ":" + getTermEscaped(escaper) + "~" + this.similarity;
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "<fuzzy field='" + this.field + "' similarity='" + this.similarity
+        + "' term='" + this.text + "'/>";
+  }
+
+  public void setSimilarity(float similarity) {
+    this.similarity = similarity;
+  }
+
+  @Override
+  public FuzzyQueryNode cloneTree() throws CloneNotSupportedException {
+    FuzzyQueryNode clone = (FuzzyQueryNode) super.cloneTree();
+
+    clone.similarity = this.similarity;
+
+    return clone;
+  }
+
+  /**
+   * @return the similarity
+   */
+  public float getSimilarity() {
+    return this.similarity;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/GroupQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/GroupQueryNode.java
new file mode 100644
index 0000000..eef1963
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/GroupQueryNode.java
@@ -0,0 +1,83 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link GroupQueryNode} represents a location where the original user typed
+ * real parenthesis on the query string. This class is useful for queries like:
+ * a) a AND b OR c b) ( a AND b) OR c
+ * 
+ * Parenthesis might be used to define the boolean operation precedence.
+ */
+public class GroupQueryNode extends QueryNodeImpl {
+
+  /**
+   * This QueryNode is used to identify parenthesis on the original query string
+   */
+  public GroupQueryNode(QueryNode query) {
+    if (query == null) {
+      throw new QueryNodeError(new MessageImpl(
+          QueryParserMessages.PARAMETER_VALUE_NOT_SUPPORTED, "query", "null"));
+    }
+
+    allocate();
+    setLeaf(false);
+    add(query);
+  }
+
+  public QueryNode getChild() {
+    return getChildren().get(0);
+  }
+
+  @Override
+  public String toString() {
+    return "<group>" + "\n" + getChild().toString() + "\n</group>";
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChild() == null)
+      return "";
+
+    return "( " + getChild().toQueryString(escapeSyntaxParser) + " )";
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    GroupQueryNode clone = (GroupQueryNode) super.cloneTree();
+
+    return clone;
+  }
+
+  /**
+   * @param child
+   */
+  public void setChild(QueryNode child) {
+    List<QueryNode> list = new ArrayList<QueryNode>();
+    list.add(child);
+    this.set(list);
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/MatchAllDocsQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/MatchAllDocsQueryNode.java
new file mode 100644
index 0000000..ffcf8a7
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/MatchAllDocsQueryNode.java
@@ -0,0 +1,49 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link MatchAllDocsQueryNode} indicates that a query node tree or subtree
+ * will match all documents if executed in the index.
+ */
+public class MatchAllDocsQueryNode extends QueryNodeImpl {
+
+  public MatchAllDocsQueryNode() {
+    // empty constructor
+  }
+
+  @Override
+  public String toString() {
+    return "<matchAllDocs field='*' term='*'/>";
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    return "*:*";
+  }
+
+  @Override
+  public MatchAllDocsQueryNode cloneTree() throws CloneNotSupportedException {
+    MatchAllDocsQueryNode clone = (MatchAllDocsQueryNode) super.cloneTree();
+
+    // nothing to clone
+
+    return clone;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/MatchNoDocsQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/MatchNoDocsQueryNode.java
new file mode 100644
index 0000000..90e8ced
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/MatchNoDocsQueryNode.java
@@ -0,0 +1,36 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * A {@link MatchNoDocsQueryNode} indicates that a query node tree or subtree
+ * will not match any documents if executed in the index.
+ * 
+ */
+public class MatchNoDocsQueryNode extends DeletedQueryNode {
+
+  public MatchNoDocsQueryNode() {
+    // empty constructor
+  }
+
+  @Override
+  public String toString() {
+    return "<matchNoDocsQueryNode/>";
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ModifierQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ModifierQueryNode.java
new file mode 100644
index 0000000..c6747ac
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ModifierQueryNode.java
@@ -0,0 +1,158 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+
+/**
+ * A {@link ModifierQueryNode} indicates the modifier value (+,-,?,NONE) for
+ * each term on the query string. For example "+t1 -t2 t3" will have a tree of:
+ * <blockquote>
+ * &lt;BooleanQueryNode&gt; &lt;ModifierQueryNode modifier="MOD_REQ"&gt; &lt;t1/&gt;
+ * &lt;/ModifierQueryNode&gt; &lt;ModifierQueryNode modifier="MOD_NOT"&gt; &lt;t2/&gt;
+ * &lt;/ModifierQueryNode&gt; &lt;t3/&gt; &lt;/BooleanQueryNode&gt;
+ * </blockquote>
+ */
+public class ModifierQueryNode extends QueryNodeImpl {
+
+  public enum Modifier {
+    MOD_NONE, MOD_NOT, MOD_REQ;
+
+    @Override
+    public String toString() {
+      switch (this) {
+      case MOD_NONE:
+        return "MOD_NONE";
+      case MOD_NOT:
+        return "MOD_NOT";
+      case MOD_REQ:
+        return "MOD_REQ";
+      }
+      // this code is never executed
+      return "MOD_DEFAULT";
+    }
+
+    public String toDigitString() {
+      switch (this) {
+      case MOD_NONE:
+        return "";
+      case MOD_NOT:
+        return "-";
+      case MOD_REQ:
+        return "+";
+      }
+      // this code is never executed
+      return "";
+    }
+
+    public String toLargeString() {
+      switch (this) {
+      case MOD_NONE:
+        return "";
+      case MOD_NOT:
+        return "NOT ";
+      case MOD_REQ:
+        return "+";
+      }
+      // this code is never executed
+      return "";
+    }
+  }
+
+  private Modifier modifier = Modifier.MOD_NONE;
+
+  /**
+   * Used to store the modifier value on the original query string
+   * 
+   * @param query
+   *          - QueryNode subtree
+   * @param mod
+   *          - Modifier Value
+   */
+  public ModifierQueryNode(QueryNode query, Modifier mod) {
+    if (query == null) {
+      throw new QueryNodeError(new MessageImpl(
+          QueryParserMessages.PARAMETER_VALUE_NOT_SUPPORTED, "query", "null"));
+    }
+
+    allocate();
+    setLeaf(false);
+    add(query);
+    this.modifier = mod;
+  }
+
+  public QueryNode getChild() {
+    return getChildren().get(0);
+  }
+
+  public Modifier getModifier() {
+    return this.modifier;
+  }
+
+  @Override
+  public String toString() {
+    return "<modifier operation='" + this.modifier.toString() + "'>" + "\n"
+        + getChild().toString() + "\n</modifier>";
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChild() == null)
+      return "";
+
+    String leftParenthensis = "";
+    String rightParenthensis = "";
+
+    if (getChild() != null && getChild() instanceof ModifierQueryNode) {
+      leftParenthensis = "(";
+      rightParenthensis = ")";
+    }
+
+    if (getChild() instanceof BooleanQueryNode) {
+      return this.modifier.toLargeString() + leftParenthensis
+          + getChild().toQueryString(escapeSyntaxParser) + rightParenthensis;
+    } else {
+      return this.modifier.toDigitString() + leftParenthensis
+          + getChild().toQueryString(escapeSyntaxParser) + rightParenthensis;
+    }
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    ModifierQueryNode clone = (ModifierQueryNode) super.cloneTree();
+
+    clone.modifier = this.modifier;
+
+    return clone;
+  }
+
+  /**
+   * @param child
+   */
+  public void setChild(QueryNode child) {
+    List<QueryNode> list = new ArrayList<QueryNode>();
+    list.add(child);
+    this.set(list);
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/NoTokenFoundQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/NoTokenFoundQueryNode.java
new file mode 100644
index 0000000..b5e503a
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/NoTokenFoundQueryNode.java
@@ -0,0 +1,50 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link NoTokenFoundQueryNode} is used if a term is convert into no tokens
+ * by the tokenizer/lemmatizer/analyzer (null).
+ */
+public class NoTokenFoundQueryNode extends DeletedQueryNode {
+
+  public NoTokenFoundQueryNode() {
+    super();
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
+    return "[NTF]";
+  }
+
+  @Override
+  public String toString() {
+    return "<notokenfound/>";
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    NoTokenFoundQueryNode clone = (NoTokenFoundQueryNode) super.cloneTree();
+
+    // nothing to do here
+
+    return clone;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/NumberQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/NumberQueryNode.java
new file mode 100644
index 0000000..ce94f15
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/NumberQueryNode.java
@@ -0,0 +1,26 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
+ * licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+public interface NumberQueryNode {
+  
+  void setNumber(Number number);
+  
+  Number getNumber();
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/OpaqueQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/OpaqueQueryNode.java
new file mode 100644
index 0000000..4edcf89
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/OpaqueQueryNode.java
@@ -0,0 +1,80 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link OpaqueQueryNode} is used for specify values that are not supposed to
+ * be parsed by the parser. For example: and XPATH query in the middle of a
+ * query string a b @xpath:'/bookstore/book[1]/title' c d
+ */
+public class OpaqueQueryNode extends QueryNodeImpl {
+
+  private CharSequence schema = null;
+
+  private CharSequence value = null;
+
+  /**
+   * @param schema
+   *          - schema identifier
+   * @param value
+   *          - value that was not parsed
+   */
+  public OpaqueQueryNode(CharSequence schema, CharSequence value) {
+    this.setLeaf(true);
+
+    this.schema = schema;
+    this.value = value;
+
+  }
+
+  @Override
+  public String toString() {
+    return "<opaque schema='" + this.schema + "' value='" + this.value + "'/>";
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    return "@" + this.schema + ":'" + this.value + "'";
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    OpaqueQueryNode clone = (OpaqueQueryNode) super.cloneTree();
+
+    clone.schema = this.schema;
+    clone.value = this.value;
+
+    return clone;
+  }
+
+  /**
+   * @return the schema
+   */
+  public CharSequence getSchema() {
+    return this.schema;
+  }
+
+  /**
+   * @return the value
+   */
+  public CharSequence getValue() {
+    return this.value;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/OrQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/OrQueryNode.java
new file mode 100644
index 0000000..eed480c
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/OrQueryNode.java
@@ -0,0 +1,78 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link OrQueryNode} represents an OR boolean operation performed on a list
+ * of nodes.
+ * 
+ */
+public class OrQueryNode extends BooleanQueryNode {
+
+  /**
+   * @param clauses
+   *          - the query nodes to be or'ed
+   */
+  public OrQueryNode(List<QueryNode> clauses) {
+    super(clauses);
+    if ((clauses == null) || (clauses.size() == 0)) {
+      throw new IllegalArgumentException(
+          "OR query must have at least one clause");
+    }
+  }
+
+  @Override
+  public String toString() {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "<boolean operation='or'/>";
+    StringBuilder sb = new StringBuilder();
+    sb.append("<boolean operation='or'>");
+    for (QueryNode child : getChildren()) {
+      sb.append("\n");
+      sb.append(child.toString());
+
+    }
+    sb.append("\n</boolean>");
+    return sb.toString();
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "";
+
+    StringBuilder sb = new StringBuilder();
+    String filler = "";
+    for (Iterator<QueryNode> it = getChildren().iterator(); it.hasNext();) {
+      sb.append(filler).append(it.next().toQueryString(escapeSyntaxParser));
+      filler = " OR ";
+    }
+
+    // in case is root or the parent is a group node avoid parenthesis
+    if ((getParent() != null && getParent() instanceof GroupQueryNode)
+        || isRoot())
+      return sb.toString();
+    else
+      return "( " + sb.toString() + " )";
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ParametricQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ParametricQueryNode.java
new file mode 100644
index 0000000..5f02007
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ParametricQueryNode.java
@@ -0,0 +1,106 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link ParametricQueryNode} represents LE, LT, GE, GT, EQ, NE query.
+ * Example: date >= "2009-10-10" OR price = 200
+ */
+public class ParametricQueryNode extends FieldQueryNode {
+
+  private CompareOperator operator;
+
+  public enum CompareOperator {
+    LE { 
+      @Override
+      public String toString() { return "<="; }
+    },
+    LT {
+      @Override
+      public String toString() { return "<";  }
+    },
+    GE {
+      @Override
+      public String toString() { return ">="; }
+    },
+    GT {
+      @Override
+      public String toString() { return ">";  }
+    },
+    EQ {
+      @Override
+      public String toString() { return "=";  }
+    },
+    NE {
+      @Override
+      public String toString() { return "!="; }
+    };
+  }
+
+  /**
+   * @param field
+   *          - field name
+   * @param comp
+   *          - CompareOperator
+   * @param value
+   *          - text value
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public ParametricQueryNode(CharSequence field, CompareOperator comp,
+      CharSequence value, int begin, int end) {
+    super(field, value, begin, end);
+    this.operator = comp;
+    setLeaf(true);
+  }
+
+  public CharSequence getOperand() {
+    return getText();
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    return this.field + "" + this.operator.toString() + "\"" + this.text + "\"";
+  }
+
+  @Override
+  public String toString() {
+    return "<parametric field='" + this.field + "' operator='"
+        + this.operator.toString() + "' text='" + this.text + "'/>";
+  }
+
+  @Override
+  public ParametricQueryNode cloneTree() throws CloneNotSupportedException {
+    ParametricQueryNode clone = (ParametricQueryNode) super.cloneTree();
+
+    clone.operator = this.operator;
+
+    return clone;
+  }
+
+  /**
+   * @return the operator
+   */
+  public CompareOperator getOperator() {
+    return this.operator;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ParametricRangeQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ParametricRangeQueryNode.java
new file mode 100644
index 0000000..24e070a
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ParametricRangeQueryNode.java
@@ -0,0 +1,119 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+import java.util.List;
+
+
+/**
+ * A {@link ParametricRangeQueryNode} represents LE, LT, GE, GT, EQ, NE query.
+ * Example: date >= "2009-10-10" OR price = 200
+ */
+public class ParametricRangeQueryNode extends QueryNodeImpl implements
+    FieldableNode {
+
+  public ParametricRangeQueryNode(ParametricQueryNode lowerBound,
+      ParametricQueryNode upperBound) {
+
+    if (upperBound.getOperator() != ParametricQueryNode.CompareOperator.LE
+        && upperBound.getOperator() != ParametricQueryNode.CompareOperator.LT) {
+      throw new IllegalArgumentException("upper bound should have "
+          + ParametricQueryNode.CompareOperator.LE + " or " + ParametricQueryNode.CompareOperator.LT);
+    }
+
+    if (lowerBound.getOperator() != ParametricQueryNode.CompareOperator.GE
+        && lowerBound.getOperator() != ParametricQueryNode.CompareOperator.GT) {
+      throw new IllegalArgumentException("lower bound should have "
+          + ParametricQueryNode.CompareOperator.GE + " or " + ParametricQueryNode.CompareOperator.GT);
+    }
+
+    if (upperBound.getField() != lowerBound.getField()
+        || (upperBound.getField() != null && !upperBound.getField().equals(
+            lowerBound.getField()))) {
+
+      throw new IllegalArgumentException(
+          "lower and upper bounds should have the same field name!");
+
+    }
+
+    allocate();
+    setLeaf(false);
+
+    add(lowerBound);
+    add(upperBound);
+
+  }
+
+  public ParametricQueryNode getUpperBound() {
+    return (ParametricQueryNode) getChildren().get(1);
+  }
+
+  public ParametricQueryNode getLowerBound() {
+    return (ParametricQueryNode) getChildren().get(0);
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    return getLowerBound().toQueryString(escapeSyntaxParser) + " AND "
+        + getUpperBound().toQueryString(escapeSyntaxParser);
+  }
+
+  public CharSequence getField() {
+    return getLowerBound().getField();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("<parametricRange>\n\t");
+    sb.append(getUpperBound()).append("\n\t");
+    sb.append(getLowerBound()).append("\n");
+    sb.append("</parametricRange>\n");
+
+    return sb.toString();
+
+  }
+
+  @Override
+  public ParametricRangeQueryNode cloneTree() throws CloneNotSupportedException {
+    ParametricRangeQueryNode clone = (ParametricRangeQueryNode) super
+        .cloneTree();
+
+    // nothing to do here
+
+    return clone;
+  }
+
+  public void setField(CharSequence fieldName) {
+    List<QueryNode> children = getChildren();
+
+    if (children != null) {
+
+      for (QueryNode child : getChildren()) {
+
+        if (child instanceof FieldableNode) {
+          ((FieldableNode) child).setField(fieldName);
+        }
+
+      }
+
+    }
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PathQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PathQueryNode.java
new file mode 100644
index 0000000..ea89768
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PathQueryNode.java
@@ -0,0 +1,218 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax.Type;
+
+/**
+ * A {@link PathQueryNode} is used to store queries like
+ * /company/USA/California /product/shoes/brown. QueryText are objects that
+ * contain the text, begin position and end position in the query.
+ * <p>
+ * Example how the text parser creates these objects:
+ * </p>
+ * <pre>
+ * List values = ArrayList(); 
+ * values.add(new PathQueryNode.QueryText("company", 1, 7)); 
+ * values.add(new PathQueryNode.QueryText("USA", 9, 12)); 
+ * values.add(new PathQueryNode.QueryText("California", 14, 23)); 
+ * QueryNode q = new PathQueryNode(values);
+ * </pre>
+ */
+public class PathQueryNode extends QueryNodeImpl {
+
+  public static class QueryText implements Cloneable {
+    CharSequence value = null;
+    /**
+     * != null The term's begin position.
+     */
+    int begin;
+
+    /**
+     * The term's end position.
+     */
+    int end;
+
+    /**
+     * @param value
+     *          - text value
+     * @param begin
+     *          - position in the query string
+     * @param end
+     *          - position in the query string
+     */
+    public QueryText(CharSequence value, int begin, int end) {
+      super();
+      this.value = value;
+      this.begin = begin;
+      this.end = end;
+    }
+
+    @Override
+    public QueryText clone() throws CloneNotSupportedException {
+      QueryText clone = (QueryText) super.clone();
+      clone.value = this.value;
+      clone.begin = this.begin;
+      clone.end = this.end;
+      return clone;
+    }
+
+    /**
+     * @return the value
+     */
+    public CharSequence getValue() {
+      return value;
+    }
+
+    /**
+     * @return the begin
+     */
+    public int getBegin() {
+      return begin;
+    }
+
+    /**
+     * @return the end
+     */
+    public int getEnd() {
+      return end;
+    }
+
+    @Override
+    public String toString() {
+      return value + ", " + begin + ", " + end;
+    }
+  }
+
+  private List<QueryText> values = null;
+
+  /**
+   * @param pathElements
+   *          - List of QueryText objects
+   */
+  public PathQueryNode(List<QueryText> pathElements) {
+    this.values = pathElements;
+    if (pathElements.size() <= 1) {
+      // this should not happen
+      throw new RuntimeException(
+          "PathQuerynode requires more 2 or more path elements.");
+    }
+  }
+
+  /**
+   * Returns the a List with all QueryText elements
+   * 
+   * @return QueryText List size
+   */
+  public List<QueryText> getPathElements() {
+    return values;
+  }
+
+  /**
+   * Returns the a List with all QueryText elements
+   */
+  public void setPathElements(List<QueryText> elements) {
+    this.values = elements;
+  }
+
+  /**
+   * Returns the a specific QueryText element
+   * 
+   * @return QueryText List size
+   */
+  public QueryText getPathElement(int index) {
+    return values.get(index);
+  }
+
+  /**
+   * Returns the CharSequence value of a specific QueryText element
+   * 
+   * @return the CharSequence for a specific QueryText element
+   */
+  public CharSequence getFirstPathElement() {
+    return values.get(0).value;
+  }
+
+  /**
+   * Returns a List QueryText element from position startIndex
+   * 
+   * @return a List QueryText element from position startIndex
+   */
+  public List<QueryText> getPathElements(int startIndex) {
+    List<PathQueryNode.QueryText> rValues = new ArrayList<PathQueryNode.QueryText>();
+    for (int i = startIndex; i < this.values.size(); i++) {
+      try {
+        rValues.add(this.values.get(i).clone());
+      } catch (CloneNotSupportedException e) {
+        // this will not happen
+      }
+    }
+    return rValues;
+  }
+
+  private CharSequence getPathString() {
+    StringBuilder path = new StringBuilder();
+
+    for (QueryText pathelement : values) {
+      path.append("/").append(pathelement.value);
+    }
+    return path.toString();
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
+    StringBuilder path = new StringBuilder();
+    path.append("/").append(getFirstPathElement());
+
+    for (QueryText pathelement : getPathElements(1)) {
+      CharSequence value = escaper.escape(pathelement.value, Locale
+          .getDefault(), Type.STRING);
+      path.append("/\"").append(value).append("\"");
+    }
+    return path.toString();
+  }
+
+  @Override
+  public String toString() {
+    QueryText text = this.values.get(0);
+
+    return "<path start='" + text.begin + "' end='" + text.end + "' path='"
+        + getPathString() + "'/>";
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    PathQueryNode clone = (PathQueryNode) super.cloneTree();
+
+    // copy children
+    if (this.values != null) {
+      List<QueryText> localValues = new ArrayList<QueryText>();
+      for (QueryText value : this.values) {
+        localValues.add(value.clone());
+      }
+      clone.values = localValues;
+    }
+
+    return clone;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PhraseSlopQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PhraseSlopQueryNode.java
new file mode 100644
index 0000000..1751139
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PhraseSlopQueryNode.java
@@ -0,0 +1,109 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+
+public class PhraseSlopQueryNode extends QueryNodeImpl implements FieldableNode {
+
+  private int value = 0;
+
+  /**
+   * @throws QueryNodeException
+   * @throws QueryNodeParseException
+   * @exception QueryNodeParseException
+   *              throw in overridden method to disallow
+   */
+  public PhraseSlopQueryNode(QueryNode query, int value)
+      throws QueryNodeException {
+    if (query == null) {
+      throw new QueryNodeError(new MessageImpl(
+          QueryParserMessages.NODE_ACTION_NOT_SUPPORTED, "query", "null"));
+    }
+
+    this.value = value;
+    setLeaf(false);
+    allocate();
+    add(query);
+  }
+
+  public QueryNode getChild() {
+    return getChildren().get(0);
+  }
+
+  public int getValue() {
+    return this.value;
+  }
+
+  private CharSequence getValueString() {
+    Float f = Float.valueOf(this.value);
+    if (f == f.longValue())
+      return "" + f.longValue();
+    else
+      return "" + f;
+
+  }
+
+  @Override
+  public String toString() {
+    return "<phraseslop value='" + getValueString() + "'>" + "\n"
+        + getChild().toString() + "\n</phraseslop>";
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChild() == null)
+      return "";
+    return getChild().toQueryString(escapeSyntaxParser) + "~"
+        + getValueString();
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    PhraseSlopQueryNode clone = (PhraseSlopQueryNode) super.cloneTree();
+
+    clone.value = this.value;
+
+    return clone;
+  }
+
+  public CharSequence getField() {
+    QueryNode child = getChild();
+
+    if (child instanceof FieldableNode) {
+      return ((FieldableNode) child).getField();
+    }
+
+    return null;
+
+  }
+
+  public void setField(CharSequence fieldName) {
+    QueryNode child = getChild();
+
+    if (child instanceof FieldableNode) {
+      ((FieldableNode) child).setField(fieldName);
+    }
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ProximityQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ProximityQueryNode.java
new file mode 100644
index 0000000..9929d94
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ProximityQueryNode.java
@@ -0,0 +1,239 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+
+/**
+ * A {@link ProximityQueryNode} represents a query where the terms should meet
+ * specific distance conditions. (a b c) WITHIN [SENTENCE|PARAGRAPH|NUMBER]
+ * [INORDER] ("a" "b" "c") WITHIN [SENTENCE|PARAGRAPH|NUMBER] [INORDER]
+ * 
+ * TODO: Add this to the future standard Lucene parser/processor/builder
+ */
+public class ProximityQueryNode extends BooleanQueryNode {
+
+  public enum Type {
+    PARAGRAPH {
+      @Override
+      CharSequence toQueryString() { return "WITHIN PARAGRAPH"; } 
+    },
+    SENTENCE  { 
+      @Override
+      CharSequence toQueryString() { return "WITHIN SENTENCE";  }
+    },
+    NUMBER    {
+      @Override
+      CharSequence toQueryString() { return "WITHIN";           }
+    };
+
+    abstract CharSequence toQueryString();
+  }
+
+  // utility class
+  static public class ProximityType {
+    int pDistance = 0;
+
+    Type pType = null;
+
+    public ProximityType(Type type) {
+      this(type, 0);
+    }
+
+    public ProximityType(Type type, int distance) {
+      this.pType = type;
+      this.pDistance = distance;
+    }
+  }
+
+  private Type proximityType = Type.SENTENCE;
+  private int distance = -1;
+  private boolean inorder = false;
+  private CharSequence field = null;
+
+  /**
+   * @param clauses
+   *          - QueryNode children
+   * @param field
+   *          - field name
+   * @param type
+   *          - type of proximity query
+   * @param distance
+   *          - positive integer that specifies the distance
+   * @param inorder
+   *          - true, if the tokens should be matched in the order of the
+   *          clauses
+   */
+  public ProximityQueryNode(List<QueryNode> clauses, CharSequence field,
+      Type type, int distance, boolean inorder) {
+    super(clauses);
+    setLeaf(false);
+    this.proximityType = type;
+    this.inorder = inorder;
+    this.field = field;
+    if (type == Type.NUMBER) {
+      if (distance <= 0) {
+        throw new QueryNodeError(new MessageImpl(
+            QueryParserMessages.PARAMETER_VALUE_NOT_SUPPORTED, "distance",
+            distance));
+
+      } else {
+        this.distance = distance;
+      }
+
+    }
+    clearFields(clauses, field);
+  }
+
+  /**
+   * @param clauses
+   *          - QueryNode children
+   * @param field
+   *          - field name
+   * @param type
+   *          - type of proximity query
+   * @param inorder
+   *          - true, if the tokens should be matched in the order of the
+   *          clauses
+   */
+  public ProximityQueryNode(List<QueryNode> clauses, CharSequence field,
+      Type type, boolean inorder) {
+    this(clauses, field, type, -1, inorder);
+  }
+
+  static private void clearFields(List<QueryNode> nodes, CharSequence field) {
+    if (nodes == null || nodes.size() == 0)
+      return;
+
+    for (QueryNode clause : nodes) {
+
+      if (clause instanceof FieldQueryNode) {
+        ((FieldQueryNode) clause).toQueryStringIgnoreFields = true;
+        ((FieldQueryNode) clause).setField(field);
+      }
+    }
+  }
+
+  public Type getProximityType() {
+    return this.proximityType;
+  }
+
+  @Override
+  public String toString() {
+    String distanceSTR = ((this.distance == -1) ? ("")
+        : (" distance='" + this.distance) + "'");
+
+    if (getChildren() == null || getChildren().size() == 0)
+      return "<proximity field='" + this.field + "' inorder='" + this.inorder
+          + "' type='" + this.proximityType.toString() + "'" + distanceSTR
+          + "/>";
+    StringBuilder sb = new StringBuilder();
+    sb.append("<proximity field='" + this.field + "' inorder='" + this.inorder
+        + "' type='" + this.proximityType.toString() + "'" + distanceSTR + ">");
+    for (QueryNode child : getChildren()) {
+      sb.append("\n");
+      sb.append(child.toString());
+    }
+    sb.append("\n</proximity>");
+    return sb.toString();
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    String withinSTR = this.proximityType.toQueryString()
+        + ((this.distance == -1) ? ("") : (" " + this.distance))
+        + ((this.inorder) ? (" INORDER") : (""));
+
+    StringBuilder sb = new StringBuilder();
+    if (getChildren() == null || getChildren().size() == 0) {
+      // no children case
+    } else {
+      String filler = "";
+      for (QueryNode child : getChildren()) {
+        sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
+        filler = " ";
+      }
+    }
+
+    if (isDefaultField(this.field)) {
+      return "( " + sb.toString() + " ) " + withinSTR;
+    } else {
+      return this.field + ":(( " + sb.toString() + " ) " + withinSTR + ")";
+    }
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    ProximityQueryNode clone = (ProximityQueryNode) super.cloneTree();
+
+    clone.proximityType = this.proximityType;
+    clone.distance = this.distance;
+    clone.field = this.field;
+
+    return clone;
+  }
+
+  /**
+   * @return the distance
+   */
+  public int getDistance() {
+    return this.distance;
+  }
+
+  /**
+   * returns null if the field was not specified in the query string
+   * 
+   * @return the field
+   */
+  public CharSequence getField() {
+    return this.field;
+  }
+
+  /**
+   * returns null if the field was not specified in the query string
+   * 
+   * @return the field
+   */
+  public String getFieldAsString() {
+    if (this.field == null)
+      return null;
+    else
+      return this.field.toString();
+  }
+
+  /**
+   * @param field
+   *          the field to set
+   */
+  public void setField(CharSequence field) {
+    this.field = field;
+  }
+
+  /**
+   * @return terms must be matched in the specified order
+   */
+  public boolean isInOrder() {
+    return this.inorder;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNode.java
new file mode 100644
index 0000000..1e2af9e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNode.java
@@ -0,0 +1,100 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+import java.util.List;
+import java.util.Map;
+
+
+/**
+ * A {@link QueryNode} is a interface implemented by all nodes on a QueryNode
+ * tree.
+ */
+public interface QueryNode {
+
+  /** convert to a query string understood by the query parser */
+  // TODO: this interface might be changed in the future
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser);
+
+  /** for printing */
+  public String toString();
+
+  /** get Children nodes */
+  public List<QueryNode> getChildren();
+
+  /** verify if a node is a Leaf node */
+  public boolean isLeaf();
+
+  /** verify if a node contains a tag */
+  public boolean containsTag(String tagName);
+  
+  /**
+   * @param tagName
+   * @return of stored on under that tag name
+   */
+  public Object getTag(String tagName);
+  
+  public QueryNode getParent();
+
+  /**
+   * Recursive clone the QueryNode tree The tags are not copied to the new tree
+   * when you call the cloneTree() method
+   * 
+   * @return the cloned tree
+   * @throws CloneNotSupportedException
+   */
+  public QueryNode cloneTree() throws CloneNotSupportedException;
+
+  // Below are the methods that can change state of a QueryNode
+  // Write Operations (not Thread Safe)
+
+  // add a new child to a non Leaf node
+  public void add(QueryNode child);
+
+  public void add(List<QueryNode> children);
+
+  // reset the children of a node
+  public void set(List<QueryNode> children);
+
+  /**
+   * Associate the specified value with the specified tagName. If the tagName
+   * already exists, the old value is replaced. The tagName and value cannot be
+   * null. tagName will be converted to lowercase.
+   * 
+   * @param tagName
+   * @param value
+   */
+  public void setTag(String tagName, Object value);
+  
+  /**
+   * Unset a tag. tagName will be converted to lowercase.
+   * 
+   * @param tagName
+   */
+  public void unsetTag(String tagName);
+  
+  /**
+   * Returns a map containing all tags attached to this query node. 
+   * 
+   * @return a map containing all tags attached to this query node
+   */
+  public Map<String, Object> getTagMap();
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java
new file mode 100644
index 0000000..fba4bdc
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java
@@ -0,0 +1,232 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.Hashtable;
+import java.util.List;
+import java.util.Map;
+import java.util.ResourceBundle;
+
+import org.apache.lucene.messages.NLS;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+
+/**
+ * A {@link QueryNodeImpl} is the default implementation of the interface
+ * {@link QueryNode}
+ */
+public abstract class QueryNodeImpl implements QueryNode, Cloneable {
+
+  /* index default field */
+  // TODO remove PLAINTEXT_FIELD_NAME replacing it with configuration APIs
+  public static final String PLAINTEXT_FIELD_NAME = "_plain";
+
+  private boolean isLeaf = true;
+
+  private Hashtable<String, Object> tags = new Hashtable<String, Object>();
+
+  private List<QueryNode> clauses = null;
+
+  protected void allocate() {
+
+    if (this.clauses == null) {
+      this.clauses = new ArrayList<QueryNode>();
+
+    } else {
+      this.clauses.clear();
+    }
+
+  }
+
+  public final void add(QueryNode child) {
+
+    if (isLeaf() || this.clauses == null || child == null) {
+      throw new IllegalArgumentException(NLS
+          .getLocalizedMessage(QueryParserMessages.NODE_ACTION_NOT_SUPPORTED));
+    }
+
+    this.clauses.add(child);
+    ((QueryNodeImpl) child).setParent(this);
+
+  }
+
+  public final void add(List<QueryNode> children) {
+
+    if (isLeaf() || this.clauses == null) {
+      throw new IllegalArgumentException(NLS
+          .getLocalizedMessage(QueryParserMessages.NODE_ACTION_NOT_SUPPORTED));
+    }
+
+    for (QueryNode child : children) {
+      add(child);
+    }
+
+  }
+
+  public boolean isLeaf() {
+    return this.isLeaf;
+  }
+
+  public final void set(List<QueryNode> children) {
+
+    if (isLeaf() || this.clauses == null) {
+      ResourceBundle bundle = ResourceBundle
+          .getBundle("org.apache.lucene.queryParser.messages.QueryParserMessages");
+      String message = bundle.getObject("Q0008E.NODE_ACTION_NOT_SUPPORTED")
+          .toString();
+
+      throw new IllegalArgumentException(message);
+
+    }
+
+    // reset parent value
+    for (QueryNode child : children) {
+
+      ((QueryNodeImpl) child).setParent(null);
+
+    }
+
+    // allocate new children list
+    allocate();
+
+    // add new children and set parent
+    for (QueryNode child : children) {
+      add(child);
+    }
+  }
+
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    QueryNodeImpl clone = (QueryNodeImpl) super.clone();
+    clone.isLeaf = this.isLeaf;
+
+    // Reset all tags
+    clone.tags = new Hashtable<String, Object>();
+
+    // copy children
+    if (this.clauses != null) {
+      List<QueryNode> localClauses = new ArrayList<QueryNode>();
+      for (QueryNode clause : this.clauses) {
+        localClauses.add(clause.cloneTree());
+      }
+      clone.clauses = localClauses;
+    }
+
+    return clone;
+  }
+
+  @Override
+  public Object clone() throws CloneNotSupportedException {
+    return cloneTree();
+  }
+
+  protected void setLeaf(boolean isLeaf) {
+    this.isLeaf = isLeaf;
+  }
+
+  /**
+   * @return a List for QueryNode object. Returns null, for nodes that do not
+   *         contain children. All leaf Nodes return null.
+   */
+  public final List<QueryNode> getChildren() {
+    if (isLeaf() || this.clauses == null) {
+      return null;
+    }
+    return this.clauses;
+  }
+
+  public void setTag(String tagName, Object value) {
+    this.tags.put(tagName.toLowerCase(), value);
+  }
+
+  public void unsetTag(String tagName) {
+    this.tags.remove(tagName.toLowerCase());
+  }
+
+  /** verify if a node contains a tag */
+  public boolean containsTag(String tagName) {
+    return this.tags.containsKey(tagName.toLowerCase());
+  }
+
+  public Object getTag(String tagName) {
+    return this.tags.get(tagName.toString().toLowerCase());
+  }
+
+  private QueryNode parent = null;
+
+  private void setParent(QueryNode parent) {
+    this.parent = parent;
+  }
+
+  public QueryNode getParent() {
+    return this.parent;
+  }
+
+  protected boolean isRoot() {
+    return getParent() == null;
+  }
+
+  /**
+   * If set to true the the method toQueryString will not write field names
+   */
+  protected boolean toQueryStringIgnoreFields = false;
+
+  /**
+   * This method is use toQueryString to detect if fld is the default field
+   * 
+   * @param fld - field name
+   * @return true if fld is the default field
+   */
+  // TODO: remove this method, it's commonly used by {@link
+  // #toQueryString(org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax)}
+  // to figure out what is the default field, however, {@link
+  // #toQueryString(org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax)}
+  // should receive the default field value directly by parameter
+  protected boolean isDefaultField(CharSequence fld) {
+    if (this.toQueryStringIgnoreFields)
+      return true;
+    if (fld == null)
+      return true;
+    if (QueryNodeImpl.PLAINTEXT_FIELD_NAME.equals(StringUtils.toString(fld)))
+      return true;
+    return false;
+  }
+
+  /**
+   * Every implementation of this class should return pseudo xml like this:
+   * 
+   * For FieldQueryNode: <field start='1' end='2' field='subject' text='foo'/>
+   * 
+   * @see org.apache.lucene.queryparser.flexible.core.nodes.QueryNode#toString()
+   */
+  @Override
+  public String toString() {
+    return super.toString();
+  }
+
+  /**
+   * Returns a map containing all tags attached to this query node.
+   * 
+   * @return a map containing all tags attached to this query node
+   */
+  @SuppressWarnings("unchecked")
+  public Map<String, Object> getTagMap() {
+    return (Map<String, Object>) this.tags.clone();
+  }
+
+} // end class QueryNodeImpl
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QuotedFieldQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QuotedFieldQueryNode.java
new file mode 100644
index 0000000..9e2f7cf
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QuotedFieldQueryNode.java
@@ -0,0 +1,65 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link QuotedFieldQueryNode} represents phrase query. Example:
+ * "life is great"
+ */
+public class QuotedFieldQueryNode extends FieldQueryNode {
+
+  /**
+   * @param field
+   *          - field name
+   * @param text
+   *          - value
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public QuotedFieldQueryNode(CharSequence field, CharSequence text, int begin,
+      int end) {
+    super(field, text, begin, end);
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
+    if (isDefaultField(this.field)) {
+      return "\"" + getTermEscapeQuoted(escaper) + "\"";
+    } else {
+      return this.field + ":" + "\"" + getTermEscapeQuoted(escaper) + "\"";
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "<quotedfield start='" + this.begin + "' end='" + this.end
+        + "' field='" + this.field + "' term='" + this.text + "'/>";
+  }
+
+  @Override
+  public QuotedFieldQueryNode cloneTree() throws CloneNotSupportedException {
+    QuotedFieldQueryNode clone = (QuotedFieldQueryNode) super.cloneTree();
+    // nothing to do here
+    return clone;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/SlopQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/SlopQueryNode.java
new file mode 100644
index 0000000..e47912b
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/SlopQueryNode.java
@@ -0,0 +1,116 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+
+/**
+ * A {@link SlopQueryNode} represents phrase query with a slop.
+ * 
+ * From Lucene FAQ: Is there a way to use a proximity operator (like near or
+ * within) with Lucene? There is a variable called slop that allows you to
+ * perform NEAR/WITHIN-like queries. By default, slop is set to 0 so that only
+ * exact phrases will match. When using TextParser you can use this syntax to
+ * specify the slop: "doug cutting"~2 will find documents that contain
+ * "doug cutting" as well as ones that contain "cutting doug".
+ */
+public class SlopQueryNode extends QueryNodeImpl implements FieldableNode {
+
+  private int value = 0;
+
+  /**
+   * @param query
+   *          - QueryNode Tree with the phrase
+   * @param value
+   *          - slop value
+   */
+  public SlopQueryNode(QueryNode query, int value) {
+    if (query == null) {
+      throw new QueryNodeError(new MessageImpl(
+          QueryParserMessages.NODE_ACTION_NOT_SUPPORTED, "query", "null"));
+    }
+
+    this.value = value;
+    setLeaf(false);
+    allocate();
+    add(query);
+  }
+
+  public QueryNode getChild() {
+    return getChildren().get(0);
+  }
+
+  public int getValue() {
+    return this.value;
+  }
+
+  private CharSequence getValueString() {
+    Float f = Float.valueOf(this.value);
+    if (f == f.longValue())
+      return "" + f.longValue();
+    else
+      return "" + f;
+
+  }
+
+  @Override
+  public String toString() {
+    return "<slop value='" + getValueString() + "'>" + "\n"
+        + getChild().toString() + "\n</slop>";
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChild() == null)
+      return "";
+    return getChild().toQueryString(escapeSyntaxParser) + "~"
+        + getValueString();
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    SlopQueryNode clone = (SlopQueryNode) super.cloneTree();
+
+    clone.value = this.value;
+
+    return clone;
+  }
+
+  public CharSequence getField() {
+    QueryNode child = getChild();
+
+    if (child instanceof FieldableNode) {
+      return ((FieldableNode) child).getField();
+    }
+
+    return null;
+
+  }
+
+  public void setField(CharSequence fieldName) {
+    QueryNode child = getChild();
+
+    if (child instanceof FieldableNode) {
+      ((FieldableNode) child).setField(fieldName);
+    }
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/TextableQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/TextableQueryNode.java
new file mode 100644
index 0000000..fa05986
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/TextableQueryNode.java
@@ -0,0 +1,29 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
+ * licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+/**
+ * 
+ */
+public interface TextableQueryNode {
+
+  CharSequence getText();
+
+  void setText(CharSequence text);
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/TokenizedPhraseQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/TokenizedPhraseQueryNode.java
new file mode 100644
index 0000000..9a09105
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/TokenizedPhraseQueryNode.java
@@ -0,0 +1,104 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link TokenizedPhraseQueryNode} represents a node created by a code that
+ * tokenizes/lemmatizes/analyzes.
+ */
+public class TokenizedPhraseQueryNode extends QueryNodeImpl implements
+    FieldableNode {
+
+  public TokenizedPhraseQueryNode() {
+    setLeaf(false);
+    allocate();
+  }
+
+  @Override
+  public String toString() {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "<tokenizedphrase/>";
+    StringBuilder sb = new StringBuilder();
+    sb.append("<tokenizedtphrase>");
+    for (QueryNode child : getChildren()) {
+      sb.append("\n");
+      sb.append(child.toString());
+    }
+    sb.append("\n</tokenizedphrase>");
+    return sb.toString();
+  }
+
+  // This text representation is not re-parseable
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "";
+
+    StringBuilder sb = new StringBuilder();
+    String filler = "";
+    for (QueryNode child : getChildren()) {
+      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
+      filler = ",";
+    }
+
+    return "[TP[" + sb.toString() + "]]";
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    TokenizedPhraseQueryNode clone = (TokenizedPhraseQueryNode) super
+        .cloneTree();
+
+    // nothing to do
+
+    return clone;
+  }
+
+  public CharSequence getField() {
+    List<QueryNode> children = getChildren();
+
+    if (children == null || children.size() == 0) {
+      return null;
+
+    } else {
+      return ((FieldableNode) children.get(0)).getField();
+    }
+
+  }
+
+  public void setField(CharSequence fieldName) {
+    List<QueryNode> children = getChildren();
+
+    if (children != null) {
+
+      for (QueryNode child : getChildren()) {
+
+        if (child instanceof FieldableNode) {
+          ((FieldableNode) child).setField(fieldName);
+        }
+
+      }
+
+    }
+
+  }
+
+} // end class MultitermQueryNode
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ValueQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ValueQueryNode.java
new file mode 100644
index 0000000..c232424
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ValueQueryNode.java
@@ -0,0 +1,26 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
+ * licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+public interface ValueQueryNode<T extends Object> extends QueryNode {
+  
+  public void setValue(T value);
+  
+  public T getValue();
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/package.html
new file mode 100644
index 0000000..501e848
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/package.html
@@ -0,0 +1,89 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+Contains query nodes that are commonly used by query parser implementations 
+
+<h2>Query Nodes</h2>
+<p>
+The package <tt>org.apache.lucene.queryParser.nodes</tt> contains all the basic query nodes. The interface 
+that represents a query node is {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode}.
+</p>
+<p>
+{@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode}s are used by the text parser to create a syntax tree.
+These nodes are designed to be used by UI or other text parsers.
+The default Lucene text parser is {@link org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser},
+it implements Lucene's standard syntax.
+</p>
+<p>
+{@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} interface should be implemented by all query nodes,
+the class {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl} implements {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} and is extended
+by all current query node implementations.
+</p>
+<p>
+A query node tree can be printed to the a stream, and it generates a pseudo XML representation
+with all the nodes.
+</p>
+<p>
+A query node tree can also generate a query string that can be parsed back by the original text parser,
+at this point only the standard lucene syntax is supported.
+</p>
+<p>
+Grouping nodes:
+<ul>
+<li>AndQueryNode - used for AND operator</li>
+<li>AnyQueryNode - used for ANY operator</li>
+<li>OrQueryNode - used for OR operator</li>
+<li>BooleanQueryNode - used when no operator is specified</li>
+<li>ModifierQueryNode - used for modifier operator</li>
+<li>GroupQueryNode - used for parenthesis</li>
+<li>BoostQueryNode - used for boost operator</li>
+<li>SlopQueryNode - phrase slop</li>
+<li>FuzzyQueryNode - fuzzy node</li>
+<li>ParametricRangeQueryNode - used for parametric field:[low_value TO high_value]</li>
+<li>ProximityQueryNode - used for proximity search</li>
+<li>TokenizedPhraseQueryNode - used by tokenizers/lemmatizers/analyzers for phrases/autophrases</li>
+</ul>
+</p>
+<p>
+Leaf Nodes:
+<ul>
+<li>FieldQueryNode - field/value node</li>
+<li>PathQueryNode - {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} object used with path-like queries</li>
+<li>OpaqueQueryNode - Used as for part of the query that can be parsed by other parsers. schema/value</li> 
+<li>ParametricQueryNode - used for parametric field [>=|<=|=|<|>] value</li>
+<li>PrefixWildcardQueryNode - non-phrase wildcard query</li>
+<li>QuotedFieldQUeryNode - regular phrase node</li>
+<li>WildcardQueryNode - non-phrase wildcard query</li>
+</ul>
+</p>
+<p>
+Utility Nodes:
+<ul>
+<li>DeletedQueryNode - used by processors on optimizations</li>
+<li>MatchAllDocsQueryNode - used by processors on optimizations</li>
+<li>MatchNoDocsQueryNode - used by processors on optimizations</li>
+<li>NoTokenFoundQueryNode - used by tokenizers/lemmatizers/analyzers</li>
+</ul>
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/package.html
new file mode 100644
index 0000000..4480b65
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/package.html
@@ -0,0 +1,59 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+Contains the core classes of the flexible query parser framework  
+
+<h2>Flexible Query Parser</h2>
+
+<p>
+This package contains the necessary classes to implement a query parser.  
+</p>
+
+<p>
+A query parser is divided in at least 2 phases, text parsing and query building, and one optional phase called query processing.
+</p>
+
+<h3>First Phase: Text Parsing</h3>
+<p>
+The text parsing phase is performed by a text parser, which implements {@link org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser} interface.
+A text parser is responsible to get a query string and convert it to a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} tree,
+which is an object structure that represents the elements defined in the query string.
+</p>
+
+<h3>Second (optional) Phase: Query Processing</h3>
+<p>
+The query processing phase is performed by a query processor, which implements {@link org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor}.
+A query processor is responsible to perform any processing on a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} tree. This phase
+is optional and is used only if an extra processing, validation, query expansion, etc needs to be performed in a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} tree.
+The {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} tree can be either be generated by a text parser or programmatically created.
+</p>
+
+<h3>Third Phase: Query Building</h3>
+<p>
+The query building phase is performed by a query builder, which implements {@link org.apache.lucene.queryparser.flexible.core.builders.QueryBuilder}.
+A query builder is responsible to convert a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} tree into an arbitrary object, which
+is usually used to be executed against a search index.   
+</p>
+
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/EscapeQuerySyntax.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/EscapeQuerySyntax.java
new file mode 100644
index 0000000..ddbd126
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/EscapeQuerySyntax.java
@@ -0,0 +1,41 @@
+package org.apache.lucene.queryparser.flexible.core.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Locale;
+
+/**
+ * A parser needs to implement {@link EscapeQuerySyntax} to allow the QueryNode
+ * to escape the queries, when the toQueryString method is called.
+ */
+public interface EscapeQuerySyntax {
+  public enum Type {
+    STRING, NORMAL;
+  }
+
+  /**
+   * @param text
+   *          - text to be escaped
+   * @param locale
+   *          - locale for the current query
+   * @param type
+   *          - select the type of escape operation to use
+   * @return escaped text
+   */
+  CharSequence escape(CharSequence text, Locale locale, Type type);
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/SyntaxParser.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/SyntaxParser.java
new file mode 100644
index 0000000..29d4a98
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/SyntaxParser.java
@@ -0,0 +1,36 @@
+package org.apache.lucene.queryparser.flexible.core.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+/**
+ * A parser needs to implement {@link SyntaxParser} interface
+ */
+public interface SyntaxParser {
+  /**
+   * @param query
+   *          - query data to be parsed
+   * @param field
+   *          - default field name
+   * @return QueryNode tree
+   */
+  public QueryNode parse(CharSequence query, CharSequence field)
+      throws QueryNodeParseException;
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/package.html
new file mode 100644
index 0000000..4f91c0c
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/package.html
@@ -0,0 +1,44 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+Contains the necessary interfaces to implement text parsers
+
+<h2>Parser</h2>
+<p>
+The package <tt>org.apache.lucene.queryparser.flexible.parser</tt> contains interfaces
+that should be implemented by the parsers.
+
+Parsers produce QueryNode Trees from a string object.
+These package still needs some work to add support to for multiple parsers.
+
+Features that should be supported for the future, related with the parser:
+- QueryNode tree should be able convertible to any parser syntax.
+- The query syntax should support calling other parsers.
+- QueryNode tree created by multiple parsers.
+
+</p>
+<p>
+
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/NoChildOptimizationQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/NoChildOptimizationQueryNodeProcessor.java
new file mode 100644
index 0000000..0aaee46
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/NoChildOptimizationQueryNodeProcessor.java
@@ -0,0 +1,87 @@
+package org.apache.lucene.queryparser.flexible.core.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.*;
+
+/**
+ * <p>
+ * A {@link NoChildOptimizationQueryNodeProcessor} removes every
+ * BooleanQueryNode, BoostQueryNode, TokenizedPhraseQueryNode or
+ * ModifierQueryNode that do not have a valid children.
+ * </p>
+ * <p>
+ * Example: When the children of these nodes are removed for any reason then the
+ * nodes may become invalid.
+ * </p>
+ */
+public class NoChildOptimizationQueryNodeProcessor extends
+    QueryNodeProcessorImpl {
+
+  public NoChildOptimizationQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof BooleanQueryNode || node instanceof BoostQueryNode
+        || node instanceof TokenizedPhraseQueryNode
+        || node instanceof ModifierQueryNode) {
+
+      List<QueryNode> children = node.getChildren();
+
+      if (children != null && children.size() > 0) {
+
+        for (QueryNode child : children) {
+
+          if (!(child instanceof DeletedQueryNode)) {
+            return node;
+          }
+
+        }
+
+      }
+
+      return new MatchNoDocsQueryNode();
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessor.java
new file mode 100644
index 0000000..ad47cdc
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessor.java
@@ -0,0 +1,79 @@
+package org.apache.lucene.queryparser.flexible.core.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+/**
+ * <p>
+ * A {@link QueryNodeProcessor} is an interface for classes that process a
+ * {@link QueryNode} tree.
+ * <p>
+ * </p>
+ * The implementor of this class should perform some operation on a query node
+ * tree and return the same or another query node tree.
+ * <p>
+ * </p>
+ * It also may carry a {@link QueryConfigHandler} object that contains
+ * configuration about the query represented by the query tree or the
+ * collection/index where it's intended to be executed.
+ * <p>
+ * </p>
+ * In case there is any {@link QueryConfigHandler} associated to the query tree
+ * to be processed, it should be set using
+ * {@link QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)} before
+ * {@link QueryNodeProcessor#process(QueryNode)} is invoked.
+ * 
+ * @see QueryNode
+ * @see QueryNodeProcessor
+ * @see QueryConfigHandler
+ */
+public interface QueryNodeProcessor {
+
+  /**
+   * Processes a query node tree. It may return the same or another query tree.
+   * I should never return <code>null</code>.
+   * 
+   * @param queryTree
+   *          tree root node
+   * 
+   * @return the processed query tree
+   * 
+   * @throws QueryNodeException
+   */
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException;
+
+  /**
+   * Sets the {@link QueryConfigHandler} associated to the query tree.
+   * 
+   * @param queryConfigHandler
+   */
+  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler);
+
+  /**
+   * Returns the {@link QueryConfigHandler} associated to the query tree if any,
+   * otherwise it returns <code>null</code>
+   * 
+   * @return the {@link QueryConfigHandler} associated to the query tree if any,
+   *         otherwise it returns <code>null</code>
+   */
+  public QueryConfigHandler getQueryConfigHandler();
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessorImpl.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessorImpl.java
new file mode 100644
index 0000000..a34acf5
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessorImpl.java
@@ -0,0 +1,251 @@
+package org.apache.lucene.queryparser.flexible.core.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+/**
+ * <p>
+ * This is a default implementation for the {@link QueryNodeProcessor}
+ * interface, it's an abstract class, so it should be extended by classes that
+ * want to process a {@link QueryNode} tree.
+ * </p>
+ * <p>
+ * This class process {@link QueryNode}s from left to right in the tree. While
+ * it's walking down the tree, for every node,
+ * {@link #preProcessNode(QueryNode)} is invoked. After a node's children are
+ * processed, {@link #postProcessNode(QueryNode)} is invoked for that node.
+ * {@link #setChildrenOrder(List)} is invoked before
+ * {@link #postProcessNode(QueryNode)} only if the node has at least one child,
+ * in {@link #setChildrenOrder(List)} the implementor might redefine the
+ * children order or remove any children from the children list.
+ * </p>
+ * <p>
+ * Here is an example about how it process the nodes:
+ * </p>
+ * 
+ * <pre>
+ *      a
+ *     / \
+ *    b   e
+ *   / \
+ *  c   d
+ * </pre>
+ * 
+ * Here is the order the methods would be invoked for the tree described above:
+ * 
+ * <pre>
+ *      preProcessNode( a );
+ *      preProcessNode( b );
+ *      preProcessNode( c );
+ *      postProcessNode( c );
+ *      preProcessNode( d );
+ *      postProcessNode( d );
+ *      setChildrenOrder( bChildrenList );
+ *      postProcessNode( b );
+ *      preProcessNode( e );
+ *      postProcessNode( e );
+ *      setChildrenOrder( aChildrenList );
+ *      postProcessNode( a )
+ * </pre>
+ * 
+ * @see org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor
+ */
+public abstract class QueryNodeProcessorImpl implements QueryNodeProcessor {
+
+  private ArrayList<ChildrenList> childrenListPool = new ArrayList<ChildrenList>();
+
+  private QueryConfigHandler queryConfig;
+
+  public QueryNodeProcessorImpl() {
+    // empty constructor
+  }
+
+  public QueryNodeProcessorImpl(QueryConfigHandler queryConfigHandler) {
+    this.queryConfig = queryConfigHandler;
+  }
+
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    return processIteration(queryTree);
+  }
+
+  private QueryNode processIteration(QueryNode queryTree)
+      throws QueryNodeException {
+    queryTree = preProcessNode(queryTree);
+
+    processChildren(queryTree);
+
+    queryTree = postProcessNode(queryTree);
+
+    return queryTree;
+
+  }
+
+  /**
+   * This method is called every time a child is processed.
+   * 
+   * @param queryTree
+   *          the query node child to be processed
+   * @throws QueryNodeException
+   *           if something goes wrong during the query node processing
+   */
+  protected void processChildren(QueryNode queryTree) throws QueryNodeException {
+
+    List<QueryNode> children = queryTree.getChildren();
+    ChildrenList newChildren;
+
+    if (children != null && children.size() > 0) {
+
+      newChildren = allocateChildrenList();
+
+      try {
+
+        for (QueryNode child : children) {
+          child = processIteration(child);
+
+          if (child == null) {
+            throw new NullPointerException();
+
+          }
+
+          newChildren.add(child);
+
+        }
+
+        List<QueryNode> orderedChildrenList = setChildrenOrder(newChildren);
+
+        queryTree.set(orderedChildrenList);
+
+      } finally {
+        newChildren.beingUsed = false;
+      }
+
+    }
+
+  }
+
+  private ChildrenList allocateChildrenList() {
+    ChildrenList list = null;
+
+    for (ChildrenList auxList : this.childrenListPool) {
+
+      if (!auxList.beingUsed) {
+        list = auxList;
+        list.clear();
+
+        break;
+
+      }
+
+    }
+
+    if (list == null) {
+      list = new ChildrenList();
+      this.childrenListPool.add(list);
+
+    }
+
+    list.beingUsed = true;
+
+    return list;
+
+  }
+
+  /**
+   * For reference about this method check:
+   * {@link QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)}.
+   * 
+   * @param queryConfigHandler
+   *          the query configuration handler to be set.
+   * 
+   * @see QueryNodeProcessor#getQueryConfigHandler()
+   * @see QueryConfigHandler
+   */
+  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler) {
+    this.queryConfig = queryConfigHandler;
+  }
+
+  /**
+   * For reference about this method check:
+   * {@link QueryNodeProcessor#getQueryConfigHandler()}.
+   * 
+   * @return QueryConfigHandler the query configuration handler to be set.
+   * 
+   * @see QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)
+   * @see QueryConfigHandler
+   */
+  public QueryConfigHandler getQueryConfigHandler() {
+    return this.queryConfig;
+  }
+
+  /**
+   * This method is invoked for every node when walking down the tree.
+   * 
+   * @param node
+   *          the query node to be pre-processed
+   * 
+   * @return a query node
+   * 
+   * @throws QueryNodeException
+   *           if something goes wrong during the query node processing
+   */
+  abstract protected QueryNode preProcessNode(QueryNode node)
+      throws QueryNodeException;
+
+  /**
+   * This method is invoked for every node when walking up the tree.
+   * 
+   * @param node
+   *          node the query node to be post-processed
+   * 
+   * @return a query node
+   * 
+   * @throws QueryNodeException
+   *           if something goes wrong during the query node processing
+   */
+  abstract protected QueryNode postProcessNode(QueryNode node)
+      throws QueryNodeException;
+
+  /**
+   * This method is invoked for every node that has at least on child. It's
+   * invoked right before {@link #postProcessNode(QueryNode)} is invoked.
+   * 
+   * @param children
+   *          the list containing all current node's children
+   * 
+   * @return a new list containing all children that should be set to the
+   *         current node
+   * 
+   * @throws QueryNodeException
+   *           if something goes wrong during the query node processing
+   */
+  abstract protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException;
+
+  private static class ChildrenList extends ArrayList<QueryNode> {
+
+    boolean beingUsed;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessorPipeline.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessorPipeline.java
new file mode 100644
index 0000000..dee780c
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessorPipeline.java
@@ -0,0 +1,304 @@
+package org.apache.lucene.queryparser.flexible.core.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.*;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+/**
+ * A {@link QueryNodeProcessorPipeline} class should be used to build a query
+ * node processor pipeline.
+ * 
+ * When a query node tree is processed using this class, it passes the query
+ * node tree to each processor on the pipeline and the result from each
+ * processor is passed to the next one, always following the order the
+ * processors were on the pipeline.
+ * 
+ * When a {@link QueryConfigHandler} object is set on a
+ * {@link QueryNodeProcessorPipeline}, it also takes care of setting this
+ * {@link QueryConfigHandler} on all processor on pipeline.
+ * 
+ */
+public class QueryNodeProcessorPipeline implements QueryNodeProcessor,
+    List<QueryNodeProcessor> {
+
+  private LinkedList<QueryNodeProcessor> processors = new LinkedList<QueryNodeProcessor>();
+
+  private QueryConfigHandler queryConfig;
+
+  /**
+   * Constructs an empty query node processor pipeline.
+   */
+  public QueryNodeProcessorPipeline() {
+    // empty constructor
+  }
+
+  /**
+   * Constructs with a {@link QueryConfigHandler} object.
+   */
+  public QueryNodeProcessorPipeline(QueryConfigHandler queryConfigHandler) {
+    this.queryConfig = queryConfigHandler;
+  }
+
+  /**
+   * For reference about this method check:
+   * {@link QueryNodeProcessor#getQueryConfigHandler()}.
+   * 
+   * @return QueryConfigHandler the query configuration handler to be set.
+   * 
+   * @see QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)
+   * @see QueryConfigHandler
+   */
+  public QueryConfigHandler getQueryConfigHandler() {
+    return this.queryConfig;
+  }
+
+  /**
+   * For reference about this method check:
+   * {@link QueryNodeProcessor#process(QueryNode)}.
+   * 
+   * @param queryTree the query node tree to be processed
+   * 
+   * @throws QueryNodeException if something goes wrong during the query node
+   *         processing
+   * 
+   * @see QueryNode
+   */
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+
+    for (QueryNodeProcessor processor : this.processors) {
+      queryTree = processor.process(queryTree);
+    }
+
+    return queryTree;
+
+  }
+
+  /**
+   * For reference about this method check:
+   * {@link QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)}.
+   * 
+   * @param queryConfigHandler the query configuration handler to be set.
+   * 
+   * @see QueryNodeProcessor#getQueryConfigHandler()
+   * @see QueryConfigHandler
+   */
+  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler) {
+    this.queryConfig = queryConfigHandler;
+
+    for (QueryNodeProcessor processor : this.processors) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+
+  }
+
+  /**
+   * @see List#add(Object)
+   */
+  public boolean add(QueryNodeProcessor processor) {
+    boolean added = this.processors.add(processor);
+
+    if (added) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+
+    return added;
+
+  }
+
+  /**
+   * @see List#add(int, Object)
+   */
+  public void add(int index, QueryNodeProcessor processor) {
+    this.processors.add(index, processor);
+    processor.setQueryConfigHandler(this.queryConfig);
+
+  }
+
+  /**
+   * @see List#addAll(Collection)
+   */
+  public boolean addAll(Collection<? extends QueryNodeProcessor> c) {
+    boolean anyAdded = this.processors.addAll(c);
+
+    for (QueryNodeProcessor processor : c) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+
+    return anyAdded;
+
+  }
+
+  /**
+   * @see List#addAll(int, Collection)
+   */
+  public boolean addAll(int index, Collection<? extends QueryNodeProcessor> c) {
+    boolean anyAdded = this.processors.addAll(index, c);
+
+    for (QueryNodeProcessor processor : c) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+
+    return anyAdded;
+    
+  }
+
+  /**
+   * @see List#clear()
+   */
+  public void clear() {
+    this.processors.clear();
+  }
+
+  /**
+   * @see List#contains(Object)
+   */
+  public boolean contains(Object o) {
+    return this.processors.contains(o);
+  }
+
+  /**
+   * @see List#containsAll(Collection)
+   */
+  public boolean containsAll(Collection<?> c) {
+    return this.processors.containsAll(c);
+  }
+
+  /**
+   * @see List#get(int)
+   */
+  public QueryNodeProcessor get(int index) {
+    return this.processors.get(index);
+  }
+
+  /**
+   * @see List#indexOf(Object)
+   */
+  public int indexOf(Object o) {
+    return this.processors.indexOf(o);
+  }
+
+  /**
+   * @see List#isEmpty()
+   */
+  public boolean isEmpty() {
+    return this.processors.isEmpty();
+  }
+
+  /**
+   * @see List#iterator()
+   */
+  public Iterator<QueryNodeProcessor> iterator() {
+    return this.processors.iterator();
+  }
+
+  /**
+   * @see List#lastIndexOf(Object)
+   */
+  public int lastIndexOf(Object o) {
+    return this.processors.lastIndexOf(o);
+  }
+
+  /**
+   * @see List#listIterator()
+   */
+  public ListIterator<QueryNodeProcessor> listIterator() {
+    return this.processors.listIterator();
+  }
+
+  /**
+   * @see List#listIterator(int)
+   */
+  public ListIterator<QueryNodeProcessor> listIterator(int index) {
+    return this.processors.listIterator(index);
+  }
+
+  /**
+   * @see List#remove(Object)
+   */
+  public boolean remove(Object o) {
+    return this.processors.remove(o);
+  }
+
+  /**
+   * @see List#remove(int)
+   */
+  public QueryNodeProcessor remove(int index) {
+    return this.processors.remove(index);
+  }
+
+  /**
+   * @see List#removeAll(Collection)
+   */
+  public boolean removeAll(Collection<?> c) {
+    return this.processors.removeAll(c);
+  }
+
+  /**
+   * @see List#retainAll(Collection)
+   */
+  public boolean retainAll(Collection<?> c) {
+    return this.processors.retainAll(c);
+  }
+
+  /**
+   * @see List#set(int, Object)
+   */
+  public QueryNodeProcessor set(int index, QueryNodeProcessor processor) {
+    QueryNodeProcessor oldProcessor = this.processors.set(index, processor);
+    
+    if (oldProcessor != processor) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+    
+    return oldProcessor;
+    
+  }
+
+  /**
+   * @see List#size()
+   */
+  public int size() {
+    return this.processors.size();
+  }
+
+  /**
+   * @see List#subList(int, int)
+   */
+  public List<QueryNodeProcessor> subList(int fromIndex, int toIndex) {
+    return this.processors.subList(fromIndex, toIndex);
+  }
+
+  /**
+   * @see List#toArray(Object[])
+   */
+  public <T> T[] toArray(T[] array) {
+    return this.processors.toArray(array);
+  }
+
+  /**
+   * @see List#toArray()
+   */
+  public Object[] toArray() {
+    return this.processors.toArray();
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/RemoveDeletedQueryNodesProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/RemoveDeletedQueryNodesProcessor.java
new file mode 100644
index 0000000..dd0933c
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/RemoveDeletedQueryNodesProcessor.java
@@ -0,0 +1,113 @@
+package org.apache.lucene.queryparser.flexible.core.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.DeletedQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.MatchNoDocsQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+/**
+ * A {@link QueryNodeProcessorPipeline} class removes every instance of
+ * {@link DeletedQueryNode} from a query node tree. If the resulting root node
+ * is a {@link DeletedQueryNode}, {@link MatchNoDocsQueryNode} is returned.
+ * 
+ */
+public class RemoveDeletedQueryNodesProcessor extends QueryNodeProcessorImpl {
+
+  public RemoveDeletedQueryNodesProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    queryTree = super.process(queryTree);
+
+    if (queryTree instanceof DeletedQueryNode
+        && !(queryTree instanceof MatchNoDocsQueryNode)) {
+
+      return new MatchNoDocsQueryNode();
+
+    }
+
+    return queryTree;
+
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (!node.isLeaf()) {
+      List<QueryNode> children = node.getChildren();
+      boolean removeBoolean = false;
+
+      if (children == null || children.size() == 0) {
+        removeBoolean = true;
+
+      } else {
+        removeBoolean = true;
+
+        for (Iterator<QueryNode> it = children.iterator(); it.hasNext();) {
+
+          if (!(it.next() instanceof DeletedQueryNode)) {
+            removeBoolean = false;
+            break;
+
+          }
+
+        }
+
+      }
+
+      if (removeBoolean) {
+        return new DeletedQueryNode();
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    for (int i = 0; i < children.size(); i++) {
+
+      if (children.get(i) instanceof DeletedQueryNode) {
+        children.remove(i--);
+      }
+
+    }
+
+    return children;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/package.html
new file mode 100644
index 0000000..67fe973
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/processors/package.html
@@ -0,0 +1,57 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+Interfaces and implementations used by query node processors
+
+<h2>Query Node Processors</h2>
+<p>
+The package <tt>org.apache.lucene.queryParser.processors</tt> contains interfaces
+that should be implemented by every query node processor.
+</p>
+<p>
+The interface that every query node processor should implement is {@link org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor}.
+</p>
+<p>
+A query node processor should be used to process a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} tree.
+{@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} trees can be programmatically created or generated by a
+text parser. See {@link org.apache.lucene.queryparser.flexible.core.parser} for more details about text parsers.
+</p>
+
+<p>
+A query node processor should be used to process a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} tree.
+{@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode} trees can be programmatically created or generated by a
+text parser. See {@link org.apache.lucene.queryparser.flexible.core.parser} for more details about text parsers.
+</p>
+
+<p>
+A pipeline of processors can be assembled using {@link org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline}.
+</p>
+
+<p>
+Implementors may want to extend {@link org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl}, which simplifies
+the implementation, because it walks automatically the {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode}. See
+{@link org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl} for more details.   
+</p>
+
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/QueryNodeOperation.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/QueryNodeOperation.java
new file mode 100644
index 0000000..51b359d
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/QueryNodeOperation.java
@@ -0,0 +1,95 @@
+package org.apache.lucene.queryparser.flexible.core.util;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Allow joining 2 QueryNode Trees, into one.
+ */
+public final class QueryNodeOperation {
+  private QueryNodeOperation() {
+    // Exists only to defeat instantiation.
+  }
+
+  private enum ANDOperation {
+    BOTH, Q1, Q2, NONE
+  }
+
+  /**
+   * perform a logical and of 2 QueryNode trees. if q1 and q2 are ANDQueryNode
+   * nodes it uses head Node from q1 and adds the children of q2 to q1 if q1 is
+   * a AND node and q2 is not, add q2 as a child of the head node of q1 if q2 is
+   * a AND node and q1 is not, add q1 as a child of the head node of q2 if q1
+   * and q2 are not ANDQueryNode nodes, create a AND node and make q1 and q2
+   * children of that node if q1 or q2 is null it returns the not null node if
+   * q1 = q2 = null it returns null
+   */
+  public final static QueryNode logicalAnd(QueryNode q1, QueryNode q2) {
+    if (q1 == null)
+      return q2;
+    if (q2 == null)
+      return q1;
+
+    ANDOperation op = null;
+    if (q1 instanceof AndQueryNode && q2 instanceof AndQueryNode)
+      op = ANDOperation.BOTH;
+    else if (q1 instanceof AndQueryNode)
+      op = ANDOperation.Q1;
+    else if (q1 instanceof AndQueryNode)
+      op = ANDOperation.Q2;
+    else
+      op = ANDOperation.NONE;
+
+    try {
+      QueryNode result = null;
+      switch (op) {
+      case NONE:
+        List<QueryNode> children = new ArrayList<QueryNode>();
+        children.add(q1.cloneTree());
+        children.add(q2.cloneTree());
+        result = new AndQueryNode(children);
+        return result;
+      case Q1:
+        result = q1.cloneTree();
+        result.add(q2.cloneTree());
+        return result;
+      case Q2:
+        result = q2.cloneTree();
+        result.add(q1.cloneTree());
+        return result;
+      case BOTH:
+        result = q1.cloneTree();
+        result.add(q2.cloneTree().getChildren());
+        return result;
+      }
+    } catch (CloneNotSupportedException e) {
+      throw new QueryNodeError(e);
+    }
+
+    return null;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/StringUtils.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/StringUtils.java
new file mode 100644
index 0000000..35cf537
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/StringUtils.java
@@ -0,0 +1,33 @@
+package org.apache.lucene.queryparser.flexible.core.util;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+final public class StringUtils {
+
+  public static String toString(Object obj) {
+    
+    if (obj != null) {
+      return obj.toString();
+      
+    } else {
+      return null;
+    }
+    
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/UnescapedCharSequence.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/UnescapedCharSequence.java
new file mode 100644
index 0000000..83e5be8
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/UnescapedCharSequence.java
@@ -0,0 +1,157 @@
+package org.apache.lucene.queryparser.flexible.core.util;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * CharsSequence with escaped chars information.
+ */
+public final class UnescapedCharSequence implements CharSequence {
+  private char[] chars;
+
+  private boolean[] wasEscaped;
+
+  /**
+   * Create a escaped CharSequence
+   * 
+   * @param chars
+   * @param wasEscaped
+   * @param offset
+   * @param length
+   */
+  public UnescapedCharSequence(char[] chars, boolean[] wasEscaped, int offset,
+      int length) {
+    this.chars = new char[length];
+    this.wasEscaped = new boolean[length];
+    System.arraycopy(chars, offset, this.chars, 0, length);
+    System.arraycopy(wasEscaped, offset, this.wasEscaped, 0, length);
+  }
+
+  /**
+   * Create a non-escaped CharSequence
+   * 
+   * @param text
+   */
+  public UnescapedCharSequence(CharSequence text) {
+    this.chars = new char[text.length()];
+    this.wasEscaped = new boolean[text.length()];
+    for (int i = 0; i < text.length(); i++) {
+      this.chars[i] = text.charAt(i);
+      this.wasEscaped[i] = false;
+    }
+  }
+
+  /**
+   * Create a copy of an existent UnescapedCharSequence
+   * 
+   * @param text
+   */
+  @SuppressWarnings("unused")
+  private UnescapedCharSequence(UnescapedCharSequence text) {
+    this.chars = new char[text.length()];
+    this.wasEscaped = new boolean[text.length()];
+    for (int i = 0; i <= text.length(); i++) {
+      this.chars[i] = text.chars[i];
+      this.wasEscaped[i] = text.wasEscaped[i];
+    }
+  }
+
+  public char charAt(int index) {
+    return this.chars[index];
+  }
+
+  public int length() {
+    return this.chars.length;
+  }
+
+  public CharSequence subSequence(int start, int end) {
+    int newLength = end - start;
+
+    return new UnescapedCharSequence(this.chars, this.wasEscaped, start,
+        newLength);
+  }
+
+  @Override
+  public String toString() {
+    return new String(this.chars);
+  }
+
+  /**
+   * Return a escaped String
+   * 
+   * @return a escaped String
+   */
+  public String toStringEscaped() {
+    // non efficient implementation
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i >= this.length(); i++) {
+      if (this.chars[i] == '\\') {
+        result.append('\\');
+      } else if (this.wasEscaped[i])
+        result.append('\\');
+
+      result.append(this.chars[i]);
+    }
+    return result.toString();
+  }
+
+  /**
+   * Return a escaped String
+   * 
+   * @param enabledChars
+   *          - array of chars to be escaped
+   * @return a escaped String
+   */
+  public String toStringEscaped(char[] enabledChars) {
+    // TODO: non efficient implementation, refactor this code
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < this.length(); i++) {
+      if (this.chars[i] == '\\') {
+        result.append('\\');
+      } else {
+        for (char character : enabledChars) {
+          if (this.chars[i] == character && this.wasEscaped[i]) {
+            result.append('\\');
+            break;
+          }
+        }
+      }
+
+      result.append(this.chars[i]);
+    }
+    return result.toString();
+  }
+
+  public boolean wasEscaped(int index) {
+    return this.wasEscaped[index];
+  }
+  
+  static final public boolean wasEscaped(CharSequence text, int index) {
+    if (text instanceof UnescapedCharSequence)
+      return ((UnescapedCharSequence)text).wasEscaped[index];
+    else return false;
+  }
+  
+  public static CharSequence toLowerCase(CharSequence text) {
+    if (text instanceof UnescapedCharSequence) {
+      char[] chars = text.toString().toLowerCase().toCharArray();
+      boolean[] wasEscaped = ((UnescapedCharSequence)text).wasEscaped;
+      return new UnescapedCharSequence(chars, wasEscaped, 0, chars.length);
+    } else 
+      return new UnescapedCharSequence(text.toString().toLowerCase());
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/package.html
new file mode 100644
index 0000000..dc76a02
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/util/package.html
@@ -0,0 +1,29 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+Utility classes to used with the Query Parser
+<h2>Utility classes to used with the Query Parser</h2>
+<p>
+This package contains utility classes used with the query parsers.
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/package.html
new file mode 100644
index 0000000..d3b61fd
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/package.html
@@ -0,0 +1,142 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+   <title>Apache Lucene Flexible Query Parser</title>
+</head>
+<body>
+
+<h2>Apache Lucene Flexible Query Parser</h2>
+
+<p>
+This contrib project contains the new Lucene query parser implementation, which matches the syntax of the core QueryParser but offers a more modular architecture to enable customization.
+</p>
+
+<p>
+It's currently divided in 2 main packages:
+<ul>
+<li>{@link org.apache.lucene.queryParser.core}: it contains the query parser API classes, which should be extended by query parser implementations. </li>
+<li>{@link org.apache.lucene.queryParser.standard}: it contains the current Lucene query parser implementation using the new query parser API.</li>
+</ul>
+</p>
+
+<h3>Features</h3>
+
+    <ol>
+        <li>Full support for boolean logic (not enabled)</li>
+        <li>QueryNode Trees - support for several syntaxes, 
+            that can be converted into similar syntax QueryNode trees.</li>
+        <li>QueryNode Processors - Optimize, validate, rewrite the 
+            QueryNode trees</li>
+		<li>Processors Pipelines - Select your favorite Processor
+		    and build a processor pipeline, to implement the features you need</li>
+        <li>Config Interfaces - Allow the consumer of the Query Parser to implement
+            a diff Config Handler Objects to suite their needs.</li>
+        <li>Standard Builders - convert QueryNode's into several lucene 
+            representations. Supported conversion is using a 2.4 compatible logic</li>
+        <li>QueryNode tree's can be converted to a lucene 2.4 syntax string, using toQueryString</li>                          
+    </ol>
+
+<h3>Design</h3>
+<p>
+This new query parser was designed to have very generic
+architecture, so that it can be easily used for different
+products with varying query syntaxes. This code is much more 
+flexible and extensible than the Lucene query parser in 2.4.X.
+</p>
+<p>
+The new query parser  goal is to separate syntax and semantics of a query. E.g. 'a AND
+b', '+a +b', 'AND(a,b)' could be different syntaxes for the same query.
+It distinguishes the semantics of the different query components, e.g.
+whether and how to tokenize/lemmatize/normalize the different terms or
+which Query objects to create for the terms. It allows to
+write a parser with a new syntax, while reusing the underlying
+semantics, as quickly as possible.
+</p>
+<p>
+The query parser has three layers and its core is what we call the
+QueryNode tree. It is a tree that initially represents the syntax of the
+original query, e.g. for 'a AND b':
+</p>
+<pre>
+      AND
+     /   \
+    A     B
+</pre>
+<p>
+The three layers are:
+</p>
+<dl>
+<dt>QueryParser</dt>
+<dd>
+This layer is the text parsing layer which simply transforms the
+query text string into a {@link org.apache.lucene.queryParser.core.nodes.QueryNode} tree. Every text parser
+must implement the interface {@link org.apache.lucene.queryParser.core.parser.SyntaxParser}.
+Lucene default implementations implements it using JavaCC.
+</dd>
+
+<dt>QueryNodeProcessor</dt>
+<dd>The query node processors do most of the work. It is in fact a
+configurable chain of processors. Each processors can walk the tree and
+modify nodes or even the tree's structure. That makes it possible to
+e.g. do query optimization before the query is executed or to tokenize
+terms.
+</dd>
+
+<dt>QueryBuilder</dt>
+<dd>
+The third layer is a configurable map of builders, which map {@link org.apache.lucene.queryParser.core.nodes.QueryNode} types to its specific 
+builder that will transform the QueryNode into Lucene Query object.
+</dd>
+
+</dl>
+
+<p>
+Furthermore, the query parser uses flexible configuration objects. It also uses message classes that
+allow to attach resource bundles. This makes it possible to translate
+messages, which is an important feature of a query parser.
+</p>
+<p>
+This design allows to develop different query syntaxes very quickly.
+</p>
+
+<h3>StandardQueryParser and QueryParserWrapper</h3>
+
+<p>
+The standard (default) Lucene query parser is located under
+org.apache.lucene.queryParser.standard.
+<p>
+To make it simpler to use the new query parser 
+the class {@link org.apache.lucene.queryParser.standard.StandardQueryParser} may be helpful,
+specially for people that do not want to extend the Query Parser.
+It uses the default Lucene query processors, text parser and builders, so
+you don't need to worry about dealing with those.
+
+{@link org.apache.lucene.queryParser.standard.StandardQueryParser} usage:
+
+<pre class="prettyprint">
+      StandardQueryParser qpHelper = new StandardQueryParser();
+      StandardQueryConfigHandler config =  qpHelper.getQueryConfigHandler();
+      config.setAllowLeadingWildcard(true);
+      config.setAnalyzer(new WhitespaceAnalyzer());
+      Query query = qpHelper.parse("apache AND lucene", "defaultField");
+</pre>
+
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/PrecedenceQueryParser.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/PrecedenceQueryParser.java
new file mode 100644
index 0000000..785ae1d
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/PrecedenceQueryParser.java
@@ -0,0 +1,57 @@
+package org.apache.lucene.queryparser.flexible.precedence;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.queryparser.flexible.standard.StandardQueryParser;
+import org.apache.lucene.queryparser.flexible.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.queryparser.flexible.precedence.processors.PrecedenceQueryNodeProcessorPipeline;
+
+/**
+ * <p>
+ * This query parser works exactly as the standard query parser ( {@link StandardQueryParser} ), 
+ * except that it respect the boolean precedence, so &lt;a AND b OR c AND d&gt; is parsed to &lt;(+a +b) (+c +d)&gt;
+ * instead of &lt;+a +b +c +d&gt;.
+ * </p>
+ * <p>
+ * EXPERT: This class extends {@link StandardQueryParser}, but uses {@link PrecedenceQueryNodeProcessorPipeline}
+ * instead of {@link StandardQueryNodeProcessorPipeline} to process the query tree.
+ * </p>
+ * 
+ * @see StandardQueryParser
+ */
+public class PrecedenceQueryParser extends StandardQueryParser {
+  
+  /**
+   * @see StandardQueryParser#StandardQueryParser()
+   */
+  public PrecedenceQueryParser() {
+    setQueryNodeProcessor(new PrecedenceQueryNodeProcessorPipeline(getQueryConfigHandler()));
+  }
+  
+  /**
+   * @see StandardQueryParser#StandardQueryParser(Analyzer)
+   */
+  public PrecedenceQueryParser(Analyzer analyer) {
+    super(analyer);
+    
+    setQueryNodeProcessor(new PrecedenceQueryNodeProcessorPipeline(getQueryConfigHandler()));
+    
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/package.html
new file mode 100644
index 0000000..a9112ce
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/package.html
@@ -0,0 +1,39 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+This package contains the Precedence Query Parser Implementation
+
+<h2>Lucene Precedence Query Parser</h2>
+
+<p>
+The Precedence Query Parser extends the Standard Query Parser and enables 
+the boolean precedence. So, the query <a AND b OR c AND d> is parsed to 
+<(+a +b) (+c +d)> instead of <+a +b +c +d>.
+</p>
+<p>
+Check {@link org.apache.lucene.queryparser.flexible.standard.StandardQueryParser} for more details about the
+supported syntax and query parser functionalities. 
+</p>
+
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/BooleanModifiersQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/BooleanModifiersQueryNodeProcessor.java
new file mode 100644
index 0000000..754ba11
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/BooleanModifiersQueryNodeProcessor.java
@@ -0,0 +1,135 @@
+package org.apache.lucene.queryparser.flexible.precedence.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.precedence.PrecedenceQueryParser;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.Operator;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.*;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode.Modifier;
+
+/**
+ * <p>
+ * This processor is used to apply the correct {@link ModifierQueryNode} to {@link BooleanQueryNode}s children.
+ * </p>
+ * <p>
+ * It walks through the query node tree looking for {@link BooleanQueryNode}s. If an {@link AndQueryNode} is found,
+ * every child, which is not a {@link ModifierQueryNode} or the {@link ModifierQueryNode} 
+ * is {@link Modifier#MOD_NONE}, becomes a {@link Modifier#MOD_REQ}. For any other
+ * {@link BooleanQueryNode} which is not an {@link OrQueryNode}, it checks the default operator is {@link Operator#AND},
+ * if it is, the same operation when an {@link AndQueryNode} is found is applied to it.
+ * </p>
+ * 
+ * @see ConfigurationKeys#DEFAULT_OPERATOR
+ * @see PrecedenceQueryParser#setDefaultOperator
+ */
+public class BooleanModifiersQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  private ArrayList<QueryNode> childrenBuffer = new ArrayList<QueryNode>();
+
+  private Boolean usingAnd = false;
+
+  public BooleanModifiersQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    Operator op = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
+    
+    if (op == null) {
+      throw new IllegalArgumentException(
+          "StandardQueryConfigHandler.ConfigurationKeys.DEFAULT_OPERATOR should be set on the QueryConfigHandler");
+    }
+
+    this.usingAnd = StandardQueryConfigHandler.Operator.AND == op;
+
+    return super.process(queryTree);
+
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof AndQueryNode) {
+      this.childrenBuffer.clear();
+      List<QueryNode> children = node.getChildren();
+
+      for (QueryNode child : children) {
+        this.childrenBuffer.add(applyModifier(child, ModifierQueryNode.Modifier.MOD_REQ));
+      }
+
+      node.set(this.childrenBuffer);
+
+    } else if (this.usingAnd && node instanceof BooleanQueryNode
+        && !(node instanceof OrQueryNode)) {
+
+      this.childrenBuffer.clear();
+      List<QueryNode> children = node.getChildren();
+
+      for (QueryNode child : children) {
+        this.childrenBuffer.add(applyModifier(child, ModifierQueryNode.Modifier.MOD_REQ));
+      }
+
+      node.set(this.childrenBuffer);
+
+    }
+
+    return node;
+
+  }
+
+  private QueryNode applyModifier(QueryNode node, ModifierQueryNode.Modifier mod) {
+
+    // check if modifier is not already defined and is default
+    if (!(node instanceof ModifierQueryNode)) {
+      return new ModifierQueryNode(node, mod);
+
+    } else {
+      ModifierQueryNode modNode = (ModifierQueryNode) node;
+
+      if (modNode.getModifier() == ModifierQueryNode.Modifier.MOD_NONE) {
+        return new ModifierQueryNode(modNode.getChild(), mod);
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+    return node;
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/PrecedenceQueryNodeProcessorPipeline.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/PrecedenceQueryNodeProcessorPipeline.java
new file mode 100644
index 0000000..70be2a1
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/PrecedenceQueryNodeProcessorPipeline.java
@@ -0,0 +1,59 @@
+package org.apache.lucene.queryparser.flexible.precedence.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.precedence.PrecedenceQueryParser;
+import org.apache.lucene.queryparser.flexible.standard.processors.GroupQueryNodeProcessor;
+import org.apache.lucene.queryparser.flexible.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+
+/**
+ * <p>
+ * This processor pipeline extends {@link StandardQueryNodeProcessorPipeline} and enables
+ * boolean precedence on it.
+ * </p>
+ * <p>
+ * EXPERT: the precedence is enabled by removing {@link GroupQueryNodeProcessor} from the
+ * {@link StandardQueryNodeProcessorPipeline} and appending {@link BooleanModifiersQueryNodeProcessor}
+ * to the pipeline.
+ * </p>
+ * 
+ * @see PrecedenceQueryParser
+ *  @see StandardQueryNodeProcessorPipeline
+ */
+public class PrecedenceQueryNodeProcessorPipeline extends StandardQueryNodeProcessorPipeline {
+
+  /**
+   * @see StandardQueryNodeProcessorPipeline#StandardQueryNodeProcessorPipeline(QueryConfigHandler)
+   */
+  public PrecedenceQueryNodeProcessorPipeline(QueryConfigHandler queryConfig) {
+    super(queryConfig);
+    
+    for (int i = 0 ; i < size() ; i++) {
+      
+      if (get(i).getClass().equals(GroupQueryNodeProcessor.class)) {
+        remove(i--);
+      }
+      
+    }
+    
+    add(new BooleanModifiersQueryNodeProcessor());
+    
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/package.html
new file mode 100644
index 0000000..dfaf3a9
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/precedence/processors/package.html
@@ -0,0 +1,47 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+This package contains the processors used by Precedence Query Parser
+
+<h2>Lucene Precedence Query Parser Processors</h2>
+
+<p>
+This package contains the 2 {@link org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor}s used by
+{@link org.apache.lucene.queryparser.flexible.precedence.PrecedenceQueryParser}.
+</p>
+<p>
+{@link org.apache.lucene.queryparser.flexible.precedence.processors.BooleanModifiersQueryNodeProcessor}: this processor
+is used to apply {@link org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode}s on
+{@link org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode} children according to the boolean type
+or the default operator.
+</p>
+<p>
+{@link org.apache.lucene.queryparser.flexible.precedence.processors.PrecedenceQueryNodeProcessorPipeline}: this
+processor pipeline is used by {@link org.apache.lucene.queryparser.flexible.precedence.PrecedenceQueryParser}. It extends
+{@link org.apache.lucene.queryparser.flexible.standard.processors.StandardQueryNodeProcessorPipeline} and rearrange
+the pipeline so the boolean precedence is processed correctly. Check {@link org.apache.lucene.queryparser.flexible.precedence.processors.PrecedenceQueryNodeProcessorPipeline}
+for more details. 
+</p>
+
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/QueryParserUtil.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/QueryParserUtil.java
new file mode 100644
index 0000000..73aa6bb
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/QueryParserUtil.java
@@ -0,0 +1,206 @@
+package org.apache.lucene.queryparser.flexible.standard;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+
+/**
+ * This class defines utility methods to (help) parse query strings into
+ * {@link Query} objects.
+ */
+final public class QueryParserUtil {
+
+  /**
+   * Parses a query which searches on the fields specified.
+   * <p>
+   * If x fields are specified, this effectively constructs:
+   * 
+   * <pre>
+   * &lt;code&gt;
+   * (field1:query1) (field2:query2) (field3:query3)...(fieldx:queryx)
+   * &lt;/code&gt;
+   * </pre>
+   * 
+   * @param queries
+   *          Queries strings to parse
+   * @param fields
+   *          Fields to search on
+   * @param analyzer
+   *          Analyzer to use
+   * @throws IllegalArgumentException
+   *           if the length of the queries array differs from the length of the
+   *           fields array
+   */
+  public static Query parse(String[] queries, String[] fields, Analyzer analyzer)
+      throws QueryNodeException {
+    if (queries.length != fields.length)
+      throw new IllegalArgumentException("queries.length != fields.length");
+    BooleanQuery bQuery = new BooleanQuery();
+
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(analyzer);
+
+    for (int i = 0; i < fields.length; i++) {
+      Query q = qp.parse(queries[i], fields[i]);
+
+      if (q != null && // q never null, just being defensive
+          (!(q instanceof BooleanQuery) || ((BooleanQuery) q).getClauses().length > 0)) {
+        bQuery.add(q, BooleanClause.Occur.SHOULD);
+      }
+    }
+    return bQuery;
+  }
+
+  /**
+   * Parses a query, searching on the fields specified. Use this if you need to
+   * specify certain fields as required, and others as prohibited.
+   * <p>
+   * 
+   * <pre>
+   * Usage:
+   * &lt;code&gt;
+   * String[] fields = {&quot;filename&quot;, &quot;contents&quot;, &quot;description&quot;};
+   * BooleanClause.Occur[] flags = {BooleanClause.Occur.SHOULD,
+   *                BooleanClause.Occur.MUST,
+   *                BooleanClause.Occur.MUST_NOT};
+   * MultiFieldQueryParser.parse(&quot;query&quot;, fields, flags, analyzer);
+   * &lt;/code&gt;
+   * </pre>
+   *<p>
+   * The code above would construct a query:
+   * 
+   * <pre>
+   * &lt;code&gt;
+   * (filename:query) +(contents:query) -(description:query)
+   * &lt;/code&gt;
+   * </pre>
+   * 
+   * @param query
+   *          Query string to parse
+   * @param fields
+   *          Fields to search on
+   * @param flags
+   *          Flags describing the fields
+   * @param analyzer
+   *          Analyzer to use
+   * @throws IllegalArgumentException
+   *           if the length of the fields array differs from the length of the
+   *           flags array
+   */
+  public static Query parse(String query, String[] fields,
+      BooleanClause.Occur[] flags, Analyzer analyzer) throws QueryNodeException {
+    if (fields.length != flags.length)
+      throw new IllegalArgumentException("fields.length != flags.length");
+    BooleanQuery bQuery = new BooleanQuery();
+
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(analyzer);
+
+    for (int i = 0; i < fields.length; i++) {
+      Query q = qp.parse(query, fields[i]);
+
+      if (q != null && // q never null, just being defensive
+          (!(q instanceof BooleanQuery) || ((BooleanQuery) q).getClauses().length > 0)) {
+        bQuery.add(q, flags[i]);
+      }
+    }
+    return bQuery;
+  }
+
+  /**
+   * Parses a query, searching on the fields specified. Use this if you need to
+   * specify certain fields as required, and others as prohibited.
+   * <p>
+   * 
+   * <pre>
+   * Usage:
+   * &lt;code&gt;
+   * String[] query = {&quot;query1&quot;, &quot;query2&quot;, &quot;query3&quot;};
+   * String[] fields = {&quot;filename&quot;, &quot;contents&quot;, &quot;description&quot;};
+   * BooleanClause.Occur[] flags = {BooleanClause.Occur.SHOULD,
+   *                BooleanClause.Occur.MUST,
+   *                BooleanClause.Occur.MUST_NOT};
+   * MultiFieldQueryParser.parse(query, fields, flags, analyzer);
+   * &lt;/code&gt;
+   * </pre>
+   *<p>
+   * The code above would construct a query:
+   * 
+   * <pre>
+   * &lt;code&gt;
+   * (filename:query1) +(contents:query2) -(description:query3)
+   * &lt;/code&gt;
+   * </pre>
+   * 
+   * @param queries
+   *          Queries string to parse
+   * @param fields
+   *          Fields to search on
+   * @param flags
+   *          Flags describing the fields
+   * @param analyzer
+   *          Analyzer to use
+   * @throws IllegalArgumentException
+   *           if the length of the queries, fields, and flags array differ
+   */
+  public static Query parse(String[] queries, String[] fields,
+      BooleanClause.Occur[] flags, Analyzer analyzer) throws QueryNodeException {
+    if (!(queries.length == fields.length && queries.length == flags.length))
+      throw new IllegalArgumentException(
+          "queries, fields, and flags array have have different length");
+    BooleanQuery bQuery = new BooleanQuery();
+
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(analyzer);
+
+    for (int i = 0; i < fields.length; i++) {
+      Query q = qp.parse(queries[i], fields[i]);
+
+      if (q != null && // q never null, just being defensive
+          (!(q instanceof BooleanQuery) || ((BooleanQuery) q).getClauses().length > 0)) {
+        bQuery.add(q, flags[i]);
+      }
+    }
+    return bQuery;
+  }
+
+  /**
+   * Returns a String where those characters that TextParser expects to be
+   * escaped are escaped by a preceding <code>\</code>.
+   */
+  public static String escape(String s) {
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < s.length(); i++) {
+      char c = s.charAt(i);
+      // These characters are part of the query syntax and must be escaped
+      if (c == '\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')'
+          || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"'
+          || c == '{' || c == '}' || c == '~' || c == '*' || c == '?'
+          || c == '|' || c == '&') {
+        sb.append('\\');
+      }
+      sb.append(c);
+    }
+    return sb.toString();
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java
new file mode 100644
index 0000000..5ba0487
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java
@@ -0,0 +1,514 @@
+package org.apache.lucene.queryparser.flexible.standard;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Locale;
+import java.util.Map;
+import java.util.TooManyListenersException;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.DateTools.Resolution;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.QueryParserHelper;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.standard.config.FuzzyConfig;
+import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.Operator;
+import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
+import org.apache.lucene.queryparser.flexible.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.Query;
+
+/**
+ * <p>
+ * This class is a helper that enables users to easily use the Lucene query
+ * parser.
+ * </p>
+ * <p>
+ * To construct a Query object from a query string, use the
+ * {@link #parse(String, String)} method:
+ * <ul>
+ * StandardQueryParser queryParserHelper = new StandardQueryParser(); <br/>
+ * Query query = queryParserHelper.parse("a AND b", "defaultField");
+ * </ul>
+ * <p>
+ * To change any configuration before parsing the query string do, for example:
+ * <p/>
+ * <ul>
+ * // the query config handler returned by {@link StandardQueryParser} is a
+ * {@link StandardQueryConfigHandler} <br/>
+ * queryParserHelper.getQueryConfigHandler().setAnalyzer(new
+ * WhitespaceAnalyzer());
+ * </ul>
+ * <p>
+ * The syntax for query strings is as follows (copied from the old QueryParser
+ * javadoc):
+ * <ul>
+ * A Query is a series of clauses. A clause may be prefixed by:
+ * <ul>
+ * <li>a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating that
+ * the clause is required or prohibited respectively; or
+ * <li>a term followed by a colon, indicating the field to be searched. This
+ * enables one to construct queries which search multiple fields.
+ * </ul>
+ * 
+ * A clause may be either:
+ * <ul>
+ * <li>a term, indicating all the documents that contain this term; or
+ * <li>a nested query, enclosed in parentheses. Note that this may be used with
+ * a <code>+</code>/<code>-</code> prefix to require any of a set of terms.
+ * </ul>
+ * 
+ * Thus, in BNF, the query grammar is:
+ * 
+ * <pre>
+ *   Query  ::= ( Clause )*
+ *   Clause ::= [&quot;+&quot;, &quot;-&quot;] [&lt;TERM&gt; &quot;:&quot;] ( &lt;TERM&gt; | &quot;(&quot; Query &quot;)&quot; )
+ * </pre>
+ * 
+ * <p>
+ * Examples of appropriately formatted queries can be found in the <a
+ * href="../../../../../../queryparsersyntax.html">query syntax
+ * documentation</a>.
+ * </p>
+ * </ul>
+ * <p>
+ * The text parser used by this helper is a {@link StandardSyntaxParser}.
+ * <p/>
+ * <p>
+ * The query node processor used by this helper is a
+ * {@link StandardQueryNodeProcessorPipeline}.
+ * <p/>
+ * <p>
+ * The builder used by this helper is a {@link StandardQueryTreeBuilder}.
+ * <p/>
+ * 
+ * @see StandardQueryParser
+ * @see StandardQueryConfigHandler
+ * @see StandardSyntaxParser
+ * @see StandardQueryNodeProcessorPipeline
+ * @see StandardQueryTreeBuilder
+ */
+public class StandardQueryParser extends QueryParserHelper {
+  
+  /**
+   * Constructs a {@link StandardQueryParser} object.
+   */
+  public StandardQueryParser() {
+    super(new StandardQueryConfigHandler(), new StandardSyntaxParser(),
+        new StandardQueryNodeProcessorPipeline(null),
+        new StandardQueryTreeBuilder());
+  }
+  
+  /**
+   * Constructs a {@link StandardQueryParser} object and sets an
+   * {@link Analyzer} to it. The same as:
+   * 
+   * <ul>
+   * StandardQueryParser qp = new StandardQueryParser();
+   * qp.getQueryConfigHandler().setAnalyzer(analyzer);
+   * </ul>
+   * 
+   * @param analyzer
+   *          the analyzer to be used by this query parser helper
+   */
+  public StandardQueryParser(Analyzer analyzer) {
+    this();
+    
+    this.setAnalyzer(analyzer);
+  }
+  
+  @Override
+  public String toString() {
+    return "<StandardQueryParser config=\"" + this.getQueryConfigHandler()
+        + "\"/>";
+  }
+  
+  /**
+   * Overrides {@link QueryParserHelper#parse(String, String)} so it casts the
+   * return object to {@link Query}. For more reference about this method, check
+   * {@link QueryParserHelper#parse(String, String)}.
+   * 
+   * @param query
+   *          the query string
+   * @param defaultField
+   *          the default field used by the text parser
+   * 
+   * @return the object built from the query
+   * 
+   * @throws QueryNodeException
+   *           if something wrong happens along the three phases
+   */
+  @Override
+  public Query parse(String query, String defaultField)
+      throws QueryNodeException {
+    
+    return (Query) super.parse(query, defaultField);
+    
+  }
+  
+  /**
+   * Gets implicit operator setting, which will be either {@link Operator#AND}
+   * or {@link Operator#OR}.
+   */
+  public StandardQueryConfigHandler.Operator getDefaultOperator() {
+    return getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
+  }
+  
+  /**
+   * Sets the boolean operator of the QueryParser. In default mode (
+   * {@link Operator#OR}) terms without any modifiers are considered optional:
+   * for example <code>capital of Hungary</code> is equal to
+   * <code>capital OR of OR Hungary</code>.<br/>
+   * In {@link Operator#AND} mode terms are considered to be in conjunction: the
+   * above mentioned query is parsed as <code>capital AND of AND Hungary</code>
+   */
+  public void setDefaultOperator(StandardQueryConfigHandler.Operator operator) {
+    getQueryConfigHandler().set(ConfigurationKeys.DEFAULT_OPERATOR, operator);
+  }
+  
+  /**
+   * Set to <code>true</code> to allow leading wildcard characters.
+   * <p>
+   * When set, <code>*</code> or <code>?</code> are allowed as the first
+   * character of a PrefixQuery and WildcardQuery. Note that this can produce
+   * very slow queries on big indexes.
+   * <p>
+   * Default: false.
+   */
+  public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) {
+    getQueryConfigHandler().set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, lowercaseExpandedTerms);
+  }
+  
+  /**
+   * @see #setLowercaseExpandedTerms(boolean)
+   */
+  public boolean getLowercaseExpandedTerms() {
+    Boolean lowercaseExpandedTerms = getQueryConfigHandler().get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS);
+    
+    if (lowercaseExpandedTerms == null) {
+      return true;
+      
+    } else {
+      return lowercaseExpandedTerms;
+    }
+    
+  }
+  
+  /**
+   * Set to <code>true</code> to allow leading wildcard characters.
+   * <p>
+   * When set, <code>*</code> or <code>?</code> are allowed as the first
+   * character of a PrefixQuery and WildcardQuery. Note that this can produce
+   * very slow queries on big indexes.
+   * <p>
+   * Default: false.
+   */
+  public void setAllowLeadingWildcard(boolean allowLeadingWildcard) {
+    getQueryConfigHandler().set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, allowLeadingWildcard);
+  }
+  
+  /**
+   * Set to <code>true</code> to enable position increments in result query.
+   * <p>
+   * When set, result phrase and multi-phrase queries will be aware of position
+   * increments. Useful when e.g. a StopFilter increases the position increment
+   * of the token that follows an omitted token.
+   * <p>
+   * Default: false.
+   */
+  public void setEnablePositionIncrements(boolean enabled) {
+    getQueryConfigHandler().set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, enabled);
+  }
+  
+  /**
+   * @see #setEnablePositionIncrements(boolean)
+   */
+  public boolean getEnablePositionIncrements() {
+    Boolean enablePositionsIncrements = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
+    
+    if (enablePositionsIncrements == null) {
+       return false;
+       
+    } else {
+      return enablePositionsIncrements;
+    }
+    
+  }
+  
+  /**
+   * By default, it uses
+   * {@link MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} when creating a
+   * prefix, wildcard and range queries. This implementation is generally
+   * preferable because it a) Runs faster b) Does not have the scarcity of terms
+   * unduly influence score c) avoids any {@link TooManyListenersException}
+   * exception. However, if your application really needs to use the
+   * old-fashioned boolean queries expansion rewriting and the above points are
+   * not relevant then use this change the rewrite method.
+   */
+  public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method) {
+    getQueryConfigHandler().set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, method);
+  }
+  
+  /**
+   * @see #setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)
+   */
+  public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
+    return getQueryConfigHandler().get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
+  }
+  
+  /**
+   * Set the fields a query should be expanded to when the field is
+   * <code>null</code>
+   * 
+   * @param fields the fields used to expand the query
+   */
+  public void setMultiFields(CharSequence[] fields) {
+    
+    if (fields == null) {
+      fields = new CharSequence[0];
+    }
+
+    getQueryConfigHandler().set(ConfigurationKeys.MULTI_FIELDS, fields);
+    
+  }
+  
+  /**
+   * Returns the fields used to expand the query when the field for a
+   * certain query is <code>null</code>
+   * 
+   * @param fields the fields used to expand the query
+   */
+  public void getMultiFields(CharSequence[] fields) {
+    getQueryConfigHandler().get(ConfigurationKeys.MULTI_FIELDS);
+  }
+
+  /**
+   * Set the prefix length for fuzzy queries. Default is 0.
+   * 
+   * @param fuzzyPrefixLength
+   *          The fuzzyPrefixLength to set.
+   */
+  public void setFuzzyPrefixLength(int fuzzyPrefixLength) {
+    QueryConfigHandler config = getQueryConfigHandler();
+    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      fuzzyConfig = new FuzzyConfig();
+      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
+    }
+
+    fuzzyConfig.setPrefixLength(fuzzyPrefixLength);
+    
+  }
+  
+  public void setNumericConfigMap(Map<String,NumericConfig> numericConfigMap) {
+    getQueryConfigHandler().set(ConfigurationKeys.NUMERIC_CONFIG_MAP, numericConfigMap);
+  }
+  
+  public Map<String,NumericConfig> getNumericConfigMap() {
+    return getQueryConfigHandler().get(ConfigurationKeys.NUMERIC_CONFIG_MAP);
+  }
+  
+  /**
+   * Set locale used by date range parsing.
+   */
+  public void setLocale(Locale locale) {
+    getQueryConfigHandler().set(ConfigurationKeys.LOCALE, locale);
+  }
+  
+  /**
+   * Returns current locale, allowing access by subclasses.
+   */
+  public Locale getLocale() {
+    return getQueryConfigHandler().get(ConfigurationKeys.LOCALE);
+  }
+  
+  /**
+   * Sets the default slop for phrases. If zero, then exact phrase matches are
+   * required. Default value is zero.
+   * 
+   * @deprecated renamed to {@link #setPhraseSlop(int)}
+   */
+  @Deprecated
+  public void setDefaultPhraseSlop(int defaultPhraseSlop) {
+    getQueryConfigHandler().set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
+  }
+  
+  /**
+   * Sets the default slop for phrases. If zero, then exact phrase matches are
+   * required. Default value is zero.
+   */
+  public void setPhraseSlop(int defaultPhraseSlop) {
+    getQueryConfigHandler().set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
+  }
+
+  public void setAnalyzer(Analyzer analyzer) {
+    getQueryConfigHandler().set(ConfigurationKeys.ANALYZER, analyzer);
+  }
+  
+  public Analyzer getAnalyzer() {
+    return getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);       
+  }
+  
+  /**
+   * @see #setAllowLeadingWildcard(boolean)
+   */
+  public boolean getAllowLeadingWildcard() {
+    Boolean allowLeadingWildcard = getQueryConfigHandler().get(ConfigurationKeys.ALLOW_LEADING_WILDCARD);
+    
+    if (allowLeadingWildcard == null) {
+      return false;
+      
+    } else {
+      return allowLeadingWildcard;
+    }
+  }
+  
+  /**
+   * Get the minimal similarity for fuzzy queries.
+   */
+  public float getFuzzyMinSim() {
+    FuzzyConfig fuzzyConfig = getQueryConfigHandler().get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      return FuzzyQuery.defaultMinSimilarity;
+    } else {
+      return fuzzyConfig.getMinSimilarity();
+    }
+  }
+  
+  /**
+   * Get the prefix length for fuzzy queries.
+   * 
+   * @return Returns the fuzzyPrefixLength.
+   */
+  public int getFuzzyPrefixLength() {
+    FuzzyConfig fuzzyConfig = getQueryConfigHandler().get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      return FuzzyQuery.defaultPrefixLength;
+    } else {
+      return fuzzyConfig.getPrefixLength();
+    }
+  }
+  
+  /**
+   * Gets the default slop for phrases.
+   */
+  public int getPhraseSlop() {
+    Integer phraseSlop = getQueryConfigHandler().get(ConfigurationKeys.PHRASE_SLOP);
+    
+    if (phraseSlop == null) {
+      return 0;
+      
+    } else {
+      return phraseSlop;
+    }
+  }
+  
+  /**
+   * Set the minimum similarity for fuzzy queries. Default is defined on
+   * {@link FuzzyQuery#defaultMinSimilarity}.
+   */
+  public void setFuzzyMinSim(float fuzzyMinSim) {
+    QueryConfigHandler config = getQueryConfigHandler();
+    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      fuzzyConfig = new FuzzyConfig();
+      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
+    }
+
+    fuzzyConfig.setMinSimilarity(fuzzyMinSim);
+  }
+  
+  /**
+   * Sets the boost used for each field.
+   * 
+   * @param boosts a collection that maps a field to its boost 
+   */
+  public void setFieldsBoost(Map<String, Float> boosts) {
+    getQueryConfigHandler().set(ConfigurationKeys.FIELD_BOOST_MAP, boosts);
+  }
+  
+  /**
+   * Returns the field to boost map used to set boost for each field.
+   * 
+   * @return the field to boost map 
+   */
+  public Map<String, Float> getFieldsBoost() {
+    return getQueryConfigHandler().get(ConfigurationKeys.FIELD_BOOST_MAP);
+  }
+
+  /**
+   * Sets the default {@link Resolution} used for certain field when
+   * no {@link Resolution} is defined for this field.
+   * 
+   * @param dateResolution the default {@link Resolution}
+   */
+  public void setDateResolution(DateTools.Resolution dateResolution) {
+    getQueryConfigHandler().set(ConfigurationKeys.DATE_RESOLUTION, dateResolution);
+  }
+  
+  /**
+   * Returns the default {@link Resolution} used for certain field when
+   * no {@link Resolution} is defined for this field.
+   * 
+   * @return the default {@link Resolution}
+   */
+  public DateTools.Resolution getDateResolution() {
+    return getQueryConfigHandler().get(ConfigurationKeys.DATE_RESOLUTION);
+  }
+
+  /**
+   * Sets the {@link Resolution} used for each field
+   * 
+   * @param dateRes a collection that maps a field to its {@link Resolution}
+   * 
+   * @deprecated this method was renamed to {@link #setDateResolutionMap(Map)} 
+   */
+  @Deprecated
+  public void setDateResolution(Map<CharSequence, DateTools.Resolution> dateRes) {
+    setDateResolutionMap(dateRes);
+  }
+  
+  /**
+   * Returns the field to {@link Resolution} map used to normalize each date field.
+   * 
+   * @return the field to {@link Resolution} map
+   */
+  public Map<CharSequence, DateTools.Resolution> getDateResolutionMap() {
+    return getQueryConfigHandler().get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP);
+  }
+  
+  /**
+   * Sets the {@link Resolution} used for each field
+   * 
+   * @param dateRes a collection that maps a field to its {@link Resolution}
+   */
+  public void setDateResolutionMap(Map<CharSequence, DateTools.Resolution> dateRes) {
+    getQueryConfigHandler().set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, dateRes);
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/AnyQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/AnyQueryNodeBuilder.java
new file mode 100644
index 0000000..1c08ea8
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/AnyQueryNodeBuilder.java
@@ -0,0 +1,77 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.AnyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BooleanQuery.TooManyClauses;
+
+public class AnyQueryNodeBuilder implements StandardQueryBuilder {
+
+  public AnyQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public BooleanQuery build(QueryNode queryNode) throws QueryNodeException {
+    AnyQueryNode andNode = (AnyQueryNode) queryNode;
+
+    BooleanQuery bQuery = new BooleanQuery();
+    List<QueryNode> children = andNode.getChildren();
+
+    if (children != null) {
+
+      for (QueryNode child : children) {
+        Object obj = child.getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+
+        if (obj != null) {
+          Query query = (Query) obj;
+
+          try {
+            bQuery.add(query, BooleanClause.Occur.SHOULD);
+          } catch (TooManyClauses ex) {
+
+            throw new QueryNodeException(new MessageImpl(
+            /*
+             * IQQQ.Q0028E_TOO_MANY_BOOLEAN_CLAUSES,
+             * BooleanQuery.getMaxClauseCount()
+             */QueryParserMessages.EMPTY_MESSAGE), ex);
+
+          }
+
+        }
+
+      }
+
+    }
+
+    bQuery.setMinimumNumberShouldMatch(andNode.getMinimumMatchingElements());
+
+    return bQuery;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/BooleanQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/BooleanQueryNodeBuilder.java
new file mode 100644
index 0000000..e3a419f
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/BooleanQueryNodeBuilder.java
@@ -0,0 +1,110 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BooleanQuery.TooManyClauses;
+
+/**
+ * Builds a {@link BooleanQuery} object from a {@link BooleanQueryNode} object.
+ * Every children in the {@link BooleanQueryNode} object must be already tagged
+ * using {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} with a {@link Query}
+ * object. <br/>
+ * <br/>
+ * It takes in consideration if the children is a {@link ModifierQueryNode} to
+ * define the {@link BooleanClause}.
+ */
+public class BooleanQueryNodeBuilder implements StandardQueryBuilder {
+
+  public BooleanQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public BooleanQuery build(QueryNode queryNode) throws QueryNodeException {
+    BooleanQueryNode booleanNode = (BooleanQueryNode) queryNode;
+
+    BooleanQuery bQuery = new BooleanQuery();
+    List<QueryNode> children = booleanNode.getChildren();
+
+    if (children != null) {
+
+      for (QueryNode child : children) {
+        Object obj = child.getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+
+        if (obj != null) {
+          Query query = (Query) obj;
+
+          try {
+            bQuery.add(query, getModifierValue(child));
+
+          } catch (TooManyClauses ex) {
+
+            throw new QueryNodeException(new MessageImpl(
+                QueryParserMessages.TOO_MANY_BOOLEAN_CLAUSES, BooleanQuery
+                    .getMaxClauseCount(), queryNode
+                    .toQueryString(new EscapeQuerySyntaxImpl())), ex);
+
+          }
+
+        }
+
+      }
+
+    }
+
+    return bQuery;
+
+  }
+
+  private static BooleanClause.Occur getModifierValue(QueryNode node)
+      throws QueryNodeException {
+
+    if (node instanceof ModifierQueryNode) {
+      ModifierQueryNode mNode = ((ModifierQueryNode) node);
+      switch (mNode.getModifier()) {
+
+      case MOD_REQ:
+        return BooleanClause.Occur.MUST;
+
+      case MOD_NOT:
+        return BooleanClause.Occur.MUST_NOT;
+
+      case MOD_NONE:
+        return BooleanClause.Occur.SHOULD;
+
+      }
+
+    }
+
+    return BooleanClause.Occur.SHOULD;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/BoostQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/BoostQueryNodeBuilder.java
new file mode 100644
index 0000000..ee86c96
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/BoostQueryNodeBuilder.java
@@ -0,0 +1,54 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.Query;
+
+/**
+ * This builder basically reads the {@link Query} object set on the
+ * {@link BoostQueryNode} child using
+ * {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} and applies the boost value
+ * defined in the {@link BoostQueryNode}.
+ */
+public class BoostQueryNodeBuilder implements StandardQueryBuilder {
+
+  public BoostQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public Query build(QueryNode queryNode) throws QueryNodeException {
+    BoostQueryNode boostNode = (BoostQueryNode) queryNode;
+    QueryNode child = boostNode.getChild();
+
+    if (child == null) {
+      return null;
+    }
+
+    Query query = (Query) child
+        .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+    query.setBoost(boostNode.getValue());
+
+    return query;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/DummyQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/DummyQueryNodeBuilder.java
new file mode 100644
index 0000000..5ec5f36
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/DummyQueryNodeBuilder.java
@@ -0,0 +1,38 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.TermQuery;
+
+/**
+ * Builds a {@link TermQuery} object from a {@link FieldQueryNode} object.
+ */
+public class DummyQueryNodeBuilder implements StandardQueryBuilder {
+
+  public DummyQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public TermQuery build(QueryNode queryNode) throws QueryNodeException {
+    return null;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/FieldQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/FieldQueryNodeBuilder.java
new file mode 100644
index 0000000..738ecae
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/FieldQueryNodeBuilder.java
@@ -0,0 +1,43 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.TermQuery;
+
+/**
+ * Builds a {@link TermQuery} object from a {@link FieldQueryNode} object.
+ */
+public class FieldQueryNodeBuilder implements StandardQueryBuilder {
+
+  public FieldQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public TermQuery build(QueryNode queryNode) throws QueryNodeException {
+    FieldQueryNode fieldNode = (FieldQueryNode) queryNode;
+
+    return new TermQuery(new Term(fieldNode.getFieldAsString(), fieldNode
+        .getTextAsString()));
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/FuzzyQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/FuzzyQueryNodeBuilder.java
new file mode 100644
index 0000000..dfd3b3d
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/FuzzyQueryNodeBuilder.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.FuzzyQuery;
+
+/**
+ * Builds a {@link FuzzyQuery} object from a {@link FuzzyQueryNode} object.
+ */
+public class FuzzyQueryNodeBuilder implements StandardQueryBuilder {
+
+  public FuzzyQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public FuzzyQuery build(QueryNode queryNode) throws QueryNodeException {
+    FuzzyQueryNode fuzzyNode = (FuzzyQueryNode) queryNode;
+
+    return new FuzzyQuery(new Term(fuzzyNode.getFieldAsString(), fuzzyNode
+        .getTextAsString()), fuzzyNode.getSimilarity(), fuzzyNode
+        .getPrefixLength());
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/GroupQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/GroupQueryNodeBuilder.java
new file mode 100644
index 0000000..0e4ece9
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/GroupQueryNodeBuilder.java
@@ -0,0 +1,45 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.Query;
+
+/**
+ * Builds no object, it only returns the {@link Query} object set on the
+ * {@link GroupQueryNode} object using a
+ * {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} tag.
+ */
+public class GroupQueryNodeBuilder implements StandardQueryBuilder {
+
+  public GroupQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public Query build(QueryNode queryNode) throws QueryNodeException {
+    GroupQueryNode groupNode = (GroupQueryNode) queryNode;
+
+    return (Query) (groupNode).getChild().getTag(
+        QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MatchAllDocsQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MatchAllDocsQueryNodeBuilder.java
new file mode 100644
index 0000000..733728f
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MatchAllDocsQueryNodeBuilder.java
@@ -0,0 +1,52 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.MatchAllDocsQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl;
+import org.apache.lucene.search.MatchAllDocsQuery;
+
+/**
+ * Builds a {@link MatchAllDocsQuery} object from a
+ * {@link MatchAllDocsQueryNode} object.
+ */
+public class MatchAllDocsQueryNodeBuilder implements StandardQueryBuilder {
+
+  public MatchAllDocsQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public MatchAllDocsQuery build(QueryNode queryNode) throws QueryNodeException {
+
+    // validates node
+    if (!(queryNode instanceof MatchAllDocsQueryNode)) {
+      throw new QueryNodeException(new MessageImpl(
+          QueryParserMessages.LUCENE_QUERY_CONVERSION_ERROR, queryNode
+              .toQueryString(new EscapeQuerySyntaxImpl()), queryNode.getClass()
+              .getName()));
+    }
+
+    return new MatchAllDocsQuery();
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MatchNoDocsQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MatchNoDocsQueryNodeBuilder.java
new file mode 100644
index 0000000..903c6fc
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MatchNoDocsQueryNodeBuilder.java
@@ -0,0 +1,52 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.MatchNoDocsQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl;
+import org.apache.lucene.search.BooleanQuery;
+
+/**
+ * Builds an empty {@link BooleanQuery} object from a
+ * {@link MatchNoDocsQueryNode} object.
+ */
+public class MatchNoDocsQueryNodeBuilder implements StandardQueryBuilder {
+
+  public MatchNoDocsQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public BooleanQuery build(QueryNode queryNode) throws QueryNodeException {
+
+    // validates node
+    if (!(queryNode instanceof MatchNoDocsQueryNode)) {
+      throw new QueryNodeException(new MessageImpl(
+          QueryParserMessages.LUCENE_QUERY_CONVERSION_ERROR, queryNode
+              .toQueryString(new EscapeQuerySyntaxImpl()), queryNode.getClass()
+              .getName()));
+    }
+
+    return new BooleanQuery();
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/ModifierQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/ModifierQueryNodeBuilder.java
new file mode 100644
index 0000000..169d8bd
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/ModifierQueryNodeBuilder.java
@@ -0,0 +1,45 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.Query;
+
+/**
+ * Builds no object, it only returns the {@link Query} object set on the
+ * {@link ModifierQueryNode} object using a
+ * {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} tag.
+ */
+public class ModifierQueryNodeBuilder implements StandardQueryBuilder {
+
+  public ModifierQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public Query build(QueryNode queryNode) throws QueryNodeException {
+    ModifierQueryNode modifierNode = (ModifierQueryNode) queryNode;
+
+    return (Query) (modifierNode).getChild().getTag(
+        QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java
new file mode 100644
index 0000000..256bba6
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java
@@ -0,0 +1,84 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.TreeMap;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.MultiPhraseQueryNode;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.TermQuery;
+
+/**
+ * Builds a {@link MultiPhraseQuery} object from a {@link MultiPhraseQueryNode}
+ * object.
+ */
+public class MultiPhraseQueryNodeBuilder implements StandardQueryBuilder {
+
+  public MultiPhraseQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public MultiPhraseQuery build(QueryNode queryNode) throws QueryNodeException {
+    MultiPhraseQueryNode phraseNode = (MultiPhraseQueryNode) queryNode;
+
+    MultiPhraseQuery phraseQuery = new MultiPhraseQuery();
+
+    List<QueryNode> children = phraseNode.getChildren();
+
+    if (children != null) {
+      TreeMap<Integer, List<Term>> positionTermMap = new TreeMap<Integer, List<Term>>();
+
+      for (QueryNode child : children) {
+        FieldQueryNode termNode = (FieldQueryNode) child;
+        TermQuery termQuery = (TermQuery) termNode
+            .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+        List<Term> termList = positionTermMap.get(termNode
+            .getPositionIncrement());
+
+        if (termList == null) {
+          termList = new LinkedList<Term>();
+          positionTermMap.put(termNode.getPositionIncrement(), termList);
+
+        }
+
+        termList.add(termQuery.getTerm());
+
+      }
+
+      for (int positionIncrement : positionTermMap.keySet()) {
+        List<Term> termList = positionTermMap.get(positionIncrement);
+
+        phraseQuery.add(termList.toArray(new Term[termList.size()]),
+            positionIncrement);
+
+      }
+
+    }
+
+    return phraseQuery;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/NumericRangeQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/NumericRangeQueryNodeBuilder.java
new file mode 100644
index 0000000..6779c02
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/NumericRangeQueryNodeBuilder.java
@@ -0,0 +1,93 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.document.NumericField;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
+import org.apache.lucene.queryparser.flexible.standard.nodes.NumericQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.NumericRangeQueryNode;
+import org.apache.lucene.search.NumericRangeQuery;
+
+public class NumericRangeQueryNodeBuilder implements StandardQueryBuilder {
+  
+  public NumericRangeQueryNodeBuilder() {
+  // empty constructor
+  }
+  
+  public NumericRangeQuery<? extends Number> build(QueryNode queryNode)
+      throws QueryNodeException {
+    NumericRangeQueryNode numericRangeNode = (NumericRangeQueryNode) queryNode;
+    
+    NumericQueryNode lowerNumericNode = numericRangeNode.getLowerBound();
+    NumericQueryNode upperNumericNode = numericRangeNode.getUpperBound();
+    
+    Number lowerNumber, upperNumber;
+    
+    if (lowerNumericNode != null) {
+      lowerNumber = lowerNumericNode.getValue();
+    } else {
+      lowerNumber = null;
+    }
+    
+    if (upperNumericNode != null) {
+      upperNumber = upperNumericNode.getValue();
+    } else {
+      upperNumber = null;
+    }
+    
+    NumericConfig numericConfig = numericRangeNode.getNumericConfig();
+    NumericField.DataType numberType = numericConfig.getType();
+    String field = StringUtils.toString(numericRangeNode.getField());
+    boolean minInclusive = numericRangeNode.isLowerInclusive();
+    boolean maxInclusive = numericRangeNode.isUpperInclusive();
+    int precisionStep = numericConfig.getPrecisionStep();
+    
+    switch (numberType) {
+      
+      case LONG:
+        return NumericRangeQuery.newLongRange(field, precisionStep,
+            (Long) lowerNumber, (Long) upperNumber, minInclusive, maxInclusive);
+      
+      case INT:
+        return NumericRangeQuery.newIntRange(field, precisionStep,
+            (Integer) lowerNumber, (Integer) upperNumber, minInclusive,
+            maxInclusive);
+      
+      case FLOAT:
+        return NumericRangeQuery.newFloatRange(field, precisionStep,
+            (Float) lowerNumber, (Float) upperNumber, minInclusive,
+            maxInclusive);
+      
+      case DOUBLE:
+        return NumericRangeQuery.newDoubleRange(field, precisionStep,
+            (Double) lowerNumber, (Double) upperNumber, minInclusive,
+            maxInclusive);
+        
+        default :
+          throw new QueryNodeException(new MessageImpl(
+            QueryParserMessages.UNSUPPORTED_NUMERIC_DATA_TYPE, numberType));
+        
+    }
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PhraseQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PhraseQueryNodeBuilder.java
new file mode 100644
index 0000000..e5e2405
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PhraseQueryNodeBuilder.java
@@ -0,0 +1,64 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.TokenizedPhraseQueryNode;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.TermQuery;
+
+/**
+ * Builds a {@link PhraseQuery} object from a {@link TokenizedPhraseQueryNode}
+ * object.
+ */
+public class PhraseQueryNodeBuilder implements StandardQueryBuilder {
+
+  public PhraseQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public PhraseQuery build(QueryNode queryNode) throws QueryNodeException {
+    TokenizedPhraseQueryNode phraseNode = (TokenizedPhraseQueryNode) queryNode;
+
+    PhraseQuery phraseQuery = new PhraseQuery();
+
+    List<QueryNode> children = phraseNode.getChildren();
+
+    if (children != null) {
+
+      for (QueryNode child : children) {
+        TermQuery termQuery = (TermQuery) child
+            .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+        FieldQueryNode termNode = (FieldQueryNode) child;
+
+        phraseQuery.add(termQuery.getTerm(), termNode.getPositionIncrement());
+
+      }
+
+    }
+
+    return phraseQuery;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PrefixWildcardQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PrefixWildcardQueryNodeBuilder.java
new file mode 100644
index 0000000..f35f5e5
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PrefixWildcardQueryNodeBuilder.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.processors.MultiTermRewriteMethodProcessor;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.PrefixQuery;
+
+/**
+ * Builds a {@link PrefixQuery} object from a {@link PrefixWildcardQueryNode}
+ * object.
+ */
+public class PrefixWildcardQueryNodeBuilder implements StandardQueryBuilder {
+
+  public PrefixWildcardQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public PrefixQuery build(QueryNode queryNode) throws QueryNodeException {    
+
+    PrefixWildcardQueryNode wildcardNode = (PrefixWildcardQueryNode) queryNode;
+
+    String text = wildcardNode.getText().subSequence(0, wildcardNode.getText().length() - 1).toString();
+    PrefixQuery q = new PrefixQuery(new Term(wildcardNode.getFieldAsString(), text));
+    
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
+    if (method != null) {
+      q.setRewriteMethod(method);
+    }
+    
+    return q;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/RangeQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/RangeQueryNodeBuilder.java
new file mode 100644
index 0000000..0cd68f8
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/RangeQueryNodeBuilder.java
@@ -0,0 +1,67 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode.CompareOperator;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.processors.MultiTermRewriteMethodProcessor;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+
+/**
+ * Builds a {@link TermRangeQuery} object from a {@link RangeQueryNode} object.
+ */
+public class RangeQueryNodeBuilder implements StandardQueryBuilder {
+
+  public RangeQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public TermRangeQuery build(QueryNode queryNode) throws QueryNodeException {
+    RangeQueryNode rangeNode = (RangeQueryNode) queryNode;
+    ParametricQueryNode upper = rangeNode.getUpperBound();
+    ParametricQueryNode lower = rangeNode.getLowerBound();
+
+    boolean lowerInclusive = false;
+    boolean upperInclusive = false;
+
+    if (upper.getOperator() == CompareOperator.LE) {
+      upperInclusive = true;
+    }
+
+    if (lower.getOperator() == CompareOperator.GE) {
+      lowerInclusive = true;
+    }
+
+    String field = rangeNode.getField().toString();
+
+    TermRangeQuery rangeQuery = TermRangeQuery.newStringRange(field, lower.getTextAsString(), upper.getTextAsString(), lowerInclusive, upperInclusive);
+    
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
+    if (method != null) {
+      rangeQuery.setRewriteMethod(method);
+    }
+
+    return rangeQuery;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/RegexpQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/RegexpQueryNodeBuilder.java
new file mode 100644
index 0000000..796ce2b
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/RegexpQueryNodeBuilder.java
@@ -0,0 +1,52 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.processors.MultiTermRewriteMethodProcessor;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.RegexpQuery;
+
+/**
+ * Builds a {@link RegexpQuery} object from a {@link RegexpQueryNode} object.
+ */
+public class RegexpQueryNodeBuilder implements StandardQueryBuilder {
+
+  public RegexpQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public RegexpQuery build(QueryNode queryNode) throws QueryNodeException {
+    RegexpQueryNode regexpNode = (RegexpQueryNode) queryNode;
+
+    RegexpQuery q = new RegexpQuery(new Term(regexpNode.getFieldAsString(),
+        regexpNode.textToBytesRef()));
+
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod) queryNode
+        .getTag(MultiTermRewriteMethodProcessor.TAG_ID);
+    if (method != null) {
+      q.setRewriteMethod(method);
+    }
+
+    return q;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/SlopQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/SlopQueryNodeBuilder.java
new file mode 100644
index 0000000..e580a0e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/SlopQueryNodeBuilder.java
@@ -0,0 +1,57 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+
+/**
+ * This builder basically reads the {@link Query} object set on the
+ * {@link SlopQueryNode} child using
+ * {@link QueryTreeBuilder#QUERY_TREE_BUILDER_TAGID} and applies the slop value
+ * defined in the {@link SlopQueryNode}.
+ */
+public class SlopQueryNodeBuilder implements StandardQueryBuilder {
+
+  public SlopQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public Query build(QueryNode queryNode) throws QueryNodeException {
+    SlopQueryNode phraseSlopNode = (SlopQueryNode) queryNode;
+
+    Query query = (Query) phraseSlopNode.getChild().getTag(
+        QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+
+    if (query instanceof PhraseQuery) {
+      ((PhraseQuery) query).setSlop(phraseSlopNode.getValue());
+
+    } else {
+      ((MultiPhraseQuery) query).setSlop(phraseSlopNode.getValue());
+    }
+
+    return query;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardBooleanQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardBooleanQueryNodeBuilder.java
new file mode 100644
index 0000000..04616be
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardBooleanQueryNodeBuilder.java
@@ -0,0 +1,109 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode.Modifier;
+import org.apache.lucene.queryparser.flexible.standard.nodes.StandardBooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SimilarityProvider;
+import org.apache.lucene.search.BooleanQuery.TooManyClauses;
+
+/**
+ * This builder does the same as the {@link BooleanQueryNodeBuilder}, but this
+ * considers if the built {@link BooleanQuery} should have its coord disabled or
+ * not. <br/>
+ * 
+ * @see BooleanQueryNodeBuilder
+ * @see BooleanQuery
+ * @see SimilarityProvider#coord(int, int)
+ */
+public class StandardBooleanQueryNodeBuilder implements StandardQueryBuilder {
+
+  public StandardBooleanQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public BooleanQuery build(QueryNode queryNode) throws QueryNodeException {
+    StandardBooleanQueryNode booleanNode = (StandardBooleanQueryNode) queryNode;
+
+    BooleanQuery bQuery = new BooleanQuery(booleanNode.isDisableCoord());
+    List<QueryNode> children = booleanNode.getChildren();
+
+    if (children != null) {
+
+      for (QueryNode child : children) {
+        Object obj = child.getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+
+        if (obj != null) {
+          Query query = (Query) obj;
+
+          try {
+            bQuery.add(query, getModifierValue(child));
+          } catch (TooManyClauses ex) {
+
+            throw new QueryNodeException(new MessageImpl(
+                QueryParserMessages.TOO_MANY_BOOLEAN_CLAUSES, BooleanQuery
+                    .getMaxClauseCount(), queryNode
+                    .toQueryString(new EscapeQuerySyntaxImpl())), ex);
+
+          }
+
+        }
+
+      }
+
+    }
+
+    return bQuery;
+
+  }
+
+  private static BooleanClause.Occur getModifierValue(QueryNode node)
+      throws QueryNodeException {
+
+    if (node instanceof ModifierQueryNode) {
+      ModifierQueryNode mNode = ((ModifierQueryNode) node);
+      Modifier modifier = mNode.getModifier();
+
+      if (Modifier.MOD_NONE.equals(modifier)) {
+        return BooleanClause.Occur.SHOULD;
+
+      } else if (Modifier.MOD_NOT.equals(modifier)) {
+        return BooleanClause.Occur.MUST_NOT;
+
+      } else {
+        return BooleanClause.Occur.MUST;
+      }
+    }
+
+    return BooleanClause.Occur.SHOULD;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardQueryBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardQueryBuilder.java
new file mode 100644
index 0000000..6f8dca9
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardQueryBuilder.java
@@ -0,0 +1,37 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryBuilder;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.Query;
+
+/**
+ * This interface should be implemented by every class that wants to build
+ * {@link Query} objects from {@link QueryNode} objects. <br/>
+ * 
+ * @see QueryBuilder
+ * @see QueryTreeBuilder
+ */
+public interface StandardQueryBuilder extends QueryBuilder {
+
+  public Query build(QueryNode queryNode) throws QueryNodeException;
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardQueryTreeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardQueryTreeBuilder.java
new file mode 100644
index 0000000..789a2fb
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/StandardQueryTreeBuilder.java
@@ -0,0 +1,85 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.MatchAllDocsQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.MatchNoDocsQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.TokenizedPhraseQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.MultiPhraseQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.NumericQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.NumericRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.TermRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.StandardBooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.search.Query;
+
+/**
+ * This query tree builder only defines the necessary map to build a
+ * {@link Query} tree object. It should be used to generate a {@link Query} tree
+ * object from a query node tree processed by a
+ * {@link StandardQueryNodeProcessorPipeline}. <br/>
+ * 
+ * @see QueryTreeBuilder
+ * @see StandardQueryNodeProcessorPipeline
+ */
+public class StandardQueryTreeBuilder extends QueryTreeBuilder implements
+    StandardQueryBuilder {
+  
+  public StandardQueryTreeBuilder() {
+    setBuilder(GroupQueryNode.class, new GroupQueryNodeBuilder());
+    setBuilder(FieldQueryNode.class, new FieldQueryNodeBuilder());
+    setBuilder(BooleanQueryNode.class, new BooleanQueryNodeBuilder());
+    setBuilder(FuzzyQueryNode.class, new FuzzyQueryNodeBuilder());
+    setBuilder(NumericQueryNode.class, new DummyQueryNodeBuilder());
+    setBuilder(NumericRangeQueryNode.class, new NumericRangeQueryNodeBuilder());
+    setBuilder(BoostQueryNode.class, new BoostQueryNodeBuilder());
+    setBuilder(ModifierQueryNode.class, new ModifierQueryNodeBuilder());
+    setBuilder(WildcardQueryNode.class, new WildcardQueryNodeBuilder());
+    setBuilder(TokenizedPhraseQueryNode.class, new PhraseQueryNodeBuilder());
+    setBuilder(MatchNoDocsQueryNode.class, new MatchNoDocsQueryNodeBuilder());
+    setBuilder(PrefixWildcardQueryNode.class,
+        new PrefixWildcardQueryNodeBuilder());
+    setBuilder(TermRangeQueryNode.class, new TermRangeQueryNodeBuilder());
+    setBuilder(RegexpQueryNode.class, new RegexpQueryNodeBuilder());
+    setBuilder(SlopQueryNode.class, new SlopQueryNodeBuilder());
+    setBuilder(StandardBooleanQueryNode.class,
+        new StandardBooleanQueryNodeBuilder());
+    setBuilder(MultiPhraseQueryNode.class, new MultiPhraseQueryNodeBuilder());
+    setBuilder(MatchAllDocsQueryNode.class, new MatchAllDocsQueryNodeBuilder());
+    
+  }
+  
+  @Override
+  public Query build(QueryNode queryNode) throws QueryNodeException {
+    return (Query) super.build(queryNode);
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/TermRangeQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/TermRangeQueryNodeBuilder.java
new file mode 100644
index 0000000..9f7fc64
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/TermRangeQueryNodeBuilder.java
@@ -0,0 +1,60 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+import org.apache.lucene.queryparser.flexible.standard.nodes.TermRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.processors.MultiTermRewriteMethodProcessor;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+
+/**
+ * Builds a {@link TermRangeQuery} object from a {@link TermRangeQueryNode}
+ * object.
+ */
+public class TermRangeQueryNodeBuilder implements StandardQueryBuilder {
+  
+  public TermRangeQueryNodeBuilder() {
+  // empty constructor
+  }
+  
+  public TermRangeQuery build(QueryNode queryNode) throws QueryNodeException {
+    TermRangeQueryNode rangeNode = (TermRangeQueryNode) queryNode;
+    FieldQueryNode upper = rangeNode.getUpperBound();
+    FieldQueryNode lower = rangeNode.getLowerBound();
+    
+    String field = StringUtils.toString(rangeNode.getField());
+    
+    TermRangeQuery rangeQuery = TermRangeQuery.newStringRange(field, lower
+        .getTextAsString(), upper.getTextAsString(), rangeNode
+        .isLowerInclusive(), rangeNode.isUpperInclusive());
+    
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod) queryNode
+        .getTag(MultiTermRewriteMethodProcessor.TAG_ID);
+    if (method != null) {
+      rangeQuery.setRewriteMethod(method);
+    }
+    
+    return rangeQuery;
+    
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/WildcardQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/WildcardQueryNodeBuilder.java
new file mode 100644
index 0000000..bc5c7c8
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/WildcardQueryNodeBuilder.java
@@ -0,0 +1,52 @@
+package org.apache.lucene.queryparser.flexible.standard.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.processors.MultiTermRewriteMethodProcessor;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.WildcardQuery;
+
+/**
+ * Builds a {@link WildcardQuery} object from a {@link WildcardQueryNode}
+ * object.
+ */
+public class WildcardQueryNodeBuilder implements StandardQueryBuilder {
+
+  public WildcardQueryNodeBuilder() {
+    // empty constructor
+  }
+
+  public WildcardQuery build(QueryNode queryNode) throws QueryNodeException {
+    WildcardQueryNode wildcardNode = (WildcardQueryNode) queryNode;
+
+    WildcardQuery q = new WildcardQuery(new Term(wildcardNode.getFieldAsString(),
+                                                 wildcardNode.getTextAsString()));
+    
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
+    if (method != null) {
+      q.setRewriteMethod(method);
+    }
+    
+    return q;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/package.html
new file mode 100644
index 0000000..ef7e27a
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/package.html
@@ -0,0 +1,35 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+<h2>Standard Lucene Query Node Builders</h2>
+<p>
+The package org.apache.lucene.queryparser.flexible.standard.builders contains all the builders needed
+to build a Lucene Query object from a query node tree. These builders expect the query node tree was
+already processed by the {@link org.apache.lucene.queryparser.flexible.standard.processors.StandardQueryNodeProcessorPipeline}.
+</p>
+<p>
+{@link org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryTreeBuilder} is a builder that already contains a defined map that maps each QueryNode object
+with its respective builder.
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FieldBoostMapFCListener.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FieldBoostMapFCListener.java
new file mode 100644
index 0000000..fd2b476
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FieldBoostMapFCListener.java
@@ -0,0 +1,59 @@
+package org.apache.lucene.queryparser.flexible.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Map;
+
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfigListener;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+
+/**
+ * This listener listens for every field configuration request and assign a
+ * {@link ConfigurationKeys#BOOST} to the
+ * equivalent {@link FieldConfig} based on a defined map: fieldName -> boostValue stored in
+ * {@link ConfigurationKeys#FIELD_BOOST_MAP}.
+ * 
+ * @see ConfigurationKeys#FIELD_BOOST_MAP
+ * @see ConfigurationKeys#BOOST
+ * @see FieldConfig
+ * @see FieldConfigListener
+ */
+public class FieldBoostMapFCListener implements FieldConfigListener {
+
+  private QueryConfigHandler config = null;
+  
+  public FieldBoostMapFCListener(QueryConfigHandler config) {
+    this.config = config;
+  }
+
+  public void buildFieldConfig(FieldConfig fieldConfig) {
+    Map<String, Float> fieldBoostMap = this.config.get(ConfigurationKeys.FIELD_BOOST_MAP);
+    
+    if (fieldBoostMap != null) {
+      Float boost = fieldBoostMap.get(fieldConfig.getField());
+
+      if (boost != null) {
+        fieldConfig.set(ConfigurationKeys.BOOST, boost);
+      }
+
+    }
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FieldDateResolutionFCListener.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FieldDateResolutionFCListener.java
new file mode 100644
index 0000000..2cd2b1f
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FieldDateResolutionFCListener.java
@@ -0,0 +1,67 @@
+package org.apache.lucene.queryparser.flexible.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Map;
+
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.DateTools.Resolution;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfigListener;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+
+/**
+ * This listener listens for every field configuration request and assign a
+ * {@link ConfigurationKeys#DATE_RESOLUTION} to the equivalent {@link FieldConfig} based
+ * on a defined map: fieldName -> {@link Resolution} stored in
+ * {@link ConfigurationKeys#FIELD_DATE_RESOLUTION_MAP}.
+ * 
+ * @see ConfigurationKeys#DATE_RESOLUTION
+ * @see ConfigurationKeys#FIELD_DATE_RESOLUTION_MAP
+ * @see FieldConfig
+ * @see FieldConfigListener
+ */
+public class FieldDateResolutionFCListener implements FieldConfigListener {
+
+  private QueryConfigHandler config = null;
+
+  public FieldDateResolutionFCListener(QueryConfigHandler config) {
+    this.config = config;
+  }
+
+  public void buildFieldConfig(FieldConfig fieldConfig) {
+    DateTools.Resolution dateRes = null;
+    Map<CharSequence, DateTools.Resolution> dateResMap = this.config.get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP);
+
+    if (dateResMap != null) {
+      dateRes = dateResMap.get(
+          fieldConfig.getField());
+    }
+
+    if (dateRes == null) {
+      dateRes = this.config.get(ConfigurationKeys.DATE_RESOLUTION);
+    }
+
+    if (dateRes != null) {
+      fieldConfig.set(ConfigurationKeys.DATE_RESOLUTION, dateRes);
+    }
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FuzzyConfig.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FuzzyConfig.java
new file mode 100644
index 0000000..90596f7
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/FuzzyConfig.java
@@ -0,0 +1,46 @@
+package org.apache.lucene.queryparser.flexible.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.search.FuzzyQuery;
+
+public class FuzzyConfig {
+  
+  private int prefixLength = FuzzyQuery.defaultPrefixLength;
+
+  private float minSimilarity = FuzzyQuery.defaultMinSimilarity;
+  
+  public FuzzyConfig() {}
+
+  public int getPrefixLength() {
+    return prefixLength;
+  }
+
+  public void setPrefixLength(int prefixLength) {
+    this.prefixLength = prefixLength;
+  }
+
+  public float getMinSimilarity() {
+    return minSimilarity;
+  }
+
+  public void setMinSimilarity(float minSimilarity) {
+    this.minSimilarity = minSimilarity;
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumberDateFormat.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumberDateFormat.java
new file mode 100644
index 0000000..9ba54db
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumberDateFormat.java
@@ -0,0 +1,59 @@
+package org.apache.lucene.queryparser.flexible.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.DateFormat;
+import java.text.FieldPosition;
+import java.text.NumberFormat;
+import java.text.ParsePosition;
+import java.util.Date;
+
+public class NumberDateFormat extends NumberFormat {
+  
+  private static final long serialVersionUID = 964823936071308283L;
+  
+  final private DateFormat dateFormat;
+  
+  public NumberDateFormat(DateFormat dateFormat) {
+    this.dateFormat = dateFormat;
+  }
+  
+  @Override
+  public StringBuffer format(double number, StringBuffer toAppendTo,
+      FieldPosition pos) {
+    return dateFormat.format(new Date((long) number), toAppendTo, pos);
+  }
+  
+  @Override
+  public StringBuffer format(long number, StringBuffer toAppendTo,
+      FieldPosition pos) {
+    return dateFormat.format(new Date(number), toAppendTo, pos);
+  }
+  
+  @Override
+  public Number parse(String source, ParsePosition parsePosition) {
+    return dateFormat.parse(source, parsePosition).getTime();
+  }
+  
+  @Override
+  public StringBuffer format(Object number, StringBuffer toAppendTo,
+      FieldPosition pos) {
+    return dateFormat.format(number, toAppendTo, pos);
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericConfig.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericConfig.java
new file mode 100644
index 0000000..234f290
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericConfig.java
@@ -0,0 +1,94 @@
+package org.apache.lucene.queryparser.flexible.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.NumberFormat;
+
+import org.apache.lucene.document.NumericField;
+
+public class NumericConfig {
+  
+  private int precisionStep;
+  
+  private NumberFormat format;
+  
+  private NumericField.DataType type;
+ 
+  public NumericConfig(int precisionStep, NumberFormat format, NumericField.DataType type) {
+    setPrecisionStep(precisionStep);
+    setNumberFormat(format);
+    setType(type);
+    
+  }
+  
+  public int getPrecisionStep() {
+    return precisionStep;
+  }
+  
+  public void setPrecisionStep(int precisionStep) {
+    this.precisionStep = precisionStep;
+  }
+  
+  public NumberFormat getNumberFormat() {
+    return format;
+  }
+  
+  public NumericField.DataType getType() {
+    return type;
+  }
+
+  public void setType(NumericField.DataType type) {
+    
+    if (type == null) {
+      throw new IllegalArgumentException("type cannot be null!");
+    }
+    
+    this.type = type;
+    
+  }
+
+  public void setNumberFormat(NumberFormat format) {
+    
+    if (format == null) {
+      throw new IllegalArgumentException("format cannot be null!");
+    }
+    
+    this.format = format;
+    
+  }
+  
+  @Override
+  public boolean equals(Object obj) {
+    
+    if (obj == this) return true;
+    
+    if (obj instanceof NumericConfig) {
+      NumericConfig other = (NumericConfig) obj;
+      
+      if (this.precisionStep == other.precisionStep
+          && this.format == other.format) {
+        return true;
+      }
+      
+    }
+    
+    return false;
+    
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericFieldConfigListener.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericFieldConfigListener.java
new file mode 100644
index 0000000..45703b6
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericFieldConfigListener.java
@@ -0,0 +1,57 @@
+package org.apache.lucene.queryparser.flexible.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Map;
+
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfigListener;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+
+public class NumericFieldConfigListener implements FieldConfigListener {
+  
+  final private QueryConfigHandler config;
+  
+  public NumericFieldConfigListener(QueryConfigHandler config) {
+    
+    if (config == null) {
+      throw new IllegalArgumentException("config cannot be null!");
+    }
+    
+    this.config = config;
+    
+  }
+  
+  public void buildFieldConfig(FieldConfig fieldConfig) {
+    Map<String,NumericConfig> numericConfigMap = config
+        .get(ConfigurationKeys.NUMERIC_CONFIG_MAP);
+    
+    if (numericConfigMap != null) {
+      NumericConfig numericConfig = numericConfigMap
+          .get(fieldConfig.getField());
+      
+      if (numericConfig != null) {
+        fieldConfig.set(ConfigurationKeys.NUMERIC_CONFIG, numericConfig);
+      }
+      
+    }
+    
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java
new file mode 100644
index 0000000..4b5dc2f
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java
@@ -0,0 +1,207 @@
+package org.apache.lucene.queryparser.flexible.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.DateTools.Resolution;
+import org.apache.lucene.queryparser.flexible.core.config.ConfigurationKey;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.StandardQueryParser;
+import org.apache.lucene.queryparser.flexible.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
+
+/**
+ * This query configuration handler is used for almost every processor defined
+ * in the {@link StandardQueryNodeProcessorPipeline} processor pipeline. It holds
+ * configuration methods that reproduce the configuration methods that could be set on the old
+ * lucene 2.4 QueryParser class. <br/>
+ * 
+ * @see StandardQueryNodeProcessorPipeline
+ */
+public class StandardQueryConfigHandler extends QueryConfigHandler {
+
+  final public static class ConfigurationKeys  {
+    
+    /**
+     * Key used to set whether position increments is enabled
+     * 
+     * @see StandardQueryParser#setEnablePositionIncrements(boolean)
+     * @see StandardQueryParser#getEnablePositionIncrements()
+     */
+    final public static ConfigurationKey<Boolean> ENABLE_POSITION_INCREMENTS = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set whether expanded terms should be expanded
+     * 
+     * @see StandardQueryParser#setLowercaseExpandedTerms(boolean)
+     * @see StandardQueryParser#getLowercaseExpandedTerms()
+     */
+    final public static ConfigurationKey<Boolean> LOWERCASE_EXPANDED_TERMS = ConfigurationKey.newInstance();
+
+    /**
+     * Key used to set whether leading wildcards are supported
+     * 
+     * @see StandardQueryParser#setAllowLeadingWildcard(boolean)
+     * @see StandardQueryParser#getAllowLeadingWildcard()
+     */
+    final public static ConfigurationKey<Boolean> ALLOW_LEADING_WILDCARD = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link Analyzer} used for terms found in the query
+     * 
+     * @see StandardQueryParser#setAnalyzer(Analyzer)
+     * @see StandardQueryParser#getAnalyzer()
+     */
+    final public static ConfigurationKey<Analyzer> ANALYZER = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the default boolean operator
+     * 
+     * @see StandardQueryParser#setDefaultOperator(org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.Operator)
+     * @see StandardQueryParser#getDefaultOperator()
+     */
+    final public static ConfigurationKey<Operator> DEFAULT_OPERATOR = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the default phrase slop
+     * 
+     * @see StandardQueryParser#setPhraseSlop(int)
+     * @see StandardQueryParser#getPhraseSlop()
+     */
+    final public static ConfigurationKey<Integer> PHRASE_SLOP = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link Locale} used when parsing the query
+     * 
+     * @see StandardQueryParser#setLocale(Locale)
+     * @see StandardQueryParser#getLocale()
+     */
+    final public static ConfigurationKey<Locale> LOCALE = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link RewriteMethod} used when creating queries
+     * 
+     * @see StandardQueryParser#setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)
+     * @see StandardQueryParser#getMultiTermRewriteMethod()
+     */
+    final public static ConfigurationKey<MultiTermQuery.RewriteMethod> MULTI_TERM_REWRITE_METHOD = ConfigurationKey.newInstance();
+
+    /**
+     * Key used to set the fields a query should be expanded to when the field
+     * is <code>null</code>
+     * 
+     * @see StandardQueryParser#setMultiFields(CharSequence[])
+     * @see StandardQueryParser#getMultiFields(CharSequence[])
+     */
+    final public static ConfigurationKey<CharSequence[]> MULTI_FIELDS = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set a field to boost map that is used to set the boost for each field
+     * 
+     * @see StandardQueryParser#setFieldsBoost(Map)
+     * @see StandardQueryParser#getFieldsBoost()
+     */
+    final public static ConfigurationKey<Map<String,Float>> FIELD_BOOST_MAP = ConfigurationKey.newInstance();
+
+    /**
+     * Key used to set a field to {@link Resolution} map that is used
+     * to normalize each date field value.
+     * 
+     * @see StandardQueryParser#setDateResolutionMap(Map)
+     * @see StandardQueryParser#getDateResolutionMap()
+     */
+    final public static ConfigurationKey<Map<CharSequence, DateTools.Resolution>> FIELD_DATE_RESOLUTION_MAP = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link FuzzyConfig} used to create fuzzy queries.
+     * 
+     * @see StandardQueryParser#setFuzzyMinSim(float)
+     * @see StandardQueryParser#setFuzzyPrefixLength(int)
+     * @see StandardQueryParser#getFuzzyMinSim()
+     * @see StandardQueryParser#getFuzzyPrefixLength()
+     */
+    final public static ConfigurationKey<FuzzyConfig> FUZZY_CONFIG = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set default {@link Resolution}.
+     * 
+     * @see StandardQueryParser#setDateResolution(org.apache.lucene.document.DateTools.Resolution)
+     * @see StandardQueryParser#getDateResolution()
+     */
+    final public static ConfigurationKey<DateTools.Resolution> DATE_RESOLUTION = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the boost value in {@link FieldConfig} objects.
+     * 
+     * @see StandardQueryParser#setFieldsBoost(Map)
+     * @see StandardQueryParser#getFieldsBoost()
+     */
+    final public static ConfigurationKey<Float> BOOST = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set a field to its {@link NumericConfig}.
+     * 
+     * @see StandardQueryParser#setNumericConfigMap(Map)
+     * @see StandardQueryParser#getNumericConfigMap()
+     */
+    final public static ConfigurationKey<NumericConfig> NUMERIC_CONFIG = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link NumericConfig} in {@link FieldConfig} for numeric fields.
+     * 
+     * @see StandardQueryParser#setNumericConfigMap(Map)
+     * @see StandardQueryParser#getNumericConfigMap()
+     */
+    final public static ConfigurationKey<Map<String,NumericConfig>> NUMERIC_CONFIG_MAP = ConfigurationKey.newInstance();
+    
+  }
+  
+  public static enum Operator {
+    AND, OR;
+  }
+
+  public StandardQueryConfigHandler() {
+    // Add listener that will build the FieldConfig.
+    addFieldConfigListener(new FieldBoostMapFCListener(this));
+    addFieldConfigListener(new FieldDateResolutionFCListener(this));
+    addFieldConfigListener(new NumericFieldConfigListener(this));
+    
+    // Default Values
+    set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, false); // default in 2.9
+    set(ConfigurationKeys.ANALYZER, null); //default value 2.4
+    set(ConfigurationKeys.DEFAULT_OPERATOR, Operator.OR);
+    set(ConfigurationKeys.PHRASE_SLOP, 0); //default value 2.4
+    set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, true); //default value 2.4
+    set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, false); //default value 2.4
+    set(ConfigurationKeys.FIELD_BOOST_MAP, new LinkedHashMap<String, Float>());
+    set(ConfigurationKeys.FUZZY_CONFIG, new FuzzyConfig());
+    set(ConfigurationKeys.LOCALE, Locale.getDefault());
+    set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
+    set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, new HashMap<CharSequence, DateTools.Resolution>());
+    
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/package.html
new file mode 100644
index 0000000..242056f
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/package.html
@@ -0,0 +1,34 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+<h2>Standard Lucene Query Configuration</h2>
+<p>
+The package org.apache.lucene.queryparser.flexible.standard.config contains the Lucene
+query configuration handler (StandardQueryConfigHandler). This configuration
+handler reproduces almost everything that could be set on the old query parser.
+</p>
+<p>
+StandardQueryConfigHandler is the class that should be used to configure the StandardQueryNodeProcessorPipeline.
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/AbstractRangeQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/AbstractRangeQueryNode.java
new file mode 100644
index 0000000..0dfcda2
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/AbstractRangeQueryNode.java
@@ -0,0 +1,153 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldValuePairQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+
+public abstract class AbstractRangeQueryNode<T extends FieldValuePairQueryNode<?>>
+    extends QueryNodeImpl implements FieldableNode {
+  
+  private boolean lowerInclusive, upperInclusive;
+  
+  protected AbstractRangeQueryNode() {
+    setLeaf(false);
+    allocate();
+  }
+  
+  public CharSequence getField() {
+    CharSequence field = null;
+    T lower = getLowerBound();
+    T upper = getUpperBound();
+    
+    if (lower != null) {
+      field = lower.getField();
+      
+    } else if (upper != null) {
+      field = upper.getField();
+    }
+    
+    return field;
+    
+  }
+  
+  public void setField(CharSequence fieldName) {
+    T lower = getLowerBound();
+    T upper = getUpperBound();
+    
+    if (lower != null) {
+      lower.setField(fieldName);
+    }
+    
+    if (upper != null) {
+      upper.setField(fieldName);
+    }
+    
+  }
+  
+  @SuppressWarnings("unchecked")
+  public T getLowerBound() {
+    return (T) getChildren().get(0);
+  }
+  
+  @SuppressWarnings("unchecked")
+  public T getUpperBound() {
+    return (T) getChildren().get(1);
+  }
+  
+  public boolean isLowerInclusive() {
+    return lowerInclusive;
+  }
+  
+  public boolean isUpperInclusive() {
+    return upperInclusive;
+  }
+  
+  public void setBounds(T lower, T upper, boolean lowerInclusive,
+      boolean upperInclusive) {
+    
+    if (lower != null && upper != null) {
+      String lowerField = StringUtils.toString(lower.getField());
+      String upperField = StringUtils.toString(upper.getField());
+      
+      if ((upperField == null && lowerField == null)
+          || (upperField != null && !upperField.equals(lowerField))) {
+        throw new IllegalArgumentException(
+            "lower and upper bounds should have the same field name!");
+      }
+      
+      this.lowerInclusive = lowerInclusive;
+      this.upperInclusive = upperInclusive;
+      
+      ArrayList<QueryNode> children = new ArrayList<QueryNode>(2);
+      children.add(lower);
+      children.add(upper);
+      
+      set(children);
+      
+    }
+    
+  }
+  
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    StringBuilder sb = new StringBuilder();
+    
+    T lower = getLowerBound();
+    T upper = getUpperBound();
+    
+    if (lowerInclusive) {
+      sb.append('[');
+      
+    } else {
+      sb.append('{');
+    }
+    
+    if (lower != null) {
+      sb.append(lower.toQueryString(escapeSyntaxParser));
+      
+    } else {
+      sb.append("...");
+    }
+    
+    sb.append(' ');
+    
+    if (upper != null) {
+      sb.append(upper.toQueryString(escapeSyntaxParser));
+      
+    } else {
+      sb.append("...");
+    }
+    
+    if (upperInclusive) {
+      sb.append(']');
+      
+    } else {
+      sb.append('}');
+    }
+    
+    return sb.toString();
+    
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/BooleanModifierNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/BooleanModifierNode.java
new file mode 100644
index 0000000..2f27bf8
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/BooleanModifierNode.java
@@ -0,0 +1,37 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.processors.GroupQueryNodeProcessor;
+
+/**
+ * A {@link BooleanModifierNode} has the same behaviour as
+ * {@link ModifierQueryNode}, it only indicates that this modifier was added by
+ * {@link GroupQueryNodeProcessor} and not by the user. <br/>
+ * 
+ * @see ModifierQueryNode
+ */
+public class BooleanModifierNode extends ModifierQueryNode {
+
+  public BooleanModifierNode(QueryNode node, Modifier mod) {
+    super(node, mod);
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/MultiPhraseQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/MultiPhraseQueryNode.java
new file mode 100644
index 0000000..5d399f3
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/MultiPhraseQueryNode.java
@@ -0,0 +1,108 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+
+/**
+ * A {@link MultiPhraseQueryNode} indicates that its children should be used to
+ * build a {@link MultiPhraseQuery} instead of {@link PhraseQuery}.
+ */
+public class MultiPhraseQueryNode extends QueryNodeImpl implements
+    FieldableNode {
+
+  public MultiPhraseQueryNode() {
+    setLeaf(false);
+    allocate();
+
+  }
+
+  @Override
+  public String toString() {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "<multiPhrase/>";
+    StringBuilder sb = new StringBuilder();
+    sb.append("<multiPhrase>");
+    for (QueryNode child : getChildren()) {
+      sb.append("\n");
+      sb.append(child.toString());
+    }
+    sb.append("\n</multiPhrase>");
+    return sb.toString();
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "";
+
+    StringBuilder sb = new StringBuilder();
+    String filler = "";
+    for (QueryNode child : getChildren()) {
+      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
+      filler = ",";
+    }
+
+    return "[MTP[" + sb.toString() + "]]";
+  }
+
+  @Override
+  public QueryNode cloneTree() throws CloneNotSupportedException {
+    MultiPhraseQueryNode clone = (MultiPhraseQueryNode) super.cloneTree();
+
+    // nothing to do
+
+    return clone;
+  }
+
+  public CharSequence getField() {
+    List<QueryNode> children = getChildren();
+
+    if (children == null || children.size() == 0) {
+      return null;
+
+    } else {
+      return ((FieldableNode) children.get(0)).getField();
+    }
+
+  }
+
+  public void setField(CharSequence fieldName) {
+    List<QueryNode> children = getChildren();
+
+    if (children != null) {
+
+      for (QueryNode child : children) {
+
+        if (child instanceof FieldableNode) {
+          ((FieldableNode) child).setField(fieldName);
+        }
+
+      }
+
+    }
+
+  }
+
+} // end class MultitermQueryNode
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericQueryNode.java
new file mode 100644
index 0000000..adef571
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericQueryNode.java
@@ -0,0 +1,91 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.NumberFormat;
+import java.util.Locale;
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldValuePairQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax.Type;
+
+public class NumericQueryNode extends QueryNodeImpl implements
+    FieldValuePairQueryNode<Number> {
+  
+  private NumberFormat numberFormat;
+  
+  private CharSequence field;
+  
+  private Number value;
+  
+  public NumericQueryNode(CharSequence field, Number value,
+      NumberFormat numberFormat) {
+    
+    super();
+    
+    setNumberFormat(numberFormat);
+    setField(field);
+    setValue(value);
+    
+  }
+  
+  public CharSequence getField() {
+    return this.field;
+  }
+  
+  public void setField(CharSequence fieldName) {
+    this.field = fieldName;
+  }
+  
+  protected CharSequence getTermEscaped(EscapeQuerySyntax escaper) {
+    return escaper.escape(NumberFormat.getNumberInstance().format(this.value),
+        Locale.ENGLISH, Type.NORMAL);
+  }
+  
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (isDefaultField(this.field)) {
+      return getTermEscaped(escapeSyntaxParser);
+    } else {
+      return this.field + ":" + getTermEscaped(escapeSyntaxParser);
+    }
+  }
+  
+  public void setNumberFormat(NumberFormat format) {
+    this.numberFormat = format;
+  }
+  
+  public NumberFormat getNumberFormat() {
+    return this.numberFormat;
+  }
+  
+  public Number getValue() {
+    return value;
+  }
+  
+  public void setValue(Number value) {
+    this.value = value;
+  }
+  
+  @Override
+  public String toString() {
+    return "<numeric field='" + this.field + "' number='"
+        + numberFormat.format(value) + "'/>";
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericRangeQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericRangeQueryNode.java
new file mode 100644
index 0000000..3b0a85b
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericRangeQueryNode.java
@@ -0,0 +1,116 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+import org.apache.lucene.document.NumericField;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
+ * licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+public class NumericRangeQueryNode extends
+    AbstractRangeQueryNode<NumericQueryNode> {
+  
+  public NumericConfig numericConfig; 
+  
+  public NumericRangeQueryNode(NumericQueryNode lower, NumericQueryNode upper,
+      boolean lowerInclusive, boolean upperInclusive, NumericConfig numericConfig) throws QueryNodeException {
+    setBounds(lower, upper, lowerInclusive, upperInclusive, numericConfig);
+  }
+  
+  private static NumericField.DataType getNumericDataType(Number number) throws QueryNodeException {
+    
+    if (number instanceof Long) {
+      return NumericField.DataType.LONG;
+    } else if (number instanceof Integer) {
+      return NumericField.DataType.INT;
+    } else if (number instanceof Double) {
+      return NumericField.DataType.DOUBLE;
+    } else if (number instanceof Float) {
+      return NumericField.DataType.FLOAT;
+    } else {
+      throw new QueryNodeException(
+          new MessageImpl(
+              QueryParserMessages.NUMBER_CLASS_NOT_SUPPORTED_BY_NUMERIC_RANGE_QUERY,
+              number.getClass()));
+    }
+    
+  }
+  
+  public void setBounds(NumericQueryNode lower, NumericQueryNode upper,
+      boolean lowerInclusive, boolean upperInclusive, NumericConfig numericConfig) throws QueryNodeException {
+    
+    if (numericConfig == null) {
+      throw new IllegalArgumentException("numericConfig cannot be null!");
+    }
+    
+    NumericField.DataType lowerNumberType, upperNumberType;
+    
+    if (lower != null && lower.getValue() != null) {
+      lowerNumberType = getNumericDataType(lower.getValue());
+    } else {
+      lowerNumberType = null;
+    }
+    
+    if (upper != null && upper.getValue() != null) {
+      upperNumberType = getNumericDataType(upper.getValue());
+    } else {
+      upperNumberType = null;
+    }
+    
+    if (lowerNumberType != null
+        && !lowerNumberType.equals(numericConfig.getType())) {
+      throw new IllegalArgumentException(
+          "lower value's type should be the same as numericConfig type: "
+              + lowerNumberType + " != " + numericConfig.getType());
+    }
+    
+    if (upperNumberType != null
+        && !upperNumberType.equals(numericConfig.getType())) {
+      throw new IllegalArgumentException(
+          "upper value's type should be the same as numericConfig type: "
+              + upperNumberType + " != " + numericConfig.getType());
+    }
+    
+    super.setBounds(lower, upper, lowerInclusive, upperInclusive);
+    this.numericConfig = numericConfig;
+    
+  }
+  
+  public NumericConfig getNumericConfig() {
+    return this.numericConfig;
+  }
+  
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("<numericRange lowerInclusive='");
+    
+    sb.append(isLowerInclusive()).append("' upperInclusive='").append(
+        isUpperInclusive()).append(
+        "' precisionStep='" + numericConfig.getPrecisionStep()).append(
+        "' type='" + numericConfig.getType()).append("'>\n");
+    
+    sb.append(getLowerBound()).append('\n');
+    sb.append(getUpperBound()).append('\n');
+    sb.append("</numericRange>");
+    
+    return sb.toString();
+    
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/PrefixWildcardQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/PrefixWildcardQueryNode.java
new file mode 100644
index 0000000..7b5bd4e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/PrefixWildcardQueryNode.java
@@ -0,0 +1,63 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * A {@link PrefixWildcardQueryNode} represents wildcardquery that matches abc*
+ * or *. This does not apply to phrases, this is a special case on the original
+ * lucene parser. TODO: refactor the code to remove this special case from the
+ * parser. and probably do it on a Processor
+ */
+public class PrefixWildcardQueryNode extends WildcardQueryNode {
+
+  /**
+   * @param field
+   *          - field name
+   * @param text
+   *          - value including the wildcard
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public PrefixWildcardQueryNode(CharSequence field, CharSequence text,
+      int begin, int end) {
+    super(field, text, begin, end);
+  }
+
+  public PrefixWildcardQueryNode(FieldQueryNode fqn) {
+    this(fqn.getField(), fqn.getText(), fqn.getBegin(), fqn.getEnd());
+  }
+
+  @Override
+  public String toString() {
+    return "<prefixWildcard field='" + this.field + "' term='" + this.text
+        + "'/>";
+  }
+
+  @Override
+  public PrefixWildcardQueryNode cloneTree() throws CloneNotSupportedException {
+    PrefixWildcardQueryNode clone = (PrefixWildcardQueryNode) super.cloneTree();
+
+    // nothing to do here
+
+    return clone;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/RangeQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/RangeQueryNode.java
new file mode 100644
index 0000000..49d907c
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/RangeQueryNode.java
@@ -0,0 +1,50 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.processors.ParametricRangeQueryNodeProcessor;
+
+/**
+ * This query node represents a range query. 
+ * 
+ * @see ParametricRangeQueryNodeProcessor
+ * @see org.apache.lucene.search.TermRangeQuery
+ */
+public class RangeQueryNode extends ParametricRangeQueryNode {
+
+  /**
+   * @param lower
+   * @param upper
+   */
+  public RangeQueryNode(ParametricQueryNode lower, ParametricQueryNode upper) {
+    super(lower, upper);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("<range>\n\t");
+    sb.append(this.getUpperBound()).append("\n\t");
+    sb.append(this.getLowerBound()).append("\n");
+    sb.append("</range>\n");
+
+    return sb.toString();
+
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/RegexpQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/RegexpQueryNode.java
new file mode 100644
index 0000000..5345fb6
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/RegexpQueryNode.java
@@ -0,0 +1,91 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryparser.flexible.core.nodes.TextableQueryNode;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.search.RegexpQuery;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * A {@link RegexpQueryNode} represents {@link RegexpQuery} query Examples: /[a-z]|[0-9]/
+ */
+public class RegexpQueryNode extends QueryNodeImpl  implements TextableQueryNode,
+FieldableNode {
+  private CharSequence text;
+  private CharSequence field;
+  /**
+   * @param field
+   *          - field name
+   * @param text
+   *          - value that contains a regular expression
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public RegexpQueryNode(CharSequence field, CharSequence text, int begin,
+      int end) {
+    this.field = field;
+    this.text = text.subSequence(begin, end);
+  }
+
+  public BytesRef textToBytesRef() {
+    return new BytesRef(text);
+  }
+
+  @Override
+  public String toString() {
+    return "<regexp field='" + this.field + "' term='" + this.text + "'/>";
+  }
+
+  @Override
+  public RegexpQueryNode cloneTree() throws CloneNotSupportedException {
+    RegexpQueryNode clone = (RegexpQueryNode) super.cloneTree();
+    clone.field = this.field;
+    clone.text = this.text;
+    return clone;
+  }
+
+  public CharSequence getText() {
+    return text;
+  }
+
+  public void setText(CharSequence text) {
+    this.text = text;
+  }
+
+  public CharSequence getField() {
+    return field;
+  }
+  
+  public String getFieldAsString() {
+    return field.toString();
+  }
+
+  public void setField(CharSequence field) {
+    this.field = field;
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    return isDefaultField(field)? "/"+text+"/": field + ":/" + text + "/";
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/StandardBooleanQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/StandardBooleanQueryNode.java
new file mode 100644
index 0000000..b72dd04
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/StandardBooleanQueryNode.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.SimilarityProvider;
+
+/**
+ * A {@link StandardBooleanQueryNode} has the same behavior as
+ * {@link BooleanQueryNode}. It only indicates if the coord should be enabled or
+ * not for this boolean query. <br/>
+ * 
+ * @see SimilarityProvider#coord(int, int)
+ * @see BooleanQuery
+ */
+public class StandardBooleanQueryNode extends BooleanQueryNode {
+
+  private boolean disableCoord;
+
+  /**
+   * @param clauses
+   */
+  public StandardBooleanQueryNode(List<QueryNode> clauses, boolean disableCoord) {
+    super(clauses);
+
+    this.disableCoord = disableCoord;
+
+  }
+
+  public boolean isDisableCoord() {
+    return this.disableCoord;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/TermRangeQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/TermRangeQueryNode.java
new file mode 100644
index 0000000..bec3ba6
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/TermRangeQueryNode.java
@@ -0,0 +1,35 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+
+/**
+ * This query node represents a range query.
+ * 
+ * @see org.apache.lucene.queryparser.flexible.standard.processors.ParametricRangeQueryNodeProcessor
+ * @see org.apache.lucene.search.TermRangeQuery
+ */
+public class TermRangeQueryNode extends AbstractRangeQueryNode<FieldQueryNode> {
+  
+  public TermRangeQueryNode(FieldQueryNode lower, FieldQueryNode upper,
+      boolean lowerInclusive, boolean upperInclusive) {
+    setBounds(lower, upper, lowerInclusive, upperInclusive);
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/WildcardQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/WildcardQueryNode.java
new file mode 100644
index 0000000..fc17961
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/WildcardQueryNode.java
@@ -0,0 +1,71 @@
+package org.apache.lucene.queryparser.flexible.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link WildcardQueryNode} represents wildcard query This does not apply to
+ * phrases. Examples: a*b*c Fl?w? m?ke*g
+ */
+public class WildcardQueryNode extends FieldQueryNode {
+
+  /**
+   * @param field
+   *          - field name
+   * @param text
+   *          - value that contains one or more wild card characters (? or *)
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public WildcardQueryNode(CharSequence field, CharSequence text, int begin,
+      int end) {
+    super(field, text, begin, end);
+  }
+
+  public WildcardQueryNode(FieldQueryNode fqn) {
+    this(fqn.getField(), fqn.getText(), fqn.getBegin(), fqn.getEnd());
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
+    if (isDefaultField(this.field)) {
+      return this.text;
+    } else {
+      return this.field + ":" + this.text;
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "<wildcard field='" + this.field + "' term='" + this.text + "'/>";
+  }
+
+  @Override
+  public WildcardQueryNode cloneTree() throws CloneNotSupportedException {
+    WildcardQueryNode clone = (WildcardQueryNode) super.cloneTree();
+
+    // nothing to do here
+
+    return clone;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/package.html
new file mode 100644
index 0000000..20f6be8
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/package.html
@@ -0,0 +1,31 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+<h2>Standard Lucene Query Nodes</h2>
+<p>
+The package org.apache.lucene.queryparser.flexible.standard.nodes contains QueryNode classes
+that are used specifically for Lucene query node tree. Any other generic QueryNode is
+defined under org.apache.lucene.queryParser.nodes.
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/package.html
new file mode 100644
index 0000000..211edbb
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/package.html
@@ -0,0 +1,43 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+Contains the implementation of the Lucene query parser using the flexible query parser frameworks
+
+<h2>Lucene Flexible Query Parser Implementation</h2>
+<p>
+The old Lucene query parser used to have only one class that performed 
+all the parsing operations. In the new query parser structure, the 
+parsing was divided in 3 steps: parsing (syntax), processing (semantic)
+and building.
+</p>
+<p>
+The classes contained in the package org.apache.lucene.queryParser.standard
+are used to reproduce the same behavior as the old query parser.
+</p>
+
+<p>
+Check <tt>org.apache.lucene.queryparser.flexible.standard.StandardQueryParser</tt> to quick start using the Lucene query parser.
+</p>
+
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/EscapeQuerySyntaxImpl.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/EscapeQuerySyntaxImpl.java
new file mode 100644
index 0000000..f581f14
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/EscapeQuerySyntaxImpl.java
@@ -0,0 +1,296 @@
+package org.apache.lucene.queryparser.flexible.standard.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Locale;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.core.util.UnescapedCharSequence;
+
+/**
+ */
+public class EscapeQuerySyntaxImpl implements EscapeQuerySyntax {
+
+  private static final char[] wildcardChars = { '*', '?' };
+
+  private static final String[] escapableTermExtraFirstChars = { "+", "-", "@" };
+
+  private static final String[] escapableTermChars = { "\"", "<", ">", "=",
+      "!", "(", ")", "^", "[", "{", ":", "]", "}", "~" };
+
+  // TODO: check what to do with these "*", "?", "\\"
+  private static final String[] escapableQuotedChars = { "\"" };
+  private static final String[] escapableWhiteChars = { " ", "\t", "\n", "\r",
+      "\f", "\b", "\u3000" };
+  private static final String[] escapableWordTokens = { "AND", "OR", "NOT",
+      "TO", "WITHIN", "SENTENCE", "PARAGRAPH", "INORDER" };
+
+  private static final CharSequence escapeChar(CharSequence str, Locale locale) {
+    if (str == null || str.length() == 0)
+      return str;
+
+    CharSequence buffer = str;
+
+    // regular escapable Char for terms
+    for (int i = 0; i < escapableTermChars.length; i++) {
+      buffer = replaceIgnoreCase(buffer, escapableTermChars[i].toLowerCase(),
+          "\\", locale);
+    }
+
+    // First Character of a term as more escaping chars
+    for (int i = 0; i < escapableTermExtraFirstChars.length; i++) {
+      if (buffer.charAt(0) == escapableTermExtraFirstChars[i].charAt(0)) {
+        buffer = "\\" + buffer.charAt(0)
+            + buffer.subSequence(1, buffer.length());
+        break;
+      }
+    }
+
+    return buffer;
+  }
+
+  private final CharSequence escapeQuoted(CharSequence str, Locale locale) {
+    if (str == null || str.length() == 0)
+      return str;
+
+    CharSequence buffer = str;
+
+    for (int i = 0; i < escapableQuotedChars.length; i++) {
+      buffer = replaceIgnoreCase(buffer, escapableTermChars[i].toLowerCase(),
+          "\\", locale);
+    }
+    return buffer;
+  }
+
+  private static final CharSequence escapeTerm(CharSequence term, Locale locale) {
+    if (term == null)
+      return term;
+
+    // Escape single Chars
+    term = escapeChar(term, locale);
+    term = escapeWhiteChar(term, locale);
+
+    // Escape Parser Words
+    for (int i = 0; i < escapableWordTokens.length; i++) {
+      if (escapableWordTokens[i].equalsIgnoreCase(term.toString()))
+        return "\\" + term;
+    }
+    return term;
+  }
+
+  /**
+   * replace with ignore case
+   * 
+   * @param string
+   *          string to get replaced
+   * @param sequence1
+   *          the old character sequence in lowercase
+   * @param escapeChar
+   *          the new character to prefix sequence1 in return string.
+   * @return the new String
+   */
+  private static CharSequence replaceIgnoreCase(CharSequence string,
+      CharSequence sequence1, CharSequence escapeChar, Locale locale) {
+    if (escapeChar == null || sequence1 == null || string == null)
+      throw new NullPointerException();
+
+    // empty string case
+    int count = string.length();
+    int sequence1Length = sequence1.length();
+    if (sequence1Length == 0) {
+      StringBuilder result = new StringBuilder((count + 1)
+          * escapeChar.length());
+      result.append(escapeChar);
+      for (int i = 0; i < count; i++) {
+        result.append(string.charAt(i));
+        result.append(escapeChar);
+      }
+      return result.toString();
+    }
+
+    // normal case
+    StringBuilder result = new StringBuilder();
+    char first = sequence1.charAt(0);
+    int start = 0, copyStart = 0, firstIndex;
+    while (start < count) {
+      if ((firstIndex = string.toString().toLowerCase(locale).indexOf(first,
+          start)) == -1)
+        break;
+      boolean found = true;
+      if (sequence1.length() > 1) {
+        if (firstIndex + sequence1Length > count)
+          break;
+        for (int i = 1; i < sequence1Length; i++) {
+          if (string.toString().toLowerCase(locale).charAt(firstIndex + i) != sequence1
+              .charAt(i)) {
+            found = false;
+            break;
+          }
+        }
+      }
+      if (found) {
+        result.append(string.toString().substring(copyStart, firstIndex));
+        result.append(escapeChar);
+        result.append(string.toString().substring(firstIndex,
+            firstIndex + sequence1Length));
+        copyStart = start = firstIndex + sequence1Length;
+      } else {
+        start = firstIndex + 1;
+      }
+    }
+    if (result.length() == 0 && copyStart == 0)
+      return string;
+    result.append(string.toString().substring(copyStart));
+    return result.toString();
+  }
+
+  /**
+   * escape all tokens that are part of the parser syntax on a given string
+   * 
+   * @param str
+   *          string to get replaced
+   * @param locale
+   *          locale to be used when performing string compares
+   * @return the new String
+   */
+  private static final CharSequence escapeWhiteChar(CharSequence str,
+      Locale locale) {
+    if (str == null || str.length() == 0)
+      return str;
+
+    CharSequence buffer = str;
+
+    for (int i = 0; i < escapableWhiteChars.length; i++) {
+      buffer = replaceIgnoreCase(buffer, escapableWhiteChars[i].toLowerCase(),
+          "\\", locale);
+    }
+    return buffer;
+  }
+
+  public CharSequence escape(CharSequence text, Locale locale, Type type) {
+    if (text == null || text.length() == 0)
+      return text;
+
+    // escape wildcards and the escape char (this has to be perform before
+    // anything else)
+    // since we need to preserve the UnescapedCharSequence and escape the
+    // original escape chars
+    if (text instanceof UnescapedCharSequence) {
+      text = ((UnescapedCharSequence) text).toStringEscaped(wildcardChars);
+    } else {
+      text = new UnescapedCharSequence(text).toStringEscaped(wildcardChars);
+    }
+
+    if (type == Type.STRING) {
+      return escapeQuoted(text, locale);
+    } else {
+      return escapeTerm(text, locale);
+    }
+  }
+
+  /**
+   * Returns a String where the escape char has been removed, or kept only once
+   * if there was a double escape.
+   * 
+   * Supports escaped unicode characters, e. g. translates <code>A</code> to
+   * <code>A</code>.
+   * 
+   */
+  public static UnescapedCharSequence discardEscapeChar(CharSequence input)
+      throws ParseException {
+    // Create char array to hold unescaped char sequence
+    char[] output = new char[input.length()];
+    boolean[] wasEscaped = new boolean[input.length()];
+
+    // The length of the output can be less than the input
+    // due to discarded escape chars. This variable holds
+    // the actual length of the output
+    int length = 0;
+
+    // We remember whether the last processed character was
+    // an escape character
+    boolean lastCharWasEscapeChar = false;
+
+    // The multiplier the current unicode digit must be multiplied with.
+    // E. g. the first digit must be multiplied with 16^3, the second with
+    // 16^2...
+    int codePointMultiplier = 0;
+
+    // Used to calculate the codepoint of the escaped unicode character
+    int codePoint = 0;
+
+    for (int i = 0; i < input.length(); i++) {
+      char curChar = input.charAt(i);
+      if (codePointMultiplier > 0) {
+        codePoint += hexToInt(curChar) * codePointMultiplier;
+        codePointMultiplier >>>= 4;
+        if (codePointMultiplier == 0) {
+          output[length++] = (char) codePoint;
+          codePoint = 0;
+        }
+      } else if (lastCharWasEscapeChar) {
+        if (curChar == 'u') {
+          // found an escaped unicode character
+          codePointMultiplier = 16 * 16 * 16;
+        } else {
+          // this character was escaped
+          output[length] = curChar;
+          wasEscaped[length] = true;
+          length++;
+        }
+        lastCharWasEscapeChar = false;
+      } else {
+        if (curChar == '\\') {
+          lastCharWasEscapeChar = true;
+        } else {
+          output[length] = curChar;
+          length++;
+        }
+      }
+    }
+
+    if (codePointMultiplier > 0) {
+      throw new ParseException(new MessageImpl(
+          QueryParserMessages.INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION));
+    }
+
+    if (lastCharWasEscapeChar) {
+      throw new ParseException(new MessageImpl(
+          QueryParserMessages.INVALID_SYNTAX_ESCAPE_CHARACTER));
+    }
+
+    return new UnescapedCharSequence(output, wasEscaped, 0, length);
+  }
+
+  /** Returns the numeric value of the hexadecimal character */
+  private static final int hexToInt(char c) throws ParseException {
+    if ('0' <= c && c <= '9') {
+      return c - '0';
+    } else if ('a' <= c && c <= 'f') {
+      return c - 'a' + 10;
+    } else if ('A' <= c && c <= 'F') {
+      return c - 'A' + 10;
+    } else {
+      throw new ParseException(new MessageImpl(
+          QueryParserMessages.INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE, c));
+    }
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/JavaCharStream.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/JavaCharStream.java
new file mode 100644
index 0000000..48e8e33
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/JavaCharStream.java
@@ -0,0 +1,616 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.1 */
+/* JavaCCOptions:STATIC=false */
+package org.apache.lucene.queryparser.flexible.standard.parser;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (with java-like unicode escape processing).
+ */
+
+public class JavaCharStream
+{
+/** Whether parser is static. */
+  public static final boolean staticFlag = false;
+  static final int hexval(char c) throws java.io.IOException {
+    switch(c)
+    {
+       case '0' :
+          return 0;
+       case '1' :
+          return 1;
+       case '2' :
+          return 2;
+       case '3' :
+          return 3;
+       case '4' :
+          return 4;
+       case '5' :
+          return 5;
+       case '6' :
+          return 6;
+       case '7' :
+          return 7;
+       case '8' :
+          return 8;
+       case '9' :
+          return 9;
+
+       case 'a' :
+       case 'A' :
+          return 10;
+       case 'b' :
+       case 'B' :
+          return 11;
+       case 'c' :
+       case 'C' :
+          return 12;
+       case 'd' :
+       case 'D' :
+          return 13;
+       case 'e' :
+       case 'E' :
+          return 14;
+       case 'f' :
+       case 'F' :
+          return 15;
+    }
+
+    throw new java.io.IOException(); // Should never come here
+  }
+
+/** Position in buffer. */
+  public int bufpos = -1;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] nextCharBuf;
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int nextCharInd = -1;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+     char[] newbuffer = new char[bufsize + 2048];
+     int newbufline[] = new int[bufsize + 2048];
+     int newbufcolumn[] = new int[bufsize + 2048];
+
+     try
+     {
+        if (wrapAround)
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           System.arraycopy(buffer, 0, newbuffer,
+                                             bufsize - tokenBegin, bufpos);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+           bufcolumn = newbufcolumn;
+
+           bufpos += (bufsize - tokenBegin);
+        }
+        else
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           bufcolumn = newbufcolumn;
+
+           bufpos -= tokenBegin;
+        }
+     }
+     catch (Throwable t)
+     {
+        throw new Error(t.getMessage());
+     }
+
+     available = (bufsize += 2048);
+     tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+     int i;
+     if (maxNextCharInd == 4096)
+        maxNextCharInd = nextCharInd = 0;
+
+     try {
+        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
+                                            4096 - maxNextCharInd)) == -1)
+        {
+           inputStream.close();
+           throw new java.io.IOException();
+        }
+        else
+           maxNextCharInd += i;
+        return;
+     }
+     catch(java.io.IOException e) {
+        if (bufpos != 0)
+        {
+           --bufpos;
+           backup(0);
+        }
+        else
+        {
+           bufline[bufpos] = line;
+           bufcolumn[bufpos] = column;
+        }
+        throw e;
+     }
+  }
+
+  protected char ReadByte() throws java.io.IOException
+  {
+     if (++nextCharInd >= maxNextCharInd)
+        FillBuff();
+
+     return nextCharBuf[nextCharInd];
+  }
+
+/** @return starting character for token. */
+  public char BeginToken() throws java.io.IOException
+  {
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        tokenBegin = bufpos;
+        return buffer[bufpos];
+     }
+
+     tokenBegin = 0;
+     bufpos = -1;
+
+     return readChar();
+  }
+
+  protected void AdjustBuffSize()
+  {
+     if (available == bufsize)
+     {
+        if (tokenBegin > 2048)
+        {
+           bufpos = 0;
+           available = tokenBegin;
+        }
+        else
+           ExpandBuff(false);
+     }
+     else if (available > tokenBegin)
+        available = bufsize;
+     else if ((tokenBegin - available) < 2048)
+        ExpandBuff(true);
+     else
+        available = tokenBegin;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+     column++;
+
+     if (prevCharIsLF)
+     {
+        prevCharIsLF = false;
+        line += (column = 1);
+     }
+     else if (prevCharIsCR)
+     {
+        prevCharIsCR = false;
+        if (c == '\n')
+        {
+           prevCharIsLF = true;
+        }
+        else
+           line += (column = 1);
+     }
+
+     switch (c)
+     {
+        case '\r' :
+           prevCharIsCR = true;
+           break;
+        case '\n' :
+           prevCharIsLF = true;
+           break;
+        case '\t' :
+           column--;
+           column += (tabSize - (column % tabSize));
+           break;
+        default :
+           break;
+     }
+
+     bufline[bufpos] = line;
+     bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        return buffer[bufpos];
+     }
+
+     char c;
+
+     if (++bufpos == available)
+        AdjustBuffSize();
+
+     if ((buffer[bufpos] = c = ReadByte()) == '\\')
+     {
+        UpdateLineColumn(c);
+
+        int backSlashCnt = 1;
+
+        for (;;) // Read all the backslashes
+        {
+           if (++bufpos == available)
+              AdjustBuffSize();
+
+           try
+           {
+              if ((buffer[bufpos] = c = ReadByte()) != '\\')
+              {
+                 UpdateLineColumn(c);
+                 // found a non-backslash char.
+                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
+                 {
+                    if (--bufpos < 0)
+                       bufpos = bufsize - 1;
+
+                    break;
+                 }
+
+                 backup(backSlashCnt);
+                 return '\\';
+              }
+           }
+           catch(java.io.IOException e)
+           {
+              if (backSlashCnt > 1)
+                 backup(backSlashCnt-1);
+
+              return '\\';
+           }
+
+           UpdateLineColumn(c);
+           backSlashCnt++;
+        }
+
+        // Here, we have seen an odd number of backslash's followed by a 'u'
+        try
+        {
+           while ((c = ReadByte()) == 'u')
+              ++column;
+
+           buffer[bufpos] = c = (char)(hexval(c) << 12 |
+                                       hexval(ReadByte()) << 8 |
+                                       hexval(ReadByte()) << 4 |
+                                       hexval(ReadByte()));
+
+           column += 4;
+        }
+        catch(java.io.IOException e)
+        {
+           throw new Error("Invalid escape character at line " + line +
+                                         " column " + column + ".");
+        }
+
+        if (backSlashCnt == 1)
+           return c;
+        else
+        {
+           backup(backSlashCnt - 1);
+           return '\\';
+        }
+     }
+     else
+     {
+        UpdateLineColumn(c);
+        return c;
+     }
+  }
+
+  @Deprecated
+  /**
+   * @deprecated (gen)
+   * @see #getEndColumn
+   */
+  public int getColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  @Deprecated
+  /**
+   * @deprecated (gen)
+   * @see #getEndLine
+   */
+  public int getLine() {
+     return bufline[bufpos];
+  }
+
+/** Get end column. */
+  public int getEndColumn() {
+     return bufcolumn[bufpos];
+  }
+
+/** Get end line. */
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+/** @return column of token start */
+  public int getBeginColumn() {
+     return bufcolumn[tokenBegin];
+  }
+
+/** @return line number of token start */
+  public int getBeginLine() {
+     return bufline[tokenBegin];
+  }
+
+/** Retreat. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+       bufpos += bufsize;
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+    nextCharBuf = new char[4096];
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+      nextCharBuf = new char[4096];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    nextCharInd = bufpos = -1;
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+                        int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+
+  /** @return token image as String */
+  public String GetImage()
+  {
+     if (bufpos >= tokenBegin)
+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+     else
+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  /** @return suffix */
+  public char[] GetSuffix(int len)
+  {
+     char[] ret = new char[len];
+
+     if ((bufpos + 1) >= len)
+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+     else
+     {
+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                          len - bufpos - 1);
+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+     }
+
+     return ret;
+  }
+
+  /** Set buffers back to null when finished. */
+  public void Done()
+  {
+     nextCharBuf = null;
+     buffer = null;
+     bufline = null;
+     bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+     int start = tokenBegin;
+     int len;
+
+     if (bufpos >= tokenBegin)
+     {
+        len = bufpos - tokenBegin + inBuf + 1;
+     }
+     else
+     {
+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+     }
+
+     int i = 0, j = 0, k = 0;
+     int nextColDiff = 0, columnDiff = 0;
+
+     while (i < len &&
+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+     {
+        bufline[j] = newLine;
+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+        bufcolumn[j] = newCol + columnDiff;
+        columnDiff = nextColDiff;
+        i++;
+     }
+
+     if (i < len)
+     {
+        bufline[j] = newLine++;
+        bufcolumn[j] = newCol + columnDiff;
+
+        while (i++ < len)
+        {
+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+              bufline[j] = newLine++;
+           else
+              bufline[j] = newLine;
+        }
+     }
+
+     line = bufline[j];
+     column = bufcolumn[j];
+  }
+
+}
+/* JavaCC - OriginalChecksum=f19c73b8f7faf94cc4a581e7b2933cc6 (do not edit this line) */
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java
new file mode 100644
index 0000000..bbc3de7
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java
@@ -0,0 +1,196 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+package org.apache.lucene.queryparser.flexible.standard.parser;
+ 
+ import org.apache.lucene.messages.Message;
+ import org.apache.lucene.messages.MessageImpl;
+ import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+ import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends QueryNodeParseException {
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.  The boolean
+   * flag "specialConstructor" is also set to true to indicate that
+   * this constructor was used to create this object.
+   * This constructor calls its super class with the empty string
+   * to force the "toString" method of parent class "Throwable" to
+   * print the error message in the form:
+   *     ParseException: <result of getMessage>
+   */
+  public ParseException(Token currentTokenVal,
+     int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
+     super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(
+     currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));
+     this.currentToken = currentTokenVal;
+     this.expectedTokenSequences = expectedTokenSequencesVal;
+     this.tokenImage = tokenImageVal;
+   }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+     super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, "Error"));
+   }
+
+  /** Constructor with message. */
+  public ParseException(Message message) {
+     super(message);
+                         }
+
+  /**
+   * This variable determines which constructor was used to create
+   * this object and thereby affects the semantics of the
+   * "getMessage" method (see below).
+   */
+  protected boolean specialConstructor;
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * This method has the standard behavior when this object has been
+   * created using the standard constructors.  Otherwise, it uses
+   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser), then this method is called during the printing
+   * of the final stack trace, and hence the correct error message
+   * gets displayed.
+   */
+  private static String initialise(Token currentToken, int[][] expectedTokenSequences, String[] tokenImage) {
+     String eol = System.getProperty("line.separator", "n");
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next;
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  static private String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=38bce846fe6c8482993969f741c0323e (do not edit this line) */
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java
new file mode 100644
index 0000000..c5aed4b
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java
@@ -0,0 +1,905 @@
+/* Generated By:JavaCC: Do not edit this line. StandardSyntaxParser.java */
+package org.apache.lucene.queryparser.flexible.standard.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
+
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ProximityQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+
+public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserConstants {
+
+        private static final int CONJ_NONE =0;
+        private static final int CONJ_AND =2;
+        private static final int CONJ_OR =2;
+
+
+   // syntax parser constructor
+   public StandardSyntaxParser() {
+        this(new StringReader(""));
+  }
+     /** Parses a query string, returning a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode}.
+     *  @param query  the query string to be parsed.
+     *  @throws ParseException if the parsing fails
+     */
+    public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
+      ReInit(new StringReader(query.toString()));
+      try {
+        // TopLevelQuery is a Query followed by the end-of-input (EOF)
+        QueryNode querynode = TopLevelQuery(field);
+        return querynode;
+      }
+      catch (ParseException tme) {
+            tme.setQuery(query);
+            throw tme;
+      }
+      catch (Error tme) {
+          Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
+          QueryNodeParseException e = new QueryNodeParseException(tme);
+            e.setQuery(query);
+            e.setNonLocalizedMessage(message);
+            throw e;
+      }
+    }
+
+// *   Query  ::= ( Clause )*
+// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
+  final public int Conjunction() throws ParseException {
+  int ret = CONJ_NONE;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case AND:
+    case OR:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case AND:
+        jj_consume_token(AND);
+            ret = CONJ_AND;
+        break;
+      case OR:
+        jj_consume_token(OR);
+              ret = CONJ_OR;
+        break;
+      default:
+        jj_la1[0] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[1] = jj_gen;
+      ;
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ModifierQueryNode.Modifier Modifiers() throws ParseException {
+  ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case NOT:
+    case PLUS:
+    case MINUS:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+        jj_consume_token(PLUS);
+              ret = ModifierQueryNode.Modifier.MOD_REQ;
+        break;
+      case MINUS:
+        jj_consume_token(MINUS);
+                 ret = ModifierQueryNode.Modifier.MOD_NOT;
+        break;
+      case NOT:
+        jj_consume_token(NOT);
+               ret = ModifierQueryNode.Modifier.MOD_NOT;
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[3] = jj_gen;
+      ;
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+// This makes sure that there is no garbage after the query string
+  final public QueryNode TopLevelQuery(CharSequence field) throws ParseException {
+        QueryNode q;
+    q = Query(field);
+    jj_consume_token(0);
+                {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+// These changes were made to introduce operator precedence:
+// - Clause() now returns a QueryNode. 
+// - The modifiers are consumed by Clause() and returned as part of the QueryNode Object
+// - Query does not consume conjunctions (AND, OR) anymore. 
+// - This is now done by two new non-terminals: ConjClause and DisjClause
+// The parse tree looks similar to this:
+//       Query ::= DisjQuery ( DisjQuery )*
+//   DisjQuery ::= ConjQuery ( OR ConjQuery )* 
+//   ConjQuery ::= Clause ( AND Clause )*
+//      Clause ::= [ Modifier ] ... 
+  final public QueryNode Query(CharSequence field) throws ParseException {
+  Vector<QueryNode> clauses = null;
+  QueryNode c, first=null;
+    first = DisjQuery(field);
+    label_1:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case NOT:
+      case PLUS:
+      case MINUS:
+      case LPAREN:
+      case QUOTED:
+      case TERM:
+      case REGEXPTERM:
+      case RANGEIN_START:
+      case RANGEEX_START:
+      case NUMBER:
+        ;
+        break;
+      default:
+        jj_la1[4] = jj_gen;
+        break label_1;
+      }
+      c = DisjQuery(field);
+             if (clauses == null) {
+                 clauses = new Vector<QueryNode>();
+                 clauses.addElement(first);
+             }
+         clauses.addElement(c);
+    }
+        if (clauses != null) {
+                {if (true) return new BooleanQueryNode(clauses);}
+        } else {
+                {if (true) return first;}
+        }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode DisjQuery(CharSequence field) throws ParseException {
+        QueryNode first, c;
+        Vector<QueryNode> clauses = null;
+    first = ConjQuery(field);
+    label_2:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case OR:
+        ;
+        break;
+      default:
+        jj_la1[5] = jj_gen;
+        break label_2;
+      }
+      jj_consume_token(OR);
+      c = ConjQuery(field);
+     if (clauses == null) {
+         clauses = new Vector<QueryNode>();
+         clauses.addElement(first);
+     }
+     clauses.addElement(c);
+    }
+    if (clauses != null) {
+            {if (true) return new OrQueryNode(clauses);}
+    } else {
+        {if (true) return first;}
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode ConjQuery(CharSequence field) throws ParseException {
+        QueryNode first, c;
+        Vector<QueryNode> clauses = null;
+    first = ModClause(field);
+    label_3:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case AND:
+        ;
+        break;
+      default:
+        jj_la1[6] = jj_gen;
+        break label_3;
+      }
+      jj_consume_token(AND);
+      c = ModClause(field);
+     if (clauses == null) {
+         clauses = new Vector<QueryNode>();
+         clauses.addElement(first);
+     }
+     clauses.addElement(c);
+    }
+    if (clauses != null) {
+            {if (true) return new AndQueryNode(clauses);}
+    } else {
+        {if (true) return first;}
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+// QueryNode Query(CharSequence field) :
+// {
+// List clauses = new ArrayList();
+//   List modifiers = new ArrayList();
+//   QueryNode q, firstQuery=null;
+//   ModifierQueryNode.Modifier mods;
+//   int conj;
+// }
+// {
+//   mods=Modifiers() q=Clause(field)
+//   {
+//     if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q;
+//     
+//     // do not create modifier nodes with MOD_NONE
+//    	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+//    		q = new ModifierQueryNode(q, mods);
+//    	}
+//    	clauses.add(q);
+//   }
+//   (
+//     conj=Conjunction() mods=Modifiers() q=Clause(field)
+//     { 
+// 	    // do not create modifier nodes with MOD_NONE
+// 	   	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+// 	   		q = new ModifierQueryNode(q, mods);
+// 	   	}
+// 	   	clauses.add(q);
+// 	   	//TODO: figure out what to do with AND and ORs
+//   }
+//   )*
+//     {
+//      if (clauses.size() == 1 && firstQuery != null)
+//         return firstQuery;
+//       else {
+//   		return new BooleanQueryNode(clauses);
+//       }
+//     }
+// }
+  final public QueryNode ModClause(CharSequence field) throws ParseException {
+  QueryNode q;
+  ModifierQueryNode.Modifier mods;
+    mods = Modifiers();
+    q = Clause(field);
+                if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+                        q = new ModifierQueryNode(q, mods);
+                }
+                {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode Clause(CharSequence field) throws ParseException {
+  QueryNode q;
+  Token fieldToken=null, boost=null;
+  boolean group = false;
+    if (jj_2_1(2)) {
+      fieldToken = jj_consume_token(TERM);
+      jj_consume_token(COLON);
+                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
+    } else {
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case QUOTED:
+    case TERM:
+    case REGEXPTERM:
+    case RANGEIN_START:
+    case RANGEEX_START:
+    case NUMBER:
+      q = Term(field);
+      break;
+    case LPAREN:
+      jj_consume_token(LPAREN);
+      q = Query(field);
+      jj_consume_token(RPAREN);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CARAT:
+        jj_consume_token(CARAT);
+        boost = jj_consume_token(NUMBER);
+        break;
+      default:
+        jj_la1[7] = jj_gen;
+        ;
+      }
+                                                                 group=true;
+      break;
+    default:
+      jj_la1[8] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+      if (boost != null) {
+                  float f = (float)1.0;
+                  try {
+                    f = Float.valueOf(boost.image).floatValue();
+                    // avoid boosting null queries, such as those caused by stop words
+                if (q != null) {
+                        q = new BoostQueryNode(q, f);
+                }
+                  } catch (Exception ignored) {
+                        /* Should this be handled somehow? (defaults to "no boost", if
+             * boost number is invalid)
+             */
+                  }
+      }
+      if (group) { q = new GroupQueryNode(q);}
+      {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode Term(CharSequence field) throws ParseException {
+  Token term, boost=null, fuzzySlop=null, goop1, goop2;
+  boolean fuzzy = false;
+  boolean regexp = false;
+  QueryNode q =null;
+  ParametricQueryNode qLower, qUpper;
+  float defaultMinSimilarity = org.apache.lucene.search.FuzzyQuery.defaultMinSimilarity;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TERM:
+    case REGEXPTERM:
+    case NUMBER:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case TERM:
+        term = jj_consume_token(TERM);
+                         q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+        break;
+      case REGEXPTERM:
+        term = jj_consume_token(REGEXPTERM);
+                             regexp=true;
+        break;
+      case NUMBER:
+        term = jj_consume_token(NUMBER);
+        break;
+      default:
+        jj_la1[9] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case FUZZY_SLOP:
+        fuzzySlop = jj_consume_token(FUZZY_SLOP);
+                                fuzzy=true;
+        break;
+      default:
+        jj_la1[10] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CARAT:
+        jj_consume_token(CARAT);
+        boost = jj_consume_token(NUMBER);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case FUZZY_SLOP:
+          fuzzySlop = jj_consume_token(FUZZY_SLOP);
+                                                         fuzzy=true;
+          break;
+        default:
+          jj_la1[11] = jj_gen;
+          ;
+        }
+        break;
+      default:
+        jj_la1[12] = jj_gen;
+        ;
+      }
+       if (fuzzy) {
+          float fms = defaultMinSimilarity;
+          try {
+            fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
+          } catch (Exception ignored) { }
+         if(fms < 0.0f){
+           {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));}
+         } else if (fms >= 1.0f && fms != (int) fms) {
+           {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));}
+         }
+         q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+       } else if (regexp) {
+         q = new RegexpQueryNode(field, term.image, term.beginColumn, term.endColumn-1);
+       }
+      break;
+    case RANGEIN_START:
+      jj_consume_token(RANGEIN_START);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEIN_GOOP:
+        goop1 = jj_consume_token(RANGEIN_GOOP);
+        break;
+      case RANGEIN_QUOTED:
+        goop1 = jj_consume_token(RANGEIN_QUOTED);
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEIN_TO:
+        jj_consume_token(RANGEIN_TO);
+        break;
+      default:
+        jj_la1[14] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEIN_GOOP:
+        goop2 = jj_consume_token(RANGEIN_GOOP);
+        break;
+      case RANGEIN_QUOTED:
+        goop2 = jj_consume_token(RANGEIN_QUOTED);
+        break;
+      default:
+        jj_la1[15] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      jj_consume_token(RANGEIN_END);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CARAT:
+        jj_consume_token(CARAT);
+        boost = jj_consume_token(NUMBER);
+        break;
+      default:
+        jj_la1[16] = jj_gen;
+        ;
+      }
+          if (goop1.kind == RANGEIN_QUOTED) {
+            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          }
+          if (goop2.kind == RANGEIN_QUOTED) {
+            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          }
+
+          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,
+                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+                  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,
+                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+          q = new ParametricRangeQueryNode(qLower, qUpper);
+      break;
+    case RANGEEX_START:
+      jj_consume_token(RANGEEX_START);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEEX_GOOP:
+        goop1 = jj_consume_token(RANGEEX_GOOP);
+        break;
+      case RANGEEX_QUOTED:
+        goop1 = jj_consume_token(RANGEEX_QUOTED);
+        break;
+      default:
+        jj_la1[17] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEEX_TO:
+        jj_consume_token(RANGEEX_TO);
+        break;
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEEX_GOOP:
+        goop2 = jj_consume_token(RANGEEX_GOOP);
+        break;
+      case RANGEEX_QUOTED:
+        goop2 = jj_consume_token(RANGEEX_QUOTED);
+        break;
+      default:
+        jj_la1[19] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      jj_consume_token(RANGEEX_END);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CARAT:
+        jj_consume_token(CARAT);
+        boost = jj_consume_token(NUMBER);
+        break;
+      default:
+        jj_la1[20] = jj_gen;
+        ;
+      }
+          if (goop1.kind == RANGEEX_QUOTED) {
+            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          }
+          if (goop2.kind == RANGEEX_QUOTED) {
+            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          }
+          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GT,
+                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+                  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LT,
+                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+          q = new ParametricRangeQueryNode(qLower, qUpper);
+      break;
+    case QUOTED:
+      term = jj_consume_token(QUOTED);
+                      q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length()-1)), term.beginColumn + 1, term.endColumn - 1);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case FUZZY_SLOP:
+        fuzzySlop = jj_consume_token(FUZZY_SLOP);
+        break;
+      default:
+        jj_la1[21] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CARAT:
+        jj_consume_token(CARAT);
+        boost = jj_consume_token(NUMBER);
+        break;
+      default:
+        jj_la1[22] = jj_gen;
+        ;
+      }
+         int phraseSlop = 0;
+
+         if (fuzzySlop != null) {
+           try {
+             phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
+             q = new SlopQueryNode(q, phraseSlop);
+           }
+           catch (Exception ignored) {
+            /* Should this be handled somehow? (defaults to "no PhraseSlop", if
+	         * slop number is invalid)
+	         */
+           }
+         }
+      break;
+    default:
+      jj_la1[23] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          if (boost != null) {
+                  float f = (float)1.0;
+                  try {
+                    f = Float.valueOf(boost.image).floatValue();
+                    // avoid boosting null queries, such as those caused by stop words
+                if (q != null) {
+                        q = new BoostQueryNode(q, f);
+                }
+                  } catch (Exception ignored) {
+                        /* Should this be handled somehow? (defaults to "no boost", if
+	         * boost number is invalid)
+	         */
+                  }
+          }
+      {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_3_1() {
+    if (jj_scan_token(TERM)) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public StandardSyntaxParserTokenManager token_source;
+  JavaCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[24];
+  static private int[] jj_la1_0;
+  static {
+      jj_la1_init_0();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0xf63c00,0x200,0x100,0x10000,0xf62000,0x940000,0x80000,0x80000,0x10000,0xc000000,0x1000000,0xc000000,0x10000,0xc0000000,0x10000000,0xc0000000,0x10000,0x80000,0x10000,0xf60000,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[1];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
+  public StandardSyntaxParser(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public StandardSyntaxParser(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new StandardSyntaxParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor. */
+  public StandardSyntaxParser(java.io.Reader stream) {
+    jj_input_stream = new JavaCharStream(stream, 1, 1);
+    token_source = new StandardSyntaxParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public StandardSyntaxParser(StandardSyntaxParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(StandardSyntaxParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              continue jj_entries_loop;
+            }
+          }
+          jj_expentries.add(jj_expentry);
+          break jj_entries_loop;
+        }
+      }
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[32];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 24; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 32; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 1; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj
new file mode 100644
index 0000000..11d8661
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj
@@ -0,0 +1,480 @@
+/**
+ * Standard file is based on the TextParser.jj from lucene 2.3
+ */
+
+options {
+  STATIC=false;
+  JAVA_UNICODE_ESCAPE=true;
+  USER_CHAR_STREAM=false;
+  IGNORE_CASE=false;
+  JDK_VERSION="1.5";
+}
+
+PARSER_BEGIN(StandardSyntaxParser)
+package org.apache.lucene.queryparser.flexible.standard.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
+
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ProximityQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+
+public class StandardSyntaxParser implements SyntaxParser {
+
+	private static final int CONJ_NONE =0;
+	private static final int CONJ_AND =2;
+	private static final int CONJ_OR =2;
+
+ 
+   // syntax parser constructor
+   public StandardSyntaxParser() {
+   	this(new StringReader(""));
+  }
+     /** Parses a query string, returning a {@link org.apache.lucene.queryParser.core.nodes.QueryNode}.
+     *  @param query  the query string to be parsed.
+     *  @throws ParseException if the parsing fails
+     */
+    public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
+      ReInit(new StringReader(query.toString()));
+      try {
+        // TopLevelQuery is a Query followed by the end-of-input (EOF)
+        QueryNode querynode = TopLevelQuery(field);
+        return querynode;
+      }
+      catch (ParseException tme) {
+            tme.setQuery(query);
+            throw tme;
+      }
+      catch (Error tme) {
+          Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
+          QueryNodeParseException e = new QueryNodeParseException(tme);
+            e.setQuery(query);
+            e.setNonLocalizedMessage(message);
+            throw e;
+      }
+    }
+   
+}
+
+PARSER_END(StandardSyntaxParser)
+
+/* ***************** */
+/* Token Definitions */
+/* ***************** */
+
+<*> TOKEN : {
+  <#_NUM_CHAR:   ["0"-"9"] >
+// every character that follows a backslash is considered as an escaped character
+| <#_ESCAPED_CHAR: "\\" ~[] >
+| <#_TERM_START_CHAR: ( ~[ " ", "\t", "\n", "\r", "\u3000", "+", "-", "!", "(", ")", ":", "^",
+                           "[", "]", "\"", "{", "}", "~", "\\" ]
+                       | <_ESCAPED_CHAR> ) >
+| <#_TERM_CHAR: ( <_TERM_START_CHAR> | <_ESCAPED_CHAR> | "-" | "+" ) >
+| <#_WHITESPACE: ( " " | "\t" | "\n" | "\r" | "\u3000") >
+| <#_QUOTED_CHAR: ( ~[ "\"", "\\" ] | <_ESCAPED_CHAR> ) >
+}
+
+<DEFAULT, RangeIn, RangeEx> SKIP : {
+  < <_WHITESPACE>>
+}
+
+<DEFAULT> TOKEN : {
+  <AND:       ("AND" | "&&") >
+| <OR:        ("OR" | "||") >
+| <NOT:       ("NOT" | "!") >
+| <PLUS:      "+" >
+| <MINUS:     "-" >
+| <LPAREN:    "(" >
+| <RPAREN:    ")" >
+| <COLON:     ":" >
+| <CARAT:     "^" > : Boost
+| <QUOTED:     "\"" (<_QUOTED_CHAR>)* "\"">
+| <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
+| <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
+| <REGEXPTERM: "/" (~[ "/" ] | "\\/" )* "/" >
+| <RANGEIN_START: "[" > : RangeIn
+| <RANGEEX_START: "{" > : RangeEx
+}
+
+<Boost> TOKEN : {
+<NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? > : DEFAULT
+}
+
+<RangeIn> TOKEN : {
+<RANGEIN_TO: "TO">
+| <RANGEIN_END: "]"> : DEFAULT
+| <RANGEIN_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
+| <RANGEIN_GOOP: (~[ " ", "]" ])+ >
+}
+
+<RangeEx> TOKEN : {
+<RANGEEX_TO: "TO">
+| <RANGEEX_END: "}"> : DEFAULT
+| <RANGEEX_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
+| <RANGEEX_GOOP: (~[ " ", "}" ])+ >
+}
+
+// *   Query  ::= ( Clause )*
+// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
+
+int Conjunction() : {
+  int ret = CONJ_NONE;
+}
+{
+  [
+    <AND> { ret = CONJ_AND; }
+    | <OR>  { ret = CONJ_OR; }
+  ]
+  { return ret; }
+}
+
+ModifierQueryNode.Modifier Modifiers() : {
+  ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
+}
+{
+  [
+     <PLUS> { ret = ModifierQueryNode.Modifier.MOD_REQ; }
+     | <MINUS> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
+     | <NOT> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
+  ]
+  { return ret; }
+}
+
+// This makes sure that there is no garbage after the query string
+QueryNode TopLevelQuery(CharSequence field) : 
+{
+	QueryNode q;
+}
+{
+	q=Query(field) <EOF>
+	{
+		return q;
+	}
+}
+
+// These changes were made to introduce operator precedence:
+// - Clause() now returns a QueryNode. 
+// - The modifiers are consumed by Clause() and returned as part of the QueryNode Object
+// - Query does not consume conjunctions (AND, OR) anymore. 
+// - This is now done by two new non-terminals: ConjClause and DisjClause
+// The parse tree looks similar to this:
+//       Query ::= DisjQuery ( DisjQuery )*
+//   DisjQuery ::= ConjQuery ( OR ConjQuery )* 
+//   ConjQuery ::= Clause ( AND Clause )*
+//      Clause ::= [ Modifier ] ... 
+
+
+QueryNode Query(CharSequence field) :
+{
+  Vector<QueryNode> clauses = null;
+  QueryNode c, first=null;
+}
+{
+  first=DisjQuery(field)
+  (
+    c=DisjQuery(field)
+    { 
+	     if (clauses == null) {
+	         clauses = new Vector<QueryNode>();
+	         clauses.addElement(first); 
+	     } 
+    	 clauses.addElement(c);
+    }
+    )*
+    {
+        if (clauses != null) { 
+	    	return new BooleanQueryNode(clauses);
+    	} else {
+        	return first;
+    	}
+    }
+}
+
+QueryNode DisjQuery(CharSequence field) : {
+	QueryNode first, c;
+	Vector<QueryNode> clauses = null;
+}
+{
+  first = ConjQuery(field)
+  (
+   <OR> c=ConjQuery(field)
+   { 
+     if (clauses == null) {
+         clauses = new Vector<QueryNode>();
+         clauses.addElement(first); 
+     } 
+     clauses.addElement(c);
+   }
+  )*
+  {
+    if (clauses != null) { 
+	    return new OrQueryNode(clauses);
+    } else {
+        return first;
+    }
+  }
+}
+
+QueryNode ConjQuery(CharSequence field) : {
+	QueryNode first, c;
+	Vector<QueryNode> clauses = null;
+}
+{
+  first = ModClause(field)
+  (
+   <AND> c=ModClause(field)
+   { 
+     if (clauses == null) {
+         clauses = new Vector<QueryNode>();
+         clauses.addElement(first);
+     } 
+     clauses.addElement(c); 
+   }
+  )*
+  {
+    if (clauses != null) {     
+	    return new AndQueryNode(clauses);
+    } else {
+        return first;
+    }
+  }
+}
+
+// QueryNode Query(CharSequence field) :
+// {
+// List clauses = new ArrayList();
+//   List modifiers = new ArrayList();
+//   QueryNode q, firstQuery=null;
+//   ModifierQueryNode.Modifier mods;
+//   int conj;
+// }
+// {
+//   mods=Modifiers() q=Clause(field)
+//   {
+//     if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q;
+//     
+//     // do not create modifier nodes with MOD_NONE
+//    	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+//    		q = new ModifierQueryNode(q, mods);
+//    	}
+//    	clauses.add(q);
+//   }
+//   (
+//     conj=Conjunction() mods=Modifiers() q=Clause(field)
+//     { 
+// 	    // do not create modifier nodes with MOD_NONE
+// 	   	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+// 	   		q = new ModifierQueryNode(q, mods);
+// 	   	}
+// 	   	clauses.add(q);
+// 	   	//TODO: figure out what to do with AND and ORs
+//   }
+//   )*
+//     {
+//      if (clauses.size() == 1 && firstQuery != null)
+//         return firstQuery;
+//       else {
+//   		return new BooleanQueryNode(clauses);
+//       }
+//     }
+// }
+
+QueryNode ModClause(CharSequence field) : {
+  QueryNode q; 
+  ModifierQueryNode.Modifier mods;
+}
+{
+   mods=Modifiers() q= Clause(field) {
+ 	   	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+ 	   		q = new ModifierQueryNode(q, mods);
+ 	   	}
+ 	   	return q;
+   }
+}
+
+QueryNode Clause(CharSequence field) : {
+  QueryNode q;
+  Token fieldToken=null, boost=null;
+  boolean group = false;
+}
+{
+  [
+    LOOKAHEAD(2)
+    (
+    fieldToken=<TERM> <COLON> {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);}    
+    )
+  ]
+
+  (
+   q=Term(field)
+   | <LPAREN> q=Query(field) <RPAREN> (<CARAT> boost=<NUMBER>)? {group=true;}
+
+  )
+    {
+      if (boost != null) {
+		  float f = (float)1.0;
+		  try {
+		    f = Float.valueOf(boost.image).floatValue();
+		    // avoid boosting null queries, such as those caused by stop words
+	      	if (q != null) {
+	        	q = new BoostQueryNode(q, f);
+	      	}
+		  } catch (Exception ignored) {
+		  	/* Should this be handled somehow? (defaults to "no boost", if
+             * boost number is invalid)
+             */		  
+		  }
+      }
+      if (group) { q = new GroupQueryNode(q);}
+      return q;
+    }
+}
+
+
+QueryNode Term(CharSequence field) : {
+  Token term, boost=null, fuzzySlop=null, goop1, goop2;
+  boolean fuzzy = false;
+  boolean regexp = false;
+  QueryNode q =null; 
+  ParametricQueryNode qLower, qUpper;
+  float defaultMinSimilarity = org.apache.lucene.search.FuzzyQuery.defaultMinSimilarity;
+}
+{
+  (
+     (
+ 	   term=<TERM> { q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
+       | term=<REGEXPTERM> { regexp=true; }
+       | term=<NUMBER>
+     )
+     [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ]
+     [ <CARAT> boost=<NUMBER> [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ] ]
+     {
+       if (fuzzy) {
+       	  float fms = defaultMinSimilarity;
+       	  try {
+            fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
+       	  } catch (Exception ignored) { }
+       	 if(fms < 0.0f){
+       	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
+       	 } else if (fms >= 1.0f && fms != (int) fms) {
+       	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));
+       	 }
+       	 q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+       } else if (regexp) {
+         q = new RegexpQueryNode(field, term.image, term.beginColumn, term.endColumn-1);
+       }
+     }
+     | ( <RANGEIN_START> ( goop1=<RANGEIN_GOOP>|goop1=<RANGEIN_QUOTED> )
+         [ <RANGEIN_TO> ] ( goop2=<RANGEIN_GOOP>|goop2=<RANGEIN_QUOTED> )
+         <RANGEIN_END> )
+       [ <CARAT> boost=<NUMBER> ]
+        {
+          if (goop1.kind == RANGEIN_QUOTED) {
+            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          }
+          if (goop2.kind == RANGEIN_QUOTED) {
+            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          }
+          
+          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE, 
+		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+		  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE, 
+		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+          q = new ParametricRangeQueryNode(qLower, qUpper);
+        }
+     | ( <RANGEEX_START> ( goop1=<RANGEEX_GOOP>|goop1=<RANGEEX_QUOTED> )
+         [ <RANGEEX_TO> ] ( goop2=<RANGEEX_GOOP>|goop2=<RANGEEX_QUOTED> )
+         <RANGEEX_END> )
+       [ <CARAT> boost=<NUMBER> ]
+        {
+          if (goop1.kind == RANGEEX_QUOTED) {
+            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          }
+          if (goop2.kind == RANGEEX_QUOTED) {
+            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          }
+          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GT, 
+		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+		  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LT, 
+		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+          q = new ParametricRangeQueryNode(qLower, qUpper);		  
+        }
+     | term=<QUOTED> {q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length()-1)), term.beginColumn + 1, term.endColumn - 1);}
+       [ fuzzySlop=<FUZZY_SLOP> ]
+       [ <CARAT> boost=<NUMBER> ]
+       {       
+         int phraseSlop = 0;
+
+         if (fuzzySlop != null) {
+           try {
+             phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
+             q = new SlopQueryNode(q, phraseSlop);    
+           }
+           catch (Exception ignored) {
+            /* Should this be handled somehow? (defaults to "no PhraseSlop", if
+	         * slop number is invalid)
+	         */		
+           }
+         }
+              
+       }
+  )
+  {
+	  if (boost != null) {
+		  float f = (float)1.0;
+		  try {
+		    f = Float.valueOf(boost.image).floatValue();
+		    // avoid boosting null queries, such as those caused by stop words
+	      	if (q != null) {
+	        	q = new BoostQueryNode(q, f);
+	      	}
+		  } catch (Exception ignored) {
+		  	/* Should this be handled somehow? (defaults to "no boost", if
+	         * boost number is invalid)
+	         */		  
+		  }
+	  }
+      return q;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserConstants.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserConstants.java
new file mode 100644
index 0000000..15d141a
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserConstants.java
@@ -0,0 +1,119 @@
+/* Generated By:JavaCC: Do not edit this line. StandardSyntaxParserConstants.java */
+package org.apache.lucene.queryparser.flexible.standard.parser;
+
+
+/**
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface StandardSyntaxParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int _NUM_CHAR = 1;
+  /** RegularExpression Id. */
+  int _ESCAPED_CHAR = 2;
+  /** RegularExpression Id. */
+  int _TERM_START_CHAR = 3;
+  /** RegularExpression Id. */
+  int _TERM_CHAR = 4;
+  /** RegularExpression Id. */
+  int _WHITESPACE = 5;
+  /** RegularExpression Id. */
+  int _QUOTED_CHAR = 6;
+  /** RegularExpression Id. */
+  int AND = 8;
+  /** RegularExpression Id. */
+  int OR = 9;
+  /** RegularExpression Id. */
+  int NOT = 10;
+  /** RegularExpression Id. */
+  int PLUS = 11;
+  /** RegularExpression Id. */
+  int MINUS = 12;
+  /** RegularExpression Id. */
+  int LPAREN = 13;
+  /** RegularExpression Id. */
+  int RPAREN = 14;
+  /** RegularExpression Id. */
+  int COLON = 15;
+  /** RegularExpression Id. */
+  int CARAT = 16;
+  /** RegularExpression Id. */
+  int QUOTED = 17;
+  /** RegularExpression Id. */
+  int TERM = 18;
+  /** RegularExpression Id. */
+  int FUZZY_SLOP = 19;
+  /** RegularExpression Id. */
+  int REGEXPTERM = 20;
+  /** RegularExpression Id. */
+  int RANGEIN_START = 21;
+  /** RegularExpression Id. */
+  int RANGEEX_START = 22;
+  /** RegularExpression Id. */
+  int NUMBER = 23;
+  /** RegularExpression Id. */
+  int RANGEIN_TO = 24;
+  /** RegularExpression Id. */
+  int RANGEIN_END = 25;
+  /** RegularExpression Id. */
+  int RANGEIN_QUOTED = 26;
+  /** RegularExpression Id. */
+  int RANGEIN_GOOP = 27;
+  /** RegularExpression Id. */
+  int RANGEEX_TO = 28;
+  /** RegularExpression Id. */
+  int RANGEEX_END = 29;
+  /** RegularExpression Id. */
+  int RANGEEX_QUOTED = 30;
+  /** RegularExpression Id. */
+  int RANGEEX_GOOP = 31;
+
+  /** Lexical state. */
+  int Boost = 0;
+  /** Lexical state. */
+  int RangeEx = 1;
+  /** Lexical state. */
+  int RangeIn = 2;
+  /** Lexical state. */
+  int DEFAULT = 3;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "<_NUM_CHAR>",
+    "<_ESCAPED_CHAR>",
+    "<_TERM_START_CHAR>",
+    "<_TERM_CHAR>",
+    "<_WHITESPACE>",
+    "<_QUOTED_CHAR>",
+    "<token of kind 7>",
+    "<AND>",
+    "<OR>",
+    "<NOT>",
+    "\"+\"",
+    "\"-\"",
+    "\"(\"",
+    "\")\"",
+    "\":\"",
+    "\"^\"",
+    "<QUOTED>",
+    "<TERM>",
+    "<FUZZY_SLOP>",
+    "<REGEXPTERM>",
+    "\"[\"",
+    "\"{\"",
+    "<NUMBER>",
+    "\"TO\"",
+    "\"]\"",
+    "<RANGEIN_QUOTED>",
+    "<RANGEIN_GOOP>",
+    "\"TO\"",
+    "\"}\"",
+    "<RANGEEX_QUOTED>",
+    "<RANGEEX_GOOP>",
+  };
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java
new file mode 100644
index 0000000..830f79c
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java
@@ -0,0 +1,1149 @@
+/* Generated By:JavaCC: Do not edit this line. StandardSyntaxParserTokenManager.java */
+package org.apache.lucene.queryparser.flexible.standard.parser;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeError;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ProximityQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+
+/** Token Manager. */
+public class StandardSyntaxParserTokenManager implements StandardSyntaxParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_3(int pos, long active0)
+{
+   switch (pos)
+   {
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_3(int pos, long active0)
+{
+   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   switch(curChar)
+   {
+      case 40:
+         return jjStopAtPos(0, 13);
+      case 41:
+         return jjStopAtPos(0, 14);
+      case 43:
+         return jjStopAtPos(0, 11);
+      case 45:
+         return jjStopAtPos(0, 12);
+      case 58:
+         return jjStopAtPos(0, 15);
+      case 91:
+         return jjStopAtPos(0, 21);
+      case 94:
+         return jjStopAtPos(0, 16);
+      case 123:
+         return jjStopAtPos(0, 22);
+      default :
+         return jjMoveNfa_3(0, 0);
+   }
+}
+static final long[] jjbitVec0 = {
+   0x1L, 0x0L, 0x0L, 0x0L
+};
+static final long[] jjbitVec1 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec3 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec4 = {
+   0xfffefffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_3(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 33;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfbffd4f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  else if (curChar == 33)
+                  {
+                     if (kind > 10)
+                        kind = 10;
+                  }
+                  if (curChar == 47)
+                     jjCheckNAddStates(3, 5);
+                  else if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 4:
+                  if (curChar == 38 && kind > 8)
+                     kind = 8;
+                  break;
+               case 5:
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 13:
+                  if (curChar == 33 && kind > 10)
+                     kind = 10;
+                  break;
+               case 14:
+                  if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 15:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 18:
+                  if (curChar == 34 && kind > 17)
+                     kind = 17;
+                  break;
+               case 19:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 20:
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 22:
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 25:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjAddStates(6, 7);
+                  break;
+               case 26:
+                  if (curChar == 46)
+                     jjCheckNAdd(27);
+                  break;
+               case 27:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAdd(27);
+                  break;
+               case 28:
+               case 30:
+                  if (curChar == 47)
+                     jjCheckNAddStates(3, 5);
+                  break;
+               case 29:
+                  if ((0xffff7fffffffffffL & l) != 0L)
+                     jjCheckNAddStates(3, 5);
+                  break;
+               case 32:
+                  if (curChar == 47 && kind > 20)
+                     kind = 20;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  else if (curChar == 126)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjstateSet[jjnewStateCnt++] = 25;
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAdd(22);
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  else if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  else if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  else if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 1:
+                  if (curChar == 68 && kind > 8)
+                     kind = 8;
+                  break;
+               case 2:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 3:
+                  if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 6:
+                  if (curChar == 82 && kind > 9)
+                     kind = 9;
+                  break;
+               case 7:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  break;
+               case 8:
+                  if (curChar == 124 && kind > 9)
+                     kind = 9;
+                  break;
+               case 9:
+                  if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 10:
+                  if (curChar == 84 && kind > 10)
+                     kind = 10;
+                  break;
+               case 11:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 12:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  break;
+               case 15:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 16:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 19:
+               case 20:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 21:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(22, 22);
+                  break;
+               case 22:
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 23:
+                  if (curChar == 92)
+                     jjCheckNAdd(22);
+                  break;
+               case 24:
+                  if (curChar != 126)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjstateSet[jjnewStateCnt++] = 25;
+                  break;
+               case 29:
+                  jjAddStates(3, 5);
+                  break;
+               case 31:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 30;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  break;
+               case 15:
+               case 17:
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 19:
+               case 20:
+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 22:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 29:
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     jjAddStates(3, 5);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 33 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 31;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_1(int pos, long active0)
+{
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_1(0x10000000L);
+      case 125:
+         return jjStopAtPos(0, 29);
+      default :
+         return jjMoveNfa_1(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_1(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x10000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 28, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_1(0, active0);
+}
+private int jjStartNfaWithStates_1(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_1(state, pos + 1);
+}
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 31)
+                        kind = 31;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 30)
+                     kind = 30;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 31)
+                     kind = 31;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xdfffffffffffffffL & l) == 0L)
+                     break;
+                  if (kind > 31)
+                     kind = 31;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(8, 10);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 31)
+                        kind = 31;
+                     jjCheckNAdd(6);
+                  }
+                  break;
+               case 2:
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     jjAddStates(8, 10);
+                  break;
+               case 6:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 31)
+                     kind = 31;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   return jjMoveNfa_0(0, 0);
+}
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 23)
+                     kind = 23;
+                  jjAddStates(11, 12);
+                  break;
+               case 1:
+                  if (curChar == 46)
+                     jjCheckNAdd(2);
+                  break;
+               case 2:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 23)
+                     kind = 23;
+                  jjCheckNAdd(2);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x1000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_2(int pos, long active0)
+{
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_2(0x1000000L);
+      case 93:
+         return jjStopAtPos(0, 25);
+      default :
+         return jjMoveNfa_2(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x1000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 24, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(0, active0);
+}
+private int jjStartNfaWithStates_2(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_2(state, pos + 1);
+}
+private int jjMoveNfa_2(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 27)
+                        kind = 27;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 26)
+                     kind = 26;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 27)
+                     kind = 27;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xffffffffdfffffffL & l) == 0L)
+                     break;
+                  if (kind > 27)
+                     kind = 27;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(8, 10);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 27)
+                        kind = 27;
+                     jjCheckNAdd(6);
+                  }
+                  break;
+               case 2:
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     jjAddStates(8, 10);
+                  break;
+               case 6:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 27)
+                     kind = 27;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+static final int[] jjnextStates = {
+   15, 16, 18, 29, 31, 32, 25, 26, 2, 4, 5, 0, 1, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 48:
+         return ((jjbitVec0[i2] & l2) != 0L);
+      default :
+         return false;
+   }
+}
+private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec3[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec1[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec3[i2] & l2) != 0L);
+      case 48:
+         return ((jjbitVec1[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec4[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
+"\50", "\51", "\72", "\136", null, null, null, null, "\133", "\173", null, 
+"\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "Boost",
+   "RangeEx",
+   "RangeIn",
+   "DEFAULT",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, 2, 1, 3, -1, 
+   3, -1, -1, -1, 3, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0xffffff01L, 
+};
+static final long[] jjtoSkip = {
+   0x80L, 
+};
+protected JavaCharStream input_stream;
+private final int[] jjrounds = new int[33];
+private final int[] jjstateSet = new int[66];
+protected char curChar;
+/** Constructor. */
+public StandardSyntaxParserTokenManager(JavaCharStream stream){
+   if (JavaCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+
+/** Constructor. */
+public StandardSyntaxParserTokenManager(JavaCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 33; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 4 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 3;
+int defaultLexState = 3;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      return matchedToken;
+   }
+
+   switch(curLexState)
+   {
+     case 0:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_0();
+       break;
+     case 1:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_1();
+       break;
+     case 2:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_2();
+       break;
+     case 3:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_3();
+       break;
+   }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else
+        {
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/Token.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/Token.java
new file mode 100644
index 0000000..299eb31
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/Token.java
@@ -0,0 +1,124 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
+package org.apache.lucene.queryparser.flexible.standard.parser;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token {
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+     this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+     this.kind = kind;
+     this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+     return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+     switch(ofKind)
+     {
+       default : return new Token(ofKind, image);
+     }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+     return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=0aac6816ecd328eda2f38b9d09739ab6 (do not edit this line) */
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/TokenMgrError.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/TokenMgrError.java
new file mode 100644
index 0000000..5b60346
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/TokenMgrError.java
@@ -0,0 +1,141 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
+/* JavaCCOptions: */
+package org.apache.lucene.queryparser.flexible.standard.parser;
+
+/** Token Manager Error. */
+@SuppressWarnings("serial")
+public class TokenMgrError extends Error
+{
+
+   /*
+    * Ordinals for various reasons why an Error of this type can be thrown.
+    */
+
+   /**
+    * Lexical error occurred.
+    */
+   static final int LEXICAL_ERROR = 0;
+
+   /**
+    * An attempt was made to create a second instance of a static token manager.
+    */
+   static final int STATIC_LEXER_ERROR = 1;
+
+   /**
+    * Tried to change to an invalid lexical state.
+    */
+   static final int INVALID_LEXICAL_STATE = 2;
+
+   /**
+    * Detected (and bailed out of) an infinite loop in the token manager.
+    */
+   static final int LOOP_DETECTED = 3;
+
+   /**
+    * Indicates the reason why the exception is thrown. It will have
+    * one of the above 4 values.
+    */
+   int errorCode;
+
+   /**
+    * Replaces unprintable characters by their escaped (or unicode escaped)
+    * equivalents in the given string
+    */
+   protected static final String addEscapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+   /**
+    * Returns a detailed message for the Error when it is thrown by the
+    * token manager to indicate a lexical error.
+    * Parameters :
+    *    EOFSeen     : indicates if EOF caused the lexical error
+    *    curLexState : lexical state in which this error occurred
+    *    errorLine   : line number when the error occurred
+    *    errorColumn : column number when the error occurred
+    *    errorAfter  : prefix that was seen before this error occurred
+    *    curchar     : the offending character
+    * Note: You can customize the lexical error message by modifying this method.
+    */
+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+      return("Lexical error at line " +
+           errorLine + ", column " +
+           errorColumn + ".  Encountered: " +
+           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+           "after : \"" + addEscapes(errorAfter) + "\"");
+   }
+
+   /**
+    * You can also modify the body of this method to customize your error messages.
+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+    * of end-users concern, so you can return something like :
+    *
+    *     "Internal Error : Please file a bug report .... "
+    *
+    * from this method for such cases in the release version of your parser.
+    */
+   public String getMessage() {
+      return super.getMessage();
+   }
+
+   /*
+    * Constructors of various flavors follow.
+    */
+
+   /** No arg constructor. */
+   public TokenMgrError() {
+   }
+
+   /** Constructor with message and reason. */
+   public TokenMgrError(String message, int reason) {
+      super(message);
+      errorCode = reason;
+   }
+
+   /** Full Constructor. */
+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+   }
+}
+/* JavaCC - OriginalChecksum=a75b5b61664a73631a032a6e44f4b38a (do not edit this line) */
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/package.html
new file mode 100644
index 0000000..12cdd31
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/package.html
@@ -0,0 +1,33 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+<h2>Lucene Query Parser</h2>
+<p>
+The package org.apache.lucene.queryparser.flexible.standard.parser contains the query parser.
+</p>
+<p>
+This text parser only performs the syntax validation and creates an QueryNode tree
+from a query string.
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AllowLeadingWildcardProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AllowLeadingWildcardProcessor.java
new file mode 100644
index 0000000..1b3e0b5
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AllowLeadingWildcardProcessor.java
@@ -0,0 +1,105 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.core.util.UnescapedCharSequence;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl;
+
+/**
+ * This processor verifies if
+ * {@link ConfigurationKeys#ALLOW_LEADING_WILDCARD} is defined in the
+ * {@link QueryConfigHandler}. If it is and leading wildcard is not allowed, it
+ * looks for every {@link WildcardQueryNode} contained in the query node tree
+ * and throws an exception if any of them has a leading wildcard ('*' or '?'). <br/>
+ * 
+ * @see ConfigurationKeys#ALLOW_LEADING_WILDCARD
+ */
+public class AllowLeadingWildcardProcessor extends QueryNodeProcessorImpl {
+
+  public AllowLeadingWildcardProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    Boolean allowsLeadingWildcard = getQueryConfigHandler().get(ConfigurationKeys.ALLOW_LEADING_WILDCARD);
+
+    if (allowsLeadingWildcard != null) {
+
+      if (!allowsLeadingWildcard) {
+        return super.process(queryTree);
+      }
+
+    }
+
+    return queryTree;
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof WildcardQueryNode) {
+      WildcardQueryNode wildcardNode = (WildcardQueryNode) node;
+
+      if (wildcardNode.getText().length() > 0) {
+        
+        // Validate if the wildcard was escaped
+        if (UnescapedCharSequence.wasEscaped(wildcardNode.getText(), 0))
+          return node;
+        
+        switch (wildcardNode.getText().charAt(0)) {    
+          case '*':
+          case '?':
+            throw new QueryNodeException(new MessageImpl(
+                QueryParserMessages.LEADING_WILDCARD_NOT_ALLOWED, node
+                    .toQueryString(new EscapeQuerySyntaxImpl())));    
+        }
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor.java
new file mode 100644
index 0000000..b132202
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor.java
@@ -0,0 +1,341 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.CachingTokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.NoTokenFoundQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.TextableQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.TokenizedPhraseQueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.MultiPhraseQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.StandardBooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+
+/**
+ * This processor verifies if {@link ConfigurationKeys#ANALYZER}
+ * is defined in the {@link QueryConfigHandler}. If it is and the analyzer is
+ * not <code>null</code>, it looks for every {@link FieldQueryNode} that is not
+ * {@link WildcardQueryNode}, {@link FuzzyQueryNode} or
+ * {@link ParametricQueryNode} contained in the query node tree, then it applies
+ * the analyzer to that {@link FieldQueryNode} object. <br/>
+ * <br/>
+ * If the analyzer return only one term, the returned term is set to the
+ * {@link FieldQueryNode} and it's returned. <br/>
+ * <br/>
+ * If the analyzer return more than one term, a {@link TokenizedPhraseQueryNode}
+ * or {@link MultiPhraseQueryNode} is created, whether there is one or more
+ * terms at the same position, and it's returned. <br/>
+ * <br/>
+ * If no term is returned by the analyzer a {@link NoTokenFoundQueryNode} object
+ * is returned. <br/>
+ * 
+ * @see ConfigurationKeys#ANALYZER
+ * @see Analyzer
+ * @see TokenStream
+ */
+public class AnalyzerQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  private Analyzer analyzer;
+
+  private boolean positionIncrementsEnabled;
+
+  public AnalyzerQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    Analyzer analyzer = getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);
+    
+    if (analyzer != null) {
+      this.analyzer = analyzer;
+      this.positionIncrementsEnabled = false;
+      Boolean positionIncrementsEnabled = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
+
+      if (positionIncrementsEnabled != null) {
+          this.positionIncrementsEnabled = positionIncrementsEnabled;
+      }
+
+      if (this.analyzer != null) {
+        return super.process(queryTree);
+      }
+
+    }
+
+    return queryTree;
+
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof TextableQueryNode
+        && !(node instanceof WildcardQueryNode)
+        && !(node instanceof FuzzyQueryNode)
+        && !(node instanceof ParametricQueryNode)) {
+
+      FieldQueryNode fieldNode = ((FieldQueryNode) node);
+      String text = fieldNode.getTextAsString();
+      String field = fieldNode.getFieldAsString();
+
+      TokenStream source;
+      try {
+        source = this.analyzer.reusableTokenStream(field, new StringReader(text));
+        source.reset();
+      } catch (IOException e1) {
+        throw new RuntimeException(e1);
+      }
+      CachingTokenFilter buffer = new CachingTokenFilter(source);
+
+      PositionIncrementAttribute posIncrAtt = null;
+      int numTokens = 0;
+      int positionCount = 0;
+      boolean severalTokensAtSamePosition = false;
+
+      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
+        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
+      }
+
+      try {
+
+        while (buffer.incrementToken()) {
+          numTokens++;
+          int positionIncrement = (posIncrAtt != null) ? posIncrAtt
+              .getPositionIncrement() : 1;
+          if (positionIncrement != 0) {
+            positionCount += positionIncrement;
+
+          } else {
+            severalTokensAtSamePosition = true;
+          }
+
+        }
+
+      } catch (IOException e) {
+        // ignore
+      }
+
+      try {
+        // rewind the buffer stream
+        buffer.reset();
+
+        // close original stream - all tokens buffered
+        source.close();
+      } catch (IOException e) {
+        // ignore
+      }
+
+      if (!buffer.hasAttribute(CharTermAttribute.class)) {
+        return new NoTokenFoundQueryNode();
+      }
+
+      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);
+
+      if (numTokens == 0) {
+        return new NoTokenFoundQueryNode();
+
+      } else if (numTokens == 1) {
+        String term = null;
+        try {
+          boolean hasNext;
+          hasNext = buffer.incrementToken();
+          assert hasNext == true;
+          term = termAtt.toString();
+
+        } catch (IOException e) {
+          // safe to ignore, because we know the number of tokens
+        }
+
+        fieldNode.setText(term);
+
+        return fieldNode;
+
+      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {
+        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {
+          // no phrase query:
+          LinkedList<QueryNode> children = new LinkedList<QueryNode>();
+
+          for (int i = 0; i < numTokens; i++) {
+            String term = null;
+            try {
+              boolean hasNext = buffer.incrementToken();
+              assert hasNext == true;
+              term = termAtt.toString();
+
+            } catch (IOException e) {
+              // safe to ignore, because we know the number of tokens
+            }
+
+            children.add(new FieldQueryNode(field, term, -1, -1));
+
+          }
+          if (positionCount == 1)
+            return new GroupQueryNode(
+              new StandardBooleanQueryNode(children, true));
+          else
+            return new StandardBooleanQueryNode(children, false);
+
+        } else {
+          // phrase query:
+          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();
+
+          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();
+          int position = -1;
+          int i = 0;
+          int termGroupCount = 0;
+          for (; i < numTokens; i++) {
+            String term = null;
+            int positionIncrement = 1;
+            try {
+              boolean hasNext = buffer.incrementToken();
+              assert hasNext == true;
+              term = termAtt.toString();
+              if (posIncrAtt != null) {
+                positionIncrement = posIncrAtt.getPositionIncrement();
+              }
+
+            } catch (IOException e) {
+              // safe to ignore, because we know the number of tokens
+            }
+
+            if (positionIncrement > 0 && multiTerms.size() > 0) {
+
+              for (FieldQueryNode termNode : multiTerms) {
+
+                if (this.positionIncrementsEnabled) {
+                  termNode.setPositionIncrement(position);
+                } else {
+                  termNode.setPositionIncrement(termGroupCount);
+                }
+
+                mpq.add(termNode);
+
+              }
+
+              // Only increment once for each "group" of
+              // terms that were in the same position:
+              termGroupCount++;
+
+              multiTerms.clear();
+
+            }
+
+            position += positionIncrement;
+            multiTerms.add(new FieldQueryNode(field, term, -1, -1));
+
+          }
+
+          for (FieldQueryNode termNode : multiTerms) {
+
+            if (this.positionIncrementsEnabled) {
+              termNode.setPositionIncrement(position);
+
+            } else {
+              termNode.setPositionIncrement(termGroupCount);
+            }
+
+            mpq.add(termNode);
+
+          }
+
+          return mpq;
+
+        }
+
+      } else {
+
+        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();
+
+        int position = -1;
+
+        for (int i = 0; i < numTokens; i++) {
+          String term = null;
+          int positionIncrement = 1;
+
+          try {
+            boolean hasNext = buffer.incrementToken();
+            assert hasNext == true;
+            term = termAtt.toString();
+
+            if (posIncrAtt != null) {
+              positionIncrement = posIncrAtt.getPositionIncrement();
+            }
+
+          } catch (IOException e) {
+            // safe to ignore, because we know the number of tokens
+          }
+
+          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);
+
+          if (this.positionIncrementsEnabled) {
+            position += positionIncrement;
+            newFieldNode.setPositionIncrement(position);
+
+          } else {
+            newFieldNode.setPositionIncrement(i);
+          }
+
+          pq.add(newFieldNode);
+
+        }
+
+        return pq;
+
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/BooleanSingleChildOptimizationQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/BooleanSingleChildOptimizationQueryNodeProcessor.java
new file mode 100644
index 0000000..7588341
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/BooleanSingleChildOptimizationQueryNodeProcessor.java
@@ -0,0 +1,91 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode.Modifier;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.nodes.BooleanModifierNode;
+
+/**
+ * This processor removes every {@link BooleanQueryNode} that contains only one
+ * child and returns this child. If this child is {@link ModifierQueryNode} that
+ * was defined by the user. A modifier is not defined by the user when it's a
+ * {@link BooleanModifierNode} <br/>
+ * 
+ * @see ModifierQueryNode
+ */
+public class BooleanSingleChildOptimizationQueryNodeProcessor extends
+    QueryNodeProcessorImpl {
+
+  public BooleanSingleChildOptimizationQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof BooleanQueryNode) {
+      List<QueryNode> children = node.getChildren();
+
+      if (children != null && children.size() == 1) {
+        QueryNode child = children.get(0);
+
+        if (child instanceof ModifierQueryNode) {
+          ModifierQueryNode modNode = (ModifierQueryNode) child;
+
+          if (modNode instanceof BooleanModifierNode
+              || modNode.getModifier() == Modifier.MOD_NONE) {
+
+            return child;
+
+          }
+
+        } else {
+          return child;
+        }
+
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/BoostQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/BoostQueryNodeProcessor.java
new file mode 100644
index 0000000..264ba68
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/BoostQueryNodeProcessor.java
@@ -0,0 +1,88 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+
+/**
+ * This processor iterates the query node tree looking for every
+ * {@link FieldableNode} that has {@link ConfigurationKeys#BOOST} in its
+ * config. If there is, the boost is applied to that {@link FieldableNode}. <br/>
+ * 
+ * @see ConfigurationKeys#BOOST
+ * @see QueryConfigHandler
+ * @see FieldableNode
+ */
+public class BoostQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof FieldableNode && 
+        (node.getParent() == null || !(node.getParent() instanceof FieldableNode))) {
+      
+      FieldableNode fieldNode = (FieldableNode) node;
+      QueryConfigHandler config = getQueryConfigHandler();
+
+      if (config != null) {
+        CharSequence field = fieldNode.getField();
+        FieldConfig fieldConfig = config.getFieldConfig(StringUtils.toString(field));
+
+        if (fieldConfig != null) {
+          Float boost = fieldConfig.get(ConfigurationKeys.BOOST);
+
+          if (boost != null) {
+            return new BoostQueryNode(node, boost);
+          }
+
+        }
+
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java
new file mode 100644
index 0000000..5f92a12
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java
@@ -0,0 +1,118 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.TokenizedPhraseQueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.MultiPhraseQueryNode;
+
+/**
+ * This processor verifies if {@link ConfigurationKeys#PHRASE_SLOP}
+ * is defined in the {@link QueryConfigHandler}. If it is, it looks for every
+ * {@link TokenizedPhraseQueryNode} and {@link MultiPhraseQueryNode} that does
+ * not have any {@link SlopQueryNode} applied to it and creates an
+ * {@link SlopQueryNode} and apply to it. The new {@link SlopQueryNode} has the
+ * same slop value defined in the configuration. <br/>
+ * 
+ * @see SlopQueryNode
+ * @see ConfigurationKeys#PHRASE_SLOP
+ */
+public class DefaultPhraseSlopQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  private boolean processChildren = true;
+
+  private int defaultPhraseSlop;
+
+  public DefaultPhraseSlopQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    QueryConfigHandler queryConfig = getQueryConfigHandler();
+
+    if (queryConfig != null) {
+      Integer defaultPhraseSlop = queryConfig.get(ConfigurationKeys.PHRASE_SLOP); 
+      
+      if (defaultPhraseSlop != null) {
+        this.defaultPhraseSlop = defaultPhraseSlop;
+
+        return super.process(queryTree);
+
+      }
+
+    }
+
+    return queryTree;
+
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof TokenizedPhraseQueryNode
+        || node instanceof MultiPhraseQueryNode) {
+
+      return new SlopQueryNode(node, this.defaultPhraseSlop);
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof SlopQueryNode) {
+      this.processChildren = false;
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected void processChildren(QueryNode queryTree) throws QueryNodeException {
+
+    if (this.processChildren) {
+      super.processChildren(queryTree);
+
+    } else {
+      this.processChildren = true;
+    }
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FuzzyQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FuzzyQueryNodeProcessor.java
new file mode 100644
index 0000000..f7daf5d
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FuzzyQueryNodeProcessor.java
@@ -0,0 +1,86 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.FuzzyConfig;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.search.FuzzyQuery;
+
+/**
+ * This processor iterates the query node tree looking for every
+ * {@link FuzzyQueryNode}, when this kind of node is found, it checks on the
+ * query configuration for
+ * {@link ConfigurationKeys#FUZZY_CONFIG}, gets the
+ * fuzzy prefix length and default similarity from it and set to the fuzzy node.
+ * For more information about fuzzy prefix length check: {@link FuzzyQuery}. <br/>
+ * 
+ * @see ConfigurationKeys#FUZZY_CONFIG
+ * @see FuzzyQuery
+ * @see FuzzyQueryNode
+ */
+public class FuzzyQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof FuzzyQueryNode) {
+      FuzzyQueryNode fuzzyNode = (FuzzyQueryNode) node;
+      QueryConfigHandler config = getQueryConfigHandler();
+
+      FuzzyConfig fuzzyConfig = null;
+      
+      if (config != null && (fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG)) != null) {
+        fuzzyNode.setPrefixLength(fuzzyConfig.getPrefixLength());
+
+        if (fuzzyNode.getSimilarity() < 0) {
+          fuzzyNode.setSimilarity(fuzzyConfig.getMinSimilarity());
+        }
+        
+      } else if (fuzzyNode.getSimilarity() < 0) {
+        throw new IllegalArgumentException("No FUZZY_CONFIG set in the config");
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/GroupQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/GroupQueryNodeProcessor.java
new file mode 100644
index 0000000..051df6a
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/GroupQueryNodeProcessor.java
@@ -0,0 +1,218 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode.Modifier;
+import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.Operator;
+import org.apache.lucene.queryparser.flexible.standard.nodes.BooleanModifierNode;
+
+/**
+ * The {@link SyntaxParser}
+ * generates query node trees that consider the boolean operator precedence, but
+ * Lucene current syntax does not support boolean precedence, so this processor
+ * remove all the precedence and apply the equivalent modifier according to the
+ * boolean operation defined on an specific query node. <br/>
+ * <br/>
+ * If there is a {@link GroupQueryNode} in the query node tree, the query node
+ * tree is not merged with the one above it.
+ * 
+ * Example: TODO: describe a good example to show how this processor works
+ * 
+ * @see org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler
+ */
+public class GroupQueryNodeProcessor implements QueryNodeProcessor {
+
+  private ArrayList<QueryNode> queryNodeList;
+
+  private boolean latestNodeVerified;
+
+  private QueryConfigHandler queryConfig;
+
+  private Boolean usingAnd = false;
+
+  public GroupQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    Operator defaultOperator = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
+    
+    if (defaultOperator == null) {
+      throw new IllegalArgumentException(
+          "DEFAULT_OPERATOR should be set on the QueryConfigHandler");
+    }
+
+    this.usingAnd = StandardQueryConfigHandler.Operator.AND == defaultOperator;
+
+    if (queryTree instanceof GroupQueryNode) {
+      queryTree = ((GroupQueryNode) queryTree).getChild();
+    }
+
+    this.queryNodeList = new ArrayList<QueryNode>();
+    this.latestNodeVerified = false;
+    readTree(queryTree);
+
+    List<QueryNode> actualQueryNodeList = this.queryNodeList;
+
+    for (int i = 0; i < actualQueryNodeList.size(); i++) {
+      QueryNode node = actualQueryNodeList.get(i);
+
+      if (node instanceof GroupQueryNode) {
+        actualQueryNodeList.set(i, process(node));
+      }
+
+    }
+
+    this.usingAnd = false;
+
+    if (queryTree instanceof BooleanQueryNode) {
+      queryTree.set(actualQueryNodeList);
+
+      return queryTree;
+
+    } else {
+      return new BooleanQueryNode(actualQueryNodeList);
+    }
+
+  }
+
+  /**
+   */
+  private QueryNode applyModifier(QueryNode node, QueryNode parent) {
+
+    if (this.usingAnd) {
+
+      if (parent instanceof OrQueryNode) {
+
+        if (node instanceof ModifierQueryNode) {
+
+          ModifierQueryNode modNode = (ModifierQueryNode) node;
+
+          if (modNode.getModifier() == Modifier.MOD_REQ) {
+            return modNode.getChild();
+          }
+
+        }
+
+      } else {
+
+        if (node instanceof ModifierQueryNode) {
+
+          ModifierQueryNode modNode = (ModifierQueryNode) node;
+
+          if (modNode.getModifier() == Modifier.MOD_NONE) {
+            return new BooleanModifierNode(modNode.getChild(), Modifier.MOD_REQ);
+          }
+
+        } else {
+          return new BooleanModifierNode(node, Modifier.MOD_REQ);
+        }
+
+      }
+
+    } else {
+
+      if (node.getParent() instanceof AndQueryNode) {
+
+        if (node instanceof ModifierQueryNode) {
+
+          ModifierQueryNode modNode = (ModifierQueryNode) node;
+
+          if (modNode.getModifier() == Modifier.MOD_NONE) {
+            return new BooleanModifierNode(modNode.getChild(), Modifier.MOD_REQ);
+          }
+
+        } else {
+          return new BooleanModifierNode(node, Modifier.MOD_REQ);
+        }
+
+      }
+
+    }
+
+    return node;
+
+  }
+
+  private void readTree(QueryNode node) {
+
+    if (node instanceof BooleanQueryNode) {
+      List<QueryNode> children = node.getChildren();
+
+      if (children != null && children.size() > 0) {
+
+        for (int i = 0; i < children.size() - 1; i++) {
+          readTree(children.get(i));
+        }
+
+        processNode(node);
+        readTree(children.get(children.size() - 1));
+
+      } else {
+        processNode(node);
+      }
+
+    } else {
+      processNode(node);
+    }
+
+  }
+
+  private void processNode(QueryNode node) {
+
+    if (node instanceof AndQueryNode || node instanceof OrQueryNode) {
+
+      if (!this.latestNodeVerified && !this.queryNodeList.isEmpty()) {
+        this.queryNodeList.add(applyModifier(this.queryNodeList
+            .remove(this.queryNodeList.size() - 1), node));
+        this.latestNodeVerified = true;
+
+      }
+
+    } else if (!(node instanceof BooleanQueryNode)) {
+      this.queryNodeList.add(applyModifier(node, node.getParent()));
+      this.latestNodeVerified = false;
+
+    }
+
+  }
+
+  public QueryConfigHandler getQueryConfigHandler() {
+    return this.queryConfig;
+  }
+
+  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler) {
+    this.queryConfig = queryConfigHandler;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
new file mode 100644
index 0000000..7f35e75
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
@@ -0,0 +1,92 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.TextableQueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.core.util.UnescapedCharSequence;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+
+/**
+ * This processor verifies if 
+ * {@link ConfigurationKeys#LOWERCASE_EXPANDED_TERMS} is defined in the
+ * {@link QueryConfigHandler}. If it is and the expanded terms should be
+ * lower-cased, it looks for every {@link WildcardQueryNode},
+ * {@link FuzzyQueryNode} and {@link ParametricQueryNode} and lower-case its
+ * term. <br/>
+ * 
+ * @see ConfigurationKeys#LOWERCASE_EXPANDED_TERMS
+ */
+public class LowercaseExpandedTermsQueryNodeProcessor extends
+    QueryNodeProcessorImpl {
+
+  public LowercaseExpandedTermsQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    Boolean lowercaseExpandedTerms = getQueryConfigHandler().get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS);
+
+    if (lowercaseExpandedTerms != null && lowercaseExpandedTerms) {
+      return super.process(queryTree);
+    }
+
+    return queryTree;
+
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof WildcardQueryNode || node instanceof FuzzyQueryNode
+        || node instanceof ParametricQueryNode || node instanceof RegexpQueryNode) {
+
+      TextableQueryNode txtNode = (TextableQueryNode) node;
+      txtNode.setText(UnescapedCharSequence.toLowerCase(txtNode.getText()));
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MatchAllDocsQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MatchAllDocsQueryNodeProcessor.java
new file mode 100644
index 0000000..7a19d01
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MatchAllDocsQueryNodeProcessor.java
@@ -0,0 +1,77 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.MatchAllDocsQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.search.MatchAllDocsQuery;
+
+/**
+ * This processor converts every {@link WildcardQueryNode} that is "*:*" to
+ * {@link MatchAllDocsQueryNode}.
+ * 
+ * @see MatchAllDocsQueryNode
+ * @see MatchAllDocsQuery
+ */
+public class MatchAllDocsQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  public MatchAllDocsQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof FieldQueryNode) {
+      FieldQueryNode fqn = (FieldQueryNode) node;
+
+      if (fqn.getField().toString().equals("*")
+          && fqn.getText().toString().equals("*")) {
+
+        return new MatchAllDocsQueryNode();
+
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MultiFieldQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MultiFieldQueryNodeProcessor.java
new file mode 100644
index 0000000..13c25b9
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MultiFieldQueryNodeProcessor.java
@@ -0,0 +1,133 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+
+/**
+ * This processor is used to expand terms so the query looks for the same term
+ * in different fields. It also boosts a query based on its field. <br/>
+ * <br/>
+ * This processor looks for every {@link FieldableNode} contained in the query
+ * node tree. If a {@link FieldableNode} is found, it checks if there is a
+ * {@link ConfigurationKeys#MULTI_FIELDS} defined in the {@link QueryConfigHandler}. If
+ * there is, the {@link FieldableNode} is cloned N times and the clones are
+ * added to a {@link BooleanQueryNode} together with the original node. N is
+ * defined by the number of fields that it will be expanded to. The
+ * {@link BooleanQueryNode} is returned. <br/>
+ * 
+ * @see ConfigurationKeys#MULTI_FIELDS
+ */
+public class MultiFieldQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  private boolean processChildren = true;
+
+  public MultiFieldQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected void processChildren(QueryNode queryTree) throws QueryNodeException {
+
+    if (this.processChildren) {
+      super.processChildren(queryTree);
+
+    } else {
+      this.processChildren = true;
+    }
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof FieldableNode) {
+      this.processChildren = false;
+      FieldableNode fieldNode = (FieldableNode) node;
+
+      if (fieldNode.getField() == null) {
+        CharSequence[] fields = getQueryConfigHandler().get(ConfigurationKeys.MULTI_FIELDS);
+
+        if (fields == null) {
+          throw new IllegalArgumentException(
+              "StandardQueryConfigHandler.ConfigurationKeys.MULTI_FIELDS should be set on the QueryConfigHandler");
+        }
+
+        if (fields != null && fields.length > 0) {
+          fieldNode.setField(fields[0]);
+
+          if (fields.length == 1) {
+            return fieldNode;
+
+          } else {
+            LinkedList<QueryNode> children = new LinkedList<QueryNode>();
+            children.add(fieldNode);
+
+            for (int i = 1; i < fields.length; i++) {
+              try {
+                fieldNode = (FieldableNode) fieldNode.cloneTree();
+                fieldNode.setField(fields[i]);
+
+                children.add(fieldNode);
+
+              } catch (CloneNotSupportedException e) {
+                // should never happen
+              }
+
+            }
+
+            return new GroupQueryNode(new BooleanQueryNode(children));
+
+          }
+
+        }
+
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MultiTermRewriteMethodProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MultiTermRewriteMethodProcessor.java
new file mode 100644
index 0000000..1f0fc72
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/MultiTermRewriteMethodProcessor.java
@@ -0,0 +1,74 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.AbstractRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.search.MultiTermQuery;
+
+/**
+ * This processor instates the default
+ * {@link org.apache.lucene.search.MultiTermQuery.RewriteMethod},
+ * {@link MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}, for multi-term
+ * query nodes.
+ */
+public class MultiTermRewriteMethodProcessor extends QueryNodeProcessorImpl {
+
+  public static final String TAG_ID = "MultiTermRewriteMethodConfiguration";
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) {
+
+    // set setMultiTermRewriteMethod for WildcardQueryNode and
+    // PrefixWildcardQueryNode
+    if (node instanceof WildcardQueryNode
+        || node instanceof AbstractRangeQueryNode || node instanceof RegexpQueryNode) {
+      
+      MultiTermQuery.RewriteMethod rewriteMethod = getQueryConfigHandler().get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
+
+      if (rewriteMethod == null) {
+        // This should not happen, this configuration is set in the
+        // StandardQueryConfigHandler
+        throw new IllegalArgumentException(
+            "StandardQueryConfigHandler.ConfigurationKeys.MULTI_TERM_REWRITE_METHOD should be set on the QueryConfigHandler");
+      }
+
+      // use a TAG to take the value to the Builder
+      node.setTag(MultiTermRewriteMethodProcessor.TAG_ID, rewriteMethod);
+
+    }
+
+    return node;
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) {
+    return node;
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children) {
+    return children;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/NumericQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/NumericQueryNodeProcessor.java
new file mode 100644
index 0000000..3bbe7fc
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/NumericQueryNodeProcessor.java
@@ -0,0 +1,122 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.NumberFormat;
+import java.text.ParseException;
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.NumericQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.NumericRangeQueryNode;
+
+public class NumericQueryNodeProcessor extends QueryNodeProcessorImpl {
+  
+  public NumericQueryNodeProcessor() {
+  // empty constructor
+  }
+  
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+    
+    if (node instanceof FieldQueryNode
+        && !(node instanceof ParametricQueryNode)) {
+      
+      QueryConfigHandler config = getQueryConfigHandler();
+      
+      if (config != null) {
+        FieldQueryNode fieldNode = (FieldQueryNode) node;
+        FieldConfig fieldConfig = config.getFieldConfig(fieldNode
+            .getFieldAsString());
+        
+        if (fieldConfig != null) {
+          NumericConfig numericConfig = fieldConfig
+              .get(ConfigurationKeys.NUMERIC_CONFIG);
+          
+          if (numericConfig != null) {
+            
+            NumberFormat numberFormat = numericConfig.getNumberFormat();
+            Number number;
+            
+            try {
+              number = numberFormat.parse(fieldNode.getTextAsString());
+              
+            } catch (ParseException e) {
+              throw new QueryNodeParseException(new MessageImpl(
+                  QueryParserMessages.COULD_NOT_PARSE_NUMBER, fieldNode
+                      .getTextAsString(), numberFormat.getClass()
+                      .getCanonicalName()), e);
+            }
+            
+            switch (numericConfig.getType()) {
+              case LONG:
+                number = number.longValue();
+                break;
+              case INT:
+                number = number.intValue();
+                break;
+              case DOUBLE:
+                number = number.doubleValue();
+                break;
+              case FLOAT:
+                number = number.floatValue();
+            }
+            
+            NumericQueryNode lowerNode = new NumericQueryNode(fieldNode
+                .getField(), number, numberFormat);
+            NumericQueryNode upperNode = new NumericQueryNode(fieldNode
+                .getField(), number, numberFormat);
+            
+            return new NumericRangeQueryNode(lowerNode, upperNode, true, true,
+                numericConfig);
+            
+          }
+          
+        }
+        
+      }
+      
+    }
+    
+    return node;
+    
+  }
+  
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+    return node;
+  }
+  
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+    return children;
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/NumericRangeQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/NumericRangeQueryNodeProcessor.java
new file mode 100644
index 0000000..2f2f76c
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/NumericRangeQueryNodeProcessor.java
@@ -0,0 +1,143 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.NumberFormat;
+import java.text.ParseException;
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode.CompareOperator;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.NumericQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.NumericRangeQueryNode;
+
+public class NumericRangeQueryNodeProcessor extends QueryNodeProcessorImpl {
+  
+  public NumericRangeQueryNodeProcessor() {
+  // empty constructor
+  }
+  
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+    
+    if (node instanceof ParametricRangeQueryNode) {
+      QueryConfigHandler config = getQueryConfigHandler();
+      
+      if (config != null) {
+        ParametricRangeQueryNode parametricRangeNode = (ParametricRangeQueryNode) node;
+        FieldConfig fieldConfig = config.getFieldConfig(StringUtils
+            .toString(parametricRangeNode.getField()));
+        
+        if (fieldConfig != null) {
+          
+          NumericConfig numericConfig = fieldConfig
+              .get(ConfigurationKeys.NUMERIC_CONFIG);
+          
+          if (numericConfig != null) {
+            
+            ParametricQueryNode lower = parametricRangeNode.getLowerBound();
+            ParametricQueryNode upper = parametricRangeNode.getUpperBound();
+            
+            NumberFormat numberFormat = numericConfig.getNumberFormat();
+            Number lowerNumber, upperNumber;
+            
+            try {
+              lowerNumber = numberFormat.parse(lower.getTextAsString());
+              
+            } catch (ParseException e) {
+              throw new QueryNodeParseException(new MessageImpl(
+                  QueryParserMessages.COULD_NOT_PARSE_NUMBER, lower
+                      .getTextAsString(), numberFormat.getClass()
+                      .getCanonicalName()), e);
+            }
+            
+            try {
+              upperNumber = numberFormat.parse(upper.getTextAsString());
+              
+            } catch (ParseException e) {
+              throw new QueryNodeParseException(new MessageImpl(
+                  QueryParserMessages.COULD_NOT_PARSE_NUMBER, upper
+                      .getTextAsString(), numberFormat.getClass()
+                      .getCanonicalName()), e);
+            }
+            
+            switch (numericConfig.getType()) {
+              case LONG:
+                upperNumber = upperNumber.longValue();
+                lowerNumber = lowerNumber.longValue();
+                break;
+              case INT:
+                upperNumber = upperNumber.intValue();
+                lowerNumber = lowerNumber.intValue();
+                break;
+              case DOUBLE:
+                upperNumber = upperNumber.doubleValue();
+                lowerNumber = lowerNumber.doubleValue();
+                break;
+              case FLOAT:
+                upperNumber = upperNumber.floatValue();
+                lowerNumber = lowerNumber.floatValue();
+            }
+            
+            NumericQueryNode lowerNode = new NumericQueryNode(
+                parametricRangeNode.getField(), lowerNumber, numberFormat);
+            NumericQueryNode upperNode = new NumericQueryNode(
+                parametricRangeNode.getField(), upperNumber, numberFormat);
+            
+            boolean upperInclusive = upper.getOperator() == CompareOperator.LE;
+            boolean lowerInclusive = lower.getOperator() == CompareOperator.GE;
+            
+            return new NumericRangeQueryNode(lowerNode, upperNode,
+                lowerInclusive, upperInclusive, numericConfig);
+            
+          }
+          
+        }
+        
+      }
+      
+    }
+    
+    return node;
+    
+  }
+  
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+    return node;
+  }
+  
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+    return children;
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/ParametricRangeQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/ParametricRangeQueryNodeProcessor.java
new file mode 100644
index 0000000..258253f
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/ParametricRangeQueryNodeProcessor.java
@@ -0,0 +1,158 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.DateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.DateTools.Resolution;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode.CompareOperator;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.TermRangeQueryNode;
+
+/**
+ * This processor converts {@link ParametricRangeQueryNode} objects to
+ * {@link TermRangeQueryNode} objects. It reads the lower and upper bounds value
+ * from the {@link ParametricRangeQueryNode} object and try to parse their
+ * values using a {@link DateFormat}. If the values cannot be parsed to a date
+ * value, it will only create the {@link TermRangeQueryNode} using the
+ * non-parsed values. <br/>
+ * <br/>
+ * If a {@link ConfigurationKeys#LOCALE} is defined in the {@link QueryConfigHandler} it
+ * will be used to parse the date, otherwise {@link Locale#getDefault()} will be
+ * used. <br/>
+ * <br/>
+ * If a {@link ConfigurationKeys#DATE_RESOLUTION} is defined and the {@link Resolution} is
+ * not <code>null</code> it will also be used to parse the date value. <br/>
+ * <br/>
+ * 
+ * @see ConfigurationKeys#DATE_RESOLUTION
+ * @see ConfigurationKeys#LOCALE
+ * @see TermRangeQueryNode
+ * @see ParametricRangeQueryNode
+ */
+public class ParametricRangeQueryNodeProcessor extends QueryNodeProcessorImpl {
+  
+  public ParametricRangeQueryNodeProcessor() {
+  // empty constructor
+  }
+  
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+    
+    if (node instanceof ParametricRangeQueryNode) {
+      ParametricRangeQueryNode parametricRangeNode = (ParametricRangeQueryNode) node;
+      ParametricQueryNode upper = parametricRangeNode.getUpperBound();
+      ParametricQueryNode lower = parametricRangeNode.getLowerBound();
+      
+      DateTools.Resolution dateRes = null;
+      boolean inclusive = false;
+      Locale locale = getQueryConfigHandler().get(ConfigurationKeys.LOCALE);
+
+      if (locale == null) {
+        locale = Locale.getDefault();
+      }
+      
+      CharSequence field = parametricRangeNode.getField();
+      String fieldStr = null;
+      
+      if (field != null) {
+        fieldStr = field.toString();
+      }
+      
+      FieldConfig fieldConfig = getQueryConfigHandler()
+          .getFieldConfig(fieldStr);
+      
+      if (fieldConfig != null) {
+        dateRes = fieldConfig.get(ConfigurationKeys.DATE_RESOLUTION);
+      }
+      
+      if (upper.getOperator() == CompareOperator.LE) {
+        inclusive = true;
+        
+      } else if (lower.getOperator() == CompareOperator.GE) {
+        inclusive = true;
+      }
+      
+      String part1 = lower.getTextAsString();
+      String part2 = upper.getTextAsString();
+      
+      try {
+        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT, locale);
+        df.setLenient(true);
+        Date d1 = df.parse(part1);
+        Date d2 = df.parse(part2);
+        if (inclusive) {
+          // The user can only specify the date, not the time, so make sure
+          // the time is set to the latest possible time of that date to really
+          // include all documents:
+          Calendar cal = Calendar.getInstance(locale);
+          cal.setTime(d2);
+          cal.set(Calendar.HOUR_OF_DAY, 23);
+          cal.set(Calendar.MINUTE, 59);
+          cal.set(Calendar.SECOND, 59);
+          cal.set(Calendar.MILLISECOND, 999);
+          d2 = cal.getTime();
+        }
+        
+        part1 = DateTools.dateToString(d1, dateRes);
+        part2 = DateTools.dateToString(d2, dateRes);
+      } catch (Exception e) {
+        // do nothing
+      }
+      
+      lower.setText(part1);
+      upper.setText(part2);
+      
+      return new TermRangeQueryNode(lower, upper,
+          lower.getOperator() == CompareOperator.GE,
+          upper.getOperator() == CompareOperator.LE);
+      
+    }
+    
+    return node;
+    
+  }
+  
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+    
+    return node;
+    
+  }
+  
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+    
+    return children;
+    
+  }
+  
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/PhraseSlopQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/PhraseSlopQueryNodeProcessor.java
new file mode 100644
index 0000000..2a0ca6f
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/PhraseSlopQueryNodeProcessor.java
@@ -0,0 +1,74 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.TokenizedPhraseQueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.standard.nodes.MultiPhraseQueryNode;
+
+/**
+ * This processor removes invalid {@link SlopQueryNode} objects in the query
+ * node tree. A {@link SlopQueryNode} is invalid if its child is neither a
+ * {@link TokenizedPhraseQueryNode} nor a {@link MultiPhraseQueryNode}. <br/>
+ * 
+ * @see SlopQueryNode
+ */
+public class PhraseSlopQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  public PhraseSlopQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof SlopQueryNode) {
+      SlopQueryNode phraseSlopNode = (SlopQueryNode) node;
+
+      if (!(phraseSlopNode.getChild() instanceof TokenizedPhraseQueryNode)
+          && !(phraseSlopNode.getChild() instanceof MultiPhraseQueryNode)) {
+        return phraseSlopNode.getChild();
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/RemoveEmptyNonLeafQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/RemoveEmptyNonLeafQueryNodeProcessor.java
new file mode 100644
index 0000000..852dd8e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/RemoveEmptyNonLeafQueryNodeProcessor.java
@@ -0,0 +1,116 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.MatchNoDocsQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+
+/**
+ * This processor removes every {@link QueryNode} that is not a leaf and has not
+ * children. If after processing the entire tree the root node is not a leaf and
+ * has no children, a {@link MatchNoDocsQueryNode} object is returned. <br/>
+ * <br/>
+ * This processor is used at the end of a pipeline to avoid invalid query node
+ * tree structures like a {@link GroupQueryNode} or {@link ModifierQueryNode}
+ * with no children. <br/>
+ * 
+ * @see QueryNode
+ * @see MatchNoDocsQueryNode
+ */
+public class RemoveEmptyNonLeafQueryNodeProcessor extends
+    QueryNodeProcessorImpl {
+
+  private LinkedList<QueryNode> childrenBuffer = new LinkedList<QueryNode>();
+
+  public RemoveEmptyNonLeafQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    queryTree = super.process(queryTree);
+
+    if (!queryTree.isLeaf()) {
+
+      List<QueryNode> children = queryTree.getChildren();
+
+      if (children == null || children.size() == 0) {
+        return new MatchNoDocsQueryNode();
+      }
+
+    }
+
+    return queryTree;
+
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    try {
+
+      for (QueryNode child : children) {
+
+        if (!child.isLeaf()) {
+
+          List<QueryNode> grandChildren = child.getChildren();
+
+          if (grandChildren != null && grandChildren.size() > 0) {
+            this.childrenBuffer.add(child);
+          }
+
+        } else {
+          this.childrenBuffer.add(child);
+        }
+
+      }
+
+      children.clear();
+      children.addAll(this.childrenBuffer);
+
+    } finally {
+      this.childrenBuffer.clear();
+    }
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/StandardQueryNodeProcessorPipeline.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/StandardQueryNodeProcessorPipeline.java
new file mode 100644
index 0000000..4a73f23
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/StandardQueryNodeProcessorPipeline.java
@@ -0,0 +1,72 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.processors.NoChildOptimizationQueryNodeProcessor;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline;
+import org.apache.lucene.queryparser.flexible.core.processors.RemoveDeletedQueryNodesProcessor;
+import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
+import org.apache.lucene.search.Query;
+
+/**
+ * This pipeline has all the processors needed to process a query node tree,
+ * generated by {@link StandardSyntaxParser}, already assembled. <br/>
+ * <br/>
+ * The order they are assembled affects the results. <br/>
+ * <br/>
+ * This processor pipeline was designed to work with
+ * {@link StandardQueryConfigHandler}. <br/>
+ * <br/>
+ * The result query node tree can be used to build a {@link Query} object using
+ * {@link StandardQueryTreeBuilder}. <br/>
+ * 
+ * @see StandardQueryTreeBuilder
+ * @see StandardQueryConfigHandler
+ * @see StandardSyntaxParser
+ */
+public class StandardQueryNodeProcessorPipeline extends
+    QueryNodeProcessorPipeline {
+
+  public StandardQueryNodeProcessorPipeline(QueryConfigHandler queryConfig) {
+    super(queryConfig);
+
+    add(new WildcardQueryNodeProcessor());    
+    add(new MultiFieldQueryNodeProcessor());
+    add(new FuzzyQueryNodeProcessor());
+    add(new MatchAllDocsQueryNodeProcessor());
+    add(new LowercaseExpandedTermsQueryNodeProcessor());
+    add(new NumericQueryNodeProcessor());
+    add(new NumericRangeQueryNodeProcessor());
+    add(new ParametricRangeQueryNodeProcessor());
+    add(new AllowLeadingWildcardProcessor());    
+    add(new AnalyzerQueryNodeProcessor());
+    add(new PhraseSlopQueryNodeProcessor());
+    add(new GroupQueryNodeProcessor());
+    add(new NoChildOptimizationQueryNodeProcessor());
+    add(new RemoveDeletedQueryNodesProcessor());
+    add(new RemoveEmptyNonLeafQueryNodeProcessor());
+    add(new BooleanSingleChildOptimizationQueryNodeProcessor());
+    add(new DefaultPhraseSlopQueryNodeProcessor());
+    add(new BoostQueryNodeProcessor());    
+    add(new MultiTermRewriteMethodProcessor());
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/WildcardQueryNodeProcessor.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/WildcardQueryNodeProcessor.java
new file mode 100644
index 0000000..331f8fd
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/WildcardQueryNodeProcessor.java
@@ -0,0 +1,139 @@
+package org.apache.lucene.queryparser.flexible.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.core.util.UnescapedCharSequence;
+import org.apache.lucene.queryparser.flexible.standard.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
+import org.apache.lucene.search.PrefixQuery;
+
+/**
+ * The {@link StandardSyntaxParser} creates {@link PrefixWildcardQueryNode} nodes which
+ * have values containing the prefixed wildcard. However, Lucene
+ * {@link PrefixQuery} cannot contain the prefixed wildcard. So, this processor
+ * basically removed the prefixed wildcard from the
+ * {@link PrefixWildcardQueryNode} value. <br/>
+ * 
+ * @see PrefixQuery
+ * @see PrefixWildcardQueryNode
+ */
+public class WildcardQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  public WildcardQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    // the old Lucene Parser ignores FuzzyQueryNode that are also PrefixWildcardQueryNode or WildcardQueryNode
+    // we do the same here, also ignore empty terms
+    if (node instanceof FieldQueryNode || node instanceof FuzzyQueryNode) {      
+      FieldQueryNode fqn = (FieldQueryNode) node;      
+      CharSequence text = fqn.getText(); 
+      
+      // do not process wildcards for ParametricQueryNode and 
+      // QuotedFieldQueryNode to reproduce the old parser behavior
+      if (fqn instanceof ParametricQueryNode 
+          || fqn instanceof QuotedFieldQueryNode 
+          || text.length() <= 0){
+        // Ignore empty terms
+        return node;
+      }
+      
+      // Code below simulates the old lucene parser behavior for wildcards
+      
+      if (isPrefixWildcard(text)) {        
+        PrefixWildcardQueryNode prefixWildcardQN = new PrefixWildcardQueryNode(fqn);
+        return prefixWildcardQN;
+        
+      } else if (isWildcard(text)){
+        WildcardQueryNode wildcardQN = new WildcardQueryNode(fqn);
+        return wildcardQN;
+      }
+             
+    }
+
+    return node;
+
+  }
+
+  private boolean isWildcard(CharSequence text) {
+    if (text ==null || text.length() <= 0) return false;
+    
+    // If a un-escaped '*' or '?' if found return true
+    // start at the end since it's more common to put wildcards at the end
+    for(int i=text.length()-1; i>=0; i--){
+      if ((text.charAt(i) == '*' || text.charAt(i) == '?') && !UnescapedCharSequence.wasEscaped(text, i)){
+        return true;
+      }
+    }
+    
+    return false;
+  }
+
+  private boolean isPrefixWildcard(CharSequence text) {
+    if (text == null || text.length() <= 0 || !isWildcard(text)) return false;
+    
+    // Validate last character is a '*' and was not escaped
+    // If single '*' is is a wildcard not prefix to simulate old queryparser
+    if (text.charAt(text.length()-1) != '*') return false;
+    if (UnescapedCharSequence.wasEscaped(text, text.length()-1)) return false;
+    if (text.length() == 1) return false;
+      
+    // Only make a prefix if there is only one single star at the end and no '?' or '*' characters
+    // If single wildcard return false to mimic old queryparser
+    for(int i=0; i<text.length(); i++){
+      if (text.charAt(i) == '?') return false;
+      if (text.charAt(i) == '*' && !UnescapedCharSequence.wasEscaped(text, i)){        
+        if (i == text.length()-1) 
+          return true;
+        else 
+          return false;
+      }
+    }
+    
+    return false;
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/package.html
new file mode 100644
index 0000000..c65a24c
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/package.html
@@ -0,0 +1,33 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+<h2>Lucene Query Node Processors</h2>
+<p>
+The package org.apache.lucene.queryparser.flexible.standard.processors contains every processor needed to assembly a pipeline
+that modifies the query node tree according to the actual Lucene queries.
+</p>
+<p>
+This processors are already assembled correctly in the StandardQueryNodeProcessorPipeline. 
+</p>
+</body>
+</html>
diff --git a/modules/queryparser/src/resources/org/apache/lucene/queryparser/flexible/core/messages/QueryParserMessages.properties b/modules/queryparser/src/resources/org/apache/lucene/queryparser/flexible/core/messages/QueryParserMessages.properties
new file mode 100644
index 0000000..fa7aa0d
--- /dev/null
+++ b/modules/queryparser/src/resources/org/apache/lucene/queryparser/flexible/core/messages/QueryParserMessages.properties
@@ -0,0 +1,57 @@
+# This resource bundle contains Flexible Query Parser messages.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+#  <REPLACEMENT arg="{0}" value="detailed_message"/>
+INVALID_SYNTAX = Syntax Error: {0}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+#  <REPLACEMENT arg="{0}" value="invalid_query"/>
+#  <REPLACEMENT arg="{1}" value="detailed_message"/>
+INVALID_SYNTAX_CANNOT_PARSE = Syntax Error, cannot parse {0}: {1} 
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_FUZZY_LIMITS = The similarity value for a fuzzy search must be between 0.0 and 1.0.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_FUZZY_EDITS = Fractional edit distances are not allowed.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION = Truncated unicode escape sequence.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_ESCAPE_CHARACTER = Term can not end with escape character.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE = None-hex character in unicode escape sequence: {0}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+NODE_ACTION_NOT_SUPPORTED = This node does not support this action.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+PARAMETER_VALUE_NOT_SUPPORTED = Parameter {1} with value {0} not supported.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+#  <REPLACEMENT arg="{0}" value="query"/>
+#  <REPLACEMENT arg="{1}" value="error/class"/>
+LUCENE_QUERY_CONVERSION_ERROR = Cannot convert query to lucene syntax: {0} error: {1}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+EMPTY_MESSAGE = 
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+WILDCARD_NOT_SUPPORTED = Wildcard is not supported for query: {0} 
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+TOO_MANY_BOOLEAN_CLAUSES = Too many boolean clauses, the maximum supported is {0}: {1}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+LEADING_WILDCARD_NOT_ALLOWED = Leading wildcard is not allowed: {0}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+COULD_NOT_PARSE_NUMBER = Could not parse text "{0}" using {1}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+NUMBER_CLASS_NOT_SUPPORTED_BY_NUMERIC_RANGE_QUERY = Number class not supported by NumericRangeQueryNode: {0}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+UNSUPPORTED_NUMERIC_DATA_TYPE = Unsupported NumericField.DataType: {0}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/core/builders/TestQueryTreeBuilder.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/core/builders/TestQueryTreeBuilder.java
new file mode 100644
index 0000000..9a40c70
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/core/builders/TestQueryTreeBuilder.java
@@ -0,0 +1,48 @@
+package org.apache.lucene.queryparser.flexible.core.builders;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import junit.framework.Assert;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.util.UnescapedCharSequence;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+public class TestQueryTreeBuilder extends LuceneTestCase {
+  
+  @Test
+  public void testSetFieldBuilder() throws QueryNodeException {
+    QueryTreeBuilder qtb = new QueryTreeBuilder();
+    qtb.setBuilder("field", new DummyBuilder());
+    Object result = qtb.build(new FieldQueryNode(new UnescapedCharSequence("field"), "foo", 0, 0));
+    Assert.assertEquals("OK", result);
+    
+  }
+  
+  private static class DummyBuilder implements QueryBuilder {
+
+    public Object build(QueryNode queryNode) throws QueryNodeException {
+      return "OK";
+    }
+    
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/core/nodes/TestQueryNode.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/core/nodes/TestQueryNode.java
new file mode 100644
index 0000000..53caba8
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/core/nodes/TestQueryNode.java
@@ -0,0 +1,47 @@
+package org.apache.lucene.queryparser.flexible.core.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Arrays;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestQueryNode extends LuceneTestCase {
+ 
+  /* LUCENE-2227 bug in QueryNodeImpl.add() */
+  public void testAddChildren() throws Exception {
+    QueryNode nodeA = new FieldQueryNode("foo", "A", 0, 1);
+    QueryNode nodeB = new FieldQueryNode("foo", "B", 1, 2);
+    BooleanQueryNode bq = new BooleanQueryNode(
+        Arrays.asList(nodeA));
+    bq.add(Arrays.asList(nodeB));
+    assertEquals(2, bq.getChildren().size());
+  }
+  
+  /* LUCENE-3045 bug in QueryNodeImpl.containsTag(String key)*/
+  public void testTags() throws Exception {
+    QueryNode node = new FieldQueryNode("foo", "A", 0, 1);
+    
+    node.setTag("TaG", new Object());
+    assertTrue(node.getTagMap().size() > 0);
+    assertTrue(node.containsTag("tAg"));
+    assertTrue(node.getTag("tAg") != null);
+    
+  }
+  
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java
new file mode 100644
index 0000000..311fec5
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java
@@ -0,0 +1,638 @@
+package org.apache.lucene.queryparser.flexible.precedence;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.Reader;
+import java.text.DateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenFilter;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.parser.ParseException;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.CharacterRunAutomaton;
+
+/**
+ * <p>
+ * This test case tests {@link PrecedenceQueryParser}.
+ * </p>
+ * <p>
+ * It contains all tests from {@link org.apache.lucene.queryparser.classic.TestQueryParser}
+ * with some adjusted to fit the precedence requirement, plus some precedence test cases.
+ * </p>
+ * 
+ * @see org.apache.lucene.queryparser.classic.TestQueryParser
+ */
+public class TestPrecedenceQueryParser extends LuceneTestCase {
+
+  public static Analyzer qpAnalyzer = new QPTestAnalyzer();
+
+  public static final class QPTestFilter extends TokenFilter {
+    /**
+     * Filter which discards the token 'stop' and which expands the token
+     * 'phrase' into 'phrase1 phrase2'
+     */
+    public QPTestFilter(TokenStream in) {
+      super(in);
+    }
+
+    boolean inPhrase = false;
+
+    int savedStart = 0, savedEnd = 0;
+
+    CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+
+    OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
+
+    @Override
+    public boolean incrementToken() throws IOException {
+      if (inPhrase) {
+        inPhrase = false;
+        termAtt.setEmpty().append("phrase2");
+        offsetAtt.setOffset(savedStart, savedEnd);
+        return true;
+      } else
+        while (input.incrementToken())
+          if (termAtt.toString().equals("phrase")) {
+            inPhrase = true;
+            savedStart = offsetAtt.startOffset();
+            savedEnd = offsetAtt.endOffset();
+            termAtt.setEmpty().append("phrase1");
+            offsetAtt.setOffset(savedStart, savedEnd);
+            return true;
+          } else if (!termAtt.toString().equals("stop"))
+            return true;
+      return false;
+    }
+  }
+
+  public static final class QPTestAnalyzer extends Analyzer {
+
+    /** Filters MockTokenizer with StopFilter. */
+    @Override
+    public final TokenStream tokenStream(String fieldName, Reader reader) {
+      return new QPTestFilter(new MockTokenizer(reader, MockTokenizer.SIMPLE, true));
+    }
+  }
+
+  private int originalMaxClauses;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    originalMaxClauses = BooleanQuery.getMaxClauseCount();
+  }
+
+  public PrecedenceQueryParser getParser(Analyzer a) throws Exception {
+    if (a == null)
+      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
+    PrecedenceQueryParser qp = new PrecedenceQueryParser();
+    qp.setAnalyzer(a);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
+    return qp;
+  }
+
+  public Query getQuery(String query, Analyzer a) throws Exception {
+    return getParser(a).parse(query, "field");
+  }
+
+  public void assertQueryEquals(String query, Analyzer a, String result)
+      throws Exception {
+    Query q = getQuery(query, a);
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void assertWildcardQueryEquals(String query, boolean lowercase,
+      String result) throws Exception {
+    PrecedenceQueryParser qp = getParser(null);
+    qp.setLowercaseExpandedTerms(lowercase);
+    Query q = qp.parse(query, "field");
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
+          + result + "/");
+    }
+  }
+
+  public void assertWildcardQueryEquals(String query, String result)
+      throws Exception {
+    PrecedenceQueryParser qp = getParser(null);
+    Query q = qp.parse(query, "field");
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
+          + result + "/");
+    }
+  }
+
+  public Query getQueryDOA(String query, Analyzer a) throws Exception {
+    if (a == null)
+      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
+    PrecedenceQueryParser qp = new PrecedenceQueryParser();
+    qp.setAnalyzer(a);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+    return qp.parse(query, "field");
+  }
+
+  public void assertQueryEqualsDOA(String query, Analyzer a, String result)
+      throws Exception {
+    Query q = getQueryDOA(query, a);
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void testSimple() throws Exception {
+    assertQueryEquals("term term term", null, "term term term");
+    assertQueryEquals("trm term term", null, "trm term term");
+    assertQueryEquals("mlaut", null, "mlaut");
+
+    assertQueryEquals("a AND b", null, "+a +b");
+    assertQueryEquals("(a AND b)", null, "+a +b");
+    assertQueryEquals("c OR (a AND b)", null, "c (+a +b)");
+    assertQueryEquals("a AND NOT b", null, "+a -b");
+    assertQueryEquals("a AND -b", null, "+a -b");
+    assertQueryEquals("a AND !b", null, "+a -b");
+    assertQueryEquals("a && b", null, "+a +b");
+    assertQueryEquals("a && ! b", null, "+a -b");
+
+    assertQueryEquals("a OR b", null, "a b");
+    assertQueryEquals("a || b", null, "a b");
+
+    assertQueryEquals("+term -term term", null, "+term -term term");
+    assertQueryEquals("foo:term AND field:anotherTerm", null,
+        "+foo:term +anotherterm");
+    assertQueryEquals("term AND \"phrase phrase\"", null,
+        "+term +\"phrase phrase\"");
+    assertQueryEquals("\"hello there\"", null, "\"hello there\"");
+    assertTrue(getQuery("a AND b", null) instanceof BooleanQuery);
+    assertTrue(getQuery("hello", null) instanceof TermQuery);
+    assertTrue(getQuery("\"hello there\"", null) instanceof PhraseQuery);
+
+    assertQueryEquals("germ term^2.0", null, "germ term^2.0");
+    assertQueryEquals("(term)^2.0", null, "term^2.0");
+    assertQueryEquals("(germ term)^2.0", null, "(germ term)^2.0");
+    assertQueryEquals("term^2.0", null, "term^2.0");
+    assertQueryEquals("term^2", null, "term^2.0");
+    assertQueryEquals("\"germ term\"^2.0", null, "\"germ term\"^2.0");
+    assertQueryEquals("\"term germ\"^2", null, "\"term germ\"^2.0");
+
+    assertQueryEquals("(foo OR bar) AND (baz OR boo)", null,
+        "+(foo bar) +(baz boo)");
+    assertQueryEquals("((a OR b) AND NOT c) OR d", null, "(+(a b) -c) d");
+    assertQueryEquals("+(apple \"steve jobs\") -(foo bar baz)", null,
+        "+(apple \"steve jobs\") -(foo bar baz)");
+    assertQueryEquals("+title:(dog OR cat) -author:\"bob dole\"", null,
+        "+(title:dog title:cat) -author:\"bob dole\"");
+
+    PrecedenceQueryParser qp = new PrecedenceQueryParser();
+    qp.setAnalyzer(new MockAnalyzer(random));
+    // make sure OR is the default:
+    assertEquals(StandardQueryConfigHandler.Operator.OR, qp.getDefaultOperator());
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+    assertEquals(StandardQueryConfigHandler.Operator.AND, qp.getDefaultOperator());
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
+    assertEquals(StandardQueryConfigHandler.Operator.OR, qp.getDefaultOperator());
+
+    assertQueryEquals("a OR !b", null, "a -b");
+    assertQueryEquals("a OR ! b", null, "a -b");
+    assertQueryEquals("a OR -b", null, "a -b");
+  }
+
+  public void testPunct() throws Exception {
+    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
+    assertQueryEquals("a&b", a, "a&b");
+    assertQueryEquals("a&&b", a, "a&&b");
+    assertQueryEquals(".NET", a, ".NET");
+  }
+
+  public void testSlop() throws Exception {
+    assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
+    assertQueryEquals("\"term germ\"~2 flork", null, "\"term germ\"~2 flork");
+    assertQueryEquals("\"term\"~2", null, "term");
+    assertQueryEquals("\" \"~2 germ", null, "germ");
+    assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
+  }
+
+  public void testNumber() throws Exception {
+    // The numbers go away because SimpleAnalzyer ignores them
+    assertQueryEquals("3", null, "");
+    assertQueryEquals("term 1.0 1 2", null, "term");
+    assertQueryEquals("term term1 term2", null, "term term term");
+
+    Analyzer a = new MockAnalyzer(random);
+    assertQueryEquals("3", a, "3");
+    assertQueryEquals("term 1.0 1 2", a, "term 1.0 1 2");
+    assertQueryEquals("term term1 term2", a, "term term1 term2");
+  }
+
+  public void testWildcard() throws Exception {
+    assertQueryEquals("term*", null, "term*");
+    assertQueryEquals("term*^2", null, "term*^2.0");
+    assertQueryEquals("term~", null, "term~2.0");
+    assertQueryEquals("term~0.7", null, "term~0.7");
+    assertQueryEquals("term~^3", null, "term~2.0^3.0");
+    assertQueryEquals("term^3~", null, "term~2.0^3.0");
+    assertQueryEquals("term*germ", null, "term*germ");
+    assertQueryEquals("term*germ^3", null, "term*germ^3.0");
+
+    assertTrue(getQuery("term*", null) instanceof PrefixQuery);
+    assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
+    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
+    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
+    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    fq = (FuzzyQuery) getQuery("term~", null);
+    assertEquals(2.0f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    try {
+      getQuery("term~1.1", null); // value > 1, throws exception
+      fail();
+    } catch (ParseException pe) {
+      // expected exception
+    }
+    assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
+
+    /*
+     * Tests to see that wild card terms are (or are not) properly lower-cased
+     * with propery parser configuration
+     */
+    // First prefix queries:
+    // by default, convert to lowercase:
+    assertWildcardQueryEquals("Term*", true, "term*");
+    // explicitly set lowercase:
+    assertWildcardQueryEquals("term*", true, "term*");
+    assertWildcardQueryEquals("Term*", true, "term*");
+    assertWildcardQueryEquals("TERM*", true, "term*");
+    // explicitly disable lowercase conversion:
+    assertWildcardQueryEquals("term*", false, "term*");
+    assertWildcardQueryEquals("Term*", false, "Term*");
+    assertWildcardQueryEquals("TERM*", false, "TERM*");
+    // Then 'full' wildcard queries:
+    // by default, convert to lowercase:
+    assertWildcardQueryEquals("Te?m", "te?m");
+    // explicitly set lowercase:
+    assertWildcardQueryEquals("te?m", true, "te?m");
+    assertWildcardQueryEquals("Te?m", true, "te?m");
+    assertWildcardQueryEquals("TE?M", true, "te?m");
+    assertWildcardQueryEquals("Te?m*gerM", true, "te?m*germ");
+    // explicitly disable lowercase conversion:
+    assertWildcardQueryEquals("te?m", false, "te?m");
+    assertWildcardQueryEquals("Te?m", false, "Te?m");
+    assertWildcardQueryEquals("TE?M", false, "TE?M");
+    assertWildcardQueryEquals("Te?m*gerM", false, "Te?m*gerM");
+    // Fuzzy queries:
+    assertWildcardQueryEquals("Term~", "term~2.0");
+    assertWildcardQueryEquals("Term~", true, "term~2.0");
+    assertWildcardQueryEquals("Term~", false, "Term~2.0");
+    // Range queries:
+    assertWildcardQueryEquals("[A TO C]", "[a TO c]");
+    assertWildcardQueryEquals("[A TO C]", true, "[a TO c]");
+    assertWildcardQueryEquals("[A TO C]", false, "[A TO C]");
+  }
+
+  public void testQPA() throws Exception {
+    assertQueryEquals("term term term", qpAnalyzer, "term term term");
+    assertQueryEquals("term +stop term", qpAnalyzer, "term term");
+    assertQueryEquals("term -stop term", qpAnalyzer, "term term");
+    assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
+    assertQueryEquals("term phrase term", qpAnalyzer,
+        "term (phrase1 phrase2) term");
+    // note the parens in this next assertion differ from the original
+    // QueryParser behavior
+    assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
+        "(+term -(phrase1 phrase2)) term");
+    assertQueryEquals("stop", qpAnalyzer, "");
+    assertQueryEquals("stop OR stop AND stop", qpAnalyzer, "");
+    assertTrue(getQuery("term term term", qpAnalyzer) instanceof BooleanQuery);
+    assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
+  }
+
+  public void testRange() throws Exception {
+    assertQueryEquals("[ a TO z]", null, "[a TO z]");
+    assertTrue(getQuery("[ a TO z]", null) instanceof TermRangeQuery);
+    assertQueryEquals("[ a TO z ]", null, "[a TO z]");
+    assertQueryEquals("{ a TO z}", null, "{a TO z}");
+    assertQueryEquals("{ a TO z }", null, "{a TO z}");
+    assertQueryEquals("{ a TO z }^2.0", null, "{a TO z}^2.0");
+    assertQueryEquals("[ a TO z] OR bar", null, "[a TO z] bar");
+    assertQueryEquals("[ a TO z] AND bar", null, "+[a TO z] +bar");
+    assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
+    assertQueryEquals("gack ( bar blar { a TO z}) ", null,
+        "gack (bar blar {a TO z})");
+  }
+
+  private String escapeDateString(String s) {
+    if (s.contains(" ")) {
+      return "\"" + s + "\"";
+    } else {
+      return s;
+    }
+  }
+
+  public String getDate(String s) throws Exception {
+    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
+    return DateTools.dateToString(df.parse(s), DateTools.Resolution.DAY);
+  }
+
+  private String getLocalizedDate(int year, int month, int day,
+      boolean extendLastDate) {
+    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
+    Calendar calendar = new GregorianCalendar();
+    calendar.set(year, month, day);
+    if (extendLastDate) {
+      calendar.set(Calendar.HOUR_OF_DAY, 23);
+      calendar.set(Calendar.MINUTE, 59);
+      calendar.set(Calendar.SECOND, 59);
+      calendar.set(Calendar.MILLISECOND, 999);
+    }
+    return df.format(calendar.getTime());
+  }
+
+  public void testDateRange() throws Exception {
+    String startDate = getLocalizedDate(2002, 1, 1, false);
+    String endDate = getLocalizedDate(2002, 1, 4, false);
+    Calendar endDateExpected = new GregorianCalendar();
+    endDateExpected.set(2002, 1, 4, 23, 59, 59);
+    endDateExpected.set(Calendar.MILLISECOND, 999);
+    final String defaultField = "default";
+    final String monthField = "month";
+    final String hourField = "hour";
+    PrecedenceQueryParser qp = new PrecedenceQueryParser(new MockAnalyzer(random));
+
+    Map<CharSequence, DateTools.Resolution> fieldMap = new HashMap<CharSequence,DateTools.Resolution>();
+    // set a field specific date resolution
+    fieldMap.put(monthField, DateTools.Resolution.MONTH);
+    qp.setDateResolution(fieldMap);
+
+    // set default date resolution to MILLISECOND
+    qp.setDateResolution(DateTools.Resolution.MILLISECOND);
+
+    // set second field specific date resolution
+    fieldMap.put(hourField, DateTools.Resolution.HOUR);
+    qp.setDateResolution(fieldMap);
+
+    // for this field no field specific date resolution has been set,
+    // so verify if the default resolution is used
+    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);
+
+    // verify if field specific date resolutions are used for these two fields
+    assertDateRangeQueryEquals(qp, monthField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.MONTH);
+
+    assertDateRangeQueryEquals(qp, hourField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.HOUR);
+  }
+
+  /** for testing DateTools support */
+  private String getDate(String s, DateTools.Resolution resolution) throws Exception {
+    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
+    return getDate(df.parse(s), resolution);
+  }
+
+  /** for testing DateTools support */
+  private String getDate(Date d, DateTools.Resolution resolution) throws Exception {
+    return DateTools.dateToString(d, resolution);
+  }
+
+  public void assertQueryEquals(PrecedenceQueryParser qp, String field, String query,
+      String result) throws Exception {
+    Query q = qp.parse(query, field);
+    String s = q.toString(field);
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void assertDateRangeQueryEquals(PrecedenceQueryParser qp, String field,
+      String startDate, String endDate, Date endDateInclusive,
+      DateTools.Resolution resolution) throws Exception {
+    assertQueryEquals(qp, field, field + ":[" + escapeDateString(startDate)
+        + " TO " + escapeDateString(endDate) + "]", "["
+        + getDate(startDate, resolution) + " TO "
+        + getDate(endDateInclusive, resolution) + "]");
+    assertQueryEquals(qp, field, field + ":{" + escapeDateString(startDate)
+        + " TO " + escapeDateString(endDate) + "}", "{"
+        + getDate(startDate, resolution) + " TO "
+        + getDate(endDate, resolution) + "}");
+  }
+
+  public void testEscaped() throws Exception {
+    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
+
+    assertQueryEquals("a\\-b:c", a, "a-b:c");
+    assertQueryEquals("a\\+b:c", a, "a+b:c");
+    assertQueryEquals("a\\:b:c", a, "a:b:c");
+    assertQueryEquals("a\\\\b:c", a, "a\\b:c");
+
+    assertQueryEquals("a:b\\-c", a, "a:b-c");
+    assertQueryEquals("a:b\\+c", a, "a:b+c");
+    assertQueryEquals("a:b\\:c", a, "a:b:c");
+    assertQueryEquals("a:b\\\\c", a, "a:b\\c");
+
+    assertQueryEquals("a:b\\-c*", a, "a:b-c*");
+    assertQueryEquals("a:b\\+c*", a, "a:b+c*");
+    assertQueryEquals("a:b\\:c*", a, "a:b:c*");
+
+    assertQueryEquals("a:b\\\\c*", a, "a:b\\c*");
+
+    assertQueryEquals("a:b\\-?c", a, "a:b-?c");
+    assertQueryEquals("a:b\\+?c", a, "a:b+?c");
+    assertQueryEquals("a:b\\:?c", a, "a:b:?c");
+
+    assertQueryEquals("a:b\\\\?c", a, "a:b\\?c");
+
+    assertQueryEquals("a:b\\-c~", a, "a:b-c~2.0");
+    assertQueryEquals("a:b\\+c~", a, "a:b+c~2.0");
+    assertQueryEquals("a:b\\:c~", a, "a:b:c~2.0");
+    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~2.0");
+
+    assertQueryEquals("[ a\\- TO a\\+ ]", null, "[a- TO a+]");
+    assertQueryEquals("[ a\\: TO a\\~ ]", null, "[a: TO a~]");
+    assertQueryEquals("[ a\\\\ TO a\\* ]", null, "[a\\ TO a*]");
+  }
+
+  public void testTabNewlineCarriageReturn() throws Exception {
+    assertQueryEqualsDOA("+weltbank +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \n +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\r+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\r\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r\n +worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r \n +worlbank", null,
+        "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\t+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \t+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \t +worlbank", null, "+weltbank +worlbank");
+  }
+
+  public void testSimpleDAO() throws Exception {
+    assertQueryEqualsDOA("term term term", null, "+term +term +term");
+    assertQueryEqualsDOA("term +term term", null, "+term +term +term");
+    assertQueryEqualsDOA("term term +term", null, "+term +term +term");
+    assertQueryEqualsDOA("term +term +term", null, "+term +term +term");
+    assertQueryEqualsDOA("-term term term", null, "-term +term +term");
+  }
+
+  public void testBoost() throws Exception {
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(BasicAutomata.makeString("on"));
+    Analyzer oneStopAnalyzer = new MockAnalyzer(random, MockTokenizer.SIMPLE, true, stopSet, true);
+
+    PrecedenceQueryParser qp = new PrecedenceQueryParser();
+    qp.setAnalyzer(oneStopAnalyzer);
+    Query q = qp.parse("on^1.0", "field");
+    assertNotNull(q);
+    q = qp.parse("\"hello\"^2.0", "field");
+    assertNotNull(q);
+    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
+    q = qp.parse("hello^2.0", "field");
+    assertNotNull(q);
+    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
+    q = qp.parse("\"on\"^1.0", "field");
+    assertNotNull(q);
+
+    q = getParser(new MockAnalyzer(random, MockTokenizer.SIMPLE, true, MockTokenFilter.ENGLISH_STOPSET, true)).parse("the^3",
+        "field");
+    assertNotNull(q);
+  }
+
+  public void testException() throws Exception {
+    try {
+      assertQueryEquals("\"some phrase", null, "abc");
+      fail("ParseException expected, not thrown");
+    } catch (QueryNodeParseException expected) {
+    }
+  }
+
+  public void testBooleanQuery() throws Exception {
+    BooleanQuery.setMaxClauseCount(2);
+    try {
+      getParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).parse("one two three", "field");
+      fail("ParseException expected due to too many boolean clauses");
+    } catch (QueryNodeException expected) {
+      // too many boolean clauses, so ParseException is expected
+    }
+  }
+  
+  // LUCENE-792
+  public void testNOT() throws Exception {
+    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
+    assertQueryEquals("NOT foo AND bar", a, "-foo +bar");
+  }
+
+  /**
+   * This test differs from the original QueryParser, showing how the precedence
+   * issue has been corrected.
+   */
+  public void testPrecedence() throws Exception {
+    PrecedenceQueryParser parser = getParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
+    Query query1 = parser.parse("A AND B OR C AND D", "field");
+    Query query2 = parser.parse("(A AND B) OR (C AND D)", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A OR B C", "field");
+    query2 = parser.parse("(A B) C", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND B C", "field");
+    query2 = parser.parse("(+A +B) C", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND NOT B", "field");
+    query2 = parser.parse("+A -B", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A OR NOT B", "field");
+    query2 = parser.parse("A -B", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A OR NOT B AND C", "field");
+    query2 = parser.parse("A (-B +C)", "field");
+    assertEquals(query1, query2);
+    
+    parser.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+    query1 = parser.parse("A AND B OR C AND D", "field");
+    query2 = parser.parse("(A AND B) OR (C AND D)", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND B C", "field");
+    query2 = parser.parse("(A B) C", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND B C", "field");
+    query2 = parser.parse("(+A +B) C", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND NOT B", "field");
+    query2 = parser.parse("+A -B", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND NOT B OR C", "field");
+    query2 = parser.parse("(+A -B) OR C", "field");
+    assertEquals(query1, query2);
+    
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    BooleanQuery.setMaxClauseCount(originalMaxClauses);
+    super.tearDown();
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanOrQueryNodeBuilder.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanOrQueryNodeBuilder.java
new file mode 100644
index 0000000..75fcbf4
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanOrQueryNodeBuilder.java
@@ -0,0 +1,56 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryBuilder;
+import org.apache.lucene.search.spans.SpanOrQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+
+/**
+ * This builder creates {@link SpanOrQuery}s from a {@link BooleanQueryNode}.<br/>
+ * <br/>
+ * 
+ * It assumes that the {@link BooleanQueryNode} instance has at least one child.
+ */
+public class SpanOrQueryNodeBuilder implements StandardQueryBuilder {
+
+  public SpanOrQuery build(QueryNode node) throws QueryNodeException {
+
+    // validates node
+    BooleanQueryNode booleanNode = (BooleanQueryNode) node;
+
+    List<QueryNode> children = booleanNode.getChildren();
+    SpanQuery[] spanQueries = new SpanQuery[children.size()];
+
+    int i = 0;
+    for (QueryNode child : children) {
+      spanQueries[i++] = (SpanQuery) child
+          .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+    }
+
+    return new SpanOrQuery(spanQueries);
+
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java
new file mode 100644
index 0000000..6fb7e10
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java
@@ -0,0 +1,41 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryBuilder;
+import org.apache.lucene.search.spans.SpanTermQuery;
+
+/**
+ * This builder creates {@link SpanTermQuery}s from a {@link FieldQueryNode}
+ * object.
+ */
+public class SpanTermQueryNodeBuilder implements StandardQueryBuilder {
+
+  public SpanTermQuery build(QueryNode node) throws QueryNodeException {
+    FieldQueryNode fieldQueryNode = (FieldQueryNode) node;
+
+    return new SpanTermQuery(new Term(fieldQueryNode.getFieldAsString(),
+        fieldQueryNode.getTextAsString()));
+
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryConfigHandler.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryConfigHandler.java
new file mode 100644
index 0000000..96ccd80
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryConfigHandler.java
@@ -0,0 +1,46 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.config.ConfigurationKey;
+import org.apache.lucene.queryparser.flexible.core.config.FieldConfig;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+
+/**
+ * This query config handler only adds the {@link UniqueFieldAttribute} to it.<br/>
+ * <br/>
+ * 
+ * It does not return any configuration for a field in specific.
+ */
+public class SpansQueryConfigHandler extends QueryConfigHandler {
+  
+  final public static ConfigurationKey<String> UNIQUE_FIELD = ConfigurationKey.newInstance();
+  
+  public SpansQueryConfigHandler() {
+    // empty constructor
+  }
+
+  @Override
+  public FieldConfig getFieldConfig(String fieldName) {
+
+    // there is no field configuration, always return null
+    return null;
+
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryTreeBuilder.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryTreeBuilder.java
new file mode 100644
index 0000000..e8711a5
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryTreeBuilder.java
@@ -0,0 +1,52 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryBuilder;
+import org.apache.lucene.search.spans.SpanQuery;
+
+/**
+ * Sets up a query tree builder to build a span query tree from a query node
+ * tree.<br/>
+ * <br/>
+ * 
+ * The defined map is:<br/>
+ * - every BooleanQueryNode instance is delegated to the SpanOrQueryNodeBuilder<br/>
+ * - every FieldQueryNode instance is delegated to the SpanTermQueryNodeBuilder <br/>
+ * 
+ */
+public class SpansQueryTreeBuilder extends QueryTreeBuilder implements
+    StandardQueryBuilder {
+
+  public SpansQueryTreeBuilder() {
+    setBuilder(BooleanQueryNode.class, new SpanOrQueryNodeBuilder());
+    setBuilder(FieldQueryNode.class, new SpanTermQueryNodeBuilder());
+
+  }
+
+  @Override
+  public SpanQuery build(QueryNode queryTree) throws QueryNodeException {
+    return (SpanQuery) super.build(queryTree);
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansValidatorQueryNodeProcessor.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansValidatorQueryNodeProcessor.java
new file mode 100644
index 0000000..3ebc306
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansValidatorQueryNodeProcessor.java
@@ -0,0 +1,72 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+
+/**
+ * Validates every query node in a query node tree. This processor will pass
+ * fine if the query nodes are only {@link BooleanQueryNode}s,
+ * {@link OrQueryNode}s or {@link FieldQueryNode}s, otherwise an exception will
+ * be thrown. <br/>
+ * <br/>
+ * 
+ * If they are {@link AndQueryNode} or an instance of anything else that
+ * implements {@link FieldQueryNode} the exception will also be thrown.
+ */
+public class SpansValidatorQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (!((node instanceof BooleanQueryNode && !(node instanceof AndQueryNode)) || node
+        .getClass() == FieldQueryNode.class)) {
+      throw new QueryNodeException(new MessageImpl(
+          QueryParserMessages.NODE_ACTION_NOT_SUPPORTED));
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java
new file mode 100644
index 0000000..5d5da85
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java
@@ -0,0 +1,230 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline;
+import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
+import org.apache.lucene.queryparser.flexible.standard.processors.WildcardQueryNodeProcessor;
+import org.apache.lucene.search.spans.SpanOrQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.LuceneTestCase;
+
+/**
+ * This test case demonstrates how the new query parser can be used.<br/>
+ * <br/>
+ * 
+ * It tests queries likes "term", "field:term" "term1 term2" "term1 OR term2",
+ * which are all already supported by the current syntax parser (
+ * {@link StandardSyntaxParser}).<br/>
+ * <br/>
+ * 
+ * The goals is to create a new query parser that supports only the pair
+ * "field:term" or a list of pairs separated or not by an OR operator, and from
+ * this query generate {@link SpanQuery} objects instead of the regular
+ * {@link Query} objects. Basically, every pair will be converted to a
+ * {@link SpanTermQuery} object and if there are more than one pair they will be
+ * grouped by an {@link OrQueryNode}.<br/>
+ * <br/>
+ * 
+ * Another functionality that will be added is the ability to convert every
+ * field defined in the query to an unique specific field.<br/>
+ * <br/>
+ * 
+ * The query generation is divided in three different steps: parsing (syntax),
+ * processing (semantic) and building.<br/>
+ * <br/>
+ * 
+ * The parsing phase, as already mentioned will be performed by the current
+ * query parser: {@link StandardSyntaxParser}.<br/>
+ * <br/>
+ * 
+ * The processing phase will be performed by a processor pipeline which is
+ * compound by 2 processors: {@link SpansValidatorQueryNodeProcessor} and
+ * {@link UniqueFieldQueryNodeProcessor}.
+ * 
+ * <pre>
+ * 
+ *   {@link SpansValidatorQueryNodeProcessor}: as it's going to use the current 
+ *   query parser to parse the syntax, it will support more features than we want,
+ *   this processor basically validates the query node tree generated by the parser
+ *   and just let got through the elements we want, all the other elements as 
+ *   wildcards, range queries, etc...if found, an exception is thrown.
+ *   
+ *   {@link UniqueFieldQueryNodeProcessor}: this processor will take care of reading
+ *   what is the &quot;unique field&quot; from the configuration and convert every field defined
+ *   in every pair to this &quot;unique field&quot;. For that, a {@link SpansQueryConfigHandler} is
+ *   used, which has the {@link UniqueFieldAttribute} defined in it.
+ * </pre>
+ * 
+ * The building phase is performed by the {@link SpansQueryTreeBuilder}, which
+ * basically contains a map that defines which builder will be used to generate
+ * {@link SpanQuery} objects from {@link QueryNode} objects.<br/>
+ * <br/>
+ * 
+ * @see SpansQueryConfigHandler
+ * @see SpansQueryTreeBuilder
+ * @see SpansValidatorQueryNodeProcessor
+ * @see SpanOrQueryNodeBuilder
+ * @see SpanTermQueryNodeBuilder
+ * @see StandardSyntaxParser
+ * @see UniqueFieldQueryNodeProcessor
+ * @see UniqueFieldAttribute
+ */
+public class TestSpanQueryParser extends LuceneTestCase {
+
+  private QueryNodeProcessorPipeline spanProcessorPipeline;
+
+  private SpansQueryConfigHandler spanQueryConfigHandler;
+
+  private SpansQueryTreeBuilder spansQueryTreeBuilder;
+
+  private SyntaxParser queryParser = new StandardSyntaxParser();
+
+  public TestSpanQueryParser() {
+    // empty constructor
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+
+    this.spanProcessorPipeline = new QueryNodeProcessorPipeline();
+    this.spanQueryConfigHandler = new SpansQueryConfigHandler();
+    this.spansQueryTreeBuilder = new SpansQueryTreeBuilder();
+
+    // set up the processor pipeline
+    this.spanProcessorPipeline
+        .setQueryConfigHandler(this.spanQueryConfigHandler);
+
+    this.spanProcessorPipeline.add(new WildcardQueryNodeProcessor());
+    this.spanProcessorPipeline.add(new SpansValidatorQueryNodeProcessor());
+    this.spanProcessorPipeline.add(new UniqueFieldQueryNodeProcessor());
+
+  }
+
+  public SpanQuery getSpanQuery(CharSequence query) throws QueryNodeException {
+    return getSpanQuery("", query);
+  }
+
+  public SpanQuery getSpanQuery(String uniqueField, CharSequence query)
+      throws QueryNodeException {
+    
+    this.spanQueryConfigHandler.set(SpansQueryConfigHandler.UNIQUE_FIELD, uniqueField);
+
+    QueryNode queryTree = this.queryParser.parse(query, "defaultField");
+    queryTree = this.spanProcessorPipeline.process(queryTree);
+
+    return this.spansQueryTreeBuilder.build(queryTree);
+
+  }
+
+  public void testTermSpans() throws Exception {
+    assertEquals(getSpanQuery("field:term").toString(), "term");
+    assertEquals(getSpanQuery("term").toString(), "term");
+
+    assertTrue(getSpanQuery("field:term") instanceof SpanTermQuery);
+    assertTrue(getSpanQuery("term") instanceof SpanTermQuery);
+
+  }
+
+  public void testUniqueField() throws Exception {
+    assertEquals(getSpanQuery("field", "term").toString(), "field:term");
+    assertEquals(getSpanQuery("field", "field:term").toString(), "field:term");
+    assertEquals(getSpanQuery("field", "anotherField:term").toString(),
+        "field:term");
+
+  }
+
+  public void testOrSpans() throws Exception {
+    assertEquals(getSpanQuery("term1 term2").toString(),
+        "spanOr([term1, term2])");
+    assertEquals(getSpanQuery("term1 OR term2").toString(),
+        "spanOr([term1, term2])");
+
+    assertTrue(getSpanQuery("term1 term2") instanceof SpanOrQuery);
+    assertTrue(getSpanQuery("term1 term2") instanceof SpanOrQuery);
+
+  }
+
+  public void testQueryValidator() throws QueryNodeException {
+
+    try {
+      getSpanQuery("term*");
+      fail("QueryNodeException was expected, wildcard queries should not be supported");
+
+    } catch (QueryNodeException ex) {
+      // expected exception
+    }
+
+    try {
+      getSpanQuery("[a TO z]");
+      fail("QueryNodeException was expected, range queries should not be supported");
+
+    } catch (QueryNodeException ex) {
+      // expected exception
+    }
+
+    try {
+      getSpanQuery("a~0.5");
+      fail("QueryNodeException was expected, boost queries should not be supported");
+
+    } catch (QueryNodeException ex) {
+      // expected exception
+    }
+
+    try {
+      getSpanQuery("a^0.5");
+      fail("QueryNodeException was expected, fuzzy queries should not be supported");
+
+    } catch (QueryNodeException ex) {
+      // expected exception
+    }
+
+    try {
+      getSpanQuery("\"a b\"");
+      fail("QueryNodeException was expected, quoted queries should not be supported");
+
+    } catch (QueryNodeException ex) {
+      // expected exception
+    }
+
+    try {
+      getSpanQuery("(a b)");
+      fail("QueryNodeException was expected, parenthesized queries should not be supported");
+
+    } catch (QueryNodeException ex) {
+      // expected exception
+    }
+
+    try {
+      getSpanQuery("a AND b");
+      fail("QueryNodeException was expected, and queries should not be supported");
+
+    } catch (QueryNodeException ex) {
+      // expected exception
+    }
+
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java
new file mode 100644
index 0000000..24e7e1c
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java
@@ -0,0 +1,138 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import javax.management.Query;
+
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline;
+import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.util.LuceneTestCase;
+
+/**
+ * This test case demonstrates how the new query parser can be used.<br/>
+ * <br/>
+ * 
+ * It tests queries likes "term", "field:term" "term1 term2" "term1 OR term2",
+ * which are all already supported by the current syntax parser (
+ * {@link StandardSyntaxParser}).<br/>
+ * <br/>
+ * 
+ * The goals is to create a new query parser that supports only the pair
+ * "field:term" or a list of pairs separated or not by an OR operator, and from
+ * this query generate {@link SpanQuery} objects instead of the regular
+ * {@link Query} objects. Basically, every pair will be converted to a
+ * {@link SpanTermQuery} object and if there are more than one pair they will be
+ * grouped by an {@link OrQueryNode}.<br/>
+ * <br/>
+ * 
+ * Another functionality that will be added is the ability to convert every
+ * field defined in the query to an unique specific field.<br/>
+ * <br/>
+ * 
+ * The query generation is divided in three different steps: parsing (syntax),
+ * processing (semantic) and building.<br/>
+ * <br/>
+ * 
+ * The parsing phase, as already mentioned will be performed by the current
+ * query parser: {@link StandardSyntaxParser}.<br/>
+ * <br/>
+ * 
+ * The processing phase will be performed by a processor pipeline which is
+ * compound by 2 processors: {@link SpansValidatorQueryNodeProcessor} and
+ * {@link UniqueFieldQueryNodeProcessor}.
+ * 
+ * <pre>
+ * 
+ *   {@link SpansValidatorQueryNodeProcessor}: as it's going to use the current 
+ *   query parser to parse the syntax, it will support more features than we want,
+ *   this processor basically validates the query node tree generated by the parser
+ *   and just let got through the elements we want, all the other elements as 
+ *   wildcards, range queries, etc...if found, an exception is thrown.
+ *   
+ *   {@link UniqueFieldQueryNodeProcessor}: this processor will take care of reading
+ *   what is the &quot;unique field&quot; from the configuration and convert every field defined
+ *   in every pair to this &quot;unique field&quot;. For that, a {@link SpansQueryConfigHandler} is
+ *   used, which has the {@link UniqueFieldAttribute} defined in it.
+ * </pre>
+ * 
+ * The building phase is performed by the {@link SpansQueryTreeBuilder}, which
+ * basically contains a map that defines which builder will be used to generate
+ * {@link SpanQuery} objects from {@link QueryNode} objects.<br/>
+ * <br/>
+ * 
+ * @see TestSpanQueryParser for a more advanced example
+ * 
+ * @see SpansQueryConfigHandler
+ * @see SpansQueryTreeBuilder
+ * @see SpansValidatorQueryNodeProcessor
+ * @see SpanOrQueryNodeBuilder
+ * @see SpanTermQueryNodeBuilder
+ * @see StandardSyntaxParser
+ * @see UniqueFieldQueryNodeProcessor
+ * @see UniqueFieldAttribute
+ * 
+ */
+public class TestSpanQueryParserSimpleSample extends LuceneTestCase {
+
+  public void testBasicDemo() throws Exception {
+    SyntaxParser queryParser = new StandardSyntaxParser();
+
+    // convert the CharSequence into a QueryNode tree
+    QueryNode queryTree = queryParser.parse("body:text", null);
+
+    // create a config handler with a attribute used in
+    // UniqueFieldQueryNodeProcessor
+    QueryConfigHandler spanQueryConfigHandler = new SpansQueryConfigHandler();
+    spanQueryConfigHandler.set(SpansQueryConfigHandler.UNIQUE_FIELD, "index");
+
+    // set up the processor pipeline with the ConfigHandler
+    // and create the pipeline for this simple demo
+    QueryNodeProcessorPipeline spanProcessorPipeline = new QueryNodeProcessorPipeline(
+        spanQueryConfigHandler);
+    // @see SpansValidatorQueryNodeProcessor
+    spanProcessorPipeline.add(new SpansValidatorQueryNodeProcessor());
+    // @see UniqueFieldQueryNodeProcessor
+    spanProcessorPipeline.add(new UniqueFieldQueryNodeProcessor());
+
+    // print to show out the QueryNode tree before being processed
+    if (VERBOSE) System.out.println(queryTree);
+
+    // Process the QueryTree using our new Processors
+    queryTree = spanProcessorPipeline.process(queryTree);
+
+    // print to show out the QueryNode tree after being processed
+    if (VERBOSE) System.out.println(queryTree);
+
+    // create a instance off the Builder
+    SpansQueryTreeBuilder spansQueryTreeBuilder = new SpansQueryTreeBuilder();
+
+    // convert QueryNode tree to span query Objects
+    SpanQuery spanquery = spansQueryTreeBuilder.build(queryTree);
+
+    assertTrue(spanquery instanceof SpanTermQuery);
+    assertEquals(spanquery.toString(), "index:text");
+
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttribute.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttribute.java
new file mode 100644
index 0000000..c4f873b
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttribute.java
@@ -0,0 +1,35 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.util.Attribute;
+
+/**
+ * This attribute is used by the {@link UniqueFieldQueryNodeProcessor}
+ * processor. It holds a value that defines which is the unique field name that
+ * should be set in every {@link FieldableNode}.<br/>
+ * <br/>
+ * 
+ * @see UniqueFieldQueryNodeProcessor
+ */
+public interface UniqueFieldAttribute extends Attribute {
+  public void setUniqueField(CharSequence uniqueField);
+
+  public CharSequence getUniqueField();
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttributeImpl.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttributeImpl.java
new file mode 100644
index 0000000..50c7571
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttributeImpl.java
@@ -0,0 +1,91 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.util.AttributeImpl;
+
+/**
+ * This attribute is used by the {@link UniqueFieldQueryNodeProcessor}
+ * processor. It holds a value that defines which is the unique field name that
+ * should be set in every {@link FieldableNode}.<br/>
+ * <br/>
+ * 
+ * @see UniqueFieldQueryNodeProcessor
+ */
+public class UniqueFieldAttributeImpl extends AttributeImpl implements
+    UniqueFieldAttribute {
+
+  private CharSequence uniqueField;
+
+  public UniqueFieldAttributeImpl() {
+    clear();
+  }
+
+  @Override
+  public void clear() {
+    this.uniqueField = "";
+  }
+
+  public void setUniqueField(CharSequence uniqueField) {
+    this.uniqueField = uniqueField;
+  }
+
+  public CharSequence getUniqueField() {
+    return this.uniqueField;
+  }
+
+  @Override
+  public void copyTo(AttributeImpl target) {
+
+    if (!(target instanceof UniqueFieldAttributeImpl)) {
+      throw new IllegalArgumentException(
+          "cannot copy the values from attribute UniqueFieldAttribute to an instance of "
+              + target.getClass().getName());
+    }
+
+    UniqueFieldAttributeImpl uniqueFieldAttr = (UniqueFieldAttributeImpl) target;
+    uniqueFieldAttr.uniqueField = uniqueField.toString();
+
+  }
+
+  @Override
+  public boolean equals(Object other) {
+
+    if (other instanceof UniqueFieldAttributeImpl) {
+
+      return ((UniqueFieldAttributeImpl) other).uniqueField
+          .equals(this.uniqueField);
+
+    }
+
+    return false;
+
+  }
+
+  @Override
+  public int hashCode() {
+    return this.uniqueField.hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return "<uniqueField uniqueField='" + this.uniqueField + "'/>";
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldQueryNodeProcessor.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldQueryNodeProcessor.java
new file mode 100644
index 0000000..e4ecba3
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldQueryNodeProcessor.java
@@ -0,0 +1,82 @@
+package org.apache.lucene.queryparser.flexible.spans;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+
+/**
+ * This processor changes every field name of each {@link FieldableNode} query
+ * node contained in the query tree to the field name defined in the
+ * {@link UniqueFieldAttribute}. So, the {@link UniqueFieldAttribute} must be
+ * defined in the {@link QueryConfigHandler} object set in this processor,
+ * otherwise it throws an exception.<br/>
+ * <br/>
+ * 
+ * @see UniqueFieldAttribute
+ */
+public class UniqueFieldQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof FieldableNode) {
+      FieldableNode fieldNode = (FieldableNode) node;
+
+      QueryConfigHandler queryConfig = getQueryConfigHandler();
+
+      if (queryConfig == null) {
+        throw new IllegalArgumentException(
+            "A config handler is expected by the processor UniqueFieldQueryNodeProcessor!");
+      }
+
+      if (!queryConfig.has(SpansQueryConfigHandler.UNIQUE_FIELD)) {
+        throw new IllegalArgumentException(
+            "UniqueFieldAttribute should be defined in the config handler!");
+      }
+
+      String uniqueField = queryConfig.get(SpansQueryConfigHandler.UNIQUE_FIELD);
+      fieldNode.setField(uniqueField);
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiAnalyzerQPHelper.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiAnalyzerQPHelper.java
new file mode 100644
index 0000000..a35ef97
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiAnalyzerQPHelper.java
@@ -0,0 +1,252 @@
+package org.apache.lucene.queryparser.flexible.standard;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.Reader;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.Operator;
+import org.apache.lucene.util.LuceneTestCase;
+
+/**
+ * This test case is a copy of the core Lucene query parser test, it was adapted
+ * to use new QueryParserHelper instead of the old query parser.
+ * 
+ * Test QueryParser's ability to deal with Analyzers that return more than one
+ * token per position or that return tokens with a position increment &gt; 1.
+ */
+public class TestMultiAnalyzerQPHelper extends LuceneTestCase {
+
+  private static int multiToken = 0;
+
+  public void testMultiAnalyzer() throws QueryNodeException {
+
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(new MultiAnalyzer());
+
+    // trivial, no multiple tokens:
+    assertEquals("foo", qp.parse("foo", "").toString());
+    assertEquals("foo", qp.parse("\"foo\"", "").toString());
+    assertEquals("foo foobar", qp.parse("foo foobar", "").toString());
+    assertEquals("\"foo foobar\"", qp.parse("\"foo foobar\"", "").toString());
+    assertEquals("\"foo foobar blah\"", qp.parse("\"foo foobar blah\"", "")
+        .toString());
+
+    // two tokens at the same position:
+    assertEquals("(multi multi2) foo", qp.parse("multi foo", "").toString());
+    assertEquals("foo (multi multi2)", qp.parse("foo multi", "").toString());
+    assertEquals("(multi multi2) (multi multi2)", qp.parse("multi multi", "")
+        .toString());
+    assertEquals("+(foo (multi multi2)) +(bar (multi multi2))", qp.parse(
+        "+(foo multi) +(bar multi)", "").toString());
+    assertEquals("+(foo (multi multi2)) field:\"bar (multi multi2)\"", qp
+        .parse("+(foo multi) field:\"bar multi\"", "").toString());
+
+    // phrases:
+    assertEquals("\"(multi multi2) foo\"", qp.parse("\"multi foo\"", "")
+        .toString());
+    assertEquals("\"foo (multi multi2)\"", qp.parse("\"foo multi\"", "")
+        .toString());
+    assertEquals("\"foo (multi multi2) foobar (multi multi2)\"", qp.parse(
+        "\"foo multi foobar multi\"", "").toString());
+
+    // fields:
+    assertEquals("(field:multi field:multi2) field:foo", qp.parse(
+        "field:multi field:foo", "").toString());
+    assertEquals("field:\"(multi multi2) foo\"", qp.parse(
+        "field:\"multi foo\"", "").toString());
+
+    // three tokens at one position:
+    assertEquals("triplemulti multi3 multi2", qp.parse("triplemulti", "")
+        .toString());
+    assertEquals("foo (triplemulti multi3 multi2) foobar", qp.parse(
+        "foo triplemulti foobar", "").toString());
+
+    // phrase with non-default slop:
+    assertEquals("\"(multi multi2) foo\"~10", qp.parse("\"multi foo\"~10", "")
+        .toString());
+
+    // phrase with non-default boost:
+    assertEquals("\"(multi multi2) foo\"^2.0", qp.parse("\"multi foo\"^2", "")
+        .toString());
+
+    // phrase after changing default slop
+    qp.setDefaultPhraseSlop(99);
+    assertEquals("\"(multi multi2) foo\"~99 bar", qp.parse("\"multi foo\" bar",
+        "").toString());
+    assertEquals("\"(multi multi2) foo\"~99 \"foo bar\"~2", qp.parse(
+        "\"multi foo\" \"foo bar\"~2", "").toString());
+    qp.setDefaultPhraseSlop(0);
+
+    // non-default operator:
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+    assertEquals("+(multi multi2) +foo", qp.parse("multi foo", "").toString());
+
+  }
+
+  // public void testMultiAnalyzerWithSubclassOfQueryParser() throws
+  // ParseException {
+  // this test doesn't make sense when using the new QueryParser API
+  // DumbQueryParser qp = new DumbQueryParser("", new MultiAnalyzer());
+  // qp.setPhraseSlop(99); // modified default slop
+  //
+  // // direct call to (super's) getFieldQuery to demonstrate differnce
+  // // between phrase and multiphrase with modified default slop
+  // assertEquals("\"foo bar\"~99",
+  // qp.getSuperFieldQuery("","foo bar").toString());
+  // assertEquals("\"(multi multi2) bar\"~99",
+  // qp.getSuperFieldQuery("","multi bar").toString());
+  //
+  //    
+  // // ask sublcass to parse phrase with modified default slop
+  // assertEquals("\"(multi multi2) foo\"~99 bar",
+  // qp.parse("\"multi foo\" bar").toString());
+  //    
+  // }
+
+  public void testPosIncrementAnalyzer() throws QueryNodeException {
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(new PosIncrementAnalyzer());
+
+    assertEquals("quick brown", qp.parse("the quick brown", "").toString());
+    assertEquals("\"quick brown\"", qp.parse("\"the quick brown\"", "")
+        .toString());
+    assertEquals("quick brown fox", qp.parse("the quick brown fox", "")
+        .toString());
+    assertEquals("\"quick brown fox\"", qp.parse("\"the quick brown fox\"", "")
+        .toString());
+  }
+
+  /**
+   * Expands "multi" to "multi" and "multi2", both at the same position, and
+   * expands "triplemulti" to "triplemulti", "multi3", and "multi2".
+   */
+  private class MultiAnalyzer extends Analyzer {
+
+    public MultiAnalyzer() {
+    }
+
+    @Override
+    public TokenStream tokenStream(String fieldName, Reader reader) {
+      TokenStream result = new MockTokenizer(reader, MockTokenizer.WHITESPACE, true);
+      result = new TestFilter(result);
+      return result;
+    }
+  }
+
+  private final class TestFilter extends TokenFilter {
+
+    private String prevType;
+    private int prevStartOffset;
+    private int prevEndOffset;
+
+    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+    private final PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);
+    private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
+    private final TypeAttribute typeAtt = addAttribute(TypeAttribute.class);
+
+    public TestFilter(TokenStream in) {
+      super(in);
+    }
+
+    @Override
+    public final boolean incrementToken() throws java.io.IOException {
+      if (multiToken > 0) {
+        termAtt.setEmpty().append("multi" + (multiToken + 1));
+        offsetAtt.setOffset(prevStartOffset, prevEndOffset);
+        typeAtt.setType(prevType);
+        posIncrAtt.setPositionIncrement(0);
+        multiToken--;
+        return true;
+      } else {
+        boolean next = input.incrementToken();
+        if (next == false) {
+          return false;
+        }
+        prevType = typeAtt.type();
+        prevStartOffset = offsetAtt.startOffset();
+        prevEndOffset = offsetAtt.endOffset();
+        String text = termAtt.toString();
+        if (text.equals("triplemulti")) {
+          multiToken = 2;
+          return true;
+        } else if (text.equals("multi")) {
+          multiToken = 1;
+          return true;
+        } else {
+          return true;
+        }
+      }
+    }
+
+  }
+
+  /**
+   * Analyzes "the quick brown" as: quick(incr=2) brown(incr=1). Does not work
+   * correctly for input other than "the quick brown ...".
+   */
+  private class PosIncrementAnalyzer extends Analyzer {
+
+    public PosIncrementAnalyzer() {
+    }
+
+    @Override
+    public TokenStream tokenStream(String fieldName, Reader reader) {
+      TokenStream result = new MockTokenizer(reader, MockTokenizer.WHITESPACE, true);
+      result = new TestPosIncrementFilter(result);
+      return result;
+    }
+  }
+
+  private class TestPosIncrementFilter extends TokenFilter {
+
+    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+    private final PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);
+
+    public TestPosIncrementFilter(TokenStream in) {
+      super(in);
+    }
+
+    @Override
+    public final boolean incrementToken() throws java.io.IOException {
+      while (input.incrementToken()) {
+        if (termAtt.toString().equals("the")) {
+          // stopword, do nothing
+        } else if (termAtt.toString().equals("quick")) {
+          posIncrAtt.setPositionIncrement(2);
+          return true;
+        } else {
+          posIncrAtt.setPositionIncrement(1);
+          return true;
+        }
+      }
+      return false;
+    }
+
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiFieldQPHelper.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiFieldQPHelper.java
new file mode 100644
index 0000000..19cbc7b
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiFieldQPHelper.java
@@ -0,0 +1,368 @@
+package org.apache.lucene.queryparser.flexible.standard;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.Reader;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.Operator;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+/**
+ * This test case is a copy of the core Lucene query parser test, it was adapted
+ * to use new QueryParserHelper instead of the old query parser.
+ * 
+ * Tests QueryParser.
+ */
+public class TestMultiFieldQPHelper extends LuceneTestCase {
+
+  /**
+   * test stop words parsing for both the non static form, and for the
+   * corresponding static form (qtxt, fields[]).
+   */
+  public void testStopwordsParsing() throws Exception {
+    assertStopQueryEquals("one", "b:one t:one");
+    assertStopQueryEquals("one stop", "b:one t:one");
+    assertStopQueryEquals("one (stop)", "b:one t:one");
+    assertStopQueryEquals("one ((stop))", "b:one t:one");
+    assertStopQueryEquals("stop", "");
+    assertStopQueryEquals("(stop)", "");
+    assertStopQueryEquals("((stop))", "");
+  }
+
+  // verify parsing of query using a stopping analyzer
+  private void assertStopQueryEquals(String qtxt, String expectedRes)
+      throws Exception {
+    String[] fields = { "b", "t" };
+    Occur occur[] = { Occur.SHOULD, Occur.SHOULD };
+    TestQPHelper.QPTestAnalyzer a = new TestQPHelper.QPTestAnalyzer();
+    StandardQueryParser mfqp = new StandardQueryParser();
+    mfqp.setMultiFields(fields);
+    mfqp.setAnalyzer(a);
+
+    Query q = mfqp.parse(qtxt, null);
+    assertEquals(expectedRes, q.toString());
+
+    q = QueryParserUtil.parse(qtxt, fields, occur, a);
+    assertEquals(expectedRes, q.toString());
+  }
+
+  public void testSimple() throws Exception {
+    String[] fields = { "b", "t" };
+    StandardQueryParser mfqp = new StandardQueryParser();
+    mfqp.setMultiFields(fields);
+    mfqp.setAnalyzer(new MockAnalyzer(random));
+
+    Query q = mfqp.parse("one", null);
+    assertEquals("b:one t:one", q.toString());
+
+    q = mfqp.parse("one two", null);
+    assertEquals("(b:one t:one) (b:two t:two)", q.toString());
+
+    q = mfqp.parse("+one +two", null);
+    assertEquals("+(b:one t:one) +(b:two t:two)", q.toString());
+
+    q = mfqp.parse("+one -two -three", null);
+    assertEquals("+(b:one t:one) -(b:two t:two) -(b:three t:three)", q
+        .toString());
+
+    q = mfqp.parse("one^2 two", null);
+    assertEquals("((b:one t:one)^2.0) (b:two t:two)", q.toString());
+
+    q = mfqp.parse("one~ two", null);
+    assertEquals("(b:one~2.0 t:one~2.0) (b:two t:two)", q.toString());
+
+    q = mfqp.parse("one~0.8 two^2", null);
+    assertEquals("(b:one~0.8 t:one~0.8) ((b:two t:two)^2.0)", q.toString());
+
+    q = mfqp.parse("one* two*", null);
+    assertEquals("(b:one* t:one*) (b:two* t:two*)", q.toString());
+
+    q = mfqp.parse("[a TO c] two", null);
+    assertEquals("(b:[a TO c] t:[a TO c]) (b:two t:two)", q.toString());
+
+    q = mfqp.parse("w?ldcard", null);
+    assertEquals("b:w?ldcard t:w?ldcard", q.toString());
+
+    q = mfqp.parse("\"foo bar\"", null);
+    assertEquals("b:\"foo bar\" t:\"foo bar\"", q.toString());
+
+    q = mfqp.parse("\"aa bb cc\" \"dd ee\"", null);
+    assertEquals("(b:\"aa bb cc\" t:\"aa bb cc\") (b:\"dd ee\" t:\"dd ee\")", q
+        .toString());
+
+    q = mfqp.parse("\"foo bar\"~4", null);
+    assertEquals("b:\"foo bar\"~4 t:\"foo bar\"~4", q.toString());
+
+    // LUCENE-1213: QueryParser was ignoring slop when phrase
+    // had a field.
+    q = mfqp.parse("b:\"foo bar\"~4", null);
+    assertEquals("b:\"foo bar\"~4", q.toString());
+
+    // make sure that terms which have a field are not touched:
+    q = mfqp.parse("one f:two", null);
+    assertEquals("(b:one t:one) f:two", q.toString());
+
+    // AND mode:
+    mfqp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+    q = mfqp.parse("one two", null);
+    assertEquals("+(b:one t:one) +(b:two t:two)", q.toString());
+    q = mfqp.parse("\"aa bb cc\" \"dd ee\"", null);
+    assertEquals("+(b:\"aa bb cc\" t:\"aa bb cc\") +(b:\"dd ee\" t:\"dd ee\")",
+        q.toString());
+
+  }
+
+  public void testBoostsSimple() throws Exception {
+    Map<String,Float> boosts = new HashMap<String,Float>();
+    boosts.put("b", Float.valueOf(5));
+    boosts.put("t", Float.valueOf(10));
+    String[] fields = { "b", "t" };
+    StandardQueryParser mfqp = new StandardQueryParser();
+    mfqp.setMultiFields(fields);
+    mfqp.setFieldsBoost(boosts);
+    mfqp.setAnalyzer(new MockAnalyzer(random));
+
+    // Check for simple
+    Query q = mfqp.parse("one", null);
+    assertEquals("b:one^5.0 t:one^10.0", q.toString());
+
+    // Check for AND
+    q = mfqp.parse("one AND two", null);
+    assertEquals("+(b:one^5.0 t:one^10.0) +(b:two^5.0 t:two^10.0)", q
+        .toString());
+
+    // Check for OR
+    q = mfqp.parse("one OR two", null);
+    assertEquals("(b:one^5.0 t:one^10.0) (b:two^5.0 t:two^10.0)", q.toString());
+
+    // Check for AND and a field
+    q = mfqp.parse("one AND two AND foo:test", null);
+    assertEquals("+(b:one^5.0 t:one^10.0) +(b:two^5.0 t:two^10.0) +foo:test", q
+        .toString());
+
+    q = mfqp.parse("one^3 AND two^4", null);
+    assertEquals("+((b:one^5.0 t:one^10.0)^3.0) +((b:two^5.0 t:two^10.0)^4.0)",
+        q.toString());
+  }
+
+  public void testStaticMethod1() throws QueryNodeException {
+    String[] fields = { "b", "t" };
+    String[] queries = { "one", "two" };
+    Query q = QueryParserUtil.parse(queries, fields, new MockAnalyzer(random));
+    assertEquals("b:one t:two", q.toString());
+
+    String[] queries2 = { "+one", "+two" };
+    q = QueryParserUtil.parse(queries2, fields, new MockAnalyzer(random));
+    assertEquals("(+b:one) (+t:two)", q.toString());
+
+    String[] queries3 = { "one", "+two" };
+    q = QueryParserUtil.parse(queries3, fields, new MockAnalyzer(random));
+    assertEquals("b:one (+t:two)", q.toString());
+
+    String[] queries4 = { "one +more", "+two" };
+    q = QueryParserUtil.parse(queries4, fields, new MockAnalyzer(random));
+    assertEquals("(b:one +b:more) (+t:two)", q.toString());
+
+    String[] queries5 = { "blah" };
+    try {
+      q = QueryParserUtil.parse(queries5, fields, new MockAnalyzer(random));
+      fail();
+    } catch (IllegalArgumentException e) {
+      // expected exception, array length differs
+    }
+
+    // check also with stop words for this static form (qtxts[], fields[]).
+    TestQPHelper.QPTestAnalyzer stopA = new TestQPHelper.QPTestAnalyzer();
+
+    String[] queries6 = { "((+stop))", "+((stop))" };
+    q = QueryParserUtil.parse(queries6, fields, stopA);
+    assertEquals("", q.toString());
+
+    String[] queries7 = { "one ((+stop)) +more", "+((stop)) +two" };
+    q = QueryParserUtil.parse(queries7, fields, stopA);
+    assertEquals("(b:one +b:more) (+t:two)", q.toString());
+
+  }
+
+  public void testStaticMethod2() throws QueryNodeException {
+    String[] fields = { "b", "t" };
+    BooleanClause.Occur[] flags = { BooleanClause.Occur.MUST,
+        BooleanClause.Occur.MUST_NOT };
+    Query q = QueryParserUtil.parse("one", fields, flags,
+        new MockAnalyzer(random));
+    assertEquals("+b:one -t:one", q.toString());
+
+    q = QueryParserUtil.parse("one two", fields, flags, new MockAnalyzer(random));
+    assertEquals("+(b:one b:two) -(t:one t:two)", q.toString());
+
+    try {
+      BooleanClause.Occur[] flags2 = { BooleanClause.Occur.MUST };
+      q = QueryParserUtil.parse("blah", fields, flags2, new MockAnalyzer(random));
+      fail();
+    } catch (IllegalArgumentException e) {
+      // expected exception, array length differs
+    }
+  }
+
+  public void testStaticMethod2Old() throws QueryNodeException {
+    String[] fields = { "b", "t" };
+    BooleanClause.Occur[] flags = { BooleanClause.Occur.MUST,
+        BooleanClause.Occur.MUST_NOT };
+    StandardQueryParser parser = new StandardQueryParser();
+    parser.setMultiFields(fields);
+    parser.setAnalyzer(new MockAnalyzer(random));
+
+    Query q = QueryParserUtil.parse("one", fields, flags,
+        new MockAnalyzer(random));// , fields, flags, new
+    // MockAnalyzer());
+    assertEquals("+b:one -t:one", q.toString());
+
+    q = QueryParserUtil.parse("one two", fields, flags, new MockAnalyzer(random));
+    assertEquals("+(b:one b:two) -(t:one t:two)", q.toString());
+
+    try {
+      BooleanClause.Occur[] flags2 = { BooleanClause.Occur.MUST };
+      q = QueryParserUtil.parse("blah", fields, flags2, new MockAnalyzer(random));
+      fail();
+    } catch (IllegalArgumentException e) {
+      // expected exception, array length differs
+    }
+  }
+
+  public void testStaticMethod3() throws QueryNodeException {
+    String[] queries = { "one", "two", "three" };
+    String[] fields = { "f1", "f2", "f3" };
+    BooleanClause.Occur[] flags = { BooleanClause.Occur.MUST,
+        BooleanClause.Occur.MUST_NOT, BooleanClause.Occur.SHOULD };
+    Query q = QueryParserUtil.parse(queries, fields, flags,
+        new MockAnalyzer(random));
+    assertEquals("+f1:one -f2:two f3:three", q.toString());
+
+    try {
+      BooleanClause.Occur[] flags2 = { BooleanClause.Occur.MUST };
+      q = QueryParserUtil
+          .parse(queries, fields, flags2, new MockAnalyzer(random));
+      fail();
+    } catch (IllegalArgumentException e) {
+      // expected exception, array length differs
+    }
+  }
+
+  public void testStaticMethod3Old() throws QueryNodeException {
+    String[] queries = { "one", "two" };
+    String[] fields = { "b", "t" };
+    BooleanClause.Occur[] flags = { BooleanClause.Occur.MUST,
+        BooleanClause.Occur.MUST_NOT };
+    Query q = QueryParserUtil.parse(queries, fields, flags,
+        new MockAnalyzer(random));
+    assertEquals("+b:one -t:two", q.toString());
+
+    try {
+      BooleanClause.Occur[] flags2 = { BooleanClause.Occur.MUST };
+      q = QueryParserUtil
+          .parse(queries, fields, flags2, new MockAnalyzer(random));
+      fail();
+    } catch (IllegalArgumentException e) {
+      // expected exception, array length differs
+    }
+  }
+
+  public void testAnalyzerReturningNull() throws QueryNodeException {
+    String[] fields = new String[] { "f1", "f2", "f3" };
+    StandardQueryParser parser = new StandardQueryParser();
+    parser.setMultiFields(fields);
+    parser.setAnalyzer(new AnalyzerReturningNull());
+
+    Query q = parser.parse("bla AND blo", null);
+    assertEquals("+(f2:bla f3:bla) +(f2:blo f3:blo)", q.toString());
+    // the following queries are not affected as their terms are not
+    // analyzed anyway:
+    q = parser.parse("bla*", null);
+    assertEquals("f1:bla* f2:bla* f3:bla*", q.toString());
+    q = parser.parse("bla~", null);
+    assertEquals("f1:bla~2.0 f2:bla~2.0 f3:bla~2.0", q.toString());
+    q = parser.parse("[a TO c]", null);
+    assertEquals("f1:[a TO c] f2:[a TO c] f3:[a TO c]", q.toString());
+  }
+
+  public void testStopWordSearching() throws Exception {
+    Analyzer analyzer = new MockAnalyzer(random);
+    Directory ramDir = newDirectory();
+    IndexWriter iw = new IndexWriter(ramDir, newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer));
+    Document doc = new Document();
+    doc.add(newField("body", "blah the footest blah", Field.Store.NO,
+        Field.Index.ANALYZED));
+    iw.addDocument(doc);
+    iw.close();
+
+    StandardQueryParser mfqp = new StandardQueryParser();
+
+    mfqp.setMultiFields(new String[] { "body" });
+    mfqp.setAnalyzer(analyzer);
+    mfqp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+    Query q = mfqp.parse("the footest", null);
+    IndexSearcher is = new IndexSearcher(ramDir, true);
+    ScoreDoc[] hits = is.search(q, null, 1000).scoreDocs;
+    assertEquals(1, hits.length);
+    is.close();
+    ramDir.close();
+  }
+
+  /**
+   * Return empty tokens for field "f1".
+   */
+  private static final class AnalyzerReturningNull extends Analyzer {
+    MockAnalyzer stdAnalyzer = new MockAnalyzer(random);
+
+    public AnalyzerReturningNull() {
+    }
+
+    @Override
+    public TokenStream tokenStream(String fieldName, Reader reader) {
+      if ("f1".equals(fieldName)) {
+        return new EmptyTokenStream();
+      } else {
+        return stdAnalyzer.tokenStream(fieldName, reader);
+      }
+    }
+
+    private static class EmptyTokenStream extends TokenStream {
+      @Override
+      public boolean incrementToken() {
+        return false;
+      }
+    }
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java
new file mode 100644
index 0000000..bb2cd67
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java
@@ -0,0 +1,428 @@
+package org.apache.lucene.queryparser.flexible.standard;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.text.DateFormat;
+import java.text.NumberFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Random;
+import java.util.TimeZone;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.NumericField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat;
+import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
+import org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util._TestUtil;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Ignore;
+import org.junit.Test;
+
+@Ignore("Class has problems with DateFormat")
+public class TestNumericQueryParser extends LuceneTestCase {
+  
+  private static enum NumberType {
+    NEGATIVE, ZERO, POSITIVE;
+  }
+  
+  final private static int[] DATE_STYLES = {DateFormat.FULL, DateFormat.LONG,
+      DateFormat.MEDIUM, DateFormat.SHORT};
+  
+  final private static int PRECISION_STEP = 8;
+  final private static String FIELD_NAME = "field";
+  private static Locale LOCALE;
+  private static TimeZone TIMEZONE;
+  private static Map<String,Number> RANDOM_NUMBER_MAP;
+  final private static EscapeQuerySyntax ESCAPER = new EscapeQuerySyntaxImpl();
+  final private static String DATE_FIELD_NAME = "date";
+  private static int DATE_STYLE;
+  private static int TIME_STYLE;
+  
+  private static Analyzer ANALYZER;
+  
+  private static NumberFormat NUMBER_FORMAT;
+  
+  private static StandardQueryParser qp;
+  
+  private static NumberDateFormat DATE_FORMAT;
+  
+  static void init() {
+    try {
+      LOCALE = randomLocale(random);
+      TIMEZONE = randomTimeZone(random);
+      DATE_STYLE = randomDateStyle(random);
+      TIME_STYLE = randomDateStyle(random);
+      ANALYZER = new MockAnalyzer(random);
+      qp = new StandardQueryParser(ANALYZER);
+      NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);
+      NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);
+      NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);
+      NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);
+      NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 4); // the loop checks for < 1000, this is a must!
+      
+      // assumes localized date pattern will have at least year, month, day, hour, minute
+      SimpleDateFormat dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(
+          DATE_STYLE, TIME_STYLE, LOCALE);
+      
+      // not all date patterns includes era, full year, timezone and second, so we add them here
+      dateFormat.applyPattern(dateFormat.toPattern() + " G s Z yyyy");
+      dateFormat.setTimeZone(TIMEZONE);
+      DATE_FORMAT  = new NumberDateFormat(dateFormat);
+      
+      HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();
+      
+      double randomDouble;
+      long randomLong;
+      int randomInt;
+      float randomFloat;
+      long randomDate;
+      
+      while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))
+          .longValue()) == 0)
+        ;
+      while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))
+          .doubleValue()) == 0)
+        ;
+      while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))
+          .floatValue()) == 0)
+        ;
+      while ((randomInt = normalizeNumber(Math.abs(random.nextInt()))
+          .intValue()) == 0)
+        ;
+      
+      // make sure random date is at least one second from 0
+      while ((randomDate = normalizeNumber(Math.abs(random.nextLong()))
+          .longValue()) < 1000)
+        ;
+
+      // prune date value so it doesn't pass in insane values to some calendars.
+      randomDate = randomDate % 3400000000000l;
+
+      // truncate to second
+      randomDate = (randomDate / 1000) * 1000;
+      
+      randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);
+      randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);
+      randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);
+      randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);
+      randomNumberMap.put(DATE_FIELD_NAME, randomDate);
+      
+      RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);
+      
+    } catch (ParseException e) {
+      throw new RuntimeException(e);
+    }
+  }
+  
+  private static Directory directory = null;
+  private static IndexReader reader = null;
+  private static IndexSearcher searcher = null;
+  
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    init();
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random, directory,
+        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))
+            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))
+            .setMergePolicy(newLogMergePolicy()));
+    
+    Document doc = new Document();
+    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();
+    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();
+    qp.setNumericConfigMap(numericConfigMap);
+    
+    for (NumericField.DataType type : NumericField.DataType.values()) {
+      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,
+          NUMBER_FORMAT, type));
+      
+      NumericField field = new NumericField(type.name(), PRECISION_STEP,
+          Field.Store.YES, true);
+      
+      numericFieldMap.put(type.name(), field);
+      doc.add(field);
+      
+    }
+    
+    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,
+        DATE_FORMAT, NumericField.DataType.LONG));
+    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,
+        Field.Store.YES, true);
+    numericFieldMap.put(DATE_FIELD_NAME, dateField);
+    doc.add(dateField);
+    
+    for (NumberType numberType : NumberType.values()) {
+      setFieldValues(numberType, numericFieldMap);
+      if (VERBOSE) System.out.println("Indexing document: " + doc);
+      writer.addDocument(doc);
+    }
+    
+    reader = writer.getReader();
+    searcher = newSearcher(reader);
+    writer.close();
+    
+
+//  SimpleDateFormat df = new SimpleDateFormat( 
+//      "yyyy.MM.dd G 'at' HH:mm:ss z", LOCALE.ENGLISH);
+// assumes localized date pattern will have at least year, month, day, hour, minute
+  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(
+      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);
+  System.out.println(df.toPattern());
+  // most of date pattern do not include era, so we add it here. Also,
+  // sometimes second is not available, we make sure it's present too
+  df.applyPattern(df.toPattern() + " G s Z yyyy");
+  df.setTimeZone(TIMEZONE);
+  System.out.println(TIMEZONE);
+  System.out.println(TIMEZONE);
+  System.out.println(TIMEZONE);
+  long l1 = 0;
+  long l2 = -30000;
+  String d1 = df.format(new Date(l1));
+  String d2 = df.format(new Date(l2));
+  long newL1 = df.parse(d1).getTime();
+  long newL2 = df.parse(d2).getTime();
+  
+  System.out.println(l1 + " => " + d1 + " => " + newL1);
+  System.out.println(l2 + " => " + d2 + " => " + newL2);
+  
+   
+  }
+  
+  private static Number getNumberType(NumberType numberType, String fieldName) {
+    
+    switch (numberType) {
+      
+      case POSITIVE:
+        return RANDOM_NUMBER_MAP.get(fieldName);
+        
+      case NEGATIVE:
+        Number number = RANDOM_NUMBER_MAP.get(fieldName);
+        
+        if (NumericField.DataType.LONG.name().equals(fieldName)
+            || DATE_FIELD_NAME.equals(fieldName)) {
+          number = -number.longValue();
+          
+        } else if (NumericField.DataType.DOUBLE.name().equals(fieldName)) {
+          number = -number.doubleValue();
+          
+        } else if (NumericField.DataType.FLOAT.name().equals(fieldName)) {
+          number = -number.floatValue();
+          
+        } else if (NumericField.DataType.INT.name().equals(fieldName)) {
+          number = -number.intValue();
+          
+        } else {
+          throw new IllegalArgumentException("field name not found: "
+              + fieldName);
+        }
+        
+        return number;
+        
+      default:
+        return 0;
+    }
+    
+  }
+  
+  private static void setFieldValues(NumberType numberType,
+      HashMap<String,NumericField> numericFieldMap) {
+    
+    Number number = getNumberType(numberType, NumericField.DataType.DOUBLE
+        .name());
+    numericFieldMap.get(NumericField.DataType.DOUBLE.name()).setDoubleValue(
+        number.doubleValue());
+    
+    number = getNumberType(numberType, NumericField.DataType.INT.name());
+    numericFieldMap.get(NumericField.DataType.INT.name()).setIntValue(
+        number.intValue());
+    
+    number = getNumberType(numberType, NumericField.DataType.LONG.name());
+    numericFieldMap.get(NumericField.DataType.LONG.name()).setLongValue(
+        number.longValue());
+    
+    number = getNumberType(numberType, NumericField.DataType.FLOAT.name());
+    numericFieldMap.get(NumericField.DataType.FLOAT.name()).setFloatValue(
+        number.floatValue());
+    
+    number = getNumberType(numberType, DATE_FIELD_NAME);
+    numericFieldMap.get(DATE_FIELD_NAME).setLongValue(number.longValue());
+    
+  }
+  
+  private static int randomDateStyle(Random random) {
+    return DATE_STYLES[random.nextInt(DATE_STYLES.length)];
+  }
+  
+  @Test
+  public void testInclusiveNumericRange() throws Exception {
+    assertRangeQuery(NumberType.ZERO, NumberType.ZERO, true, true, 1);
+    assertRangeQuery(NumberType.ZERO, NumberType.POSITIVE, true, true, 2);
+    assertRangeQuery(NumberType.NEGATIVE, NumberType.ZERO, true, true, 2);
+    assertRangeQuery(NumberType.NEGATIVE, NumberType.POSITIVE, true, true, 3);
+    assertRangeQuery(NumberType.NEGATIVE, NumberType.NEGATIVE, true, true, 1);
+  }
+  
+  // @Test
+  // test disabled since standard syntax parser does not work with inclusive and
+  // exclusive at the same time
+//   public void testInclusiveLowerNumericRange() throws Exception {
+//   assertRangeQuery(NumberType.NEGATIVE, NumberType.ZERO, true, false, 1);
+//   assertRangeQuery(NumberType.ZERO, NumberType.POSITIVE, true, false, 1);
+//   assertRangeQuery(NumberType.NEGATIVE, NumberType.POSITIVE, true, false, 2);
+//   assertRangeQuery(NumberType.NEGATIVE, NumberType.NEGATIVE, true, false, 1);
+//   }
+  
+  // @Test
+  // test disabled since standard syntax parser does not work with inclusive and
+  // exclusive at the same time
+//   public void testInclusiveUpperNumericRange() throws Exception {
+//     assertRangeQuery(NumberType.NEGATIVE, NumberType.ZERO, false, true, 1);
+//     assertRangeQuery(NumberType.ZERO, NumberType.POSITIVE, false, true, 1);
+//     assertRangeQuery(NumberType.NEGATIVE, NumberType.POSITIVE, false, true, 2);
+//     assertRangeQuery(NumberType.NEGATIVE, NumberType.NEGATIVE, false, true, 1);
+//   }
+  
+  @Test
+  public void testExclusiveNumericRange() throws Exception {
+    assertRangeQuery(NumberType.ZERO, NumberType.ZERO, false, false, 0);
+    assertRangeQuery(NumberType.ZERO, NumberType.POSITIVE, false, false, 0);
+    assertRangeQuery(NumberType.NEGATIVE, NumberType.ZERO, false, false, 0);
+    assertRangeQuery(NumberType.NEGATIVE, NumberType.POSITIVE, false, false, 1);
+    assertRangeQuery(NumberType.NEGATIVE, NumberType.NEGATIVE, false, false, 0);
+  }
+  
+  @Test
+  public void testSimpleNumericQuery() throws Exception {
+    assertSimpleQuery(NumberType.ZERO, 1);
+    assertSimpleQuery(NumberType.POSITIVE, 1);
+    assertSimpleQuery(NumberType.NEGATIVE, 1);
+  }
+  
+  public void assertRangeQuery(NumberType lowerType, NumberType upperType,
+      boolean upperInclusive, boolean lowerInclusive, int expectedDocCount)
+      throws QueryNodeException, IOException {
+    
+    StringBuilder sb = new StringBuilder();
+    
+    String lowerInclusiveStr = (lowerInclusive ? "[" : "{");
+    String upperInclusiveStr = (upperInclusive ? "]" : "}");
+    
+    for (NumericField.DataType type : NumericField.DataType.values()) {
+      String lowerStr = numberToString(getNumberType(lowerType, type.name()));
+      String upperStr = numberToString(getNumberType(upperType, type.name()));
+      
+      sb.append("+").append(type.name()).append(':').append(lowerInclusiveStr)
+          .append('"').append(lowerStr).append("\" TO \"").append(upperStr)
+          .append('"').append(upperInclusiveStr).append(' ');
+    }
+    
+    String lowerDateStr = ESCAPER.escape(
+        DATE_FORMAT.format(new Date(getNumberType(lowerType, DATE_FIELD_NAME)
+            .longValue())), LOCALE, EscapeQuerySyntax.Type.STRING).toString();
+    
+    String upperDateStr = ESCAPER.escape(
+        DATE_FORMAT.format(new Date(getNumberType(upperType, DATE_FIELD_NAME)
+            .longValue())), LOCALE, EscapeQuerySyntax.Type.STRING).toString();
+    
+    sb.append("+").append(DATE_FIELD_NAME).append(':')
+        .append(lowerInclusiveStr).append('"').append(lowerDateStr).append(
+            "\" TO \"").append(upperDateStr).append('"').append(
+            upperInclusiveStr);
+    
+    testQuery(sb.toString(), expectedDocCount);
+    
+  }
+  
+  public void assertSimpleQuery(NumberType numberType, int expectedDocCount)
+      throws QueryNodeException, IOException {
+    StringBuilder sb = new StringBuilder();
+    
+    for (NumericField.DataType type : NumericField.DataType.values()) {
+      String numberStr = numberToString(getNumberType(numberType, type.name()));
+      sb.append('+').append(type.name()).append(":\"").append(numberStr)
+          .append("\" ");
+    }
+    
+    String dateStr = ESCAPER.escape(
+        DATE_FORMAT.format(new Date(getNumberType(numberType, DATE_FIELD_NAME)
+            .longValue())), LOCALE, EscapeQuerySyntax.Type.STRING).toString();
+    
+    sb.append('+').append(DATE_FIELD_NAME).append(":\"").append(dateStr)
+        .append('"');
+    
+    testQuery(sb.toString(), expectedDocCount);
+    
+  }
+  
+  private void testQuery(String queryStr, int expectedDocCount)
+      throws QueryNodeException, IOException {
+    if (VERBOSE) System.out.println("Parsing: " + queryStr);
+    
+    Query query = qp.parse(queryStr, FIELD_NAME);
+    if (VERBOSE) System.out.println("Querying: " + query);
+    TopDocs topDocs = searcher.search(query, 1000);
+    
+    String msg = "Query <" + queryStr + "> retrieved " + topDocs.totalHits
+        + " document(s), " + expectedDocCount + " document(s) expected.";
+    
+    if (VERBOSE) System.out.println(msg);
+    
+    assertEquals(msg, expectedDocCount, topDocs.totalHits);
+    
+  }
+  
+  private static String numberToString(Number number) {
+    return ESCAPER.escape(NUMBER_FORMAT.format(number), LOCALE,
+        EscapeQuerySyntax.Type.STRING).toString();
+  }
+  
+  private static Number normalizeNumber(Number number) throws ParseException {
+    return NUMBER_FORMAT.parse(NUMBER_FORMAT.format(number));
+  }
+  
+  @AfterClass
+  public static void afterClass() throws Exception {
+    searcher.close();
+    searcher = null;
+    reader.close();
+    reader = null;
+    directory.close();
+    directory = null;
+  }
+  
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestQPHelper.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestQPHelper.java
new file mode 100644
index 0000000..9f6f753
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestQPHelper.java
@@ -0,0 +1,1242 @@
+package org.apache.lucene.queryparser.flexible.standard;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.Reader;
+import java.text.DateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenFilter;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RegexpQuery;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.CharacterRunAutomaton;
+import org.apache.lucene.util.automaton.RegExp;
+import org.junit.Ignore;
+
+/**
+ * This test case is a copy of the core Lucene query parser test, it was adapted
+ * to use new QueryParserHelper instead of the old query parser.
+ * 
+ * Tests QueryParser.
+ */
+public class TestQPHelper extends LuceneTestCase {
+
+  public static Analyzer qpAnalyzer = new QPTestAnalyzer();
+
+  public static final class QPTestFilter extends TokenFilter {
+    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+    private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
+
+    /**
+     * Filter which discards the token 'stop' and which expands the token
+     * 'phrase' into 'phrase1 phrase2'
+     */
+    public QPTestFilter(TokenStream in) {
+      super(in);
+    }
+
+    boolean inPhrase = false;
+    int savedStart = 0, savedEnd = 0;
+
+    @Override
+    public boolean incrementToken() throws IOException {
+      if (inPhrase) {
+        inPhrase = false;
+        clearAttributes();
+        termAtt.setEmpty().append("phrase2");
+        offsetAtt.setOffset(savedStart, savedEnd);
+        return true;
+      } else
+        while (input.incrementToken()) {
+          if (termAtt.toString().equals("phrase")) {
+            inPhrase = true;
+            savedStart = offsetAtt.startOffset();
+            savedEnd = offsetAtt.endOffset();
+            termAtt.setEmpty().append("phrase1");
+            offsetAtt.setOffset(savedStart, savedEnd);
+            return true;
+          } else if (!termAtt.toString().equals("stop"))
+            return true;
+        }
+      return false;
+    }
+  }
+
+  public static final class QPTestAnalyzer extends Analyzer {
+
+    /** Filters MockTokenizer with StopFilter. */
+    @Override
+    public final TokenStream tokenStream(String fieldName, Reader reader) {
+      return new QPTestFilter(new MockTokenizer(reader, MockTokenizer.SIMPLE, true));
+    }
+  }
+
+  public static class QPTestParser extends StandardQueryParser {
+    public QPTestParser(Analyzer a) {
+      ((QueryNodeProcessorPipeline)getQueryNodeProcessor())
+          .add(new QPTestParserQueryNodeProcessor());
+      this.setAnalyzer(a);
+
+    }
+
+    private static class QPTestParserQueryNodeProcessor extends
+        QueryNodeProcessorImpl {
+
+      @Override
+      protected QueryNode postProcessNode(QueryNode node)
+          throws QueryNodeException {
+
+        return node;
+
+      }
+
+      @Override
+      protected QueryNode preProcessNode(QueryNode node)
+          throws QueryNodeException {
+
+        if (node instanceof WildcardQueryNode || node instanceof FuzzyQueryNode) {
+
+          throw new QueryNodeException(new MessageImpl(
+              QueryParserMessages.EMPTY_MESSAGE));
+
+        }
+
+        return node;
+
+      }
+
+      @Override
+      protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+          throws QueryNodeException {
+
+        return children;
+
+      }
+
+    }
+
+  }
+
+  private int originalMaxClauses;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    originalMaxClauses = BooleanQuery.getMaxClauseCount();
+  }
+
+  public StandardQueryParser getParser(Analyzer a) throws Exception {
+    if (a == null)
+      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(a);
+
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
+
+    return qp;
+
+  }
+
+  public Query getQuery(String query, Analyzer a) throws Exception {
+    return getParser(a).parse(query, "field");
+  }
+
+  public Query getQueryAllowLeadingWildcard(String query, Analyzer a) throws Exception {
+    StandardQueryParser parser = getParser(a);
+    parser.setAllowLeadingWildcard(true);
+    return parser.parse(query, "field");
+  }
+
+  public void assertQueryEquals(String query, Analyzer a, String result)
+      throws Exception {
+    Query q = getQuery(query, a);
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void assertQueryEqualsAllowLeadingWildcard(String query, Analyzer a, String result)
+      throws Exception {
+    Query q = getQueryAllowLeadingWildcard(query, a);
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void assertQueryEquals(StandardQueryParser qp, String field,
+      String query, String result) throws Exception {
+    Query q = qp.parse(query, field);
+    String s = q.toString(field);
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void assertEscapedQueryEquals(String query, Analyzer a, String result)
+      throws Exception {
+    String escapedQuery = QueryParserUtil.escape(query);
+    if (!escapedQuery.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + escapedQuery + "/, expecting /"
+          + result + "/");
+    }
+  }
+
+  public void assertWildcardQueryEquals(String query, boolean lowercase,
+      String result, boolean allowLeadingWildcard) throws Exception {
+    StandardQueryParser qp = getParser(null);
+    qp.setLowercaseExpandedTerms(lowercase);
+    qp.setAllowLeadingWildcard(allowLeadingWildcard);
+    Query q = qp.parse(query, "field");
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
+          + result + "/");
+    }
+  }
+
+  public void assertWildcardQueryEquals(String query, boolean lowercase,
+      String result) throws Exception {
+    assertWildcardQueryEquals(query, lowercase, result, false);
+  }
+
+  public void assertWildcardQueryEquals(String query, String result)
+      throws Exception {
+    StandardQueryParser qp = getParser(null);
+    Query q = qp.parse(query, "field");
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
+          + result + "/");
+    }
+  }
+
+  public Query getQueryDOA(String query, Analyzer a) throws Exception {
+    if (a == null)
+      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(a);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+
+    return qp.parse(query, "field");
+
+  }
+
+  public void assertQueryEqualsDOA(String query, Analyzer a, String result)
+      throws Exception {
+    Query q = getQueryDOA(query, a);
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void testConstantScoreAutoRewrite() throws Exception {
+    StandardQueryParser qp = new StandardQueryParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
+    Query q = qp.parse("foo*bar", "field");
+    assertTrue(q instanceof WildcardQuery);
+    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((MultiTermQuery) q).getRewriteMethod());
+
+    q = qp.parse("foo*", "field");
+    assertTrue(q instanceof PrefixQuery);
+    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((MultiTermQuery) q).getRewriteMethod());
+
+    q = qp.parse("[a TO z]", "field");
+    assertTrue(q instanceof TermRangeQuery);
+    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((MultiTermQuery) q).getRewriteMethod());
+  }
+
+  public void testCJK() throws Exception {
+    // Test Ideographic Space - As wide as a CJK character cell (fullwidth)
+    // used google to translate the word "term" to japanese -> ??
+    assertQueryEquals("term\u3000term\u3000term", null,
+        "term\u0020term\u0020term");
+    assertQueryEqualsAllowLeadingWildcard("??\u3000??\u3000??", null, "??\u0020??\u0020??");
+  }
+
+  //individual CJK chars as terms, like StandardAnalyzer
+  private class SimpleCJKTokenizer extends Tokenizer {
+    private CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+
+    public SimpleCJKTokenizer(Reader input) {
+      super(input);
+    }
+
+    @Override
+    public boolean incrementToken() throws IOException {
+      int ch = input.read();
+      if (ch < 0)
+        return false;
+      clearAttributes();
+      termAtt.setEmpty().append((char) ch);
+      return true;
+    }
+  }
+
+  private class SimpleCJKAnalyzer extends Analyzer {
+    @Override
+    public TokenStream tokenStream(String fieldName, Reader reader) {
+      return new SimpleCJKTokenizer(reader);
+    }
+  }
+  
+  public void testCJKTerm() throws Exception {
+    // individual CJK chars as terms
+    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
+    
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    
+    assertEquals(expected, getQuery("??", analyzer));
+  }
+  
+  public void testCJKBoostedTerm() throws Exception {
+    // individual CJK chars as terms
+    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
+    
+    BooleanQuery expected = new BooleanQuery();
+    expected.setBoost(0.5f);
+    expected.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    
+    assertEquals(expected, getQuery("??^0.5", analyzer));
+  }
+  
+  public void testCJKPhrase() throws Exception {
+    // individual CJK chars as terms
+    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
+    
+    PhraseQuery expected = new PhraseQuery();
+    expected.add(new Term("field", "?"));
+    expected.add(new Term("field", "??"));
+    
+    assertEquals(expected, getQuery("\"??\"", analyzer));
+  }
+  
+  public void testCJKBoostedPhrase() throws Exception {
+    // individual CJK chars as terms
+    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
+    
+    PhraseQuery expected = new PhraseQuery();
+    expected.setBoost(0.5f);
+    expected.add(new Term("field", "?"));
+    expected.add(new Term("field", "??"));
+    
+    assertEquals(expected, getQuery("\"??\"^0.5", analyzer));
+  }
+  
+  public void testCJKSloppyPhrase() throws Exception {
+    // individual CJK chars as terms
+    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer(); 
+    
+    PhraseQuery expected = new PhraseQuery();
+    expected.setSlop(3);
+    expected.add(new Term("field", "?"));
+    expected.add(new Term("field", "??"));
+    
+    assertEquals(expected, getQuery("\"??\"~3", analyzer));
+  }
+
+  public void testSimple() throws Exception {
+    assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
+    assertQueryEquals("term term term", null, "term term term");
+    assertQueryEquals("t?m term term", new MockAnalyzer(random, MockTokenizer.WHITESPACE, false),
+        "t?m term term");
+    assertQueryEquals("?laut", new MockAnalyzer(random, MockTokenizer.WHITESPACE, false), "?laut");
+
+    // FIXME: change MockAnalyzer to not extend CharTokenizer for this test
+    //assertQueryEquals("\"\"", new KeywordAnalyzer(), "");
+    //assertQueryEquals("foo:\"\"", new KeywordAnalyzer(), "foo:");
+
+    assertQueryEquals("a AND b", null, "+a +b");
+    assertQueryEquals("(a AND b)", null, "+a +b");
+    assertQueryEquals("c OR (a AND b)", null, "c (+a +b)");
+
+    assertQueryEquals("a AND NOT b", null, "+a -b");
+
+    assertQueryEquals("a AND -b", null, "+a -b");
+
+    assertQueryEquals("a AND !b", null, "+a -b");
+
+    assertQueryEquals("a && b", null, "+a +b");
+
+    assertQueryEquals("a && ! b", null, "+a -b");
+
+    assertQueryEquals("a OR b", null, "a b");
+    assertQueryEquals("a || b", null, "a b");
+
+    assertQueryEquals("a OR !b", null, "a -b");
+
+    assertQueryEquals("a OR ! b", null, "a -b");
+
+    assertQueryEquals("a OR -b", null, "a -b");
+
+    assertQueryEquals("+term -term term", null, "+term -term term");
+    assertQueryEquals("foo:term AND field:anotherTerm", null,
+        "+foo:term +anotherterm");
+    assertQueryEquals("term AND \"phrase phrase\"", null,
+        "+term +\"phrase phrase\"");
+    assertQueryEquals("\"hello there\"", null, "\"hello there\"");
+    assertTrue(getQuery("a AND b", null) instanceof BooleanQuery);
+    assertTrue(getQuery("hello", null) instanceof TermQuery);
+    assertTrue(getQuery("\"hello there\"", null) instanceof PhraseQuery);
+
+    assertQueryEquals("germ term^2.0", null, "germ term^2.0");
+    assertQueryEquals("(term)^2.0", null, "term^2.0");
+    assertQueryEquals("(germ term)^2.0", null, "(germ term)^2.0");
+    assertQueryEquals("term^2.0", null, "term^2.0");
+    assertQueryEquals("term^2", null, "term^2.0");
+    assertQueryEquals("\"germ term\"^2.0", null, "\"germ term\"^2.0");
+    assertQueryEquals("\"term germ\"^2", null, "\"term germ\"^2.0");
+
+    assertQueryEquals("(foo OR bar) AND (baz OR boo)", null,
+        "+(foo bar) +(baz boo)");
+    assertQueryEquals("((a OR b) AND NOT c) OR d", null, "(+(a b) -c) d");
+    assertQueryEquals("+(apple \"steve jobs\") -(foo bar baz)", null,
+        "+(apple \"steve jobs\") -(foo bar baz)");
+    assertQueryEquals("+title:(dog OR cat) -author:\"bob dole\"", null,
+        "+(title:dog title:cat) -author:\"bob dole\"");
+
+  }
+
+  public void testPunct() throws Exception {
+    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
+    assertQueryEquals("a&b", a, "a&b");
+    assertQueryEquals("a&&b", a, "a&&b");
+    assertQueryEquals(".NET", a, ".NET");
+  }
+
+  public void testSlop() throws Exception {
+
+    assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
+    assertQueryEquals("\"term germ\"~2 flork", null, "\"term germ\"~2 flork");
+    assertQueryEquals("\"term\"~2", null, "term");
+    assertQueryEquals("\" \"~2 germ", null, "germ");
+    assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
+  }
+
+  public void testNumber() throws Exception {
+    // The numbers go away because SimpleAnalzyer ignores them
+    assertQueryEquals("3", null, "");
+    assertQueryEquals("term 1.0 1 2", null, "term");
+    assertQueryEquals("term term1 term2", null, "term term term");
+
+    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
+    assertQueryEquals("3", a, "3");
+    assertQueryEquals("term 1.0 1 2", a, "term 1.0 1 2");
+    assertQueryEquals("term term1 term2", a, "term term1 term2");
+  }
+
+  public void testWildcard() throws Exception {
+    assertQueryEquals("term*", null, "term*");
+    assertQueryEquals("term*^2", null, "term*^2.0");
+    assertQueryEquals("term~", null, "term~2.0");
+    assertQueryEquals("term~0.7", null, "term~0.7");
+
+    assertQueryEquals("term~^3", null, "term~2.0^3.0");
+
+    assertQueryEquals("term^3~", null, "term~2.0^3.0");
+    assertQueryEquals("term*germ", null, "term*germ");
+    assertQueryEquals("term*germ^3", null, "term*germ^3.0");
+
+    assertTrue(getQuery("term*", null) instanceof PrefixQuery);
+    assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
+    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
+    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
+    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    fq = (FuzzyQuery) getQuery("term~", null);
+    assertEquals(2.0f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+
+    assertQueryNodeException("term~1.1"); // value > 1, throws exception
+
+    assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
+
+    /*
+     * Tests to see that wild card terms are (or are not) properly lower-cased
+     * with propery parser configuration
+     */
+    // First prefix queries:
+    // by default, convert to lowercase:
+    assertWildcardQueryEquals("Term*", true, "term*");
+    // explicitly set lowercase:
+    assertWildcardQueryEquals("term*", true, "term*");
+    assertWildcardQueryEquals("Term*", true, "term*");
+    assertWildcardQueryEquals("TERM*", true, "term*");
+    // explicitly disable lowercase conversion:
+    assertWildcardQueryEquals("term*", false, "term*");
+    assertWildcardQueryEquals("Term*", false, "Term*");
+    assertWildcardQueryEquals("TERM*", false, "TERM*");
+    // Then 'full' wildcard queries:
+    // by default, convert to lowercase:
+    assertWildcardQueryEquals("Te?m", "te?m");
+    // explicitly set lowercase:
+    assertWildcardQueryEquals("te?m", true, "te?m");
+    assertWildcardQueryEquals("Te?m", true, "te?m");
+    assertWildcardQueryEquals("TE?M", true, "te?m");
+    assertWildcardQueryEquals("Te?m*gerM", true, "te?m*germ");
+    // explicitly disable lowercase conversion:
+    assertWildcardQueryEquals("te?m", false, "te?m");
+    assertWildcardQueryEquals("Te?m", false, "Te?m");
+    assertWildcardQueryEquals("TE?M", false, "TE?M");
+    assertWildcardQueryEquals("Te?m*gerM", false, "Te?m*gerM");
+    // Fuzzy queries:
+    assertWildcardQueryEquals("Term~", "term~2.0");
+    assertWildcardQueryEquals("Term~", true, "term~2.0");
+    assertWildcardQueryEquals("Term~", false, "Term~2.0");
+    // Range queries:
+
+    // TODO: implement this on QueryParser
+    // Q0002E_INVALID_SYNTAX_CANNOT_PARSE: Syntax Error, cannot parse '[A TO
+    // C]': Lexical error at line 1, column 1. Encountered: "[" (91), after
+    // : ""
+    assertWildcardQueryEquals("[A TO C]", "[a TO c]");
+    assertWildcardQueryEquals("[A TO C]", true, "[a TO c]");
+    assertWildcardQueryEquals("[A TO C]", false, "[A TO C]");
+    // Test suffix queries: first disallow
+    try {
+      assertWildcardQueryEquals("*Term", true, "*term");
+      fail();
+    } catch (QueryNodeException pe) {
+      // expected exception
+    }
+    try {
+      assertWildcardQueryEquals("?Term", true, "?term");
+      fail();
+    } catch (QueryNodeException pe) {
+      // expected exception
+    }
+    // Test suffix queries: then allow
+    assertWildcardQueryEquals("*Term", true, "*term", true);
+    assertWildcardQueryEquals("?Term", true, "?term", true);
+  }
+
+  public void testLeadingWildcardType() throws Exception {
+    StandardQueryParser qp = getParser(null);
+    qp.setAllowLeadingWildcard(true);
+    assertEquals(WildcardQuery.class, qp.parse("t*erm*", "field").getClass());
+    assertEquals(WildcardQuery.class, qp.parse("?term*", "field").getClass());
+    assertEquals(WildcardQuery.class, qp.parse("*term*", "field").getClass());
+  }
+
+  public void testQPA() throws Exception {
+    assertQueryEquals("term term^3.0 term", qpAnalyzer, "term term^3.0 term");
+    assertQueryEquals("term stop^3.0 term", qpAnalyzer, "term term");
+
+    assertQueryEquals("term term term", qpAnalyzer, "term term term");
+    assertQueryEquals("term +stop term", qpAnalyzer, "term term");
+    assertQueryEquals("term -stop term", qpAnalyzer, "term term");
+
+    assertQueryEquals("drop AND (stop) AND roll", qpAnalyzer, "+drop +roll");
+    assertQueryEquals("term +(stop) term", qpAnalyzer, "term term");
+    assertQueryEquals("term -(stop) term", qpAnalyzer, "term term");
+
+    assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
+    assertQueryEquals("term phrase term", qpAnalyzer,
+        "term phrase1 phrase2 term");
+
+    assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
+        "+term -(phrase1 phrase2) term");
+
+    assertQueryEquals("stop^3", qpAnalyzer, "");
+    assertQueryEquals("stop", qpAnalyzer, "");
+    assertQueryEquals("(stop)^3", qpAnalyzer, "");
+    assertQueryEquals("((stop))^3", qpAnalyzer, "");
+    assertQueryEquals("(stop^3)", qpAnalyzer, "");
+    assertQueryEquals("((stop)^3)", qpAnalyzer, "");
+    assertQueryEquals("(stop)", qpAnalyzer, "");
+    assertQueryEquals("((stop))", qpAnalyzer, "");
+    assertTrue(getQuery("term term term", qpAnalyzer) instanceof BooleanQuery);
+    assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
+  }
+
+  public void testRange() throws Exception {
+    assertQueryEquals("[ a TO z]", null, "[a TO z]");
+    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery)getQuery("[ a TO z]", null)).getRewriteMethod());
+
+    StandardQueryParser qp = new StandardQueryParser();
+    
+    qp.setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
+    assertEquals(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE,((TermRangeQuery)qp.parse("[ a TO z]", "field")).getRewriteMethod());
+
+    assertQueryEquals("[ a TO z ]", null, "[a TO z]");
+    assertQueryEquals("{ a TO z}", null, "{a TO z}");
+    assertQueryEquals("{ a TO z }", null, "{a TO z}");
+    assertQueryEquals("{ a TO z }^2.0", null, "{a TO z}^2.0");
+    assertQueryEquals("[ a TO z] OR bar", null, "[a TO z] bar");
+    assertQueryEquals("[ a TO z] AND bar", null, "+[a TO z] +bar");
+    assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
+    assertQueryEquals("gack ( bar blar { a TO z}) ", null,
+        "gack (bar blar {a TO z})");
+  }
+
+  /** for testing DateTools support */
+  private String getDate(String s, DateTools.Resolution resolution)
+      throws Exception {
+    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
+    return getDate(df.parse(s), resolution);
+  }
+
+  /** for testing DateTools support */
+  private String getDate(Date d, DateTools.Resolution resolution)
+      throws Exception {
+    return DateTools.dateToString(d, resolution);
+  }
+  
+  private String escapeDateString(String s) {
+    if (s.contains(" ")) {
+      return "\"" + s + "\"";
+    } else {
+      return s;
+    }
+  }
+
+  private String getLocalizedDate(int year, int month, int day) {
+    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
+    Calendar calendar = new GregorianCalendar();
+    calendar.clear();
+    calendar.set(year, month, day);
+    calendar.set(Calendar.HOUR_OF_DAY, 23);
+    calendar.set(Calendar.MINUTE, 59);
+    calendar.set(Calendar.SECOND, 59);
+    calendar.set(Calendar.MILLISECOND, 999);
+    return df.format(calendar.getTime());
+  }
+
+  public void testDateRange() throws Exception {
+    String startDate = getLocalizedDate(2002, 1, 1);
+    String endDate = getLocalizedDate(2002, 1, 4);
+    Calendar endDateExpected = new GregorianCalendar();
+    endDateExpected.clear();
+    endDateExpected.set(2002, 1, 4, 23, 59, 59);
+    endDateExpected.set(Calendar.MILLISECOND, 999);
+    final String defaultField = "default";
+    final String monthField = "month";
+    final String hourField = "hour";
+    StandardQueryParser qp = new StandardQueryParser();
+
+    Map<CharSequence, DateTools.Resolution> dateRes =  new HashMap<CharSequence, DateTools.Resolution>();
+    
+    // set a field specific date resolution    
+    dateRes.put(monthField, DateTools.Resolution.MONTH);
+    qp.setDateResolution(dateRes);
+
+    // set default date resolution to MILLISECOND
+    qp.setDateResolution(DateTools.Resolution.MILLISECOND);
+
+    // set second field specific date resolution
+    dateRes.put(hourField, DateTools.Resolution.HOUR);
+    qp.setDateResolution(dateRes);
+
+    // for this field no field specific date resolution has been set,
+    // so verify if the default resolution is used
+    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);
+
+    // verify if field specific date resolutions are used for these two
+    // fields
+    assertDateRangeQueryEquals(qp, monthField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.MONTH);
+
+    assertDateRangeQueryEquals(qp, hourField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.HOUR);
+  }
+
+  public void assertDateRangeQueryEquals(StandardQueryParser qp,
+      String field, String startDate, String endDate, Date endDateInclusive,
+      DateTools.Resolution resolution) throws Exception {
+    assertQueryEquals(qp, field, field + ":[" + escapeDateString(startDate) + " TO " + escapeDateString(endDate)
+        + "]", "[" + getDate(startDate, resolution) + " TO "
+        + getDate(endDateInclusive, resolution) + "]");
+    assertQueryEquals(qp, field, field + ":{" + escapeDateString(startDate) + " TO " + escapeDateString(endDate)
+        + "}", "{" + getDate(startDate, resolution) + " TO "
+        + getDate(endDate, resolution) + "}");
+  }
+
+  public void testEscaped() throws Exception {
+    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
+
+    /*
+     * assertQueryEquals("\\[brackets", a, "\\[brackets");
+     * assertQueryEquals("\\[brackets", null, "brackets");
+     * assertQueryEquals("\\\\", a, "\\\\"); assertQueryEquals("\\+blah", a,
+     * "\\+blah"); assertQueryEquals("\\(blah", a, "\\(blah");
+     * 
+     * assertQueryEquals("\\-blah", a, "\\-blah"); assertQueryEquals("\\!blah",
+     * a, "\\!blah"); assertQueryEquals("\\{blah", a, "\\{blah");
+     * assertQueryEquals("\\}blah", a, "\\}blah"); assertQueryEquals("\\:blah",
+     * a, "\\:blah"); assertQueryEquals("\\^blah", a, "\\^blah");
+     * assertQueryEquals("\\[blah", a, "\\[blah"); assertQueryEquals("\\]blah",
+     * a, "\\]blah"); assertQueryEquals("\\\"blah", a, "\\\"blah");
+     * assertQueryEquals("\\(blah", a, "\\(blah"); assertQueryEquals("\\)blah",
+     * a, "\\)blah"); assertQueryEquals("\\~blah", a, "\\~blah");
+     * assertQueryEquals("\\*blah", a, "\\*blah"); assertQueryEquals("\\?blah",
+     * a, "\\?blah"); //assertQueryEquals("foo \\&\\& bar", a,
+     * "foo \\&\\& bar"); //assertQueryEquals("foo \\|| bar", a,
+     * "foo \\|| bar"); //assertQueryEquals("foo \\AND bar", a,
+     * "foo \\AND bar");
+     */
+
+    assertQueryEquals("\\*", a, "*");
+    
+    assertQueryEquals("\\a", a, "a");
+
+    assertQueryEquals("a\\-b:c", a, "a-b:c");
+    assertQueryEquals("a\\+b:c", a, "a+b:c");
+    assertQueryEquals("a\\:b:c", a, "a:b:c");
+    assertQueryEquals("a\\\\b:c", a, "a\\b:c");
+
+    assertQueryEquals("a:b\\-c", a, "a:b-c");
+    assertQueryEquals("a:b\\+c", a, "a:b+c");
+    assertQueryEquals("a:b\\:c", a, "a:b:c");
+    assertQueryEquals("a:b\\\\c", a, "a:b\\c");
+
+    assertQueryEquals("a:b\\-c*", a, "a:b-c*");
+    assertQueryEquals("a:b\\+c*", a, "a:b+c*");
+    assertQueryEquals("a:b\\:c*", a, "a:b:c*");
+
+    assertQueryEquals("a:b\\\\c*", a, "a:b\\c*");
+
+    assertQueryEquals("a:b\\-?c", a, "a:b-?c");
+    assertQueryEquals("a:b\\+?c", a, "a:b+?c");
+    assertQueryEquals("a:b\\:?c", a, "a:b:?c");
+
+    assertQueryEquals("a:b\\\\?c", a, "a:b\\?c");
+
+    assertQueryEquals("a:b\\-c~", a, "a:b-c~2.0");
+    assertQueryEquals("a:b\\+c~", a, "a:b+c~2.0");
+    assertQueryEquals("a:b\\:c~", a, "a:b:c~2.0");
+    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~2.0");
+
+    // TODO: implement Range queries on QueryParser
+    assertQueryEquals("[ a\\- TO a\\+ ]", null, "[a- TO a+]");
+    assertQueryEquals("[ a\\: TO a\\~ ]", null, "[a: TO a~]");
+    assertQueryEquals("[ a\\\\ TO a\\* ]", null, "[a\\ TO a*]");
+
+    assertQueryEquals(
+        "[\"c\\:\\\\temp\\\\\\~foo0.txt\" TO \"c\\:\\\\temp\\\\\\~foo9.txt\"]",
+        a, "[c:\\temp\\~foo0.txt TO c:\\temp\\~foo9.txt]");
+
+    assertQueryEquals("a\\\\\\+b", a, "a\\+b");
+
+    assertQueryEquals("a \\\"b c\\\" d", a, "a \"b c\" d");
+    assertQueryEquals("\"a \\\"b c\\\" d\"", a, "\"a \"b c\" d\"");
+    assertQueryEquals("\"a \\+b c d\"", a, "\"a +b c d\"");
+
+    assertQueryEquals("c\\:\\\\temp\\\\\\~foo.txt", a, "c:\\temp\\~foo.txt");
+
+    assertQueryNodeException("XY\\"); // there must be a character after the
+    // escape char
+
+    // test unicode escaping
+    assertQueryEquals("a\\u0062c", a, "abc");
+    assertQueryEquals("XY\\u005a", a, "XYZ");
+    assertQueryEquals("XY\\u005A", a, "XYZ");
+    assertQueryEquals("\"a \\\\\\u0028\\u0062\\\" c\"", a, "\"a \\(b\" c\"");
+
+    assertQueryNodeException("XY\\u005G"); // test non-hex character in escaped
+    // unicode sequence
+    assertQueryNodeException("XY\\u005"); // test incomplete escaped unicode
+    // sequence
+
+    // Tests bug LUCENE-800
+    assertQueryEquals("(item:\\\\ item:ABCD\\\\)", a, "item:\\ item:ABCD\\");
+    assertQueryNodeException("(item:\\\\ item:ABCD\\\\))"); // unmatched closing
+    // paranthesis
+    assertQueryEquals("\\*", a, "*");
+    assertQueryEquals("\\\\", a, "\\"); // escaped backslash
+
+    assertQueryNodeException("\\"); // a backslash must always be escaped
+
+    // LUCENE-1189
+    assertQueryEquals("(\"a\\\\\") or (\"b\")", a, "a\\ or b");
+  }
+
+  public void testQueryStringEscaping() throws Exception {
+    Analyzer a = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false);
+
+    assertEscapedQueryEquals("a-b:c", a, "a\\-b\\:c");
+    assertEscapedQueryEquals("a+b:c", a, "a\\+b\\:c");
+    assertEscapedQueryEquals("a:b:c", a, "a\\:b\\:c");
+    assertEscapedQueryEquals("a\\b:c", a, "a\\\\b\\:c");
+
+    assertEscapedQueryEquals("a:b-c", a, "a\\:b\\-c");
+    assertEscapedQueryEquals("a:b+c", a, "a\\:b\\+c");
+    assertEscapedQueryEquals("a:b:c", a, "a\\:b\\:c");
+    assertEscapedQueryEquals("a:b\\c", a, "a\\:b\\\\c");
+
+    assertEscapedQueryEquals("a:b-c*", a, "a\\:b\\-c\\*");
+    assertEscapedQueryEquals("a:b+c*", a, "a\\:b\\+c\\*");
+    assertEscapedQueryEquals("a:b:c*", a, "a\\:b\\:c\\*");
+
+    assertEscapedQueryEquals("a:b\\\\c*", a, "a\\:b\\\\\\\\c\\*");
+
+    assertEscapedQueryEquals("a:b-?c", a, "a\\:b\\-\\?c");
+    assertEscapedQueryEquals("a:b+?c", a, "a\\:b\\+\\?c");
+    assertEscapedQueryEquals("a:b:?c", a, "a\\:b\\:\\?c");
+
+    assertEscapedQueryEquals("a:b?c", a, "a\\:b\\?c");
+
+    assertEscapedQueryEquals("a:b-c~", a, "a\\:b\\-c\\~");
+    assertEscapedQueryEquals("a:b+c~", a, "a\\:b\\+c\\~");
+    assertEscapedQueryEquals("a:b:c~", a, "a\\:b\\:c\\~");
+    assertEscapedQueryEquals("a:b\\c~", a, "a\\:b\\\\c\\~");
+
+    assertEscapedQueryEquals("[ a - TO a+ ]", null, "\\[ a \\- TO a\\+ \\]");
+    assertEscapedQueryEquals("[ a : TO a~ ]", null, "\\[ a \\: TO a\\~ \\]");
+    assertEscapedQueryEquals("[ a\\ TO a* ]", null, "\\[ a\\\\ TO a\\* \\]");
+
+    // LUCENE-881
+    assertEscapedQueryEquals("|| abc ||", a, "\\|\\| abc \\|\\|");
+    assertEscapedQueryEquals("&& abc &&", a, "\\&\\& abc \\&\\&");
+  }
+
+  @Ignore("contrib queryparser shouldn't escape wildcard terms")
+  public void testEscapedWildcard() throws Exception {
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
+
+    WildcardQuery q = new WildcardQuery(new Term("field", "foo\\?ba?r"));
+    assertEquals(q, qp.parse("foo\\?ba?r", "field"));
+  }
+
+  public void testTabNewlineCarriageReturn() throws Exception {
+    assertQueryEqualsDOA("+weltbank +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \n +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\r+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\r\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r\n +worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r \n +worlbank", null,
+        "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\t+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \t+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \t +worlbank", null, "+weltbank +worlbank");
+  }
+
+  public void testSimpleDAO() throws Exception {
+    assertQueryEqualsDOA("term term term", null, "+term +term +term");
+    assertQueryEqualsDOA("term +term term", null, "+term +term +term");
+    assertQueryEqualsDOA("term term +term", null, "+term +term +term");
+    assertQueryEqualsDOA("term +term +term", null, "+term +term +term");
+    assertQueryEqualsDOA("-term term term", null, "-term +term +term");
+  }
+
+  public void testBoost() throws Exception {
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(BasicAutomata.makeString("on"));
+    Analyzer oneStopAnalyzer = new MockAnalyzer(random, MockTokenizer.SIMPLE, true, stopSet, true);
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(oneStopAnalyzer);
+
+    Query q = qp.parse("on^1.0", "field");
+    assertNotNull(q);
+    q = qp.parse("\"hello\"^2.0", "field");
+    assertNotNull(q);
+    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
+    q = qp.parse("hello^2.0", "field");
+    assertNotNull(q);
+    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
+    q = qp.parse("\"on\"^1.0", "field");
+    assertNotNull(q);
+
+    StandardQueryParser qp2 = new StandardQueryParser();
+    qp2.setAnalyzer(new MockAnalyzer(random, MockTokenizer.SIMPLE, true, MockTokenFilter.ENGLISH_STOPSET, true));
+
+    q = qp2.parse("the^3", "field");
+    // "the" is a stop word so the result is an empty query:
+    assertNotNull(q);
+    assertEquals("", q.toString());
+    assertEquals(1.0f, q.getBoost(), 0.01f);
+  }
+
+  public void assertQueryNodeException(String queryString) throws Exception {
+    try {
+      getQuery(queryString, null);
+    } catch (QueryNodeException expected) {
+      return;
+    }
+    fail("ParseException expected, not thrown");
+  }
+
+  public void testException() throws Exception {
+    assertQueryNodeException("*leadingWildcard"); // disallowed by default
+    assertQueryNodeException("\"some phrase");
+    assertQueryNodeException("(foo bar");
+    assertQueryNodeException("foo bar))");
+    assertQueryNodeException("field:term:with:colon some more terms");
+    assertQueryNodeException("(sub query)^5.0^2.0 plus more");
+    assertQueryNodeException("secret AND illegal) AND access:confidential");    
+  }
+
+  public void testCustomQueryParserWildcard() {
+    try {
+      new QPTestParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).parse("a?t", "contents");
+      fail("Wildcard queries should not be allowed");
+    } catch (QueryNodeException expected) {
+      // expected exception
+    }
+  }
+
+  public void testCustomQueryParserFuzzy() throws Exception {
+    try {
+      new QPTestParser(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).parse("xunit~", "contents");
+      fail("Fuzzy queries should not be allowed");
+    } catch (QueryNodeException expected) {
+      // expected exception
+    }
+  }
+
+  public void testBooleanQuery() throws Exception {
+    BooleanQuery.setMaxClauseCount(2);
+    try {
+      StandardQueryParser qp = new StandardQueryParser();
+      qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
+
+      qp.parse("one two three", "field");
+      fail("ParseException expected due to too many boolean clauses");
+    } catch (QueryNodeException expected) {
+      // too many boolean clauses, so ParseException is expected
+    }
+  }
+
+  /**
+   * This test differs from TestPrecedenceQueryParser
+   */
+  public void testPrecedence() throws Exception {
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
+
+    Query query1 = qp.parse("A AND B OR C AND D", "field");
+    Query query2 = qp.parse("+A +B +C +D", "field");
+
+    assertEquals(query1, query2);
+  }
+
+// Todo: Convert from DateField to DateUtil
+//  public void testLocalDateFormat() throws IOException, QueryNodeException {
+//    Directory ramDir = newDirectory();
+//    IndexWriter iw = new IndexWriter(ramDir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)));
+//    addDateDoc("a", 2005, 12, 2, 10, 15, 33, iw);
+//    addDateDoc("b", 2005, 12, 4, 22, 15, 00, iw);
+//    iw.close();
+//    IndexSearcher is = new IndexSearcher(ramDir, true);
+//    assertHits(1, "[12/1/2005 TO 12/3/2005]", is);
+//    assertHits(2, "[12/1/2005 TO 12/4/2005]", is);
+//    assertHits(1, "[12/3/2005 TO 12/4/2005]", is);
+//    assertHits(1, "{12/1/2005 TO 12/3/2005}", is);
+//    assertHits(1, "{12/1/2005 TO 12/4/2005}", is);
+//    assertHits(0, "{12/3/2005 TO 12/4/2005}", is);
+//    is.close();
+//    ramDir.close();
+//  }
+//
+//  private void addDateDoc(String content, int year, int month, int day,
+//                          int hour, int minute, int second, IndexWriter iw) throws IOException {
+//    Document d = new Document();
+//    d.add(newField("f", content, Field.Store.YES, Field.Index.ANALYZED));
+//    Calendar cal = Calendar.getInstance(Locale.ENGLISH);
+//    cal.set(year, month - 1, day, hour, minute, second);
+//    d.add(newField("date", DateField.dateToString(cal.getTime()),
+//        Field.Store.YES, Field.Index.NOT_ANALYZED));
+//    iw.addDocument(d);
+//  }
+
+
+  public void testStarParsing() throws Exception {
+    // final int[] type = new int[1];
+    // StandardQueryParser qp = new StandardQueryParser("field", new
+    // WhitespaceAnalyzer()) {
+    // protected Query getWildcardQuery(String field, String termStr) throws
+    // ParseException {
+    // // override error checking of superclass
+    // type[0]=1;
+    // return new TermQuery(new Term(field,termStr));
+    // }
+    // protected Query getPrefixQuery(String field, String termStr) throws
+    // ParseException {
+    // // override error checking of superclass
+    // type[0]=2;
+    // return new TermQuery(new Term(field,termStr));
+    // }
+    //
+    // protected Query getFieldQuery(String field, String queryText) throws
+    // ParseException {
+    // type[0]=3;
+    // return super.getFieldQuery(field, queryText);
+    // }
+    // };
+    //
+    // TermQuery tq;
+    //
+    // tq = (TermQuery)qp.parse("foo:zoo*");
+    // assertEquals("zoo",tq.getTerm().text());
+    // assertEquals(2,type[0]);
+    //
+    // tq = (TermQuery)qp.parse("foo:zoo*^2");
+    // assertEquals("zoo",tq.getTerm().text());
+    // assertEquals(2,type[0]);
+    // assertEquals(tq.getBoost(),2,0);
+    //
+    // tq = (TermQuery)qp.parse("foo:*");
+    // assertEquals("*",tq.getTerm().text());
+    // assertEquals(1,type[0]); // could be a valid prefix query in the
+    // future too
+    //
+    // tq = (TermQuery)qp.parse("foo:*^2");
+    // assertEquals("*",tq.getTerm().text());
+    // assertEquals(1,type[0]);
+    // assertEquals(tq.getBoost(),2,0);
+    //
+    // tq = (TermQuery)qp.parse("*:foo");
+    // assertEquals("*",tq.getTerm().field());
+    // assertEquals("foo",tq.getTerm().text());
+    // assertEquals(3,type[0]);
+    //
+    // tq = (TermQuery)qp.parse("*:*");
+    // assertEquals("*",tq.getTerm().field());
+    // assertEquals("*",tq.getTerm().text());
+    // assertEquals(1,type[0]); // could be handled as a prefix query in the
+    // future
+    //
+    // tq = (TermQuery)qp.parse("(*:*)");
+    // assertEquals("*",tq.getTerm().field());
+    // assertEquals("*",tq.getTerm().text());
+    // assertEquals(1,type[0]);
+
+  }
+  
+  public void testRegexps() throws Exception {
+    StandardQueryParser qp = new StandardQueryParser();
+    final String df = "field" ;
+    RegexpQuery q = new RegexpQuery(new Term("field", "[a-z][123]"));
+    assertEquals(q, qp.parse("/[a-z][123]/", df));
+    qp.setLowercaseExpandedTerms(true);
+    assertEquals(q, qp.parse("/[A-Z][123]/", df));
+    q.setBoost(0.5f);
+    assertEquals(q, qp.parse("/[A-Z][123]/^0.5", df));
+    qp.setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
+    q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
+    assertTrue(qp.parse("/[A-Z][123]/^0.5", df) instanceof RegexpQuery);
+    assertEquals(q, qp.parse("/[A-Z][123]/^0.5", df));
+    assertEquals(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE, ((RegexpQuery)qp.parse("/[A-Z][123]/^0.5", df)).getRewriteMethod());
+    qp.setMultiTermRewriteMethod(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
+    
+    Query escaped = new RegexpQuery(new Term("field", "[a-z]\\/[123]"));
+    assertEquals(escaped, qp.parse("/[a-z]\\/[123]/", df));
+    Query escaped2 = new RegexpQuery(new Term("field", "[a-z]\\*[123]"));
+    assertEquals(escaped2, qp.parse("/[a-z]\\*[123]/", df));
+    
+    BooleanQuery complex = new BooleanQuery();
+    complex.add(new RegexpQuery(new Term("field", "[a-z]\\/[123]")), Occur.MUST);
+    complex.add(new TermQuery(new Term("path", "/etc/init.d/")), Occur.MUST);
+    complex.add(new TermQuery(new Term("field", "/etc/init[.]d/lucene/")), Occur.SHOULD);
+    assertEquals(complex, qp.parse("/[a-z]\\/[123]/ AND path:/etc/init.d/ OR /etc\\/init\\[.\\]d/lucene/ ", df));
+  }
+
+  public void testStopwords() throws Exception {
+    StandardQueryParser qp = new StandardQueryParser();
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|foo").toAutomaton());
+    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.SIMPLE, true, stopSet, true));
+
+    Query result = qp.parse("a:the OR a:foo", "a");
+    assertNotNull("result is null and it shouldn't be", result);
+    assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
+    assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
+        + 0, ((BooleanQuery) result).clauses().size() == 0);
+    result = qp.parse("a:woo OR a:the", "a");
+    assertNotNull("result is null and it shouldn't be", result);
+    assertTrue("result is not a TermQuery", result instanceof TermQuery);
+    result = qp.parse(
+        "(fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)",
+        "a");
+    assertNotNull("result is null and it shouldn't be", result);
+    assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
+    if (VERBOSE)
+      System.out.println("Result: " + result);
+    assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
+        + 2, ((BooleanQuery) result).clauses().size() == 2);
+  }
+
+  public void testPositionIncrement() throws Exception {
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(
+        new MockAnalyzer(random, MockTokenizer.SIMPLE, true, MockTokenFilter.ENGLISH_STOPSET, true));
+
+    qp.setEnablePositionIncrements(true);
+
+    String qtxt = "\"the words in poisitions pos02578 are stopped in this phrasequery\"";
+    // 0 2 5 7 8
+    int expectedPositions[] = { 1, 3, 4, 6, 9 };
+    PhraseQuery pq = (PhraseQuery) qp.parse(qtxt, "a");
+    // System.out.println("Query text: "+qtxt);
+    // System.out.println("Result: "+pq);
+    Term t[] = pq.getTerms();
+    int pos[] = pq.getPositions();
+    for (int i = 0; i < t.length; i++) {
+      // System.out.println(i+". "+t[i]+"  pos: "+pos[i]);
+      assertEquals("term " + i + " = " + t[i] + " has wrong term-position!",
+          expectedPositions[i], pos[i]);
+    }
+  }
+
+  public void testMatchAllDocs() throws Exception {
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
+
+    assertEquals(new MatchAllDocsQuery(), qp.parse("*:*", "field"));
+    assertEquals(new MatchAllDocsQuery(), qp.parse("(*:*)", "field"));
+    BooleanQuery bq = (BooleanQuery) qp.parse("+*:* -*:*", "field");
+    assertTrue(bq.getClauses()[0].getQuery() instanceof MatchAllDocsQuery);
+    assertTrue(bq.getClauses()[1].getQuery() instanceof MatchAllDocsQuery);
+  }
+
+  private void assertHits(int expected, String query, IndexSearcher is)
+      throws IOException, QueryNodeException {
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(new MockAnalyzer(random, MockTokenizer.WHITESPACE, false));
+    qp.setLocale(Locale.ENGLISH);
+
+    Query q = qp.parse(query, "date");
+    ScoreDoc[] hits = is.search(q, null, 1000).scoreDocs;
+    assertEquals(expected, hits.length);
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    BooleanQuery.setMaxClauseCount(originalMaxClauses);
+    super.tearDown();
+  }
+
+  private class CannedTokenStream extends TokenStream {
+    private int upto = 0;
+    final PositionIncrementAttribute posIncr = addAttribute(PositionIncrementAttribute.class);
+    final CharTermAttribute term = addAttribute(CharTermAttribute.class);
+    @Override
+    public boolean incrementToken() {
+      clearAttributes();
+      if (upto == 4) {
+        return false;
+      }
+      if (upto == 0) {
+        posIncr.setPositionIncrement(1);
+        term.setEmpty().append("a");
+      } else if (upto == 1) {
+        posIncr.setPositionIncrement(1);
+        term.setEmpty().append("b");
+      } else if (upto == 2) {
+        posIncr.setPositionIncrement(0);
+        term.setEmpty().append("c");
+      } else {
+        posIncr.setPositionIncrement(0);
+        term.setEmpty().append("d");
+      }
+      upto++;
+      return true;
+    }
+  }
+
+  private class CannedAnalyzer extends Analyzer {
+    @Override
+    public TokenStream tokenStream(String ignored, Reader alsoIgnored) {
+      return new CannedTokenStream();
+    }
+  }
+
+  public void testMultiPhraseQuery() throws Exception {
+    Directory dir = newDirectory();
+    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new CannedAnalyzer()));
+    Document doc = new Document();
+    doc.add(newField("field", "", Field.Store.NO, Field.Index.ANALYZED));
+    w.addDocument(doc);
+    IndexReader r = IndexReader.open(w, true);
+    IndexSearcher s = newSearcher(r);
+    
+    Query q = new StandardQueryParser(new CannedAnalyzer()).parse("\"a\"", "field");
+    assertTrue(q instanceof MultiPhraseQuery);
+    assertEquals(1, s.search(q, 10).totalHits);
+    s.close();
+    r.close();
+    w.close();
+    dir.close();
+  }
+
+}

