GitDiffStart: c8aa9c1f42642188807f65b74c5f95afa78bab72 | Wed Aug 29 06:26:02 2012 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index 267a272..c856b7b 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -7553,7 +7553,7 @@ Infrastructure
 11. Fixed bugs in GermanAnalyzer (gschwarz)
 
 
-1.2 RC2:
+1.2 RC2
  - added sources to distribution
  - removed broken build scripts and libraries from distribution
  - SegmentsReader: fixed potential race condition
@@ -7568,7 +7568,8 @@ Infrastructure
  - JDK 1.1 compatibility fix: disabled lock files for JDK 1.1,
    since they rely on a feature added in JDK 1.2.
 
-1.2 RC1 (first Apache release):
+1.2 RC1
+  - first Apache release
   - packages renamed from com.lucene to org.apache.lucene
   - license switched from LGPL to Apache
   - ant-only build -- no more makefiles
@@ -7579,7 +7580,8 @@ Infrastructure
   - Analyzers can choose tokenizer based on field name
   - misc bug fixes.
 
-1.01b (last Sourceforge release)
+1.01b
+ . last Sourceforge release
  . a few bug fixes
  . new Query Parser
  . new prefix query (search for "foo*" matches "food")
diff --git a/lucene/build.xml b/lucene/build.xml
index 6401a8c..3bf2095 100644
--- a/lucene/build.xml
+++ b/lucene/build.xml
@@ -470,24 +470,6 @@
     <modules-crawl target="test" failonerror="true"/>
   </target>
 
-  <!--
-   compile changes.txt into an html file
-   -->
-  <macrodef name="build-changes">
-    <attribute name="changes.src.dir" default="${changes.src.dir}"/>
-    <attribute name="changes.target.dir" default="${changes.target.dir}"/>
-    <sequential>
-      <mkdir dir="@{changes.target.dir}"/>
-      <exec executable="perl" input="CHANGES.txt" output="@{changes.target.dir}/Changes.html"
-            failonerror="true" logError="true">
-        <arg value="@{changes.src.dir}/changes2html.pl"/>
-      </exec>
-      <copy todir="@{changes.target.dir}">
-        <fileset dir="@{changes.src.dir}" includes="*.css"/>
-      </copy>
-    </sequential>
-  </macrodef>
-
   <target name="changes-to-html">
     <build-changes changes.src.dir="${changes.src.dir}" changes.target.dir="${changes.target.dir}" />
   </target>
diff --git a/lucene/common-build.xml b/lucene/common-build.xml
index 7037389..91401d8 100644
--- a/lucene/common-build.xml
+++ b/lucene/common-build.xml
@@ -1681,4 +1681,22 @@ ${tests-output}/junit4-*.suites     - per-JVM executed suites
      </sequential>
   </macrodef>
 
+  <!--
+   compile changes.txt into an html file
+   -->
+  <macrodef name="build-changes">
+    <attribute name="changes.src.dir" default="${changes.src.dir}"/>
+    <attribute name="changes.target.dir" default="${changes.target.dir}"/>
+    <sequential>
+      <mkdir dir="@{changes.target.dir}"/>
+      <exec executable="perl" input="CHANGES.txt" output="@{changes.target.dir}/Changes.html"
+            failonerror="true" logError="true">
+        <arg value="@{changes.src.dir}/changes2html.pl"/>
+      </exec>
+      <copy todir="@{changes.target.dir}">
+        <fileset dir="@{changes.src.dir}" includes="*.css"/>
+      </copy>
+    </sequential>
+  </macrodef>
+
 </project>
diff --git a/lucene/site/changes/changes2html.pl b/lucene/site/changes/changes2html.pl
index 2ade718..98e8d8f 100755
--- a/lucene/site/changes/changes2html.pl
+++ b/lucene/site/changes/changes2html.pl
@@ -25,13 +25,12 @@ use strict;
 use warnings;
 
 # JIRA REST API documentation: <http://docs.atlassian.com/jira/REST/latest/>
-my $project_info_url = 'https://issues.apache.org/jira/rest/api/2/project/LUCENE';
+my $project_info_url = 'https://issues.apache.org/jira/rest/api/2/project';
 my $jira_url_prefix = 'http://issues.apache.org/jira/browse/';
 my $bugzilla_url_prefix = 'http://issues.apache.org/bugzilla/show_bug.cgi?id=';
-my %release_dates = &setup_release_dates;
 my $month_regex = &setup_month_regex;
 my %month_nums = &setup_month_nums;
-my %bugzilla_jira_map = &setup_bugzilla_jira_map;
+my %lucene_bugzilla_jira_map = &setup_lucene_bugzilla_jira_map;
 my $title = undef;
 my $release = undef;
 my $reldate = undef;
@@ -44,20 +43,35 @@ my @releases = ();
 
 my @lines = <>;                        # Get all input at once
 
+my $product = '';
+for my $line (@lines) {
+  ($product) = $line =~ /(Solr|Lucene)/i;
+  if ($product) {
+    $product = uc($product);
+    last;
+  }
+}
+my %release_dates = &setup_release_dates;
+my $in_major_component_versions_section = 0;
+
+
 #
 # Parse input and build hierarchical release structure in @releases
 #
 for (my $line_num = 0 ; $line_num <= $#lines ; ++$line_num) {
   $_ = $lines[$line_num];
-  next unless (/\S/);                  # Skip blank lines
+  unless (/\S/) {                      # Skip blank lines
+    $in_major_component_versions_section = 0;
+    next;
+  }
   next if (/^\s*\$Id(?::.*)?\$/);      # Skip $Id$ lines
+  next if (/^\s{0,4}-{5,}\s*$/);       # Skip Solr's section underlines
 
   unless ($title) {
     if (/\S/) {
-      s/^\s+//;                        # Trim leading whitespace
+      s/^[^\p{N}\p{L}]*//;             # Trim leading non-alphanum chars, including BOM chars, if any
       s/\s+$//;                        # Trim trailing whitespace
     }
-    s/^[^Ll]*//;                       # Trim leading BOM characters if exists
     $title = $_;
     next;
   }
@@ -71,8 +85,11 @@ for (my $line_num = 0 ; $line_num <= $#lines ; ++$line_num) {
     ($reldate, $relinfo) = get_release_date($release, $relinfo);
     $sections = [];
     push @releases, [ $release, $reldate, $relinfo, $sections ];
-    ($first_relid = lc($release)) =~ s/\s+/_/g   if ($#releases == 0);
-    ($second_relid = lc($release)) =~ s/\s+/_/g  if ($#releases == 1);
+    ($first_relid = lc($release)) =~ s/\s+/_/g
+       if ($#releases == 0 or ($#releases == 1 and not ($releases[0][0])));
+    ($second_relid = lc($release)) =~ s/\s+/_/g
+       if (   ($#releases == 1 and $releases[0][0])
+           or ($#releases == 2 and not $releases[0][0]));
     $items = undef;
     next;
   }
@@ -90,18 +107,43 @@ for (my $line_num = 0 ; $line_num <= $#lines ; ++$line_num) {
     next;
   }
 
+  if (m!^20\d\d[-/]\d{1,2}[-/]\d{1,2}!) { # Collect dated postscripts
+    my $item = $_;
+    my $line = '';
+    while ($line_num < $#lines and ($line = $lines[++$line_num]) =~ /\S/) {
+      $line =~ s/^\s+//;                   # Trim leading whitespace
+      $line =~ s/\s+$//;                   # Trim trailing whitespace
+      $item .= "$line\n";
+    }
+    push @releases, [ $item, '', '', [] ];
+    next;
+  }
+
   # Section heading: no leading whitespace, initial word capitalized,
   #                  five words or less, and no trailing punctuation
-  if (/^([A-Z]\S*(?:\s+\S+){0,4})(?<![-.:;!()])\s*$/) {
+  if (    /^([A-Z]\S*(?:\s+\S+){0,4})(?<![-.:;!()])\s*$/
+      and not $in_major_component_versions_section) {
     my $heading = $1;
     $items = [];
+    unless (@releases) {
+      $sections = [];
+      # Make a fake release to hold pre-release sections
+      push @releases, [ undef, undef, undef, $sections ];
+    }
     push @$sections, [ $heading, $items ];
+    $in_major_component_versions_section
+      = ($heading =~ /Versions of Major Components/i);
     next;
   }
 
   # Handle earlier releases without sections - create a headless section
   unless ($items) {
     $items = [];
+    unless (@releases) {
+      $sections = [];
+      # Make a fake release to hold pre-release sections and items
+      push @releases, [ undef, undef, undef, $sections ];
+    }
     push @$sections, [ undef, $items ];
   }
 
@@ -130,7 +172,7 @@ for (my $line_num = 0 ; $line_num <= $#lines ; ++$line_num) {
     }
     $item =~ s/\n+\Z/\n/;                  # Trim trailing blank lines
     push @$items, $item;
-    --$line_num unless ($line_num == $#lines);
+    --$line_num unless ($line_num == $#lines && $lines[$line_num] !~ /^20/);
   } elsif ($type eq 'paragraph') {         # List item boundary is a blank line
     my $line;
     my $item = $_;
@@ -139,18 +181,22 @@ for (my $line_num = 0 ; $line_num <= $#lines ; ++$line_num) {
     $item =~ s/\s+$//;                     # Trim trailing whitespace
     $item .= "\n";
 
-    while ($line_num < $#lines and ($line = $lines[++$line_num]) =~ /\S/) {
-      $line =~ s/^\s{$leading_ws_width}//; # Trim leading whitespace
-      $line =~ s/\s+$//;                   # Trim trailing whitespace
-      $item .= "$line\n";
+    unless ($in_major_component_versions_section) {
+      while ($line_num < $#lines and ($line = $lines[++$line_num]) =~ /\S/) {
+        $line =~ s/^\s{$leading_ws_width}//; # Trim leading whitespace
+        $line =~ s/\s+$//;                   # Trim trailing whitespace
+        $item .= "$line\n";
+      }
+    } else {
+      ++$line_num;
     }
     push @$items, $item;
-    --$line_num unless ($line_num == $#lines);
+    --$line_num unless ($line_num == $#lines && $lines[$line_num] !~ /^20/);
   } else { # $type is one of the bulleted types
     # List item boundary is another bullet or a blank line
     my $line;
     my $item = $_;
-    $item =~ s/^(\s*\Q$type\E\s*)//;           # Trim the leading bullet
+    $item =~ s/^(\s*\Q$type\E\s*)//;       # Trim the leading bullet
     my $leading_ws_width = length($1);
     $item =~ s/\s+$//;                     # Trim trailing whitespace
     $item .= "\n";
@@ -162,7 +208,7 @@ for (my $line_num = 0 ; $line_num <= $#lines ; ++$line_num) {
       $item .= "$line\n";
     }
     push @$items, $item;
-    --$line_num unless ($line_num == $#lines);
+    --$line_num unless ($line_num == $#lines && $lines[$line_num] !~ /^20/);
   }
 }
 
@@ -357,51 +403,71 @@ __HTML_HEADER__
 my $heading;
 my $relcnt = 0;
 my $header = 'h2';
+my $subheader = 'h3';
+
 for my $rel (@releases) {
-  if (++$relcnt == 3) {
+  if ($relcnt == 2) {
     $header = 'h3';
+    $subheader = 'h4';
     print "<h2><a id=\"older\" href=\"javascript:toggleList('older')\">";
     print "Older Releases";
     print "</a></h2>\n";
     print "<ul id=\"older.list\">\n"
   }
-      
+
   ($release, $reldate, $relinfo, $sections) = @$rel;
 
   # The first section heading is undefined for the older sectionless releases
   my $has_release_sections = has_release_sections($sections);
 
-  (my $relid = lc($release)) =~ s/\s+/_/g;
-  print "<$header><a id=\"$relid\" href=\"javascript:toggleList('$relid')\">";
-  print "Release " unless ($release =~ /^trunk$/i);
-  print "$release $relinfo";
-  print " [$reldate]" unless ($reldate eq 'unknown');
-  print "</a></$header>\n";
-  print "<ul id=\"$relid.list\">\n"
-    if ($has_release_sections);
+  my $relid = '';
+  if ($release) { # Pre-release sections have no release ID
+    ++$relcnt;
+    ($relid = lc($release)) =~ s/\s+/_/g;
+    print "<$header>";
+    print "<a id=\"$relid\" href=\"javascript:toggleList('$relid')\">"
+      unless ($release =~ /^20\d\d/);
+    print "Release " unless ($release =~ /^trunk$|^20\d\d/i);
+    print "$release $relinfo";
+    print " [$reldate]" unless ($reldate eq 'unknown' or not $reldate);
+    print "</a>" unless ($release =~ /^20\d\d/);
+    print "</$header>\n";
+    print "<ul id=\"$relid.list\">\n"
+      if ($has_release_sections);
+  }
 
   for my $section (@$sections) {
     ($heading, $items) = @$section;
     (my $sectid = lc($heading)) =~ s/\s+/_/g;
     my $numItemsStr = $#{$items} > 0 ? "($#{$items})" : "(none)";  
 
-    print "  <li><a id=\"$relid.$sectid\"",
-          " href=\"javascript:toggleList('$relid.$sectid')\">",
-          ($heading || ''), "</a>&nbsp;&nbsp;&nbsp;$numItemsStr\n"
-      if ($has_release_sections and $heading);
+    my $list_item = "li";
+    if ($release) {
+      if ($heading and $heading eq 'Detailed Change List') {
+        print "  <$subheader>$heading</$subheader>\n";
+        next;
+      } elsif ($has_release_sections and $heading) {
+        print "  <li><a id=\"$relid.$sectid\"",
+              " href=\"javascript:toggleList('$relid.$sectid')\">",
+              ($heading || ''), "</a>&nbsp;&nbsp;&nbsp;$numItemsStr\n"
+      }
+    } else {
+      print "<h2>$heading</h2>\n" if ($heading);
+      $list_item = "p";
+    }
 
     my $list_type = $items->[0] || '';
     my $list = ($has_release_sections || $list_type eq 'numbered' ? 'ol' : 'ul');
     my $listid = $sectid ? "$relid.$sectid" : $relid;
     print "    <$list id=\"$listid.list\">\n"
-      unless ($has_release_sections and not $heading);
+      unless (not $release or ($has_release_sections and not $heading));
 
     for my $itemnum (1..$#{$items}) {
       my $item = $items->[$itemnum];
-      $item =~ s:&:&amp;:g;               # Escape HTML metachars, but leave 
-      $item =~ s:<(?!/?code>):&lt;:gi;    #   <code> tags intact and add <pre>
-      $item =~ s:(?<!code)>:&gt;:gi;      #   wrappers for non-inline sections
-      $item =~ s{((?:^|.*\n)\s*)<code>(?!</code>.+)(.+)</code>(?![ \t]*\S)}
+      $item =~ s:&:&amp;:g;                       # Escape HTML metachars, but leave <code> tags
+      $item =~ s~<(?!/?code>(?:[^,]|$))~&lt;~gi;  #   intact - unless followed by a comma - and
+      $item =~ s:(?<!code)>:&gt;:gi;              #   add <pre> wrappers for non-inline sections
+      $item =~ s{((?:^|.*\n)\s*)<code>(?!,)(?!</code>.+)(.+)</code>(?![ \t]*\S)}
                 { 
                   my $prefix = $1; 
                   my $code = $2;
@@ -409,62 +475,67 @@ for my $rel (@releases) {
                   "$prefix<code><pre>$code</pre></code>"
                 }gise;
 
-      # Put attributions on their own lines.
-      # Check for trailing parenthesized attribution with no following period.
-      # Exclude things like "(see #3 above)" and "(use the bug number instead of xxxx)" 
-      unless ($item =~ s:\s*(\((?!see #|use the bug number)[^()"]+?\))\s*$:\n<br /><span class="attrib">$1</span>:) {
-        # If attribution is not found, then look for attribution with a
-        # trailing period, but try not to include trailing parenthesized things
-        # that are not attributions.
-        #
-        # Rule of thumb: if a trailing parenthesized expression with a following
-        # period does not contain "LUCENE-XXX", and it either has three or 
-        # fewer words or it includes the word "via" or the phrase "updates from",
-	    # then it is considered to be an attribution.
-
-        $item =~ s{(\s*(\((?!see \#|use the bug number)[^()"]+?\)))
-                   ((?:\.|(?i:\.?\s*Issue\s+\d{3,}|LUCENE-\d+)\.?)\s*)$}
-                  {
-                    my $subst = $1;  # default: no change
-                    my $parenthetical = $2;
-		                my $trailing_period_and_or_issue = $3;
-                    if ($parenthetical !~ /LUCENE-\d+/) {
-                      my ($no_parens) = $parenthetical =~ /^\((.*)\)$/s;
-                      my @words = grep {/\S/} split /\s+/, $no_parens;
-                      if ($no_parens =~ /\b(?:via|updates\s+from)\b/i || scalar(@words) <= 3) {
-                        $subst = "\n<br /><span class=\"attrib\">$parenthetical</span>";
-                      }
-                    }
-                    $subst . $trailing_period_and_or_issue;
-                  }ex;
-      }
+      $item = markup_trailing_attribution($item) unless ($item =~ /\n[ ]*-/);
 
       $item =~ s{(.*?)(<code><pre>.*?</pre></code>)|(.*)}
                 {
                   my $uncode = undef;
-                  if (defined($2)) {
-                    $uncode = $1 || '';
+                  my ($one,$two,$three) = ($1,$2,$3);
+                  if (defined($two)) {
+                    $uncode = $one || '';
+                    $uncode =~ s{^(.*?)(?=\n[ ]*-)}
+                                {
+                                  my $prefix = $1;
+                                  my ($primary,$additional_work) = $prefix =~ /^(.*?)((?:\s*Additional\s+Work:\s*)?)$/si;
+                                  my $result = markup_trailing_attribution($primary);
+                                  $result .= "<br />\n$additional_work<br />" if ($additional_work);
+                                  $result;
+                                }se;
                     $uncode =~ s{((?<=\n)[ ]*-.*\n(?:.*\n)*)}
                                 {
                                   my $bulleted_list = $1;
-                                  $bulleted_list 
+                                  $bulleted_list
                                     =~ s{(?:(?<=\n)|\A)[ ]*-[ ]*(.*(?:\n|\z)(?:[ ]+[^ -].*(?:\n|\z))*)}
-                                        {<li class="bulleted-list">\n$1</li>\n}g;
+                                        {
+                                            qq!<li class="bulleted-list">\n!
+                                          . markup_trailing_attribution($1)
+                                          . "</li>\n"
+                                        }ge;
                                   $bulleted_list
-                                    =~ s!(<li.*</li>\n)!<ul class="bulleted-list">\n$1</ul>\n!s;
+                                    =~ s{(<li.*</li>\n)(.*)}
+                                        {
+                                            qq!<ul class="bulleted-list">\n$1</ul>\n!
+                                          . markup_trailing_attribution($2 || '')
+                                        }se;
                                   $bulleted_list;
                                 }ge;
-                    "$uncode$2";
+                    "$uncode$two";
                   } else {
-                    $uncode = $3 || '';
+                    $uncode = $three || '';
+                    $uncode =~ s{^(.*?)(?=\n[ ]*-)}
+                                {
+                                  my $prefix = $1;
+                                  my ($primary,$additional_work) = $prefix =~ /^(.*?)((?:\s*Additional\s+Work:\s*)?)$/si;
+                                  my $result = markup_trailing_attribution($primary);
+                                  $result .= "<br />\n$additional_work<br />" if ($additional_work);
+                                  $result;
+                                }se;
                     $uncode =~ s{((?<=\n)[ ]*-.*\n(?:.*\n)*)}
                                 {
                                   my $bulleted_list = $1;
-                                  $bulleted_list 
+                                  $bulleted_list
                                     =~ s{(?:(?<=\n)|\A)[ ]*-[ ]*(.*(?:\n|\z)(?:[ ]+[^ -].*(?:\n|\z))*)}
-                                        {<li class="bulleted-list">\n$1</li>\n}g;
+                                        {
+                                            qq!<li class="bulleted-list">\n!
+                                          . markup_trailing_attribution($1)
+                                          . "</li>\n"
+                                        }ge;
                                   $bulleted_list
-                                    =~ s!(<li.*</li>\n)!<ul class="bulleted-list">\n$1</ul>\n!s;
+                                    =~ s{(<li.*</li>\n)(.*)}
+                                        {
+                                            qq!<ul class="bulleted-list">\n$1</ul>\n!
+                                          . markup_trailing_attribution($2 || '')
+                                        }se;
                                   $bulleted_list;
                                 }ge;
                     $uncode;
@@ -480,49 +551,119 @@ for my $rel (@releases) {
       # Link Lucene XXX, SOLR XXX and INFRA XXX to JIRA
       $item =~ s{((LUCENE|SOLR|INFRA)\s+(\d{3,}))}
                 {<a href="${jira_url_prefix}\U$2\E-$3">$1</a>}gi;
-      # Find single Bugzilla issues
-      $item =~ s~((?i:bug|patch|issue)\s*\#?\s*(\d+))
-                ~ my $issue = $1;
-                  my $jira_issue_num = $bugzilla_jira_map{$2}; # Link to JIRA copies
-                  $issue = qq!<a href="${jira_url_prefix}LUCENE-$jira_issue_num">!
-                         . qq!$issue&nbsp;[LUCENE-$jira_issue_num]</a>!
-                    if (defined($jira_issue_num));
-                  $issue;
-                ~gex;
-      # Find multiple Bugzilla issues
-      $item =~ s~(?<=(?i:bugs))(\s*)(\d+)(\s*(?i:\&|and)\s*)(\d+)
-		            ~ my $leading_whitespace = $1;
-		              my $issue_num_1 = $2;
-		              my $interlude = $3;
-                  my $issue_num_2 = $4;
-                  # Link to JIRA copies
-                  my $jira_issue_1 = $bugzilla_jira_map{$issue_num_1};
-                  my $issue1
-		                  = qq!<a href="${jira_url_prefix}LUCENE-$jira_issue_1">!
-                      . qq!$issue_num_1&nbsp;[LUCENE-$jira_issue_1]</a>!
-                    if (defined($jira_issue_1));
-                  my $jira_issue_2 = $bugzilla_jira_map{$issue_num_2};
-                  my $issue2
-		                  = qq!<a href="${jira_url_prefix}LUCENE-$jira_issue_2">!
-                      . qq!$issue_num_2&nbsp;[LUCENE-$jira_issue_2]</a>!
-                    if (defined($jira_issue_2));
-                  $leading_whitespace . $issue1 . $interlude . $issue2;
-                ~gex;
+      if ($product eq 'LUCENE') {
+        # Find single Bugzilla issues
+        $item =~ s~((?i:bug|patch|issue)\s*\#?\s*(\d+))
+                  ~ my $issue = $1;
+                    my $jira_issue_num = $lucene_bugzilla_jira_map{$2}; # Link to JIRA copies
+                    $issue = qq!<a href="${jira_url_prefix}LUCENE-$jira_issue_num">!
+                           . qq!$issue&nbsp;[LUCENE-$jira_issue_num]</a>!
+                      if (defined($jira_issue_num));
+                    $issue;
+                  ~gex;
+        # Find multiple Bugzilla issues
+        $item =~ s~(?<=(?i:bugs))(\s*)(\d+)(\s*(?i:\&|and)\s*)(\d+)
+		              ~ my $leading_whitespace = $1;
+		                my $issue_num_1 = $2;
+		                my $interlude = $3;
+                    my $issue_num_2 = $4;
+                    # Link to JIRA copies
+                    my $jira_issue_1 = $lucene_bugzilla_jira_map{$issue_num_1};
+                    my $issue1
+		                    = qq!<a href="${jira_url_prefix}LUCENE-$jira_issue_1">!
+                        . qq!$issue_num_1&nbsp;[LUCENE-$jira_issue_1]</a>!
+                      if (defined($jira_issue_1));
+                    my $jira_issue_2 = $lucene_bugzilla_jira_map{$issue_num_2};
+                    my $issue2
+		                    = qq!<a href="${jira_url_prefix}LUCENE-$jira_issue_2">!
+                        . qq!$issue_num_2&nbsp;[LUCENE-$jira_issue_2]</a>!
+                      if (defined($jira_issue_2));
+                    $leading_whitespace . $issue1 . $interlude . $issue2;
+                  ~gex;
+      }
 
       # Linkify URLs, except Bugzilla links, which don't work anymore
-      $item =~ s~(?<![">])(https?://(?!(?:nagoya|issues)\.apache\.org/bugzilla)\S+)~<a href="$1">$1</a>~g;
+      $item =~ s~(?<![">])(https?://(?!(?:nagoya|issues)\.apache\.org/bugzilla)[^\s\)]+)~<a href="$1">$1</a>~g;
 
-      print "      <li>$item</li>\n";
+      $item =~ s~</ul>\s+<p/>\s+<br\s*/>~</ul>~;
+
+      print "      <$list_item>$item</$list_item>\n";
     }
-    print "    </$list>\n" unless ($has_release_sections and not $heading);
-    print "  </li>\n" if ($has_release_sections);
+    print "    </$list>\n" unless (not $release or ($has_release_sections and not $heading));
+    print "  </li>\n" if ($release and $has_release_sections);
   }
-  print "</ul>\n" if ($has_release_sections);
+  print "</ul>\n" if ($release and $has_release_sections);
 }
 print "</ul>\n" if ($relcnt > 3);
 print "</body>\n</html>\n";
 
 
+# Subroutine: markup_trailing_attribution
+#
+# Takes one parameter:
+#
+#   - text possibly containing a trailing parenthesized attribution
+#
+# Returns one scalar:
+#
+#   - text with the the trailing attribution, if any, marked up with the color green
+#
+sub markup_trailing_attribution {
+  my $item = shift;
+
+  # Put attributions on their own lines.
+  # Check for trailing parenthesized attribution with no following period.
+  # Exclude things like "(see #3 above)" and "(use the bug number instead of xxxx)"
+  unless ($item =~ s{\s*(\((?![Ss]ee )
+                           (?!spans\b)
+                           (?!mainly\ )
+                           (?!LUCENE-\d+\))
+                           (?!and\ )
+                           (?!backported\ )
+                           (?!in\ )
+                           (?!inverse\ )
+                           (?![Tt]he\ )
+                           (?!use\ the\ bug\ number)
+                     [^()"]+?\))\s*$}
+                    {\n<br /><span class="attrib">$1</span>}x) {
+    # If attribution is not found, then look for attribution with a
+    # trailing period, but try not to include trailing parenthesized things
+    # that are not attributions.
+    #
+    # Rule of thumb: if a trailing parenthesized expression with a following
+    # period does not contain "LUCENE-XXX", and it either has three or
+    # fewer words or it includes the word "via" or the phrase "updates from",
+	  # then it is considered to be an attribution.
+
+    $item =~ s{(\s*(\((?![Ss]ee\ )
+                      (?!spans\b)
+                      (?!mainly\ )
+                      (?!LUCENE-\d+\))
+                      (?!and\ )
+                      (?!backported\ )
+                      (?!in\ )
+                      (?!inverse\ )
+                      (?![Tt]he\ )
+                      (?!use\ the\ bug\ number)
+                 [^()"]+?\)))
+                ((?:\.|(?i:\.?\s*Issue\s+\d{3,}|LUCENE-\d+)\.?)\s*)$}
+              {
+                my $subst = $1;  # default: no change
+                my $parenthetical = $2;
+	              my $trailing_period_and_or_issue = $3;
+                if ($parenthetical !~ /LUCENE-\d+/) {
+                  my ($no_parens) = $parenthetical =~ /^\((.*)\)$/s;
+                  my @words = grep {/\S/} split /\s+/, $no_parens;
+                  if ($no_parens =~ /\b(?:via|updates\s+from)\b/i || scalar(@words) <= 4) {
+                    $subst = "\n<br /><span class=\"attrib\">$parenthetical</span>";
+                  }
+                }
+                $subst . $trailing_period_and_or_issue;
+              }ex;
+  }
+  return $item;
+}
+
 #
 # Subroutine: has_release_sections
 #
@@ -636,6 +777,8 @@ sub get_release_date {
     # Handle '1.2 RC6', which should be '1.2 final'
     $release = '1.2 final' if ($release eq '1.2 RC6');
 
+    $release =~ s/\.0\.0/\.0/;
+
     $reldate = ( exists($release_dates{$release}) 
                ? $release_dates{$release}
                : 'unknown');
@@ -658,7 +801,9 @@ sub get_release_date {
 # as well as those named "final" are included below.
 #
 sub setup_release_dates {
-  my %release_dates
+  my %release_dates;
+  if (uc($product) eq 'LUCENE') {
+    %release_dates
        = ( '0.01' => '2000-03-30',      '0.04' => '2000-04-19',
            '1.0' => '2000-10-04',       '1.01b' => '2001-06-02',
            '1.2 RC1' => '2001-10-02',   '1.2 RC2' => '2001-10-19',
@@ -677,9 +822,11 @@ sub setup_release_dates {
            '2.4.0' => '2008-10-06',     '2.4.1' => '2009-03-09',
            '2.9.0' => '2009-09-23',     '2.9.1' => '2009-11-06',
            '3.0.0' => '2009-11-25');
+  }
+
+  print STDERR "Retrieving $project_info_url/$product ...\n";
+  my $project_info_json = get_url_contents("$project_info_url/$product");
 
-  my $project_info_json = get_url_contents($project_info_url);
-  
   my $project_info = json2perl($project_info_json);
   for my $version (@{$project_info->{versions}}) {
     if ($version->{releaseDate}) {
@@ -750,12 +897,12 @@ sub setup_month_nums {
 
 
 #
-# setup_bugzilla_jira_map
+# setup_lucene_bugzilla_jira_map
 #
 # Returns a list of alternating Bugzilla bug IDs and LUCENE-* JIRA issue
-# numbers, for use in populating the %bugzilla_jira_map hash
+# numbers, for use in populating the %lucene_bugzilla_jira_map hash
 #
-sub setup_bugzilla_jira_map {
+sub setup_lucene_bugzilla_jira_map {
   return (  4049 =>   1,  4102 =>   2,  4105 =>   3,  4254 =>   4,
             4555 =>   5,  4568 =>   6,  4754 =>   7,  5313 =>   8,
             5456 =>   9,  6078 =>  10,  6091 =>  11,  6140 =>  12,
@@ -879,7 +1026,14 @@ sub json2perl {
   my $json_string = shift;
   $json_string =~ s/(:\s*)(true|false)/$1"$2"/g;
   $json_string =~ s/":/",/g;
-  return eval $json_string;
+  $json_string =~ s/\'/\\'/g;
+  $json_string =~ s/\"/\'/g;
+  my $project_info = eval $json_string;
+  die "ERROR eval'ing munged JSON string ||$json_string||: $@\n"
+    if ($@);
+  die "ERROR empty value after eval'ing JSON string ||$json_string||\n"
+    unless $project_info;
+  return $project_info;
 }
 
 1;
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index cda1222..572ae2e 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -103,6 +103,10 @@ Other Changes
 
 * SOLR-3707: Upgrade Solr to Tika 1.2 (janhoy)
 
+* SOLR-2747: Updated changes2html.pl to handle Solr's CHANGES.txt; added
+  target 'changes-to-html' to solr/build.xml.
+  (Steve Rowe, Robert Muir)
+
 ==================  4.0.0-BETA ===================
 
 
@@ -237,7 +241,7 @@ Bug Fixes
 
 * SOLR-3660: Velocity: Link to admin page broken (janhoy)
 
-* SOLR-3658: Adding thousands of docs with one UpdateProcessorChain instance can briefly create 
+* SOLR-3658: Adding thousands of docs with one UpdateProcessorChain instance can briefly create
   spikes of threads in the thousands. (yonik, Mark Miller)
 
 * SOLR-3656: A core reload now always uses the same dataDir.  (Mark Miller, yonik)
@@ -311,6 +315,7 @@ Other Changes
   Also, the configuration itself can be passed using the "dataConfig" parameter rather than
   using a file (this previously worked in debug mode only).  When configuration errors are 
   encountered, the error message is returned in XML format.  (James Dyer)
+  
 * SOLR-3439: Make SolrCell easier to use out of the box. Also improves "/browse" to display
   rich-text documents correctly, along with facets for author and content_type.  
   With the new "content" field, highlighting of body is supported. See also SOLR-3672 for
@@ -424,26 +429,26 @@ New Features
   built-in load balancing, and distributed indexing. 
   (Jamie Johnson, Sami Siren, Ted Dunning, yonik, Mark Miller)
   Additional Work:
-  SOLR-2324: SolrCloud solr.xml parameters are not persisted by CoreContainer.
-  (Massimo Schiavon, Mark Miller)
-  SOLR-2287: Allow users to query by multiple, compatible collections with SolrCloud.
-  (Soheb Mahmood, Alex Cowell, Mark Miller)
-  SOLR-2622: ShowFileRequestHandler does not work in SolrCloud mode. 
-  (Stefan Matheis, Mark Miller)
-  SOLR-3108: Error in SolrCloud's replica lookup code when replica's are hosted in same Solr instance.
-  (Bruno Dumon, Sami Siren, Mark Miller)
-  SOLR-3080: Remove shard info from zookeeper when SolrCore is explicitly unloaded.
-  (yonik, Mark Miller, siren)
-  SOLR-3437: Recovery issues a spurious commit to the cluster. (Trym R. MÃ¸ller via Mark Miller)
-  SOLR-2822: Skip update processors already run on other nodes (hossman)
+  - SOLR-2324: SolrCloud solr.xml parameters are not persisted by CoreContainer.
+    (Massimo Schiavon, Mark Miller)
+  - SOLR-2287: Allow users to query by multiple, compatible collections with SolrCloud.
+    (Soheb Mahmood, Alex Cowell, Mark Miller)
+  - SOLR-2622: ShowFileRequestHandler does not work in SolrCloud mode.
+    (Stefan Matheis, Mark Miller)
+  - SOLR-3108: Error in SolrCloud's replica lookup code when replica's are hosted in same Solr instance.
+    (Bruno Dumon, Sami Siren, Mark Miller)
+  - SOLR-3080: Remove shard info from zookeeper when SolrCore is explicitly unloaded.
+    (yonik, Mark Miller, siren)
+  - SOLR-3437: Recovery issues a spurious commit to the cluster. (Trym R. MÃ¸ller via Mark Miller)
+  - SOLR-2822: Skip update processors already run on other nodes (hossman)
 
 * SOLR-1566: Transforming documents in the ResponseWriters.  This will allow
   for more complex results in responses and open the door for function queries
   as results. 
-  (ryan with patches from grant, noble, cmale, yonik, Jan HÃ¸ydahl, 
+  (ryan with patches from grant, noble, cmale, yonik, Jan HÃ¸ydahl,
   Arul Kalaipandian, Luca Cavanna, hossman)
-  SOLR-2037: Thanks to SOLR-1566, documents boosted by the QueryElevationComponent
-  can be marked as boosted.  (gsingers, ryan, yonik)
+  - SOLR-2037: Thanks to SOLR-1566, documents boosted by the QueryElevationComponent
+    can be marked as boosted.  (gsingers, ryan, yonik)
 
 * SOLR-2396: Add CollationField, which is much more efficient than 
   the Solr 3.x CollationKeyFilterFactory, and also supports 
@@ -459,10 +464,10 @@ New Features
   (Jan HÃ¸ydahl via yonik)
 
 * SOLR-2272: Pseudo-join queries / filters.  Examples:
-  To restrict to the set of parents with at least one blue-eyed child:
-    fq={!join from=parent to=name}eyes:blue
-  To restrict to the set of children with at least one blue-eyed parent:
-    fq={!join from=name to=parent}eyes:blue
+  - To restrict to the set of parents with at least one blue-eyed child:
+      fq={!join from=parent to=name}eyes:blue
+  - To restrict to the set of children with at least one blue-eyed parent:
+      fq={!join from=name to=parent}eyes:blue
   (yonik)
 
 * SOLR-1942: Added the ability to select postings format per fieldType in schema.xml
@@ -509,12 +514,12 @@ New Features
 * SOLR-2703: Added support for Lucene's "surround" query parser. (Simon Rosenthal, ehatcher)
 
 * SOLR-2754: Added factories for several ranking algorithms: 
-    BM25SimilarityFactory: Okapi BM25
-    DFRSimilarityFactory: Divergence from Randomness models
-    IBSimilarityFactory: Information-based models
-    LMDirichletSimilarity: LM with Dirichlet smoothing
-    LMJelinekMercerSimilarity: LM with Jelinek-Mercer smoothing
- (David Mark Nemeskey, Robert Muir)
+    - BM25SimilarityFactory: Okapi BM25
+    - DFRSimilarityFactory: Divergence from Randomness models
+    - IBSimilarityFactory: Information-based models
+    - LMDirichletSimilarity: LM with Dirichlet smoothing
+    - LMJelinekMercerSimilarity: LM with Jelinek-Mercer smoothing
+  (David Mark Nemeskey, Robert Muir)
  
 * SOLR-2134 Trie* fields should support sortMissingLast=true, and deprecate Sortable* Field Types
   (Ryan McKinley, Mike McCandless, Uwe Schindler, Erick Erickson)
@@ -537,18 +542,18 @@ New Features
 * SOLR-2802: New FieldMutatingUpdateProcessor and Factory to simplify the
   development of UpdateProcessors that modify field values of documents as 
   they are indexed. Also includes several useful new implementations:
-      RemoveBlankFieldUpdateProcessorFactory
-      TrimFieldUpdateProcessorFactory
-      HTMLStripFieldUpdateProcessorFactory
-      RegexReplaceProcessorFactory
-      FieldLengthUpdateProcessorFactory
-      ConcatFieldUpdateProcessorFactory
-      FirstFieldValueUpdateProcessorFactory
-      LastFieldValueUpdateProcessorFactory
-      MinFieldValueUpdateProcessorFactory
-      MaxFieldValueUpdateProcessorFactory
-      TruncateFieldUpdateProcessorFactory
-      IgnoreFieldUpdateProcessorFactory 
+    - RemoveBlankFieldUpdateProcessorFactory
+    - TrimFieldUpdateProcessorFactory
+    - HTMLStripFieldUpdateProcessorFactory
+    - RegexReplaceProcessorFactory
+    - FieldLengthUpdateProcessorFactory
+    - ConcatFieldUpdateProcessorFactory
+    - FirstFieldValueUpdateProcessorFactory
+    - LastFieldValueUpdateProcessorFactory
+    - MinFieldValueUpdateProcessorFactory
+    - MaxFieldValueUpdateProcessorFactory
+    - TruncateFieldUpdateProcessorFactory
+    - IgnoreFieldUpdateProcessorFactory
   (hossman, janhoy)
 
 * SOLR-3120: Optional post filtering for spatial queries bbox and geofilt
@@ -562,8 +567,8 @@ New Features
 
 * SOLR-2898: Support grouped faceting. (Martijn van Groningen)
   Additional Work:
-  SOLR-3406: Extended grouped faceting support to facet.query and facet.range parameters.
-             (David Boychuck, Martijn van Groningen)
+  - SOLR-3406: Extended grouped faceting support to facet.query and facet.range parameters.
+               (David Boychuck, Martijn van Groningen)
 
 * SOLR-2949: QueryElevationComponent is now supported with distributed search.
   (Mark Miller, yonik)
@@ -646,9 +651,9 @@ New Features
 
 * SOLR-3508: Simplify JSON update format for deletes as well as allow
   version specification for optimistic locking.  Examples:
-    {"delete":"myid"}
-    {"delete":["id1","id2","id3"]}
-    {"delete":{"id":"myid", "_version_":123456789}}
+    - {"delete":"myid"}
+    - {"delete":["id1","id2","id3"]}
+    - {"delete":{"id":"myid", "_version_":123456789}}
   (yonik)
 
 * SOLR-3211:  Allow parameter overrides in conjunction with "spellcheck.maxCollationTries".
@@ -692,9 +697,9 @@ Optimizations
   works with SolrCore to provide faster 'soft' commits, and has an improved API 
   that requires less instanceof special casing. (Mark Miller, Robert Muir)
   Additional Work:
-  SOLR-2697: commit and autocommit operations don't reset 
-  DirectUpdateHandler2.numDocsPending stats attribute.
-  (Alexey Serba, Mark Miller)
+  - SOLR-2697: commit and autocommit operations don't reset
+    DirectUpdateHandler2.numDocsPending stats attribute.
+    (Alexey Serba, Mark Miller)
 
 * SOLR-2950: The QueryElevationComponent now avoids using the FieldCache and looking up
   every document id (gsingers, yonik)
@@ -739,8 +744,8 @@ Bug Fixes
 * SOLR-2193, SOLR-2565, SOLR-2651: SolrCores now properly share IndexWriters across SolrCore reloads.
   (Mark Miller, Robert Muir)
   Additional Work:
-  SOLR-2705: On reload, IndexWriterProvider holds onto the initial SolrCore it was created with.
-  (Yury Kats, Mark Miller)
+  - SOLR-2705: On reload, IndexWriterProvider holds onto the initial SolrCore it was created with.
+    (Yury Kats, Mark Miller)
 
 * SOLR-2682: Remove addException() in SimpleFacet. FacetComponent no longer catches and embeds
   exceptions occurred during facet processing, it throws HTTP 400 or 500 exceptions instead. (koji)
@@ -919,7 +924,7 @@ Other Changes
 * SOLR-2607: Removed deprecated client/ruby directory, which included solr-ruby and flare.
   (ehatcher)
   
-* Solr-3032: logOnce from SolrException logOnce and all the supporting
+* SOLR-3032: logOnce from SolrException logOnce and all the supporting
   structure is gone. abortOnConfugrationError is also gone as it is no longer referenced.
   Errors should be caught and logged at the top-most level or logged and NOT propagated up the 
   chain. (Erick Erickson)
@@ -999,7 +1004,7 @@ More information about this release, including any errata related to the
 release notes, upgrade instructions, or other changes may be found online at:
    https://wiki.apache.org/solr/Solr3.6.1
 
-Bug Fixes:
+Bug Fixes
 
 * LUCENE-3969: Throw IAE on bad arguments that could cause confusing errors in
   PatternTokenizer. CommonGrams populates PositionLengthAttribute correctly.
@@ -1174,7 +1179,7 @@ New Features
 * SOLR-2001: The query component will substitute an empty query that matches
   no documents if the query parser returns null.  This also prevents an
   exception from being thrown by the default parser if "q" is missing. (yonik)
-  SOLR-435: if q is "" then it's also acceptable. (dsmiley, hoss)
+  - SOLR-435: if q is "" then it's also acceptable. (dsmiley, hoss)
 
 * SOLR-2919: Added parametric tailoring options to ICUCollationKeyFilterFactory.
   These can be used to customize range query/sort behavior, for example to
@@ -1557,7 +1562,7 @@ Bug Fixes
 * SOLR-2875: Fix the incorrect url in DIH example tika-data-config.xml 
   (Shinichiro Abe via koji)
 
- Other Changes
+Other Changes
 ----------------------
 
 * SOLR-2750: Make both "update.chain" and the deprecated "update.param" work
@@ -1767,7 +1772,7 @@ Bug Fixes
 * SOLR-2668: DIH multithreaded mode does not rollback on errors from 
   EntityProcessor (Frank Wesemann, shalin)
 
- Other Changes
+Other Changes
 ----------------------
 
 * SOLR-2629: Eliminate deprecation warnings in some JSPs.
@@ -2913,10 +2918,10 @@ Use of the "charset" option when configuring the following Analysis
 Factories has been deprecated and will cause a warning to be logged.
 In future versions of Solr attempting to use this option will cause an
 error.  See SOLR-1410 for more information.
- * GreekLowerCaseFilterFactory
- * RussianStemFilterFactory
- * RussianLowerCaseFilterFactory
- * RussianLetterTokenizerFactory
+ - GreekLowerCaseFilterFactory
+ - RussianStemFilterFactory
+ - RussianLowerCaseFilterFactory
+ - RussianLetterTokenizerFactory
 
 DIH: Evaluator API has been changed in a non back-compatible way. Users who 
 have developed custom Evaluators will need to change their code according to 
@@ -2993,7 +2998,7 @@ New Features
  7. SOLR-680: Add StatsComponent. This gets simple statistics on matched numeric fields,
     including: min, max, mean, median, stddev.  (koji, ryan)
 
-    7.1 SOLR-1380: Added support for multi-valued fields (Harish Agarwal via gsingers)
+    - SOLR-1380: Added support for multi-valued fields (Harish Agarwal via gsingers)
 
  8. SOLR-561: Added Replication implemented in Java as a request handler. Supports index replication
     as well as configuration replication and exposes detailed statistics and progress information
@@ -3514,11 +3519,12 @@ Bug Fixes
 28. SOLR-1008: Fix stats.jsp XML encoding for <stat> item entries with ampersands in their names.  (ehatcher)
 
 29. SOLR-976: deleteByQuery is ignored when deleteById is placed prior to deleteByQuery in a <delete>.
-    Now both delete by id and delete by query can be specified at the same time as follows. (koji)
+    Now both delete by id and delete by query can be specified at the same time as follows.
       <delete>
         <id>05991</id><id>06000</id>
         <query>office:Bridgewater</query><query>office:Osaka</query>
       </delete>
+    (koji)
 
 30. SOLR-1016: HTTP 503 error changes 500 in SolrCore (koji)
 
@@ -3777,7 +3783,7 @@ Other Changes
  8. SOLR-875: Upgraded to Lucene 2.9-dev (r723985) and consolidated the BitSet implementations (Michael Busch, gsingers)
 
  9. SOLR-819: Upgraded to Lucene 2.9-dev (r724059) to get access to Arabic public constructors (gsingers)
-                                                 and
+
 10. SOLR-900: Moved solrj into /src/solrj.  The contents of solr-common.jar is now included
     in the solr-solrj.jar. (ryan)
 
@@ -3861,10 +3867,10 @@ Other Changes
     (hossman)
 
 42. Upgraded to Lucene 2.9-dev r794238. Other changes include:
-    LUCENE-1614 - Use Lucene's DocIdSetIterator.NO_MORE_DOCS as the sentinel value.
-    LUCENE-1630 - Add acceptsDocsOutOfOrder method to Collector implementations.
-    LUCENE-1673, LUCENE-1701 - Trie has moved to Lucene core and renamed to NumericRangeQuery.
-    LUCENE-1662, LUCENE-1687 - Replace usage of ExtendedFieldCache by FieldCache.
+    - LUCENE-1614 - Use Lucene's DocIdSetIterator.NO_MORE_DOCS as the sentinel value.
+    - LUCENE-1630 - Add acceptsDocsOutOfOrder method to Collector implementations.
+    - LUCENE-1673, LUCENE-1701 - Trie has moved to Lucene core and renamed to NumericRangeQuery.
+    - LUCENE-1662, LUCENE-1687 - Replace usage of ExtendedFieldCache by FieldCache.
     (shalin)
 
 42. SOLR-1241: Solr's CharFilter has been moved to Lucene. Remove CharFilter and related classes
@@ -3874,7 +3880,7 @@ Other Changes
 
 44. Upgraded to Lucene 2.9-dev r801856 (Mark Miller)
 
-45. SOLR1276: Added StatsComponentTest (Rafaï¿½Å? Kuï¿½Ä?, gsingers)
+45. SOLR-1276: Added StatsComponentTest (Rafa? Ku?, gsingers)
 
 46. SOLR-1377:  The TokenizerFactory API has changed to explicitly return a Tokenizer 
     rather then a TokenStream (that may be or may not be a Tokenizer).  This change 
@@ -3971,7 +3977,7 @@ Build
 
 Documentation
 ----------------------
- 1. SOLR-789: The javadoc of RandomSortField is not readable (Nicolas Lalevï¿½Ã?¿½e via koji)
+ 1. SOLR-789: The javadoc of RandomSortField is not readable (Nicolas LalevÃ©e via koji)
 
  2. SOLR-962: Note about null handling in ModifiableSolrParams.add javadoc
     (Kay Kay via hossman)
@@ -4016,8 +4022,8 @@ example solrconfig.xml) for more details...
 In Solr 1.2, DateField did not enforce the canonical representation of
 the ISO 8601 format when parsing incoming data, and did not generation
 the canonical format when generating dates from "Date Math" strings
-(particularly as it pertains to milliseconds ending in trailing zeros)
--- As a result equivalent dates could not always be compared properly.
+(particularly as it pertains to milliseconds ending in trailing zeros).
+As a result equivalent dates could not always be compared properly.
 This problem is corrected in Solr 1.3, but DateField users that might
 have been affected by indexing inconsistent formats of equivilent
 dates (ie: 1995-12-31T23:59:59Z vs 1995-12-31T23:59:59.000Z) may want
@@ -4340,7 +4346,7 @@ Changes in runtime behavior
 
  2. SOLR-689 / SOLR-695: If you have used "MultiCore" functionality in an unreleased
     version of 1.3-dev, many classes and configs have been renamed for the official 
-    1.3 release.  Speciffically, solr.xml has replaced multicore.xml, and uses a slightly 
+    1.3 release.  Speciffically, solr.xml has replaced multicore.xml, and uses a slightly
     different syntax.  The solrj classes: MultiCore{Request/Response/Params} have been 
     renamed:  CoreAdmin{Request/Response/Params}  (hossman, ryan, Henri Biestro)
 
@@ -4419,7 +4425,7 @@ Bug Fixes
  9. SOLR-294: Logging of elapsed time broken on Solaris because the date command
     there does not support the %s output format.  (bill)
 
-10. SOLR-136: Snappuller - "date -d" and locales don't mix.  (Jï¿½Ã?¿½rgen Hermann via    bill)
+10. SOLR-136: Snappuller - "date -d" and locales don't mix.  (JÃ¼rgen Hermann via bill)
 
 11. SOLR-333: Changed distributiondump.jsp to use Solr HOME instead of CWD to set path.
  
@@ -4469,8 +4475,8 @@ Bug Fixes
 27. SOLR-267: Changed logging to report number of hits, and also provide a mechanism to add log 
     messages to be output by the SolrCore via a NamedList toLog member variable.  
     (Will Johnson, yseeley, gsingers)
-    
-    SOLR-267: Removed adding values to the HTTP headers in SolrDispatchFilter (gsingers)
+
+    - SOLR-267: Removed adding values to the HTTP headers in SolrDispatchFilter (gsingers)
 
 28. SOLR-509: Moved firstSearcher event notification to the end of the SolrCore constructor 
     (Koji Sekiguchi via gsingers)
diff --git a/solr/build.xml b/solr/build.xml
index 80b12b2..8652786 100644
--- a/solr/build.xml
+++ b/solr/build.xml
@@ -320,6 +320,9 @@
     <!-- Exclude clover license files incompatible with the ASL -->
     <delete dir="${svn.export.dir}/lucene/tools/clover"/>
 
+    <build-changes changes.src.dir="${svn.export.dir}/site/changes"
+                   changes.target.dir="${svn.export.dir}/docs/changes"/>
+
     <tar destfile="${source.package.file}" compression="gzip" longfile="gnu">
       <tarfileset dir="${svn.export.dir}"
                   prefix="${fullnamever}"
@@ -368,7 +371,7 @@
 
   <target name="create-package"
           description="Packages the Solr Binary Distribution"
-          depends="init-dist, dist, example, javadocs">
+          depends="init-dist, dist, example, javadocs, changes-to-html">
     <mkdir dir="${dest}/${fullnamever}"/>
     <delete includeemptydirs="true">
       <fileset dir="${example}/solr-webapp" includes="**/*"/>
@@ -444,6 +447,10 @@
     </zip>
     <make-checksums file="${package.dir}/${fullnamever}.zip"/>
   </target>
+
+  <target name="changes-to-html">
+    <build-changes changes.src.dir="${changes.src.dir}" changes.target.dir="${changes.target.dir}" />
+  </target>
  
   <target name="sign-artifacts">
     <sign-artifacts-macro artifacts.dir="${package.dir}"/>
diff --git a/solr/common-build.xml b/solr/common-build.xml
index 3493cdd..3ff864c 100644
--- a/solr/common-build.xml
+++ b/solr/common-build.xml
@@ -49,6 +49,8 @@
   <property name="tests.loggingfile" value="${common-solr.dir}/testlogging.properties"/>
   <property name="tests.cleanthreads.sysprop" value="perClass"/>
 
+  <property name="changes.target.dir" value="${dest}/docs/changes"/>
+
   <import file="${common-solr.dir}/../lucene/module-build.xml"/>
 
   <path id="additional.dependencies">

