STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/BaseTokenStreamTestCase.java,run,481-481,[      } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/BaseTokenStreamTestCase.java,copyTo,107-107,[      ((CheckClearAttributesAttributeImpl) target).clear();],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/CannedBinaryTokenStream.java,copyTo,106-106,[      BinaryTermAttributeImpl other = (BinaryTermAttributeImpl) target;],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/lucene/analysis/CannedBinaryTokenStream.java,,131-131,[      offsetAtt.setOffset(token.startOffset, token.endOffset);],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/lucene/analysis/CannedBinaryTokenStream.java,,131-131,[      offsetAtt.setOffset(token.startOffset, token.endOffset);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/analysis/CollationTestBase.java,assertMatches,155-166,[    ScoreDoc[] result = searcher.search(query, null, 1000, sort).scoreDocs;,     StringBuilder buff = new StringBuilder(10);,     int n = result.length;,     for (int i = 0 ; i < n ; ++i) {,       StoredDocument doc = searcher.doc(result[i].doc);,       StorableField[] v = doc.getFields("tracer");,       for (int j = 0 ; j < v.length ; ++j) {,         buff.append(v[j].stringValue());,       },     },     assertEquals(expectedResult, buff.toString());,   }],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/analysis/CollationTestBase.java,,54-54,[  protected String firstRangeBeginningOriginal = "\u062F";],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/analysis/CollationTestBase.java,,55-55,[  protected String firstRangeEndOriginal = "\u0698";],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/analysis/CollationTestBase.java,,57-57,[  protected String secondRangeBeginningOriginal = "\u0633";],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/analysis/CollationTestBase.java,,58-58,[  protected String secondRangeEndOriginal = "\u0638";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/analysis/CollationTestBase.java,,194-215,[      threads[i] = new Thread() {,         @Override,         public void run() {,           try {,             for (Map.Entry<String,BytesRef> mapping : map.entrySet()) {,               String term = mapping.getKey();,               BytesRef expected = mapping.getValue();,               try (TokenStream ts = analyzer.tokenStream("fake", term)) {,                 TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);,                 BytesRef bytes = termAtt.getBytesRef();,                 ts.reset();,                 assertTrue(ts.incrementToken());,                 termAtt.fillBytesRef();,                 assertEquals(expected, bytes);,                 assertFalse(ts.incrementToken());,                 ts.end();,               },             },           } catch (IOException e) {,             throw new RuntimeException(e);,           },         }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/MockAnalyzer.java,maybePayload,103-108,[        switch(random.nextInt(3)) {,           case 0: val = -1; // no payloads,                   break;,           case 1: val = Integer.MAX_VALUE; // variable length payload,                   break;,           case 2: val = random.nextInt(12); // fixed length payload],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/lucene/analysis/MockPayloadAnalyzer.java,incrementToken,74-74,[      if (pos == 0 || i % 2 == 1) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/MockPayloadAnalyzer.java,,61-61,[    this.fieldName = fieldName;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/MockPayloadAnalyzer.java,,66-66,[    termAttr = input.addAttribute(CharTermAttribute.class);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/lucene/analysis/MockRandomLookaheadTokenFilter.java,incrementToken,82-82,[    if (result) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/MockRandomLookaheadTokenFilter.java,,32-32,[  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/Token.java,copyTo,195-195,[    ((FlagsAttribute) target).setFlags(flags);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/Token.java,copyTo,196-196,[    ((PayloadAttribute) target).setPayload((payload == null) ? null : payload.clone());],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/analysis/ar/ArabicStemmer.java,,55-55,[      ("" + WAW).toCharArray(),],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/analysis/ar/ArabicStemmer.java,,68-68,[    ("" + YEH).toCharArray(),],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/lucene/analysis/br/BrazilianStemmer.java,replaceSuffix,429-429,[          replaceSuffix(CT,"logias","log") ; return true;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,zzUnpackAction,333-333,[    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,zzUnpackAttribute,29757-29757,[    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,zzUnpackRowMap,2210-2210,[    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,zzUnpackTrans,29632-29632,[    offset = zzUnpackTrans(ZZ_TRANS_PACKED_12, offset, result);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,nextChar,30436-30438,[  yybegin(LEFT_ANGLE_BRACKET);,           },         case 56: break;],,nextChar,30443-30445,[  yybegin(AMPERSAND);,           },         case 57: break;],,nextChar,30455-30457,[          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);,           },         case 59: break;],,nextChar,30507-30510,[      yybegin(START_TAG_TAIL_SUBSTITUTE);,     },           },         case 62: break;],,nextChar,30517-30520,[      yybegin(START_TAG_TAIL_EXCLUDE);,     },           },         case 63: break;],,nextChar,30522-30524,[          { inputSegment.append('!'); yybegin(BANG);,           },         case 64: break;],,nextChar,30527-30529,[    yybegin(LEFT_ANGLE_BRACKET_SPACE);,           },         case 65: break;],,nextChar,30531-30533,[          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);,           },         case 66: break;],,nextChar,30535-30537,[          { inputSegment.append(yytext());,           },         case 67: break;],,nextChar,30544-30546,[    yybegin(YYINITIAL);,           },         case 68: break;],,nextChar,30552-30554,[          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);,           },         case 70: break;],,nextChar,30556-30558,[          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);,           },         case 71: break;],,nextChar,30565-30568,[      yybegin(END_TAG_TAIL_SUBSTITUTE);,     },           },         case 72: break;],,nextChar,30575-30578,[      yybegin(END_TAG_TAIL_EXCLUDE);,     },           },         case 73: break;],,nextChar,30580-30582,[          { inputSegment.write(zzBuffer, zzStartRead, yylength());,           },         case 74: break;],,nextChar,30594-30596,[    yybegin(SINGLE_QUOTED_STRING);,           },         case 76: break;],,nextChar,30600-30602,[    yybegin(DOUBLE_QUOTED_STRING);,           },         case 77: break;],,nextChar,30604-30606,[          { yybegin(restoreState); restoreState = previousRestoreState;,           },         case 78: break;],,nextChar,30631-30633,[    yybegin(YYINITIAL);,           },         case 81: break;],,nextChar,30645-30647,[          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);,           },         case 83: break;],,nextChar,30649-30651,[          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);,           },         case 84: break;],,nextChar,30659-30661,[    yybegin(CHARACTER_REFERENCE_TAIL);,           },         case 85: break;],,nextChar,30701-30704,[      yybegin(COMMENT);,     },           },         case 87: break;],,nextChar,30727-30729,[    yybegin(YYINITIAL);,           },         case 89: break;],,nextChar,30731-30733,[          { yybegin(SCRIPT);,           },         case 90: break;],,nextChar,30755-30757,[    yybegin(YYINITIAL);,           },         case 92: break;],,nextChar,30759-30761,[          { yybegin(restoreState);,           },         case 93: break;],,nextChar,30763-30765,[          { yybegin(STYLE);,           },         case 94: break;],,nextChar,30767-30769,[          { yybegin(SCRIPT_COMMENT);,           },         case 95: break;],,nextChar,30771-30773,[          { yybegin(STYLE_COMMENT);,           },         case 96: break;],,nextChar,30775-30777,[          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);,           },         case 97: break;],,nextChar,30779-30781,[          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);,           },         case 98: break;],,nextChar,30783-30785,[          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);,           },         case 99: break;],,nextChar,30815-30818,[      yybegin(CDATA);,     },           },         case 102: break;],,nextChar,30924-30926,[    yybegin(NUMERIC_CHARACTER);,           },         case 106: break;],,nextChar,30957-30959,[    yybegin(NUMERIC_CHARACTER);,           },         case 107: break;],,nextChar,30993-30995,[    yybegin(NUMERIC_CHARACTER);,           },         case 108: break;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,yycharat,30222-30222,[    return zzBuffer[zzStartRead+pos];],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,yyreset,30170-30181,[    zzReader = reader;,     zzAtBOL  = true;,     zzAtEOF  = false;,     zzEOFDone = false;,     zzEndRead = zzStartRead = 0;,     zzCurrentPos = zzMarkedPos = 0;,     zzFinalHighSurrogate = 0;,     yyline = yychar = yycolumn = 0;,     zzLexicalState = YYINITIAL;,     if (zzBuffer.length > ZZ_BUFFERSIZE),       zzBuffer = new char[ZZ_BUFFERSIZE];,   }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,yystate,30188-30188,[    return zzLexicalState;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.java,,30024-30057,[  private class TextSegment extends OpenStringBuilder {,     /** The position from which the next char will be read. */,     int pos = 0;, ,     /** Wraps the given buffer and sets this.len to the given length. */,     TextSegment(char[] buffer, int length) {,       super(buffer, length);,     }, ,     /** Allocates an internal buffer of the given size. */,     TextSegment(int size) {,       super(size);,     }, ,     /** Sets len = 0 and pos = 0. */,     void clear() {,       reset();,       restart();,     }, ,     /** Sets pos = 0 */,     void restart() {,       pos = 0;,     }, ,     /** Returns the next char in the segment. */,     int nextChar() {,       assert (! isRead()): "Attempting to read past the end of a segment.";,       return buf[pos++];,     }, ,     /** Returns true when all characters in the text segment have been read */,     boolean isRead() {,       return pos >= len;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/charfilter/MappingCharFilterFactory.java,parseString,113-125,[        switch( c ) {,           case '\\' : c = '\\'; break;,           case '"' : c = '"'; break;,           case 'n' : c = '\n'; break;,           case 't' : c = '\t'; break;,           case 'r' : c = '\r'; break;,           case 'b' : c = '\b'; break;,           case 'f' : c = '\f'; break;,           case 'u' :,             if( readPos + 3 >= len ),               throw new IllegalArgumentException("Invalid escaped char in [" + s + "]");,             c = (char)Integer.parseInt( s.substring( readPos, readPos + 4 ), 16 );,             readPos += 4;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/lucene/analysis/cjk/CJKBigramFilter.java,incrementToken,174-174,[        if (type == doHan || type == doHiragana || type == doKatakana || type == doHangul) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/lucene/analysis/cjk/CJKBigramFilter.java,incrementToken,174-174,[        if (type == doHan || type == doHiragana || type == doKatakana || type == doHangul) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/lucene/analysis/cjk/CJKBigramFilter.java,incrementToken,174-174,[        if (type == doHan || type == doHiragana || type == doKatakana || type == doHangul) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/lucene/analysis/cjk/CJKBigramFilter.java,incrementToken,174-174,[        if (type == doHan || type == doHiragana || type == doKatakana || type == doHangul) {],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/lucene/analysis/cn/smart/AnalyzerProfile.java,init,66-66,[          ANALYSIS_DATA_DIR = getAnalysisDataDir(file).toString();],,
MALICIOUS_CODE,MS_CANNOT_BE_FINAL,org/apache/lucene/analysis/cn/smart/AnalyzerProfile.java,,40-40,[  public static String ANALYSIS_DATA_DIR = "";],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,DM_STRING_CTOR,org/apache/lucene/analysis/cn/smart/Utility.java,<clinit>,28-28,[  public static final char[] STRING_CHAR_ARRAY = new String("??##ä¸?")],,<clinit>,31-31,[  public static final char[] NUMBER_CHAR_ARRAY = new String("??##??")],,<clinit>,34-34,[  public static final char[] START_CHAR_ARRAY = new String("å§?##å§?")],,<clinit>,37-37,[  public static final char[] END_CHAR_ARRAY = new String("??##??").toCharArray();],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/analysis/cn/smart/Utility.java,,42-42,[  public static final char[] COMMON_DELIMITER = new char[] { ',' };],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/analysis/cn/smart/Utility.java,,37-37,[  public static final char[] END_CHAR_ARRAY = new String("??##??").toCharArray();],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/analysis/cn/smart/Utility.java,,32-32,[      .toCharArray();],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/analysis/cn/smart/Utility.java,,35-35,[      .toCharArray();],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/analysis/cn/smart/Utility.java,,29-29,[      .toCharArray();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/analysis/cn/smart/hhmm/BigramDictionary.java,saveToObj,102-102,[    } catch (Exception e) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/lucene/analysis/cn/smart/hhmm/BigramDictionary.java,load,108-108,[    InputStream input = this.getClass().getResourceAsStream("bigramdict.mem");],,load,109-109,[    loadFromInputStream(input);],,load,110-110,[  }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/analysis/cn/smart/hhmm/BigramDictionary.java,loadFromFile,150-150,[    DataInputStream dctFile = new DataInputStream(Files.newInputStream(Paths.get(dctFilePath)));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/analysis/cn/smart/hhmm/BigramDictionary.java,saveToObj,96-96,[      ObjectOutputStream output = new ObjectOutputStream(Files.newOutputStream(],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/cn/smart/hhmm/BigramDictionary.java,saveToObj,102-102,[    } catch (Exception e) {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/lucene/analysis/cn/smart/hhmm/BigramDictionary.java,loadFromFile,158-158,[      dctFile.read(intBuffer);],,loadFromFile,167-167,[        dctFile.read(intBuffer);],,loadFromFile,170-170,[        dctFile.read(intBuffer);],,loadFromFile,173-173,[        dctFile.read(intBuffer);],,loadFromFile,180-180,[          dctFile.read(lchBuffer);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/analysis/cn/smart/hhmm/HHMMSegmenter.java,createSegGraph,104-106,[          hasFullWidth = true; /* intentional fallthrough */,         case CharType.LETTER:,           j = i + 1;],,createSegGraph,122-124,[          hasFullWidth = true; /* intentional fallthrough */,         case CharType.DIGIT:,           j = i + 1;],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/lucene/analysis/cn/smart/hhmm/PathNode.java,compareTo,36-36,[    else if (weight == pn.weight)],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/analysis/cn/smart/hhmm/PathNode.java,compareTo,36-36,[    else if (weight == pn.weight)],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/cn/smart/hhmm/SegToken.java,<init>,69-69,[    this.charArray = idArray;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,saveToObj,171-171,[    } catch (Exception e) {],,
STYLE,IM_AVERAGE_COMPUTATION_COULD_OVERFLOW,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,getPrefixMatch,476-476,[    int mid = (start + end) / 2, cmpResult;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,load,137-137,[    InputStream input = this.getClass().getResourceAsStream("coredict.mem");],,load,138-138,[    loadFromObjectInputStream(input);],,load,139-139,[  }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,loadMainDataFromFile,190-190,[    DataInputStream dctFile = new DataInputStream(Files.newInputStream(Paths.get(dctFilePath)));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,saveToObj,163-163,[      ObjectOutputStream output = new ObjectOutputStream(Files.newOutputStream(],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,saveToObj,171-171,[    } catch (Exception e) {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,loadMainDataFromFile,197-197,[      dctFile.read(intBuffer);],,loadMainDataFromFile,211-211,[        dctFile.read(intBuffer);],,loadMainDataFromFile,214-214,[        dctFile.read(intBuffer);],,loadMainDataFromFile,217-217,[        dctFile.read(intBuffer);],,loadMainDataFromFile,227-227,[          dctFile.read(lchBuffer);],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,findInTable,442-442,[      else if (cmpResult > 0)],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/analysis/compound/CompoundWordTokenFilterBase.java,,138-144,[    public CompoundToken(int offset, int length) {,       this.txt = CompoundWordTokenFilterBase.this.termAtt.subSequence(offset, offset + length);,       ,       // offsets of the original word,       this.startOffset = CompoundWordTokenFilterBase.this.offsetAtt.startOffset();,       this.endOffset = CompoundWordTokenFilterBase.this.offsetAtt.endOffset();,     }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/compound/hyphenation/ByteVector.java,getArray,76-76,[    return array;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/compound/hyphenation/ByteVector.java,<init>,61-61,[    array = a;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/compound/hyphenation/ByteVector.java,<init>,71-71,[    array = a;],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/analysis/compound/hyphenation/CharVector.java,clone,84-86,[    CharVector cv = new CharVector(array.clone(), blockSize);,     cv.n = this.n;,     return cv;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/compound/hyphenation/CharVector.java,getArray,90-90,[    return array;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/compound/hyphenation/CharVector.java,<init>,61-61,[    array = a;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/compound/hyphenation/CharVector.java,<init>,71-71,[    array = a;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/compound/hyphenation/Hyphenation.java,getHyphenationPoints,47-47,[    return hyphenPoints;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/compound/hyphenation/HyphenationTree.java,addPattern,447-447,[      ivalues.insert(ivalue, (char) k);],,addPattern,444-444,[    int k = ivalues.find(ivalue);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/compound/hyphenation/PatternParser.java,characters,340-352,[      switch (currElement) {,         case ELEM_CLASSES:,           consumer.addClass(word);,           break;,         case ELEM_EXCEPTIONS:,           exception.add(word);,           exception = normalizeException(exception);,           consumer.addException(getExceptionWord(exception),,               (ArrayList) exception.clone());,           exception.clear();,           break;,         case ELEM_PATTERNS:,           consumer.addPattern(getPattern(word), getInterletterValues(word));],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/lucene/analysis/compound/hyphenation/PatternParser.java,resolveEntity,251-251,[      return new InputSource(this.getClass().getResource("hyphenation.dtd").toExternalForm());],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/analysis/compound/hyphenation/PatternParser.java,getLocationString,364-379,[    StringBuilder str = new StringBuilder();, ,     String systemId = ex.getSystemId();,     if (systemId != null) {,       int index = systemId.lastIndexOf('/');,       if (index != -1) {,         systemId = systemId.substring(index + 1);,       },       str.append(systemId);,     },     str.append(':');,     str.append(ex.getLineNumber());,     str.append(':');,     str.append(ex.getColumnNumber());, ,     return str.toString();],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/analysis/compound/hyphenation/TernaryTree.java,clone,353-363,[    TernaryTree t = new TernaryTree();,     t.lo = this.lo.clone();,     t.hi = this.hi.clone();,     t.eq = this.eq.clone();,     t.sc = this.sc.clone();,     t.kv = this.kv.clone();,     t.root = this.root;,     t.freenode = this.freenode;,     t.length = this.length;, ,     return t;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/compound/hyphenation/TernaryTree.java,up,542-542,[      Item i = new Item();],,
PERFORMANCE,DM_STRING_CTOR,org/apache/lucene/analysis/compound/hyphenation/TernaryTree.java,nextElement,520-520,[      String res = new String(curkey);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/de/GermanLightStemmer.java,stem,66-82,[      switch(s[i]) {,         case 'Ã¤':,         case '?':,         case 'Ã¡':,         case 'Ã¢': s[i] = 'a'; break;,         case 'Ã¶':,         case 'Ã²':,         case 'Ã³':,         case 'Ã´': s[i] = 'o'; break;,         case 'Ã¯':,         case 'Ã¬':,         case 'Ã­':,         case 'Ã®': s[i] = 'i'; break;,         case 'Ã¼': ,         case 'Ã¹': ,         case 'Ãº':,         case 'Ã»': s[i] = 'u'; break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/lucene/analysis/de/GermanMinimalStemmer.java,stem,80-80,[        case 'n': if (s[len-2] == 'e') return len - 2; else break;],,stem,82-82,[        case 's': if (s[len-2] == 'e') return len - 2; else break;],,stem,83-83,[        case 'r': if (s[len-2] == 'e') return len - 2; else break;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/de/GermanMinimalStemmer.java,stem,69-72,[      switch(s[i]) {,         case 'Ã¤': s[i] = 'a'; break;,         case 'Ã¶': s[i] = 'o'; break;,         case 'Ã¼': s[i] = 'u'; break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/analysis/de/GermanStemFilter.java,incrementToken,72-72,[          if ((s != null) && !s.equals(term))],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/en/KStemmer.java,stem,1473-1473,[      entry = wordInDict();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/lucene/analysis/en/KStemmer.java,matched,1489-1489,[      matched();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/analysis/en/KStemmer.java,finalChar,257-257,[    return word.charAt(k);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/en/PorterStemmer.java,step3,299-335,[    switch (b[k-1]) {,     case 'a':,       if (ends("ational")) { r("ate"); break; },       if (ends("tional")) { r("tion"); break; },       break;,     case 'c':,       if (ends("enci")) { r("ence"); break; },       if (ends("anci")) { r("ance"); break; },       break;,     case 'e':,       if (ends("izer")) { r("ize"); break; },       break;,     case 'l':,       if (ends("bli")) { r("ble"); break; },       if (ends("alli")) { r("al"); break; },       if (ends("entli")) { r("ent"); break; },       if (ends("eli")) { r("e"); break; },       if (ends("ousli")) { r("ous"); break; },       break;,     case 'o':,       if (ends("ization")) { r("ize"); break; },       if (ends("ation")) { r("ate"); break; },       if (ends("ator")) { r("ate"); break; },       break;,     case 's':,       if (ends("alism")) { r("al"); break; },       if (ends("iveness")) { r("ive"); break; },       if (ends("fulness")) { r("ful"); break; },       if (ends("ousness")) { r("ous"); break; },       break;,     case 't':,       if (ends("aliti")) { r("al"); break; },       if (ends("iviti")) { r("ive"); break; },       if (ends("biliti")) { r("ble"); break; },       break;,     case 'g':,       if (ends("logi")) { r("log"); break; }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/en/PorterStemmer.java,step4,342-356,[    switch (b[k]) {,     case 'e':,       if (ends("icate")) { r("ic"); break; },       if (ends("ative")) { r(""); break; },       if (ends("alize")) { r("al"); break; },       break;,     case 'i':,       if (ends("iciti")) { r("ic"); break; },       break;,     case 'l':,       if (ends("ical")) { r("ic"); break; },       if (ends("ful")) { r(""); break; },       break;,     case 's':,       if (ends("ness")) { r(""); break; }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/es/SpanishLightStemmer.java,stem,69-89,[      switch(s[i]) {,         case '?': ,         case 'Ã¡':,         case 'Ã¢':,         case 'Ã¤': s[i] = 'a'; break;,         case 'Ã²':,         case 'Ã³':,         case 'Ã´':,         case 'Ã¶': s[i] = 'o'; break;,         case 'Ã¨':,         case 'Ã©':,         case 'Ãª':,         case 'Ã«': s[i] = 'e'; break;,         case 'Ã¹':,         case 'Ãº':,         case 'Ã»':,         case 'Ã¼': s[i] = 'u'; break;,         case 'Ã¬':,         case 'Ã­':,         case 'Ã®':,         case 'Ã¯': s[i] = 'i'; break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/fi/FinnishLightStemmer.java,stem,71-74,[      switch(s[i]) {,         case 'Ã¤':,         case 'Ã¥': s[i] = 'a'; break;,         case 'Ã¶': s[i] = 'o'; break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/fr/FrenchLightStemmer.java,norm,233-244,[        switch(s[i]) {,           case '?': ,           case 'Ã¡':,           case 'Ã¢': s[i] = 'a'; break;,           case 'Ã´': s[i] = 'o'; break;,           case 'Ã¨':,           case 'Ã©':,           case 'Ãª': s[i] = 'e'; break;,           case 'Ã¹':,           case 'Ã»': s[i] = 'u'; break;,           case 'Ã®': s[i] = 'i'; break;,           case 'Ã§': s[i] = 'c'; break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/gl/GalicianStemmer.java,stem,72-78,[      switch(s[i]) {,         case 'Ã¡': s[i] = 'a'; break;,         case 'Ã©':,         case 'Ãª': s[i] = 'e'; break;,         case 'Ã­': s[i] = 'i'; break;,         case 'Ã³': s[i] = 'o'; break;,         case 'Ãº': s[i] = 'u'; break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/hu/HungarianLightStemmer.java,stem,67-80,[      switch(s[i]) {,         case 'Ã¡': s[i] = 'a'; break;,         case 'Ã«':,         case 'Ã©': s[i] = 'e'; break;,         case 'Ã­': s[i] = 'i'; break;,         case 'Ã³':,         case '?':,         case 'Ãµ':,         case 'Ã¶': s[i] = 'o'; break;,         case 'Ãº':,         case 'Å±':,         case 'Å©':,         case 'Ã»':,         case 'Ã¼': s[i] = 'u'; break;],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/lucene/analysis/hunspell/Dictionary.java,parseAffix,465-465,[    boolean isSuffix = conditionPattern == SUFFIX_CONDITION_REGEX_PATTERN;],,
STYLE,NP_DEREFERENCE_OF_READLINE_VALUE,org/apache/lucene/analysis/hunspell/Dictionary.java,parseAffix,474-474,[      String ruleArgs[] = line.split("\\s+");],,
STYLE,NP_DEREFERENCE_OF_READLINE_VALUE,org/apache/lucene/analysis/hunspell/Dictionary.java,parseConversions,593-593,[      String parts[] = line.split("\\s+");],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/lucene/analysis/hunspell/Dictionary.java,readDictionaryFiles,786-786,[        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/analysis/hunspell/Dictionary.java,,828-861,[    OfflineSorter sorter = new OfflineSorter(new Comparator<BytesRef>() {,       BytesRef scratch1 = new BytesRef();,       BytesRef scratch2 = new BytesRef();,       ,       @Override,       public int compare(BytesRef o1, BytesRef o2) {,         scratch1.bytes = o1.bytes;,         scratch1.offset = o1.offset;,         scratch1.length = o1.length;,         ,         for (int i = scratch1.length - 1; i >= 0; i--) {,           if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {,             scratch1.length = i;,             break;,           },         },         ,         scratch2.bytes = o2.bytes;,         scratch2.offset = o2.offset;,         scratch2.length = o2.length;,         ,         for (int i = scratch2.length - 1; i >= 0; i--) {,           if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {,             scratch2.length = i;,             break;,           },         },         ,         int cmp = scratch1.compareTo(scratch2);,         if (cmp == 0) {,           // tie break on whole row,           return o1.compareTo(o2);,         } else {,           return cmp;],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/lucene/analysis/hunspell/Dictionary.java,parseFlags,1134-1134,[      if (rawFlags.length() % 2 == 1) {],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/hunspell/Stemmer.java,applyAffix,514-514,[    condition >>>= 1;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/hunspell/Stemmer.java,stem,331-331,[          char flag = (char) (affixReader.readShort() & 0xffff);],,stem,415-415,[          char flag = (char) (affixReader.readShort() & 0xffff);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/analysis/icu/ICUTransformFilter.java,,116-189,[  final class ReplaceableTermAttribute implements Replaceable {,     private char buffer[];,     private int length;,     private CharTermAttribute token;, ,     void setText(final CharTermAttribute token) {,       this.token = token;,       this.buffer = token.buffer();,       this.length = token.length();,     }, ,     @Override,     public int char32At(int pos) {,       return UTF16.charAt(buffer, 0, length, pos);,     }, ,     @Override,     public char charAt(int pos) {,       return buffer[pos];,     }, ,     @Override,     public void copy(int start, int limit, int dest) {,       char text[] = new char[limit - start];,       getChars(start, limit, text, 0);,       replace(dest, dest, text, 0, limit - start);,     }, ,     @Override,     public void getChars(int srcStart, int srcLimit, char[] dst, int dstStart) {,       System.arraycopy(buffer, srcStart, dst, dstStart, srcLimit - srcStart);,     }, ,     @Override,     public boolean hasMetaData() {,       return false;,     }, ,     @Override,     public int length() {,       return length;,     }, ,     @Override,     public void replace(int start, int limit, String text) {,       final int charsLen = text.length();,       final int newLength = shiftForReplace(start, limit, charsLen);,       // insert the replacement text,       text.getChars(0, charsLen, buffer, start);,       token.setLength(length = newLength);,     }, ,     @Override,     public void replace(int start, int limit, char[] text, int charsStart,,         int charsLen) {,       // shift text if necessary for the replacement,       final int newLength = shiftForReplace(start, limit, charsLen);,       // insert the replacement text,       System.arraycopy(text, charsStart, buffer, start, charsLen);,       token.setLength(length = newLength);,     }, ,     /** shift text (if necessary) for a replacement operation */,     private int shiftForReplace(int start, int limit, int charsLen) {,       final int replacementLength = limit - start;,       final int newLength = length - replacementLength + charsLen;,       // resize if necessary,       if (newLength > length),         buffer = token.resizeBuffer(newLength);,       // if the substring being replaced is longer or shorter than the,       // replacement, need to shift things around,       if (replacementLength != charsLen && limit < length),         System.arraycopy(buffer, limit, buffer, start + charsLen, length - limit);,       return newLength;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/icu/ICUTransformFilter.java,replace,165-165,[      token.setLength(length = newLength);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/icu/ICUTransformFilter.java,replace,175-175,[      token.setLength(length = newLength);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/icu/ICUTransformFilter.java,shiftForReplace,184-184,[        buffer = token.resizeBuffer(newLength);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/analysis/icu/segmentation/BreakIteratorWrapper.java,,56-56,[    this.length = length;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/icu/segmentation/CharArrayIterator.java,current,62-62,[    return (index == limit) ? DONE : array[index];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/icu/segmentation/CompositeBreakIterator.java,current,77-77,[    final int current = rbbi.current();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/icu/segmentation/CompositeBreakIterator.java,getRuleStatus,89-89,[    return rbbi.getRuleStatus();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/icu/segmentation/CompositeBreakIterator.java,next,60-60,[    int next = rbbi.next();],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/analysis/icu/segmentation/DefaultICUTokenizerConfig.java,readBreakIterator,118-118,[      DefaultICUTokenizerConfig.class.getResourceAsStream(filename);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory.java,parseRules,134-134,[    BufferedReader reader = new BufferedReader],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory.java,,116-123,[      config = new DefaultICUTokenizerConfig(cjkAsWords) {,         ,         @Override,         public BreakIterator getBreakIterator(int script) {,           if (breakers[script] != null) {,             return (BreakIterator) breakers[script].clone();,           } else {,             return super.getBreakIterator(script);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/icu/tokenattributes/ScriptAttributeImpl.java,,31-92,[  private int code = UScript.COMMON;,   ,   /** Initializes this attribute with <code>UScript.COMMON</code> */,   public ScriptAttributeImpl() {},   ,   @Override,   public int getCode() {,     return code;,   },   ,   @Override,   public void setCode(int code) {,     this.code = code;,   }, ,   @Override,   public String getName() {,     return UScript.getName(code);,   }, ,   @Override,   public String getShortName() {,     return UScript.getShortName(code);,   },   ,   @Override,   public void clear() {,     code = UScript.COMMON;,   }, ,   @Override,   public void copyTo(AttributeImpl target) {,     ScriptAttribute t = (ScriptAttribute) target;,     t.setCode(code);,   },   ,   @Override,   public boolean equals(Object other) {,     if (this == other) {,       return true;,     },     ,     if (other instanceof ScriptAttributeImpl) {,       return ((ScriptAttributeImpl) other).code == code;,     },     ,     return false;,   }, ,   @Override,   public int hashCode() {,     return code;,   }, ,   @Override,   public void reflectWith(AttributeReflector reflector) {,     // when wordbreaking CJK, we use the 15924 code Japanese (Han+Hiragana+Katakana) to ,     // mark runs of Chinese/Japanese. our use is correct (as for chinese Han is a subset), ,     // but this is just to help prevent confusion.,     String name = code == UScript.JAPANESE ? "Chinese/Japanese" : getName();,     reflector.reflect(ScriptAttribute.class, "script", name);,   }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/in/IndicNormalizer.java,normalize,250-250,[        if (sd.decompMask.get(ch))],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/lucene/analysis/it/ItalianLightStemmer.java,stem,104-107,[        if (s[len-2] == 'i'),           return len - 2;,         else,           return len - 1;],,stem,109-112,[        if (s[len-2] == 'i'),           return len - 2;,         else,           return len - 1;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/it/ItalianLightStemmer.java,stem,69-89,[      switch(s[i]) {,         case '?': ,         case 'Ã¡':,         case 'Ã¢':,         case 'Ã¤': s[i] = 'a'; break;,         case 'Ã²':,         case 'Ã³':,         case 'Ã´':,         case 'Ã¶': s[i] = 'o'; break;,         case 'Ã¨':,         case 'Ã©':,         case 'Ãª':,         case 'Ã«': s[i] = 'e'; break;,         case 'Ã¹':,         case 'Ãº':,         case 'Ã»':,         case 'Ã¼': s[i] = 'u'; break;,         case 'Ã¬':,         case 'Ã­':,         case 'Ã®':,         case 'Ã¯': s[i] = 'i'; break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/ja/Token.java,getSurfaceForm,61-61,[    return surfaceForm;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/ja/Token.java,<init>,42-42,[    this.surfaceForm = surfaceForm;],,
STYLE,DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD,org/apache/lucene/analysis/ja/dict/ConnectionCosts.java,<init>,43-43,[    short[][] costs = null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/lucene/analysis/ja/dict/UserDictionary.java,getAllFeaturesArray,246-246,[      return null;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/analysis/ja/dict/UserDictionary.java,toIndexArray,181-181,[      int[] wordIdAndLength = input.get(i);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/analysis/ja/dict/UserDictionary.java,,82-85,[    Collections.sort(featureEntries, new Comparator<String[]>() {,       @Override,       public int compare(String[] left, String[] right) {,         return left[0].compareTo(right[0]);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/ja/tokenattributes/BaseFormAttributeImpl.java,,27-54,[public class BaseFormAttributeImpl extends AttributeImpl implements BaseFormAttribute, Cloneable {,   private Token token;,   ,   @Override,   public String getBaseForm() {,     return token == null ? null : token.getBaseForm();,   },   ,   @Override,   public void setToken(Token token) {,     this.token = token;,   }, ,   @Override,   public void clear() {,     token = null;,   }, ,   @Override,   public void copyTo(AttributeImpl target) {,     BaseFormAttribute t = (BaseFormAttribute) target;,     t.setToken(token);,   },   ,   @Override,   public void reflectWith(AttributeReflector reflector) {,     reflector.reflect(BaseFormAttribute.class, "baseForm", getBaseForm());,   }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/ja/tokenattributes/InflectionAttributeImpl.java,,28-67,[public class InflectionAttributeImpl extends AttributeImpl implements InflectionAttribute, Cloneable {,   private Token token;,   ,   @Override,   public String getInflectionType() {,     return token == null ? null : token.getInflectionType();,   },   ,   @Override,   public String getInflectionForm() {,     return token == null ? null : token.getInflectionForm();,   },   ,   @Override,   public void setToken(Token token) {,     this.token = token;,   }, ,   @Override,   public void clear() {,     token = null;,   }, ,   @Override,   public void copyTo(AttributeImpl target) {,     InflectionAttribute t = (InflectionAttribute) target;,     t.setToken(token);,   },   ,   @Override,   public void reflectWith(AttributeReflector reflector) {,     String type = getInflectionType();,     String typeEN = type == null ? null : ToStringUtil.getInflectionTypeTranslation(type);,     reflector.reflect(InflectionAttribute.class, "inflectionType", type);,     reflector.reflect(InflectionAttribute.class, "inflectionType (en)", typeEN);,     String form = getInflectionForm();,     String formEN = form == null ? null : ToStringUtil.getInflectedFormTranslation(form);,     reflector.reflect(InflectionAttribute.class, "inflectionForm", form);,     reflector.reflect(InflectionAttribute.class, "inflectionForm (en)", formEN);,   }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/ja/tokenattributes/PartOfSpeechAttributeImpl.java,,28-58,[public class PartOfSpeechAttributeImpl extends AttributeImpl implements PartOfSpeechAttribute, Cloneable {,   private Token token;,   ,   @Override,   public String getPartOfSpeech() {,     return token == null ? null : token.getPartOfSpeech();,   },   ,   @Override,   public void setToken(Token token) {,     this.token = token;,   }, ,   @Override,   public void clear() {,     token = null;,   }, ,   @Override,   public void copyTo(AttributeImpl target) {,     PartOfSpeechAttribute t = (PartOfSpeechAttribute) target;,     t.setToken(token);,   },   ,   @Override,   public void reflectWith(AttributeReflector reflector) {,     String partOfSpeech = getPartOfSpeech();,     String partOfSpeechEN = partOfSpeech == null ? null : ToStringUtil.getPOSTranslation(partOfSpeech);,     reflector.reflect(PartOfSpeechAttribute.class, "partOfSpeech", partOfSpeech);,     reflector.reflect(PartOfSpeechAttribute.class, "partOfSpeech (en)", partOfSpeechEN);,   }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/ja/tokenattributes/ReadingAttributeImpl.java,,28-67,[public class ReadingAttributeImpl extends AttributeImpl implements ReadingAttribute, Cloneable {,   private Token token;,   ,   @Override,   public String getReading() {,     return token == null ? null : token.getReading();,   },   ,   @Override,   public String getPronunciation() {,     return token == null ? null : token.getPronunciation();,   },   ,   @Override,   public void setToken(Token token) {,     this.token = token;,   }, ,   @Override,   public void clear() {,     token = null;,   }, ,   @Override,   public void copyTo(AttributeImpl target) {,     ReadingAttribute t = (ReadingAttribute) target;,     t.setToken(token);,   },   ,   @Override,   public void reflectWith(AttributeReflector reflector) {,     String reading = getReading();,     String readingEN = reading == null ? null : ToStringUtil.getRomanization(reading);,     String pronunciation = getPronunciation();,     String pronunciationEN = pronunciation == null ? null : ToStringUtil.getRomanization(pronunciation);,     reflector.reflect(ReadingAttribute.class, "reading", reading);,     reflector.reflect(ReadingAttribute.class, "reading (en)", readingEN);,     reflector.reflect(ReadingAttribute.class, "pronunciation", pronunciation);,     reflector.reflect(ReadingAttribute.class, "pronunciation (en)", pronunciationEN);,   }],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/lucene/analysis/ja/util/CSVUtil.java,quoteEscape,104-104,[      result.replace("\"", ESCAPED_QUOTE);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/lv/LatvianStemmer.java,numVowels,165-169,[      switch(s[i]) {,         case 'a': case 'e': case 'i':  ,         case 'o': case 'u': case '?':  ,         case 'Ä«': case '?': case 'Å«':,           n++;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/miscellaneous/WordDelimiterFilterFactory.java,parseString,182-193,[        switch( c ) {,           case '\\' : c = '\\'; break;,           case 'n' : c = '\n'; break;,           case 't' : c = '\t'; break;,           case 'r' : c = '\r'; break;,           case 'b' : c = '\b'; break;,           case 'f' : c = '\f'; break;,           case 'u' :,             if( readPos + 3 >= len ),               throw new IllegalArgumentException("Invalid escaped char in [" + s + "]");,             c = (char)Integer.parseInt( s.substring( readPos, readPos + 4 ), 16 );,             readPos += 4;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/analysis/miscellaneous/WordDelimiterIterator.java,,93-93,[    DEFAULT_WORD_DELIM_TABLE = tab;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/analysis/morfologik/MorphosyntacticTagsAttributeImpl.java,clone,95-97,[    MorphosyntacticTagsAttributeImpl cloned = new MorphosyntacticTagsAttributeImpl();,     this.copyTo(cloned);,     return cloned;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/morfologik/MorphosyntacticTagsAttributeImpl.java,,29-102,[public class MorphosyntacticTagsAttributeImpl extends AttributeImpl ,   implements MorphosyntacticTagsAttribute, Cloneable {,   ,   /** Initializes this attribute with no tags */,   public MorphosyntacticTagsAttributeImpl() {},   ,   /**,    * A list of potential tag variants for the current token.,    */,   private List<StringBuilder> tags;, ,   /**,    * Returns the POS tag of the term. If you need a copy of this char sequence, copy,    * its contents (and clone {@link StringBuilder}s) because it changes with ,    * each new term to avoid unnecessary memory allocations.,    */,   @Override,   public List<StringBuilder> getTags() {,     return tags;,   }, ,   @Override,   public void clear() {,     tags = null;,   }, ,   @Override,   public boolean equals(Object other) {,     if (other instanceof MorphosyntacticTagsAttribute) {,       return equal(this.getTags(), ((MorphosyntacticTagsAttribute) other).getTags());,     },     return false;,   }, ,   private boolean equal(Object l1, Object l2) {,     return l1 == null ? (l2 == null) : (l1.equals(l2));,   }, ,   @Override,   public int hashCode() {,     return this.tags == null ? 0 : tags.hashCode();,   }, ,   /**,    * Sets the internal tags reference to the given list. The contents,    * is not copied. ,    */,   @Override,   public void setTags(List<StringBuilder> tags) {,     this.tags = tags;,   }, ,   @Override,   public void copyTo(AttributeImpl target) {,     List<StringBuilder> cloned = null;,     if (tags != null) {,       cloned = new ArrayList<>(tags.size());,       for (StringBuilder b : tags) {,         cloned.add(new StringBuilder(b));,       },     },     ((MorphosyntacticTagsAttribute) target).setTags(cloned);,   }, ,   @Override,   public MorphosyntacticTagsAttributeImpl clone() {,     MorphosyntacticTagsAttributeImpl cloned = new MorphosyntacticTagsAttributeImpl();,     this.copyTo(cloned);,     return cloned;,   },   ,   @Override,   public String toString() {,     return tags == null ? "<no tags>" : tags.toString();],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/ngram/NGramTokenFilter.java,,116-116,[          hasIllegalOffsets = (tokStart + curTermLength) != tokEnd;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/no/NorwegianMinimalStemmer.java,,77-77,[    useBokmaal = (flags & BOKMAAL) != 0;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/payloads/FloatEncoder.java,,28-35,[public class FloatEncoder extends AbstractEncoder implements PayloadEncoder {, ,   @Override,   public BytesRef encode(char[] buffer, int offset, int length) {,     float payload = Float.parseFloat(new String(buffer, offset, length));//TODO: improve this so that we don't have to new Strings,     byte[] bytes = PayloadHelper.encodeFloat(payload);,     BytesRef result = new BytesRef(bytes);,     return result;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/payloads/IdentityEncoder.java,,32-50,[  protected Charset charset = StandardCharsets.UTF_8;,   ,   public IdentityEncoder() {,   }, ,   public IdentityEncoder(Charset charset) {,     this.charset = charset;,   }, ,   @Override,   public BytesRef encode(char[] buffer, int offset, int length) {,     final ByteBuffer bb = charset.encode(CharBuffer.wrap(buffer, offset, length));,     if (bb.hasArray()) {,       return new BytesRef(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining());,     } else {,       // normally it should always have an array, but who knows?,       final byte[] b = new byte[bb.remaining()];,       bb.get(b);,       return new BytesRef(b);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/payloads/IntegerEncoder.java,,29-36,[public class IntegerEncoder extends AbstractEncoder implements PayloadEncoder {, ,   @Override,   public BytesRef encode(char[] buffer, int offset, int length) {,     int payload = ArrayUtil.parseInt(buffer, offset, length);//TODO: improve this so that we don't have to new Strings,     byte[] bytes = PayloadHelper.encodeInt(payload);,     BytesRef result = new BytesRef(bytes);,     return result;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/phonetic/PhoneticFilter.java,incrementToken,73-73,[    } catch (Exception ignored) {} // just use the direct text],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/phonetic/PhoneticFilterFactory.java,getEncoder,152-152,[    } catch (Exception e) {],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/pt/PortugueseLightStemmer.java,stem,76-79,[      switch(s[len-1]) {,         case 'e':,         case 'a':,         case 'o': len--; break;],,stem,83-106,[      switch(s[i]) {,         case '?': ,         case 'Ã¡':,         case 'Ã¢':,         case 'Ã¤': ,         case 'Ã£': s[i] = 'a'; break;,         case 'Ã²':,         case 'Ã³':,         case 'Ã´':,         case 'Ã¶': ,         case 'Ãµ': s[i] = 'o'; break;,         case 'Ã¨':,         case 'Ã©':,         case 'Ãª':,         case 'Ã«': s[i] = 'e'; break;,         case 'Ã¹':,         case 'Ãº':,         case 'Ã»':,         case 'Ã¼': s[i] = 'u'; break;,         case 'Ã¬':,         case 'Ã­':,         case 'Ã®':,         case 'Ã¯': s[i] = 'i'; break;,         case 'Ã§': s[i] = 'c'; break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/analysis/pt/PortugueseStemmer.java,stem,70-97,[      switch(s[i]) {,         case '?':,         case 'Ã¡':,         case 'Ã¢':,         case 'Ã£':,         case 'Ã¤':,         case 'Ã¥': s[i] = 'a'; break;,         case 'Ã§': s[i] = 'c'; break;,         case 'Ã¨':,         case 'Ã©':,         case 'Ãª':,         case 'Ã«': s[i] = 'e'; break;,         case 'Ã¬':,         case 'Ã­':,         case 'Ã®':,         case 'Ã¯': s[i] = 'i'; break;,         case 'Ã±': s[i] = 'n'; break;,         case 'Ã²':,         case 'Ã³':,         case 'Ã´':,         case 'Ãµ':,         case 'Ã¶': s[i] = 'o'; break;,         case 'Ã¹':,         case 'Ãº':,         case 'Ã»':,         case 'Ã¼': s[i] = 'u'; break;,         case 'Ã½':,         case 'Ã¿': s[i] = 'y'; break;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/lucene/analysis/pt/RSLPStemmerBase.java,parseList,324-324,[      return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/lucene/analysis/pt/RSLPStemmerBase.java,parseRules,319-319,[    return null;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/pt/RSLPStemmerBase.java,<init>,196-196,[      this.rules = rules;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/analysis/query/QueryAutoStopWordAnalyzer.java,getStopWords,196-196,[      Set<String> stopWords = stopWordsPerField.get(fieldName);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/analysis/shingle/ShingleFilter.java,,585-591,[    boolean isFiller = false;,       ,     public InputWindowToken(AttributeSource attSource) {,       this.attSource = attSource;,       this.termAtt = attSource.getAttribute(CharTermAttribute.class);,       this.offsetAtt = attSource.getAttribute(OffsetAttribute.class);,     }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/snowball/SnowballFilter.java,<init>,83-83,[    } catch (Exception e) {],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/lucene/analysis/sr/SerbianNormalizationFilter.java,incrementToken,130-131,[          buffer[i] = 's';,           break;],,incrementToken,162-163,[          buffer[i] = 's';,           break;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/lucene/analysis/standard/ClassicFilter.java,incrementToken,61-61,[    } else if (type == ACRONYM_TYPE) {      // remove dots],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/lucene/analysis/standard/ClassicFilter.java,incrementToken,55-55,[    if (type == APOSTROPHE_TYPE &&      // remove 's],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/analysis/standard/ClassicTokenizer.java,,66-66,[  public static final String [] TOKEN_TYPES = new String [] {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,zzUnpackAction,137-137,[    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,zzUnpackAttribute,278-278,[    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,zzUnpackRowMap,171-171,[    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,zzUnpackTrans,236-236,[    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,,504-504,[    yyline = yychar = yycolumn = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,,504-504,[    yyline = yychar = yycolumn = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,,335-335,[  private boolean zzAtBOL = true;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,,500-500,[    zzEOFDone = false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/analysis/standard/ClassicTokenizerImpl.java,,363-363,[public static final String [] TOKEN_TYPES = StandardTokenizer.TOKEN_TYPES;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/StandardTokenizerImpl.java,zzUnpackAction,227-227,[    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/StandardTokenizerImpl.java,zzUnpackAttribute,348-348,[    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/StandardTokenizerImpl.java,zzUnpackRowMap,257-257,[    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/StandardTokenizerImpl.java,zzUnpackTrans,306-306,[    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/StandardTokenizerImpl.java,,583-583,[    yyline = yychar = yycolumn = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/StandardTokenizerImpl.java,,583-583,[    yyline = yychar = yycolumn = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/StandardTokenizerImpl.java,,405-405,[  private boolean zzAtBOL = true;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/StandardTokenizerImpl.java,,579-579,[    zzEOFDone = false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizer.java,,63-63,[  public static final String [] TOKEN_TYPES = new String [] {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,zzUnpackAction,275-275,[    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,zzUnpackAttribute,6710-6710,[    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,zzUnpackRowMap,666-666,[    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,zzUnpackTrans,6641-6641,[    offset = zzUnpackTrans(ZZ_TRANS_PACKED_2, offset, result);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,getNextToken,7138-7140,[          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */,           },         case 15: break;],,getNextToken,7188-7190,[          { yybegin(AVOID_BAD_URL); yypushback(yylength());,           },         case 26: break;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,,6949-6949,[    yyline = yychar = yycolumn = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,,6949-6949,[    yyline = yychar = yycolumn = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,,6767-6767,[  private boolean zzAtBOL = true;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl.java,,6945-6945,[    zzEOFDone = false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/lucene/analysis/stempel/StempelStemmer.java,load,75-75,[      in.close();],,load,65-65,[    DataInputStream in = null;],,load,67-67,[      in = new DataInputStream(new BufferedInputStream(stemmerTable));],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/synonym/SynonymFilterFactory.java,loadAnalyzer,203-203,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/synonym/SynonymFilterFactory.java,loadSynonyms,169-169,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/analysis/synonym/SynonymFilterFactory.java,loadTokenizerFactory,190-190,[    } catch (Exception e) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/analysis/synonym/SynonymFilterFactory.java,<init>,109-109,[        tokArgs.put(key.replaceAll("^tokenizerFactory\\.",""), args.get(key));],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java,buffer,48-48,[    return termBuffer;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java,resizeBuffer,60-60,[    return termBuffer;   ],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java,,30-282,[public class CharTermAttributeImpl extends AttributeImpl implements CharTermAttribute, TermToBytesRefAttribute, Cloneable {,   private static int MIN_BUFFER_SIZE = 10;,   ,   private char[] termBuffer = new char[ArrayUtil.oversize(MIN_BUFFER_SIZE, RamUsageEstimator.NUM_BYTES_CHAR)];,   private int termLength = 0;,   ,   /** Initialize this attribute with empty term text */,   public CharTermAttributeImpl() {}, ,   @Override,   public final void copyBuffer(char[] buffer, int offset, int length) {,     growTermBuffer(length);,     System.arraycopy(buffer, offset, termBuffer, 0, length);,     termLength = length;,   }, ,   @Override,   public final char[] buffer() {,     return termBuffer;,   },   ,   @Override,   public final char[] resizeBuffer(int newSize) {,     if(termBuffer.length < newSize){,       // Not big enough; create a new array with slight,       // over allocation and preserve content,       final char[] newCharBuffer = new char[ArrayUtil.oversize(newSize, RamUsageEstimator.NUM_BYTES_CHAR)];,       System.arraycopy(termBuffer, 0, newCharBuffer, 0, termBuffer.length);,       termBuffer = newCharBuffer;,     },     return termBuffer;   ,   },   ,   private void growTermBuffer(int newSize) {,     if(termBuffer.length < newSize){,       // Not big enough; create a new array with slight,       // over allocation:,       termBuffer = new char[ArrayUtil.oversize(newSize, RamUsageEstimator.NUM_BYTES_CHAR)];,     },   }, ,   @Override,   public final CharTermAttribute setLength(int length) {,     if (length > termBuffer.length),       throw new IllegalArgumentException("length " + length + " exceeds the size of the termBuffer (" + termBuffer.length + ")");,     termLength = length;,     return this;,   },   ,   @Override,   public final CharTermAttribute setEmpty() {,     termLength = 0;,     return this;,   },   ,   // *** TermToBytesRefAttribute interface ***,   private BytesRefBuilder bytes = new BytesRefBuilder();, ,   @Override,   public void fillBytesRef() {,     bytes.copyChars(termBuffer, 0, termLength);,   }, ,   @Override,   public BytesRef getBytesRef() {,     return bytes.get();,   },   ,   // *** CharSequence interface ***,   @Override,   public final int length() {,     return termLength;,   },   ,   @Override,   public final char charAt(int index) {,     if (index >= termLength),       throw new IndexOutOfBoundsException();,     return termBuffer[index];,   },   ,   @Override,   public final CharSequence subSequence(final int start, final int end) {,     if (start > termLength || end > termLength),       throw new IndexOutOfBoundsException();,     return new String(termBuffer, start, end - start);,   },   ,   // *** Appendable interface ***, ,   @Override,   public final CharTermAttribute append(CharSequence csq) {,     if (csq == null) // needed for Appendable compliance,       return appendNull();,     return append(csq, 0, csq.length());,   },   ,   @Override,   public final CharTermAttribute append(CharSequence csq, int start, int end) {,     if (csq == null) // needed for Appendable compliance,       csq = "null";,     final int len = end - start, csqlen = csq.length();,     if (len < 0 || start > csqlen || end > csqlen),       throw new IndexOutOfBoundsException();,     if (len == 0),       return this;,     resizeBuffer(termLength + len);,     if (len > 4) { // only use instanceof check series for longer CSQs, else simply iterate,       if (csq instanceof String) {,         ((String) csq).getChars(start, end, termBuffer, termLength);,       } else if (csq instanceof StringBuilder) {,         ((StringBuilder) csq).getChars(start, end, termBuffer, termLength);,       } else if (csq instanceof CharTermAttribute) {,         System.arraycopy(((CharTermAttribute) csq).buffer(), start, termBuffer, termLength, len);,       } else if (csq instanceof CharBuffer && ((CharBuffer) csq).hasArray()) {,         final CharBuffer cb = (CharBuffer) csq;,         System.arraycopy(cb.array(), cb.arrayOffset() + cb.position() + start, termBuffer, termLength, len);,       } else if (csq instanceof StringBuffer) {,         ((StringBuffer) csq).getChars(start, end, termBuffer, termLength);,       } else {,         while (start < end),           termBuffer[termLength++] = csq.charAt(start++);,         // no fall-through here, as termLength is updated!,         return this;,       },       termLength += len;,       return this;,     } else {,       while (start < end),         termBuffer[termLength++] = csq.charAt(start++);,       return this;,     },   },   ,   @Override,   public final CharTermAttribute append(char c) {,     resizeBuffer(termLength + 1)[termLength++] = c;,     return this;,   },   ,   // *** For performance some convenience methods in addition to CSQ's ***,   ,   @Override,   public final CharTermAttribute append(String s) {,     if (s == null) // needed for Appendable compliance,       return appendNull();,     final int len = s.length();,     s.getChars(0, len, resizeBuffer(termLength + len), termLength);,     termLength += len;,     return this;,   },   ,   @Override,   public final CharTermAttribute append(StringBuilder s) {,     if (s == null) // needed for Appendable compliance,       return appendNull();,     final int len = s.length();,     s.getChars(0, len, resizeBuffer(termLength + len), termLength);,     termLength += len;,     return this;,   },   ,   @Override,   public final CharTermAttribute append(CharTermAttribute ta) {,     if (ta == null) // needed for Appendable compliance,       return appendNull();,     final int len = ta.length();,     System.arraycopy(ta.buffer(), 0, resizeBuffer(termLength + len), termLength, len);,     termLength += len;,     return this;,   }, ,   private CharTermAttribute appendNull() {,     resizeBuffer(termLength + 4);,     termBuffer[termLength++] = 'n';,     termBuffer[termLength++] = 'u';,     termBuffer[termLength++] = 'l';,     termBuffer[termLength++] = 'l';,     return this;,   },   ,   // *** AttributeImpl ***, ,   @Override,   public int hashCode() {,     int code = termLength;,     code = code * 31 + ArrayUtil.hashCode(termBuffer, 0, termLength);,     return code;,   }, ,   @Override,   public void clear() {,     termLength = 0;    ,   }, ,   @Override,   public CharTermAttributeImpl clone() {,     CharTermAttributeImpl t = (CharTermAttributeImpl)super.clone();,     // Do a deep clone,     t.termBuffer = new char[this.termLength];,     System.arraycopy(this.termBuffer, 0, t.termBuffer, 0, this.termLength);,     t.bytes = new BytesRefBuilder();,     t.bytes.copyBytes(bytes.get());,     return t;,   },   ,   @Override,   public boolean equals(Object other) {,     if (other == this) {,       return true;,     },     ,     if (other instanceof CharTermAttributeImpl) {,       final CharTermAttributeImpl o = ((CharTermAttributeImpl) other);,       if (termLength != o.termLength),         return false;,       for(int i=0;i<termLength;i++) {,         if (termBuffer[i] != o.termBuffer[i]) {,           return false;,         },       },       return true;,     },     ,     return false;,   }, ,   /** ,    * Returns solely the term text as specified by the,    * {@link CharSequence} interface.,    * <p>This method changed the behavior with Lucene 3.1,,    * before it returned a String representation of the whole,    * term with all attributes.,    * This affects especially the,    * {@link org.apache.lucene.analysis.Token} subclass.,    */,   @Override,   public String toString() {,     return new String(termBuffer, 0, termLength);,   },   ,   @Override,   public void reflectWith(AttributeReflector reflector) {,     reflector.reflect(CharTermAttribute.class, "term", toString());,     fillBytesRef();,     reflector.reflect(TermToBytesRefAttribute.class, "bytes", bytes.toBytesRef());,   },   ,   @Override,   public void copyTo(AttributeImpl target) {,     CharTermAttribute t = (CharTermAttribute) target;,     t.copyBuffer(termBuffer, 0, termLength);,   }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/tokenattributes/FlagsAttributeImpl.java,,24-66,[  private int flags = 0;,   ,   /** Initialize this attribute with no bits set */,   public FlagsAttributeImpl() {},   ,   @Override,   public int getFlags() {,     return flags;,   }, ,   @Override,   public void setFlags(int flags) {,     this.flags = flags;,   },   ,   @Override,   public void clear() {,     flags = 0;,   }, ,   @Override,   public boolean equals(Object other) {,     if (this == other) {,       return true;,     },     ,     if (other instanceof FlagsAttributeImpl) {,       return ((FlagsAttributeImpl) other).flags == flags;,     },     ,     return false;,   }, ,   @Override,   public int hashCode() {,     return flags;,   },   ,   @Override,   public void copyTo(AttributeImpl target) {,     FlagsAttribute t = (FlagsAttribute) target;,     t.setFlags(flags);,   }],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/analysis/tokenattributes/KeywordAttributeImpl.java,equals,48-53,[    if (this == obj),       return true;,     if (getClass() != obj.getClass()),       return false;,     final KeywordAttributeImpl other = (KeywordAttributeImpl) obj;,     return keyword == other.keyword;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/tokenattributes/OffsetAttributeImpl.java,,28-92,[  public OffsetAttributeImpl() {}, ,   @Override,   public int startOffset() {,     return startOffset;,   }, ,   @Override,   public void setOffset(int startOffset, int endOffset) {, ,     // TODO: we could assert that this is set-once, ie,,     // current values are -1?  Very few token filters should,     // change offsets once set by the tokenizer... and,     // tokenizer should call clearAtts before re-using,     // OffsetAtt, ,     if (startOffset < 0 || endOffset < startOffset) {,       throw new IllegalArgumentException("startOffset must be non-negative, and endOffset must be >= startOffset, ",           + "startOffset=" + startOffset + ",endOffset=" + endOffset);,     }, ,     this.startOffset = startOffset;,     this.endOffset = endOffset;,   },   ,   @Override,   public int endOffset() {,     return endOffset;,   }, , ,   @Override,   public void clear() {,     // TODO: we could use -1 as default here?  Then we can,     // assert in setOffset...,     startOffset = 0;,     endOffset = 0;,   },   ,   @Override,   public boolean equals(Object other) {,     if (other == this) {,       return true;,     },     ,     if (other instanceof OffsetAttributeImpl) {,       OffsetAttributeImpl o = (OffsetAttributeImpl) other;,       return o.startOffset == startOffset && o.endOffset == endOffset;,     },     ,     return false;,   }, ,   @Override,   public int hashCode() {,     int code = startOffset;,     code = code * 31 + endOffset;,     return code;,   } ,   ,   @Override,   public void copyTo(AttributeImpl target) {,     OffsetAttribute t = (OffsetAttribute) target;,     t.setOffset(startOffset, endOffset);,   }  ],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/tokenattributes/PackedTokenAttributeImpl.java,copyTo,189-189,[      ((OffsetAttribute) target).setOffset(startOffset, endOffset);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/tokenattributes/PackedTokenAttributeImpl.java,copyTo,190-190,[      ((PositionIncrementAttribute) target).setPositionIncrement(positionIncrement);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/tokenattributes/PackedTokenAttributeImpl.java,copyTo,191-191,[      ((PositionLengthAttribute) target).setPositionLength(positionLength);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/tokenattributes/PackedTokenAttributeImpl.java,copyTo,192-192,[      ((TypeAttribute) target).setType(type);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/analysis/tokenattributes/PayloadAttributeImpl.java,equals,70-70,[      PayloadAttributeImpl o = (PayloadAttributeImpl) other;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/tokenattributes/PayloadAttributeImpl.java,,24-90,[public class PayloadAttributeImpl extends AttributeImpl implements PayloadAttribute, Cloneable {,   private BytesRef payload;  ,   ,   /**,    * Initialize this attribute with no payload.,    */,   public PayloadAttributeImpl() {},   ,   /**,    * Initialize this attribute with the given payload. ,    */,   public PayloadAttributeImpl(BytesRef payload) {,     this.payload = payload;,   },   ,   @Override,   public BytesRef getPayload() {,     return this.payload;,   }, ,   @Override,   public void setPayload(BytesRef payload) {,     this.payload = payload;,   },   ,   @Override,   public void clear() {,     payload = null;,   }, ,   @Override,   public PayloadAttributeImpl clone()  {,     PayloadAttributeImpl clone = (PayloadAttributeImpl) super.clone();,     if (payload != null) {,       clone.payload = BytesRef.deepCopyOf(payload);,     },     return clone;,   }, ,   @Override,   public boolean equals(Object other) {,     if (other == this) {,       return true;,     },     ,     if (other instanceof PayloadAttribute) {,       PayloadAttributeImpl o = (PayloadAttributeImpl) other;,       if (o.payload == null || payload == null) {,         return o.payload == null && payload == null;,       },       ,       return o.payload.equals(payload);,     },     ,     return false;,   }, ,   @Override,   public int hashCode() {,     return (payload == null) ? 0 : payload.hashCode();,   }, ,   @Override,   public void copyTo(AttributeImpl target) {,     PayloadAttribute t = (PayloadAttribute) target;,     t.setPayload((payload == null) ? null : BytesRef.deepCopyOf(payload));,   }  ],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/tokenattributes/PositionIncrementAttributeImpl.java,,24-71,[  private int positionIncrement = 1;,   ,   /** Initialize this attribute with position increment of 1 */,   public PositionIncrementAttributeImpl() {}, ,   @Override,   public void setPositionIncrement(int positionIncrement) {,     if (positionIncrement < 0) {,       throw new IllegalArgumentException,         ("Increment must be zero or greater: got " + positionIncrement);,     },     this.positionIncrement = positionIncrement;,   }, ,   @Override,   public int getPositionIncrement() {,     return positionIncrement;,   }, ,   @Override,   public void clear() {,     this.positionIncrement = 1;,   },   ,   @Override,   public boolean equals(Object other) {,     if (other == this) {,       return true;,     },     ,     if (other instanceof PositionIncrementAttributeImpl) {,       PositionIncrementAttributeImpl _other = (PositionIncrementAttributeImpl) other;,       return positionIncrement ==  _other.positionIncrement;,     },  ,     return false;,   }, ,   @Override,   public int hashCode() {,     return positionIncrement;,   },   ,   @Override,   public void copyTo(AttributeImpl target) {,     PositionIncrementAttribute t = (PositionIncrementAttribute) target;,     t.setPositionIncrement(positionIncrement);,   }  ],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/tokenattributes/PositionLengthAttributeImpl.java,,24-71,[  private int positionLength = 1;,   ,   /** Initializes this attribute with position length of 1. */,   public PositionLengthAttributeImpl() {},   ,   @Override,   public void setPositionLength(int positionLength) {,     if (positionLength < 1) {,       throw new IllegalArgumentException,         ("Position length must be 1 or greater: got " + positionLength);,     },     this.positionLength = positionLength;,   }, ,   @Override,   public int getPositionLength() {,     return positionLength;,   }, ,   @Override,   public void clear() {,     this.positionLength = 1;,   },   ,   @Override,   public boolean equals(Object other) {,     if (other == this) {,       return true;,     },     ,     if (other instanceof PositionLengthAttributeImpl) {,       PositionLengthAttributeImpl _other = (PositionLengthAttributeImpl) other;,       return positionLength ==  _other.positionLength;,     },  ,     return false;,   }, ,   @Override,   public int hashCode() {,     return positionLength;,   },   ,   @Override,   public void copyTo(AttributeImpl target) {,     PositionLengthAttribute t = (PositionLengthAttribute) target;,     t.setPositionLength(positionLength);,   }  ],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/analysis/tokenattributes/TypeAttributeImpl.java,,28-74,[    this(DEFAULT_TYPE); ,   },   ,   /** Initialize this attribute with <code>type</code> */,   public TypeAttributeImpl(String type) {,     this.type = type;,   },   ,   @Override,   public String type() {,     return type;,   }, ,   @Override,   public void setType(String type) {,     this.type = type;,   }, ,   @Override,   public void clear() {,     type = DEFAULT_TYPE;    ,   }, ,   @Override,   public boolean equals(Object other) {,     if (other == this) {,       return true;,     },     ,     if (other instanceof TypeAttributeImpl) {,       final TypeAttributeImpl o = (TypeAttributeImpl) other;,       return (this.type == null ? o.type == null : this.type.equals(o.type));,     },     ,     return false;,   }, ,   @Override,   public int hashCode() {,     return (type == null) ? 0 : type.hashCode();,   },   ,   @Override,   public void copyTo(AttributeImpl target) {,     TypeAttribute t = (TypeAttribute) target;,     t.setType(type);,   }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/analysis/uima/ae/BasicAEProvider.java,,73-73,[    return UIMAFramework.produceAnalysisEngine(cachedDescription);],,,45-45,[      if (cachedDescription == null) {],,,54-54,[              .parseAnalysisEngineDescription(in);],,,55-55,[          configureDescription(cachedDescription);],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/lucene/analysis/uima/ae/BasicAEProvider.java,getInputSource,84-84,[      return new XMLInputSource(getClass().getResource(aePath));],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/util/CharArrayIterator.java,getText,36-36,[    return array;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/util/CharArrayIterator.java,setText,55-55,[    this.array = array;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/analysis/util/CharArrayIterator.java,current,64-64,[    return (index == limit) ? DONE : jreBugWorkaround(array[index]);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/util/CharacterUtils.java,getBuffer,359-359,[      return buffer;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/analysis/util/OpenStringBuilder.java,getArray,46-46,[  public char[] getArray() { return buf; }],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/analysis/util/OpenStringBuilder.java,set,42-42,[    this.buf = arr;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,,470-470,[public static final String [] TOKEN_TYPES = WikipediaTokenizer.TOKEN_TYPES;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,zzUnpackAction,102-102,[    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,zzUnpackAttribute,366-366,[    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,zzUnpackRowMap,152-152,[    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,zzUnpackTrans,318-318,[    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,,635-635,[    yyline = yychar = yycolumn = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,,635-635,[    yyline = yychar = yycolumn = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,,423-423,[  private boolean zzAtBOL = true;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.java,,631-631,[    zzEOFDone = false;],,
MALICIOUS_CODE,MS_FINAL_PKGPROTECT,org/apache/lucene/benchmark/Constants.java,,29-29,[    public static Boolean[] BOOLEANS = new Boolean[] { Boolean.FALSE, Boolean.TRUE };],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/benchmark/Constants.java,,29-29,[    public static Boolean[] BOOLEANS = new Boolean[] { Boolean.FALSE, Boolean.TRUE };],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/PerfRunData.java,,170-170,[    IOUtils.close(indexReader, directory);],,,172-172,[    indexReader = null;],,,312-312,[    if (indexReader != null) {],,,315-315,[    return indexReader;],,,313-313,[      indexReader.incRef();],,,338-338,[    if (indexReader == this.indexReader) {],,,342-342,[    if (this.indexReader != null) {],,,347-347,[    this.indexReader = indexReader;],,,344-344,[      this.indexReader.decRef();],,,324-324,[    if (indexReader != null) {],,,325-325,[      indexReader.incRef();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/PerfRunData.java,,174-174,[    IOUtils.close(taxonomyWriter, taxonomyReader, taxonomyDir);],,,176-176,[    taxonomyReader = null;],,,289-289,[    if (taxonomyReader != null) {],,,292-292,[    return taxonomyReader;],,,290-290,[      taxonomyReader.incRef();],,,270-270,[    if (taxoReader == this.taxonomyReader) {],,,273-273,[    if (taxonomyReader != null) {],,,274-274,[      taxonomyReader.decRef();],,,280-280,[    this.taxonomyReader = taxoReader;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/AbstractQueryMaker.java,,33-33,[    qnum = 0;],,,64-64,[    int res = qnum;],,,65-65,[    qnum = (qnum+1) % queries.length;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/feeds/AbstractQueryMaker.java,makeQuery,59-59,[    return queries[nextQnum()];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/feeds/AbstractQueryMaker.java,nextQnum,65-65,[    qnum = (qnum+1) % queries.length;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/ContentItemsSource.java,,134-134,[    bytesCount = 0;],,,112-112,[  public final long getBytesCount() { return bytesCount; }],,,72-72,[    bytesCount += numBytes;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/ContentItemsSource.java,,120-120,[  public final long getTotalBytesCount() { return totalBytesCount; }],,,73-73,[    totalBytesCount += numBytes;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/ContentItemsSource.java,,123-123,[  public final int getTotalItemsCount() { return totalItemCount; }],,,79-79,[    ++totalItemCount;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/benchmark/byTask/feeds/ContentItemsSource.java,,88-94,[    Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {,       @Override,       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {,         if (Files.isReadable(file)) {,           files.add(file.toRealPath());,         },         return FileVisitResult.CONTINUE;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/DirContentSource.java,,260-260,[      inputFiles = new Iterator(dataDir);],,,265-265,[    if (inputFiles == null) {],,,244-244,[    inputFiles = new Iterator(dataDir);],,,204-204,[      if (!inputFiles.hasNext()) { ],,,212-212,[      f = inputFiles.next();],,,209-209,[        inputFiles = new Iterator(dataDir);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/benchmark/byTask/feeds/DirContentSource.java,setConfig,265-265,[    if (inputFiles == null) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/benchmark/byTask/feeds/DirContentSource.java,,61-81,[    static class Comparator implements java.util.Comparator<Path> {,       @Override,       public int compare(Path _a, Path _b) {,         String a = _a.toString();,         String b = _b.toString();,         int diff = a.length() - b.length();, ,         if (diff > 0) {,           while (diff-- > 0) {,             b = "0" + b;,           },         } else if (diff < 0) {,           diff = -diff;,           while (diff-- > 0) {,             a = "0" + a;,           },         }, ,         /* note it's reversed because we're going to push,,            which reverses again */,         return b.compareTo(a);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/lucene/benchmark/byTask/feeds/DocData.java,getID,63-63,[    return id;],,getId,153-153,[      return id;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/DocMaker.java,,424-424,[    this.config = config;],,,416-416,[    setConfig(config, source);],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java,time,104-104,[      buffer.append(months[Integer.valueOf(original.substring(5, 7)).intValue() - 1]);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java,,178-178,[        while(!stopped){],,,242-242,[        stopped = true;],,,72-72,[        while(tuple == null && nmde == null && !threadDone && !stopped) {],,,134-134,[              while (tuple != null && !stopped) {],,,195-195,[            if (stopped || !forever) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java,,65-65,[        threadDone = false;],,,72-72,[        while(tuple == null && nmde == null && !threadDone && !stopped) {],,,211-211,[          threadDone = true;],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java,endElement,142-142,[              notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java,next,82-82,[          notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java,run,212-212,[          notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java,stop,245-245,[          notify();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/benchmark/byTask/feeds/EnwikiQueryMaker.java,,41-133,[public class EnwikiQueryMaker extends AbstractQueryMaker implements,     QueryMaker {, ,   // common and a few uncommon queries from wikipedia search logs,   private static String[] STANDARD_QUERIES = { "Images catbox gif",,       "Imunisasi haram", "Favicon ico", "Michael jackson", "Unknown artist",,       "Lily Thai", "Neda", "The Last Song", "Metallica", "Nicola Tesla",,       "Max B", "Skil Corporation", "\"The 100 Greatest Artists of All Time\"",,       "\"Top 100 Global Universities\"", "Pink floyd", "Bolton Sullivan",,       "Frank Lucas Jr", "Drake Woods", "Radiohead", "George Freeman",,       "Oksana Grigorieva", "The Elder Scrolls V", "Deadpool", "Green day",,       "\"Red hot chili peppers\"", "Jennifer Bini Taylor",,       "The Paradiso Girls", "Queen", "3Me4Ph", "Paloma Jimenez", "AUDI A4",,       "Edith Bouvier Beale: A Life In Pictures", "\"Skylar James Deleon\"",,       "Simple Explanation", "Juxtaposition", "The Woody Show", "London WITHER",,       "In A Dark Place", "George Freeman", "LuAnn de Lesseps", "Muhammad.",,       "U2", "List of countries by GDP", "Dean Martin Discography", "Web 3.0",,       "List of American actors", "The Expendables",,       "\"100 Greatest Guitarists of All Time\"", "Vince Offer.",,       "\"List of ZIP Codes in the United States\"", "Blood type diet",,       "Jennifer Gimenez", "List of hobbies", "The beatles", "Acdc",,       "Nightwish", "Iron maiden", "Murder Was the Case", "Pelvic hernia",,       "Naruto Shippuuden", "campaign", "Enthesopathy of hip region",,       "operating system", "mouse",,       "List of Xbox 360 games without region encoding", "Shakepearian sonnet",,       "\"The Monday Night Miracle\"", "India", "Dad's Army",,       "Solanum melanocerasum", "\"List of PlayStation Portable Wi-Fi games\"",,       "Little Pixie Geldof", "Planes, Trains & Automobiles", "Freddy Ingalls",,       "The Return of Chef", "Nehalem", "Turtle", "Calculus", "Superman-Prime",,       "\"The Losers\"", "pen-pal", "Audio stream input output", "lifehouse",,       "50 greatest gunners", "Polyfecalia", "freeloader", "The Filthy Youth" };, ,   private static Query[] getPrebuiltQueries(String field) {,     WildcardQuery wcq = new WildcardQuery(new Term(field, "fo*"));,     wcq .setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);,     // be wary of unanalyzed text,     return new Query[] {,         new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 5),,         new SpanNearQuery(new SpanQuery[] {,             new SpanTermQuery(new Term(field, "night")),,             new SpanTermQuery(new Term(field, "trading")) }, 4, false),,         new SpanNearQuery(new SpanQuery[] {,             new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 10),,             new SpanTermQuery(new Term(field, "credit")) }, 10, false), wcq, };,   }, ,   /**,    * Parse the strings containing Lucene queries.,    * ,    * @param qs array of strings containing query expressions,    * @param a analyzer to use when parsing queries,    * @return array of Lucene queries,    */,   private static Query[] createQueries(List<Object> qs, Analyzer a) {,     QueryParser qp = new QueryParser(DocMaker.BODY_FIELD, a);,     List<Object> queries = new ArrayList<>();,     for (int i = 0; i < qs.size(); i++) {,       try {, ,         Object query = qs.get(i);,         Query q = null;,         if (query instanceof String) {,           q = qp.parse((String) query);, ,         } else if (query instanceof Query) {,           q = (Query) query;, ,         } else {,           System.err.println("Unsupported Query Type: " + query);,         }, ,         if (q != null) {,           queries.add(q);,         }, ,       } catch (Exception e) {,         e.printStackTrace();,       },     }, ,     return queries.toArray(new Query[0]);,   }, ,   @Override,   protected Query[] prepareQueries() throws Exception {,     // analyzer (default is standard analyzer),     Analyzer anlzr = NewAnalyzerTask.createAnalyzer(config.get("analyzer", StandardAnalyzer.class.getName()));, ,     List<Object> queryList = new ArrayList<>(20);,     queryList.addAll(Arrays.asList(STANDARD_QUERIES));,     if(!config.get("enwikiQueryMaker.disableSpanQueries", false)),       queryList.addAll(Arrays.asList(getPrebuiltQueries(DocMaker.BODY_FIELD)));,     return createQueries(queryList, anlzr);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/lucene/benchmark/byTask/feeds/FileBasedQueryMaker.java,prepareQueries,78-78,[          BufferedReader buffered = new BufferedReader(reader);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/benchmark/byTask/feeds/FileBasedQueryMaker.java,,48-100,[public class FileBasedQueryMaker extends AbstractQueryMaker implements QueryMaker{, , ,   @Override,   protected Query[] prepareQueries() throws Exception {, ,     Analyzer anlzr = NewAnalyzerTask.createAnalyzer(config.get("analyzer",,             "org.apache.lucene.analysis.standard.StandardAnalyzer"));,     String defaultField = config.get("file.query.maker.default.field", DocMaker.BODY_FIELD);,     QueryParser qp = new QueryParser(defaultField, anlzr);,     qp.setAllowLeadingWildcard(true);, ,     List<Query> qq = new ArrayList<>();,     String fileName = config.get("file.query.maker.file", null);,     if (fileName != null),     {,       Path path = Paths.get(fileName);,       Reader reader = null;,       // note: we use a decoding reader, so if your queries are screwed up you know,       if (Files.exists(path)) {,         reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);,       } else {,         //see if we can find it as a resource,         InputStream asStream = FileBasedQueryMaker.class.getClassLoader().getResourceAsStream(fileName);,         if (asStream != null) {,           reader = IOUtils.getDecodingReader(asStream, StandardCharsets.UTF_8);,         },       },       if (reader != null) {,         try {,           BufferedReader buffered = new BufferedReader(reader);,           String line = null;,           int lineNum = 0;,           while ((line = buffered.readLine()) != null) {,             line = line.trim();,             if (line.length() != 0 && !line.startsWith("#")) {,               try {,                 qq.add(qp.parse(line));,               } catch (ParseException e) {,                 System.err.println("Exception: " + e.getMessage() + " occurred while parsing line: " + lineNum + " Text: " + line);,               },             },             lineNum++;,           },         } finally {,           reader.close();,         },       } else {,         System.err.println("No Reader available for: " + fileName);,       },       ,     },     return qq.toArray(new Query[qq.size()]) ;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/LineDocSource.java,,232-232,[    docDataLineReader.parseLine(docData, line);],,,219-219,[      if (docDataLineReader == null) { // first line ever, one time initialization,],,,220-220,[        docDataLineReader = createDocDataLineReader(line);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/LineDocSource.java,,280-280,[    file = Paths.get(fileName).toAbsolutePath();],,,186-186,[      InputStream is = StreamUtils.inputStream(file);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/benchmark/byTask/feeds/LineDocSource.java,createDocDataLineReader,255-255,[      } catch (Exception e) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/benchmark/byTask/feeds/LineDocSource.java,<init>,62-62,[      this.header = header; ],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/LongToEnglishContentSource.java,,63-63,[    counter = Long.MIN_VALUE + 10;],,,46-46,[      curCounter = counter;],,,47-47,[      if (counter == Long.MAX_VALUE){],,,50-50,[        ++counter;],,,48-48,[        counter = Long.MIN_VALUE;//loop around],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/LongToEnglishQueryMaker.java,,67-67,[    counter = Long.MIN_VALUE + 10;],,,72-72,[    return "LongToEnglish: [" + Long.MIN_VALUE + " TO " + counter + "]";],,,53-53,[    if (counter == Long.MAX_VALUE){],,,56-56,[    return counter++;],,,54-54,[      counter = Long.MIN_VALUE + 10;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/feeds/LongToEnglishQueryMaker.java,,62-62,[    parser = new QueryParser(DocMaker.BODY_FIELD, anlzr);],,,49-49,[    return parser.parse("" + rnbf.format(getNextCounter()) + "");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/feeds/LongToEnglishQueryMaker.java,makeQuery,49-49,[    return parser.parse("" + rnbf.format(getNextCounter()) + "");],,
CORRECTNESS,UR_UNINIT_READ,org/apache/lucene/benchmark/byTask/feeds/RandomFacetSource.java,<init>,52-52,[  private int maxValue = maxDocFacets * maxFacetDepth;],,
CORRECTNESS,UR_UNINIT_READ,org/apache/lucene/benchmark/byTask/feeds/RandomFacetSource.java,<init>,52-52,[  private int maxValue = maxDocFacets * maxFacetDepth;],,
STYLE,NP_DEREFERENCE_OF_READLINE_VALUE,org/apache/lucene/benchmark/byTask/feeds/ReutersContentSource.java,getNextDocData,135-135,[      Date date = parseDate(dateStr.trim());],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java,,40-113,[public class ReutersQueryMaker extends AbstractQueryMaker implements QueryMaker {, ,   private static String [] STANDARD_QUERIES = {,     //Start with some short queries,     "Salomon", "Comex", "night trading", "Japan Sony",,     //Try some Phrase Queries,     "\"Sony Japan\"", "\"food needs\"~3",,     "\"World Bank\"^2 AND Nigeria", "\"World Bank\" -Nigeria",,     "\"Ford Credit\"~5",,     //Try some longer queries,     "airline Europe Canada destination",,     "Long term pressure by trade " +,     "ministers is necessary if the current Uruguay round of talks on " +,     "the General Agreement on Trade and Tariffs (GATT) is to " +,     "succeed",   };,   ,   private static Query[] getPrebuiltQueries(String field) {,     //  be wary of unanalyzed text,     return new Query[] {,         new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 5),,         new SpanNearQuery(new SpanQuery[]{new SpanTermQuery(new Term(field, "night")), new SpanTermQuery(new Term(field, "trading"))}, 4, false),,         new SpanNearQuery(new SpanQuery[]{new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 10), new SpanTermQuery(new Term(field, "credit"))}, 10, false),,         new WildcardQuery(new Term(field, "fo*")),,     };,   },   ,   /**,    * Parse the strings containing Lucene queries.,    *,    * @param qs array of strings containing query expressions,    * @param a  analyzer to use when parsing queries,    * @return array of Lucene queries,    */,   private static Query[] createQueries(List<Object> qs, Analyzer a) {,     QueryParser qp = new QueryParser(DocMaker.BODY_FIELD, a);,     List<Object> queries = new ArrayList<>();,     for (int i = 0; i < qs.size(); i++)  {,       try {,         ,         Object query = qs.get(i);,         Query q = null;,         if (query instanceof String) {,           q = qp.parse((String) query);,           ,         } else if (query instanceof Query) {,           q = (Query) query;,           ,         } else {,           System.err.println("Unsupported Query Type: " + query);,         },         ,         if (q != null) {,           queries.add(q);,         },         ,       } catch (Exception e)  {,         e.printStackTrace();,       },     },     ,     return queries.toArray(new Query[0]);,   },   ,   @Override,   protected Query[] prepareQueries() throws Exception {,     // analyzer (default is standard analyzer),     Analyzer anlzr= NewAnalyzerTask.createAnalyzer(config.get("analyzer",,     "org.apache.lucene.analysis.standard.StandardAnalyzer")); ,     ,     List<Object> queryList = new ArrayList<>(20);,     queryList.addAll(Arrays.asList(STANDARD_QUERIES));,     queryList.addAll(Arrays.asList(getPrebuiltQueries(DocMaker.BODY_FIELD)));,     return createQueries(queryList, anlzr);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java,,35-67,[public class SimpleQueryMaker extends AbstractQueryMaker implements QueryMaker {, , ,   /**,    * Prepare the queries for this test.,    * Extending classes can override this method for preparing different queries. ,    * @return prepared queries.,    * @throws Exception if cannot prepare the queries.,    */,   @Override,   protected Query[] prepareQueries() throws Exception {,     // analyzer (default is standard analyzer),     Analyzer anlzr= NewAnalyzerTask.createAnalyzer(config.get("analyzer",,         "org.apache.lucene.analysis.standard.StandardAnalyzer")); ,     ,     QueryParser qp = new QueryParser(DocMaker.BODY_FIELD,anlzr);,     ArrayList<Query> qq = new ArrayList<>();,     Query q1 = new TermQuery(new Term(DocMaker.ID_FIELD,"doc2"));,     qq.add(q1);,     Query q2 = new TermQuery(new Term(DocMaker.BODY_FIELD,"simple"));,     qq.add(q2);,     BooleanQuery bq = new BooleanQuery();,     bq.add(q1,Occur.MUST);,     bq.add(q2,Occur.MUST);,     qq.add(bq);,     qq.add(qp.parse("synthetic body"));,     qq.add(qp.parse("\"synthetic body\""));,     qq.add(qp.parse("synthetic text"));,     qq.add(qp.parse("\"synthetic text\""));,     qq.add(qp.parse("\"synthetic text\"~3"));,     qq.add(qp.parse("zoom*"));,     qq.add(qp.parse("synth*"));,     return  qq.toArray(new Query[0]);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/feeds/SpatialDocMaker.java,makeDocument,177-177,[      shape = shapeConverter.convert(shape);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/feeds/SpatialDocMaker.java,makeDocument,179-179,[      for (Field f : strategy.createIndexableFields(shape)) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/benchmark/byTask/feeds/SpatialDocMaker.java,,76-84,[    Map<String, String> configMap = new AbstractMap<String, String>() {,       @Override,       public Set<Entry<String, String>> entrySet() {,         throw new UnsupportedOperationException();,       }, ,       @Override,       public String get(Object key) {,         return config.get("spatial." + key, null);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/feeds/SpatialFileQueryMaker.java,prepareQueries,84-84,[          shape = shapeConverter.convert(shape);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/feeds/SpatialFileQueryMaker.java,makeQueryFromShape,111-111,[      Filter filter = strategy.makeFilter(args);],,makeQueryFromShape,105-105,[      ValueSource valueSource = strategy.makeDistanceValueSource(shape.getCenter());],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/benchmark/byTask/feeds/TrecContentSource.java,read,155-155,[          sep = NEW_LINE;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/benchmark/byTask/feeds/TrecContentSource.java,openNextFile,188-188,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/benchmark/byTask/feeds/TrecContentSource.java,setConfig,315-315,[    } catch (Exception e) {],,setConfig,324-324,[    } catch (Exception e) {],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/lucene/benchmark/byTask/feeds/TrecContentSource.java,read,150-150,[      line.length();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/feeds/TrecContentSource.java,read,143-143,[      String line = reader.readLine();],,
STYLE,DMI_USELESS_SUBSTRING,org/apache/lucene/benchmark/byTask/feeds/TrecDocParser.java,stripTags,99-99,[      buf = buf.substring(0);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/lucene/benchmark/byTask/feeds/TrecDocParser.java,pathType,63-63,[      ParsePathType ppt = pathName2Type.get(f.getFileName().toString().toUpperCase(Locale.ROOT));],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/lucene/benchmark/byTask/feeds/TrecFBISParser.java,parse,61-61,[    docData.setBody(stripTags(docBuf, mark).toString());],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/lucene/benchmark/byTask/feeds/TrecFR94Parser.java,parse,55-55,[        dateStr = stripTags(dateStr,0).toString();],,parse,62-62,[    docData.setBody(stripTags(docBuf, mark).toString());],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/lucene/benchmark/byTask/feeds/TrecFTParser.java,parse,53-53,[    docData.setBody(stripTags(docBuf, mark).toString());],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/lucene/benchmark/byTask/feeds/TrecLATimesParser.java,parse,50-50,[      dateStr = stripTags(dateStr,0).toString();],,parse,60-60,[      title = stripTags(title,0).toString().trim();],,parse,67-67,[    docData.setBody(stripTags(docBuf, mark).toString());],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/benchmark/byTask/stats/Points.java,,70-70,[    return currentStats;],,,64-64,[    this.currentStats = stats;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/benchmark/byTask/stats/TaskStats.java,getCountsByTime,104-104,[    return countsByTime;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/benchmark/byTask/stats/TaskStats.java,setCountsByTime,99-99,[    countsByTime = counts;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/lucene/benchmark/byTask/tasks/AddDocTask.java,setup,47-54,[    super.setup();,     DocMaker docMaker = getRunData().getDocMaker();,     if (docSize > 0) {,       doc = docMaker.makeDocument(docSize);,     } else {,       doc = docMaker.makeDocument();,     },   }],,setUp,51-51,[public abstract class BaseCompoundFormatTestCase extends BaseIndexFileFormatTestCase {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/tasks/AddIndexesTask.java,tearDown,98-98,[    inputDir.close();],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask.java,createAnalysisPipelineComponent,339-345,[                  argValue = TRAILING_DOT_ZERO_PATTERN.matcher(argValue).replaceFirst("");,                   // Intentional fall-through,               },               case '"':,               case '\'':,               case StreamTokenizer.TT_WORD: {,                 argMap.put(argName, argValue);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask.java,setParams,156-162,[                  argValue = TRAILING_DOT_ZERO_PATTERN.matcher(argValue).replaceFirst("");,                   // Intentional fallthrough,                 },                 case '"':,                 case '\'':,                 case StreamTokenizer.TT_WORD: {,                   if (argName.equalsIgnoreCase("name")) {],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/benchmark/byTask/tasks/PerfTask.java,runAndMaybeStats,140-140,[    if (reportStats && depth <= maxDepthLogStart && !shouldNeverLogAtStart()) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/benchmark/byTask/tasks/ReadTokensTask.java,,103-103,[  ReusableStringReader stringReader = new ReusableStringReader();],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/benchmark/byTask/tasks/ReportTask.java,,70-70,[  protected static final String COLS[] = {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/benchmark/byTask/tasks/RollbackIndexTask.java,,36-36,[  boolean doWait = true;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/benchmark/byTask/tasks/SearchWithCollectorTask.java,createCollector,55-55,[    if (clnName.equalsIgnoreCase("topScoreDocOrdered") == true) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java,,34-34,[  public static int REPEAT_EXHAUST = -2; ],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/lucene/benchmark/byTask/tasks/WriteEnwikiLineDocTask.java,categoriesLineFile,55-55,[    return dir.resolve(categoriesName);],,categoriesLineFile,53-53,[    Path dir = f.toAbsolutePath().getParent();],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/benchmark/byTask/tasks/WriteLineDocTask.java,,75-75,[  public static final String[] DEFAULT_FIELDS = new String[] {],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/benchmark/byTask/utils/Algorithm.java,<init>,254-258,[              currSequence.setNoChildReport(); /* intentional fallthrough */,             case '}' : ,             case ']' : ,               // end sequence,               colonOk = true; prevTask = currSequence;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/benchmark/byTask/utils/Algorithm.java,<init>,157-263,[          switch(c) {,           ,             case ':' :,               if (!colonOk) throw new Exception("colon unexpexted: - "+stok.toString());,               colonOk = false;,               // get repetitions number,               stok.nextToken();,               if ((char)stok.ttype == '*') {,                 ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);,               } else {,                 if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {,                   throw new Exception("expected repetitions number or XXXs: - "+stok.toString());,                 } else {,                   double num = stok.nval;,                   stok.nextToken();,                   if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals("s")) {,                     ((TaskSequence) prevTask).setRunTime(num);,                   } else {,                     stok.pushBack();,                     ((TaskSequence) prevTask).setRepetitions((int) num);,                   },                 },               },               // check for rate specification (ops/min),               stok.nextToken();,               if (stok.ttype!=':') {,                 stok.pushBack();,               } else {,                 // get rate number,                 stok.nextToken();,                 if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception("expected rate number: - "+stok.toString());,                 // check for unit - min or sec, sec is default,                 stok.nextToken();,                 if (stok.ttype!='/') {,                   stok.pushBack();,                   ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec,                 } else {,                   stok.nextToken();,                   if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception("expected rate unit: 'min' or 'sec' - "+stok.toString());,                   String unit = stok.sval.toLowerCase(Locale.ROOT);,                   if ("min".equals(unit)) {,                     ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min,                   } else if ("sec".equals(unit)) {,                     ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec,                   } else {,                     throw new Exception("expected rate unit: 'min' or 'sec' - "+stok.toString());,                   },                 },               },               colonOk = false;,               break;,     ,             case '{' : ,             case '[' :  ,               // a sequence,               // check for sequence name,               String name = null;,               stok.nextToken();,               if (stok.ttype!='"') {,                 stok.pushBack();,               } else {,                 name = stok.sval;,                 if (stok.ttype!='"' || name==null || name.length()==0) {,                   throw new Exception("sequence name problem - "+stok.toString()); ,                 },               },               // start the sequence,               TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');,               currSequence.addTask(seq2);,               currSequence = seq2;,               colonOk = false;,               break;, ,             case '&' :,               if (currSequence.isParallel()) {,                 throw new Exception("Can only create background tasks within a serial task");,               },               stok.nextToken();,               final int deltaPri;,               if (stok.ttype != StreamTokenizer.TT_NUMBER) {,                 stok.pushBack();,                 deltaPri = 0;,               } else {,                 // priority,                 deltaPri = (int) stok.nval;,               }, ,               if (prevTask == null) {,                 throw new Exception("& was unexpected");,               } else if (prevTask.getRunInBackground()) {,                 throw new Exception("double & was unexpected");,               } else {,                 prevTask.setRunInBackground(deltaPri);,               },               break;,     ,             case '>' :,               currSequence.setNoChildReport(); /* intentional fallthrough */,             case '}' : ,             case ']' : ,               // end sequence,               colonOk = true; prevTask = currSequence;,               currSequence = currSequence.getParent();,               break;,           ,             case '-' :,               isDisableCountNextTask = true;],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/benchmark/byTask/utils/Algorithm.java,<init>,219-219,[                if (stok.ttype!='"' || name==null || name.length()==0) {],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/lucene/benchmark/byTask/utils/Config.java,propToBooleanArray,374-374,[      a.add(new Boolean(t));],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/benchmark/byTask/utils/Config.java,getColsNamesForValsByRound,392-392,[      String colName = colForValByRound.get(name);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/benchmark/byTask/utils/Config.java,getColsValuesForValsByRound,407-407,[      String colName = colForValByRound.get(name);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/benchmark/byTask/utils/Config.java,newRound,280-280,[        Object a = valByRound.get(name);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/lucene/benchmark/byTask/utils/StreamUtils.java,fileType,95-95,[    String fileName = file.getFileName().toString();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/benchmark/quality/QualityBenchmark.java,<init>,72-72,[    this.qualityQueries = qqs;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/benchmark/quality/QualityQuery.java,compareTo,78-83,[      int n = Integer.parseInt(queryID);,       int nOther = Integer.parseInt(other.queryID);,       return n - nOther;,     } catch (NumberFormatException e) {,       // fall back to string comparison,       return queryID.compareTo(other.queryID);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/benchmark/quality/trec/TrecTopicsReader.java,read,126-126,[          sep = newline;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/benchmark/quality/utils/SimpleQQParser.java,<init>,46-46,[    this.qqNames = qqNames;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/benchmark/utils/ExtractWikipedia.java,,43-43,[  static public int count = 0;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/benchmark/utils/ExtractWikipedia.java,extract,96-96,[      while ((doc = docMaker.makeDocument()) != null) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/lucene/benchmark/utils/ExtractWikipedia.java,create,73-73,[    Path d = directory(count++, null);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/classification/CachingNaiveBayesClassifier.java,assignClassNormalizedList,97-129,[    if (leafReader == null) {,       throw new IOException("You must first call Classifier#train");,     }, ,     String[] tokenizedDoc = tokenizeDoc(inputDocument);, ,     List<ClassificationResult<BytesRef>> dataList = calculateLogLikelihood(tokenizedDoc);, ,     // normalization,     // The values transforms to a 0-1 range,     ArrayList<ClassificationResult<BytesRef>> returnList = new ArrayList<>();,     if (!dataList.isEmpty()) {,       Collections.sort(dataList);,       // this is a negative number closest to 0 = a,       double smax = dataList.get(0).getScore();, ,       double sumLog = 0;,       // log(sum(exp(x_n-a))),       for (ClassificationResult<BytesRef> cr : dataList) {,         // getScore-smax <=0 (both negative, smax is the smallest abs(),         sumLog += Math.exp(cr.getScore() - smax);,       },       // loga=a+log(sum(exp(x_n-a))) = log(sum(exp(x_n))),       double loga = smax;,       loga += Math.log(sumLog);, ,       // 1/sum*x = exp(log(x))*1/sum = exp(log(x)-log(sum)),       for (ClassificationResult<BytesRef> cr : dataList) {,         returnList.add(new ClassificationResult<>(cr.getAssignedClass(), Math.exp(cr.getScore() - loga)));,       },     }, ,     return returnList;],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/lucene/classification/ClassificationResult.java,getScore,65-65,[    return this.getScore() < o.getScore() ? 1 : this.getScore() > o.getScore() ? -1 : 0;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/classification/ClassificationResult.java,compareTo,65-65,[    return this.getScore() < o.getScore() ? 1 : this.getScore() > o.getScore() ? -1 : 0;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/classification/KNearestNeighborClassifier.java,train,185-185,[    this.textFieldNames = textFieldNames;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/classification/KNearestNeighborClassifier.java,buildListFromTopDocs,139-139,[      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/classification/KNearestNeighborClassifier.java,knnSearch,133-133,[    return indexSearcher.search(mltQuery, k);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/classification/KNearestNeighborClassifier.java,knnSearch,125-125,[    for (String textFieldName : textFieldNames) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/classification/SimpleNaiveBayesClassifier.java,train,114-114,[    this.textFieldNames = textFieldNames;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/classification/utils/DatasetSplitter.java,split,122-122,[    } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,253-256,[                    new Iterable<Number>() {,                       @Override,                       public Iterator<Number> iterator() {,                         return new Iterator<Number>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,334-337,[                   new Iterable<BytesRef>() {,                      @Override,                      public Iterator<BytesRef> iterator() {,                        return new Iterator<BytesRef>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,419-422,[        new Iterable<Number>() {,           @Override,           public Iterator<Number> iterator() {,             return new Iterator<Number>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,482-485,[        new Iterable<Number>() {,           @Override,           public Iterator<Number> iterator() {,             return new Iterator<Number>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,598-601,[        new Iterable<BytesRef>() {,           @Override,           public Iterator<BytesRef> iterator() {,             return new Iterator<BytesRef>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,629-632,[        new Iterable<Number>() {,           @Override,           public Iterator<Number> iterator() {,             return new Iterator<Number>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,738-741,[        new Iterable<BytesRef>() {,           @Override,           public Iterator<BytesRef> iterator() {,             return new Iterator<BytesRef>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,769-772,[        new Iterable<Number>() {,           @Override,           public Iterator<Number> iterator() {,             return new Iterator<Number>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/DocValuesConsumer.java,,836-839,[        new Iterable<Number>() {,           @Override,           public Iterator<Number> iterator() {,             return new Iterator<Number>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/NormsConsumer.java,,111-114,[                    new Iterable<Number>() {,                       @Override,                       public Iterator<Number> iterator() {,                         return new Iterator<Number>() {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/StoredFieldsWriter.java,name,191-191,[      return currentField.name;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/codecs/asserting/AssertingDocValuesFormat.java,addNumericField,83-83,[      for (Number v : values) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/codecs/asserting/AssertingPostingsFormat.java,write,158-158,[        assert terms != null;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/lucene/codecs/blockterms/BlockTermsReader.java,equals,92-92,[      FieldAndTerm other = (FieldAndTerm) _other;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/codecs/blockterms/BlockTermsReader.java,equals,92-93,[      FieldAndTerm other = (FieldAndTerm) _other;,       return other.field.equals(field) && term.bytesEquals(other.term);],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/lucene/codecs/blockterms/BlockTermsReader.java,seekCeil,362-362,[          if (nextIndexTerm == null) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/codecs/blockterms/BlockTermsWriter.java,,60-193,[public class BlockTermsWriter extends FieldsConsumer implements Closeable {, ,   final static String CODEC_NAME = "BlockTermsWriter";, ,   // Initial format,   public static final int VERSION_START = 4;,   public static final int VERSION_CURRENT = VERSION_START;, ,   /** Extension of terms file */,   static final String TERMS_EXTENSION = "tib";, ,   protected IndexOutput out;,   final PostingsWriterBase postingsWriter;,   final FieldInfos fieldInfos;,   FieldInfo currentField;,   private final TermsIndexWriterBase termsIndexWriter;,   private final int maxDoc;, ,   private static class FieldMetaData {,     public final FieldInfo fieldInfo;,     public final long numTerms;,     public final long termsStartPointer;,     public final long sumTotalTermFreq;,     public final long sumDocFreq;,     public final int docCount;,     public final int longsSize;, ,     public FieldMetaData(FieldInfo fieldInfo, long numTerms, long termsStartPointer, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize) {,       assert numTerms > 0;,       this.fieldInfo = fieldInfo;,       this.termsStartPointer = termsStartPointer;,       this.numTerms = numTerms;,       this.sumTotalTermFreq = sumTotalTermFreq;,       this.sumDocFreq = sumDocFreq;,       this.docCount = docCount;,       this.longsSize = longsSize;,     },   }, ,   private final List<FieldMetaData> fields = new ArrayList<>();, ,   // private final String segment;, ,   public BlockTermsWriter(TermsIndexWriterBase termsIndexWriter,,       SegmentWriteState state, PostingsWriterBase postingsWriter),       throws IOException {,     final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);,     this.termsIndexWriter = termsIndexWriter;,     maxDoc = state.segmentInfo.getDocCount();,     out = state.directory.createOutput(termsFileName, state.context);,     boolean success = false;,     try {,       fieldInfos = state.fieldInfos;,       CodecUtil.writeIndexHeader(out, CODEC_NAME, VERSION_CURRENT, state.segmentInfo.getId(), state.segmentSuffix);,       currentField = null;,       this.postingsWriter = postingsWriter;,       // segment = state.segmentName;,       ,       //System.out.println("BTW.init seg=" + state.segmentName);,       ,       postingsWriter.init(out, state); // have consumer write its format/header,       success = true;,     } finally {,       if (!success) {,         IOUtils.closeWhileHandlingException(out);,       },     },   }, ,   @Override,   public void write(Fields fields) throws IOException {, ,     for(String field : fields) {, ,       Terms terms = fields.terms(field);,       if (terms == null) {,         continue;,       }, ,       TermsEnum termsEnum = terms.iterator(null);, ,       TermsWriter termsWriter = addField(fieldInfos.fieldInfo(field));, ,       while (true) {,         BytesRef term = termsEnum.next();,         if (term == null) {,           break;,         }, ,         termsWriter.write(term, termsEnum);,       }, ,       termsWriter.finish();,     },   }, ,   private TermsWriter addField(FieldInfo field) throws IOException {,     //System.out.println("\nBTW.addField seg=" + segment + " field=" + field.name);,     assert currentField == null || currentField.name.compareTo(field.name) < 0;,     currentField = field;,     TermsIndexWriterBase.FieldWriter fieldIndexWriter = termsIndexWriter.addField(field, out.getFilePointer());,     return new TermsWriter(fieldIndexWriter, field, postingsWriter);,   }, ,   @Override,   public void close() throws IOException {,     if (out != null) {,       try {,         final long dirStart = out.getFilePointer();,         ,         out.writeVInt(fields.size());,         for(FieldMetaData field : fields) {,           out.writeVInt(field.fieldInfo.number);,           out.writeVLong(field.numTerms);,           out.writeVLong(field.termsStartPointer);,           if (field.fieldInfo.getIndexOptions() != IndexOptions.DOCS) {,             out.writeVLong(field.sumTotalTermFreq);,           },           out.writeVLong(field.sumDocFreq);,           out.writeVInt(field.docCount);,           out.writeVInt(field.longsSize);,         },         writeTrailer(dirStart);,         CodecUtil.writeFooter(out);,       } finally {,         IOUtils.close(out, postingsWriter, termsIndexWriter);,         out = null;,       },     },   }, ,   private void writeTrailer(long dirStart) throws IOException {,     out.writeLong(dirStart);    ,   }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/codecs/blockterms/FixedGapTermsIndexReader.java,,217-278,[  private final class FieldIndexData implements Accountable {,     // where this field's terms begin in the packed byte[],     // data,     final long termBytesStart;,     ,     // offset into index termBytes,     final MonotonicBlockPackedReader termOffsets;,     ,     // index pointers into main terms dict,     final MonotonicBlockPackedReader termsDictOffsets;,     ,     final long numIndexTerms;,     final long termsStart;,     ,     public FieldIndexData(IndexInput in, PagedBytes termBytes, long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, long numIndexTerms) throws IOException {,       ,       this.termsStart = termsStart;,       termBytesStart = termBytes.getPointer();,       ,       IndexInput clone = in.clone();,       clone.seek(indexStart);,       ,       this.numIndexTerms = numIndexTerms;,       assert this.numIndexTerms  > 0: "numIndexTerms=" + numIndexTerms;,       ,       // slurp in the images from disk:,       ,       try {,         final long numTermBytes = packedIndexStart - indexStart;,         termBytes.copy(clone, numTermBytes);,         ,         // records offsets into main terms dict file,         termsDictOffsets = MonotonicBlockPackedReader.of(clone, packedIntsVersion, blocksize, numIndexTerms, false);,         ,         // records offsets into byte[] term data,         termOffsets = MonotonicBlockPackedReader.of(clone, packedIntsVersion, blocksize, 1+numIndexTerms, false);,       } finally {,         clone.close();,       },     },     ,     @Override,     public long ramBytesUsed() {,       return ((termOffsets!=null)? termOffsets.ramBytesUsed() : 0) + ,           ((termsDictOffsets!=null)? termsDictOffsets.ramBytesUsed() : 0);,     }, ,     @Override,     public Iterable<Accountable> getChildResources() {,       List<Accountable> resources = new ArrayList<>();,       if (termOffsets != null) {,         resources.add(Accountables.namedAccountable("term lengths", termOffsets));,       },       if (termsDictOffsets != null) {,         resources.add(Accountables.namedAccountable("offsets", termsDictOffsets));,       },       return Collections.unmodifiableList(resources);,     }, ,     @Override,     public String toString() {,       return "FixedGapTermIndex(indexterms=" + numIndexTerms + ")";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/codecs/blockterms/VariableGapTermsIndexReader.java,,144-178,[  private final class FieldIndexData implements Accountable {,     private final FST<Long> fst;, ,     public FieldIndexData(IndexInput in, FieldInfo fieldInfo, long indexStart) throws IOException {,       IndexInput clone = in.clone();,       clone.seek(indexStart);,       fst = new FST<>(clone, fstOutputs);,       clone.close();, ,       /*,       final String dotFileName = segment + "_" + fieldInfo.name + ".dot";,       Writer w = new OutputStreamWriter(new FileOutputStream(dotFileName));,       Util.toDot(fst, w, false, false);,       System.out.println("FST INDEX: SAVED to " + dotFileName);,       w.close();,       */,     }, ,     @Override,     public long ramBytesUsed() {,       return fst == null ? 0 : fst.ramBytesUsed();,     }, ,     @Override,     public Iterable<Accountable> getChildResources() {,       if (fst == null) {,         return Collections.emptyList();,       } else {,         return Collections.singletonList(Accountables.namedAccountable("index data", fst));,       },     },     ,     @Override,     public String toString() {,       return "VarGapTermIndex";],,
CORRECTNESS,IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN,org/apache/lucene/codecs/blocktree/BlockTreeTermsReader.java,seekDir,222-222,[    dirOffset = input.readLong();],,
CORRECTNESS,UR_UNINIT_READ,org/apache/lucene/codecs/blocktree/BlockTreeTermsReader.java,<init>,148-148,[      seekDir(termsIn, dirOffset);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java,finish,939-939,[                                     ((PendingBlock) pending.get(0)).index.getEmptyOutput(),],,finish,916-916,[        assert root.index.getEmptyOutput() != null;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java,writeBlock,762-762,[            PendingBlock block = (PendingBlock) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java,writeBlock,679-679,[          PendingTerm term = (PendingTerm) ent;],,writeBlock,719-719,[            PendingTerm term = (PendingTerm) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java,writeBlocks,572-572,[          PendingBlock block = (PendingBlock) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java,writeBlocks,561-561,[          PendingTerm term = (PendingTerm) ent;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java,writeBlock,680-680,[          assert StringHelper.startsWith(term.termBytes, prefix): "term.term=" + term.termBytes + " prefix=" + prefix;],,writeBlock,720-720,[            assert StringHelper.startsWith(term.termBytes, prefix): "term.term=" + term.termBytes + " prefix=" + prefix;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/lucene/codecs/blocktree/IntersectTermsEnum.java,<init>,92-92,[    final FST.Arc<BytesRef> arc = fr.index.getFirstArc(arcs[0]);],,<init>,79-79,[    if (fr.index == null) {],,<init>,80-80,[      fstReader = null;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/codecs/blocktree/SegmentTermsEnum.java,printSeekState,823-867,[    if (currentFrame == staticFrame) {,       out.println("  no prior seek");,     } else {,       out.println("  prior seek state:");,       int ord = 0;,       boolean isSeekFrame = true;,       while(true) {,         SegmentTermsEnumFrame f = getFrame(ord);,         assert f != null;,         final BytesRef prefix = new BytesRef(term.get().bytes, 0, f.prefix);,         if (f.nextEnt == -1) {,           out.println("    frame " + (isSeekFrame ? "(seek)" : "(next)") + " ord=" + ord + " fp=" + f.fp + (f.isFloor ? (" (fpOrig=" + f.fpOrig + ")") : "") + " prefixLen=" + f.prefix + " prefix=" + prefix + (f.nextEnt == -1 ? "" : (" (of " + f.entCount + ")")) + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " code=" + ((f.fp<< BlockTreeTermsReader.OUTPUT_FLAGS_NUM_BITS) + (f.hasTerms ? BlockTreeTermsReader.OUTPUT_FLAG_HAS_TERMS:0) + (f.isFloor ? BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR:0)) + " isLastInFloor=" + f.isLastInFloor + " mdUpto=" + f.metaDataUpto + " tbOrd=" + f.getTermBlockOrd());,         } else {,           out.println("    frame " + (isSeekFrame ? "(seek, loaded)" : "(next, loaded)") + " ord=" + ord + " fp=" + f.fp + (f.isFloor ? (" (fpOrig=" + f.fpOrig + ")") : "") + " prefixLen=" + f.prefix + " prefix=" + prefix + " nextEnt=" + f.nextEnt + (f.nextEnt == -1 ? "" : (" (of " + f.entCount + ")")) + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " code=" + ((f.fp<< BlockTreeTermsReader.OUTPUT_FLAGS_NUM_BITS) + (f.hasTerms ? BlockTreeTermsReader.OUTPUT_FLAG_HAS_TERMS:0) + (f.isFloor ? BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR:0)) + " lastSubFP=" + f.lastSubFP + " isLastInFloor=" + f.isLastInFloor + " mdUpto=" + f.metaDataUpto + " tbOrd=" + f.getTermBlockOrd());,         },         if (fr.index != null) {,           assert !isSeekFrame || f.arc != null: "isSeekFrame=" + isSeekFrame + " f.arc=" + f.arc;,           if (f.prefix > 0 && isSeekFrame && f.arc.label != (term.byteAt(f.prefix-1)&0xFF)) {,             out.println("      broken seek state: arc.label=" + (char) f.arc.label + " vs term byte=" + (char) (term.byteAt(f.prefix-1)&0xFF));,             throw new RuntimeException("seek state is broken");,           },           BytesRef output = Util.get(fr.index, prefix);,           if (output == null) {,             out.println("      broken seek state: prefix is not final in index");,             throw new RuntimeException("seek state is broken");,           } else if (isSeekFrame && !f.isFloor) {,             final ByteArrayDataInput reader = new ByteArrayDataInput(output.bytes, output.offset, output.length);,             final long codeOrig = reader.readVLong();,             final long code = (f.fp << BlockTreeTermsReader.OUTPUT_FLAGS_NUM_BITS) | (f.hasTerms ? BlockTreeTermsReader.OUTPUT_FLAG_HAS_TERMS:0) | (f.isFloor ? BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR:0);,             if (codeOrig != code) {,               out.println("      broken seek state: output code=" + codeOrig + " doesn't match frame code=" + code);,               throw new RuntimeException("seek state is broken");,             },           },         },         if (f == currentFrame) {,           break;,         },         if (f.prefix == validIndexPrefix) {,           isSeekFrame = false;,         },         ord++;,       },     },   }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java,append,430-430,[        long blockTermCount = output.endOrd - output.startOrd + 1;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java,finish,871-871,[        assert root.index.getEmptyOutput() != null;],,finish,893-893,[                                     ((PendingBlock) pending.get(0)).index.getEmptyOutput(),],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java,writeBlock,720-720,[            PendingBlock block = (PendingBlock) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java,writeBlock,630-630,[          PendingTerm term = (PendingTerm) ent;],,writeBlock,674-674,[            PendingTerm term = (PendingTerm) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java,writeBlocks,520-520,[          PendingBlock block = (PendingBlock) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java,writeBlocks,509-509,[          PendingTerm term = (PendingTerm) ent;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java,writeBlock,664-664,[        termCount = end-start;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java,writeBlock,631-631,[          assert StringHelper.startsWith(term.termBytes, prefix): "term.term=" + term.termBytes + " prefix=" + prefix;],,writeBlock,675-675,[            assert StringHelper.startsWith(term.termBytes, prefix): "term.term=" + term.termBytes + " prefix=" + prefix;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/lucene/codecs/blocktreeords/OrdsIntersectTermsEnum.java,<init>,90-90,[    final FST.Arc<Output> arc = fr.index.getFirstArc(arcs[0]);],,<init>,77-77,[    if (fr.index == null) {],,<init>,78-78,[      fstReader = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum.java,<init>,105-105,[      arc = null;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum.java,printSeekState,754-798,[    if (currentFrame == staticFrame) {,       out.println("  no prior seek");,     } else {,       out.println("  prior seek state:");,       int ord = 0;,       boolean isSeekFrame = true;,       while(true) {,         OrdsSegmentTermsEnumFrame f = getFrame(ord);,         assert f != null;,         final BytesRef prefix = new BytesRef(term.bytes(), 0, f.prefix);,         if (f.nextEnt == -1) {,           out.println("    frame " + (isSeekFrame ? "(seek)" : "(next)") + " ord=" + ord + " fp=" + f.fp + (f.isFloor ? (" (fpOrig=" + f.fpOrig + ")") : "") + " prefixLen=" + f.prefix + " prefix=" + brToString(prefix) + (f.nextEnt == -1 ? "" : (" (of " + f.entCount + ")")) + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " code=" + ((f.fp<<OrdsBlockTreeTermsWriter.OUTPUT_FLAGS_NUM_BITS) + (f.hasTerms ? OrdsBlockTreeTermsWriter.OUTPUT_FLAG_HAS_TERMS:0) + (f.isFloor ? OrdsBlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR:0)) + " isLastInFloor=" + f.isLastInFloor + " mdUpto=" + f.metaDataUpto + " tbOrd=" + f.getTermBlockOrd() + " termOrd=" + f.termOrd);,         } else {,           out.println("    frame " + (isSeekFrame ? "(seek, loaded)" : "(next, loaded)") + " ord=" + ord + " fp=" + f.fp + (f.isFloor ? (" (fpOrig=" + f.fpOrig + ")") : "") + " prefixLen=" + f.prefix + " prefix=" + brToString(prefix) + " nextEnt=" + f.nextEnt + (f.nextEnt == -1 ? "" : (" (of " + f.entCount + ")")) + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " code=" + ((f.fp<<OrdsBlockTreeTermsWriter.OUTPUT_FLAGS_NUM_BITS) + (f.hasTerms ? OrdsBlockTreeTermsWriter.OUTPUT_FLAG_HAS_TERMS:0) + (f.isFloor ? OrdsBlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR:0)) + " lastSubFP=" + f.lastSubFP + " isLastInFloor=" + f.isLastInFloor + " mdUpto=" + f.metaDataUpto + " tbOrd=" + f.getTermBlockOrd() + " termOrd=" + f.termOrd);,         },         if (fr.index != null) {,           assert !isSeekFrame || f.arc != null: "isSeekFrame=" + isSeekFrame + " f.arc=" + f.arc;,           if (f.prefix > 0 && isSeekFrame && f.arc.label != (term.byteAt(f.prefix-1)&0xFF)) {,             out.println("      broken seek state: arc.label=" + (char) f.arc.label + " vs term byte=" + (char) (term.byteAt(f.prefix-1)&0xFF));,             throw new RuntimeException("seek state is broken");,           },           Output output = Util.get(fr.index, prefix);,           if (output == null) {,             out.println("      broken seek state: prefix is not final in index");,             throw new RuntimeException("seek state is broken");,           } else if (isSeekFrame && !f.isFloor) {,             final ByteArrayDataInput reader = new ByteArrayDataInput(output.bytes.bytes, output.bytes.offset, output.bytes.length);,             final long codeOrig = reader.readVLong();,             final long code = (f.fp << OrdsBlockTreeTermsWriter.OUTPUT_FLAGS_NUM_BITS) | (f.hasTerms ? OrdsBlockTreeTermsWriter.OUTPUT_FLAG_HAS_TERMS:0) | (f.isFloor ? OrdsBlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR:0);,             if (codeOrig != code) {,               out.println("      broken seek state: output code=" + codeOrig + " doesn't match frame code=" + code);,               throw new RuntimeException("seek state is broken");,             },           },         },         if (f == currentFrame) {,           break;,         },         if (f.prefix == validIndexPrefix) {,           isSeekFrame = false;,         },         ord++;,       },     },   }],,
CORRECTNESS,GC_UNRELATED_TYPES,org/apache/lucene/codecs/bloom/BloomFilteringPostingsFormat.java,write,474-474,[            assert bloomFilters.containsKey(field) == false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/codecs/bloom/BloomFilteringPostingsFormat.java,,306-395,[    final class BloomFilteredTermsEnum extends TermsEnum {,       private Terms delegateTerms;,       private TermsEnum delegateTermsEnum;,       private TermsEnum reuseDelegate;,       private final FuzzySet filter;,       ,       public BloomFilteredTermsEnum(Terms delegateTerms, TermsEnum reuseDelegate, FuzzySet filter) throws IOException {,         this.delegateTerms = delegateTerms;,         this.reuseDelegate = reuseDelegate;,         this.filter = filter;,       },       ,       void reset(Terms delegateTerms, TermsEnum reuseDelegate) throws IOException {,         this.delegateTerms = delegateTerms;,         this.reuseDelegate = reuseDelegate;,         this.delegateTermsEnum = null;,       },       ,       private TermsEnum delegate() throws IOException {,         if (delegateTermsEnum == null) {,           /* pull the iterator only if we really need it -,            * this can be a relativly heavy operation depending on the ,            * delegate postings format and they underlying directory,            * (clone IndexInput) */,           delegateTermsEnum = delegateTerms.iterator(reuseDelegate);,         },         return delegateTermsEnum;,       },       ,       @Override,       public BytesRef next() throws IOException {,         return delegate().next();,       },       ,       @Override,       public boolean seekExact(BytesRef text),           throws IOException {,         // The magical fail-fast speed up that is the entire point of all of,         // this code - save a disk seek if there is a match on an in-memory,         // structure,         // that may occasionally give a false positive but guaranteed no false,         // negatives,         if (filter.contains(text) == ContainsResult.NO) {,           return false;,         },         return delegate().seekExact(text);,       },       ,       @Override,       public SeekStatus seekCeil(BytesRef text),           throws IOException {,         return delegate().seekCeil(text);,       },       ,       @Override,       public void seekExact(long ord) throws IOException {,         delegate().seekExact(ord);,       },       ,       @Override,       public BytesRef term() throws IOException {,         return delegate().term();,       },       ,       @Override,       public long ord() throws IOException {,         return delegate().ord();,       },       ,       @Override,       public int docFreq() throws IOException {,         return delegate().docFreq();,       },       ,       @Override,       public long totalTermFreq() throws IOException {,         return delegate().totalTermFreq();,       },       , ,       @Override,       public DocsAndPositionsEnum docsAndPositions(Bits liveDocs,,           DocsAndPositionsEnum reuse, int flags) throws IOException {,         return delegate().docsAndPositions(liveDocs, reuse, flags);,       }, ,       @Override,       public DocsEnum docs(Bits liveDocs, DocsEnum reuse, int flags),           throws IOException {,         return delegate().docs(liveDocs, reuse, flags);],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.java,doReset,437-437,[          throw new CorruptIndexException("bitsPerLength=" + bitsPerLength, fieldsStream);],,doReset,436-436,[        } else if (bitsPerStoredFields > 31) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter.java,writeZDouble,380-380,[    if (d == intVal &&],,writeZDouble,387-387,[    } else if (d == (float) d) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter.java,writeZFloat,341-341,[    if (f == intVal],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/codecs/compressing/CompressingTermVectorsReader.java,,71-1088,[public final class CompressingTermVectorsReader extends TermVectorsReader implements Closeable {, ,   private final FieldInfos fieldInfos;,   final CompressingStoredFieldsIndexReader indexReader;,   final IndexInput vectorsStream;,   private final int version;,   private final int packedIntsVersion;,   private final CompressionMode compressionMode;,   private final Decompressor decompressor;,   private final int chunkSize;,   private final int numDocs;,   private boolean closed;,   private final BlockPackedReaderIterator reader;, ,   // used by clone,   private CompressingTermVectorsReader(CompressingTermVectorsReader reader) {,     this.fieldInfos = reader.fieldInfos;,     this.vectorsStream = reader.vectorsStream.clone();,     this.indexReader = reader.indexReader.clone();,     this.packedIntsVersion = reader.packedIntsVersion;,     this.compressionMode = reader.compressionMode;,     this.decompressor = reader.decompressor.clone();,     this.chunkSize = reader.chunkSize;,     this.numDocs = reader.numDocs;,     this.reader = new BlockPackedReaderIterator(vectorsStream, packedIntsVersion, BLOCK_SIZE, 0);,     this.version = reader.version;,     this.closed = false;,   }, ,   /** Sole constructor. */,   public CompressingTermVectorsReader(Directory d, SegmentInfo si, String segmentSuffix, FieldInfos fn,,       IOContext context, String formatName, CompressionMode compressionMode) throws IOException {,     this.compressionMode = compressionMode;,     final String segment = si.name;,     boolean success = false;,     fieldInfos = fn;,     numDocs = si.getDocCount();,     int version = -1;,     CompressingStoredFieldsIndexReader indexReader = null;,     ,     // Load the index into memory,     final String indexName = IndexFileNames.segmentFileName(segment, segmentSuffix, VECTORS_INDEX_EXTENSION);,     try (ChecksumIndexInput input = d.openChecksumInput(indexName, context)) {,       Throwable priorE = null;,       try {,         final String codecNameIdx = formatName + CODEC_SFX_IDX;,         version = CodecUtil.checkIndexHeader(input, codecNameIdx, VERSION_START, VERSION_CURRENT, si.getId(), segmentSuffix);,         assert CodecUtil.indexHeaderLength(codecNameIdx, segmentSuffix) == input.getFilePointer();,         indexReader = new CompressingStoredFieldsIndexReader(input, si);,         input.readVLong(); // the end of the data file,       } catch (Throwable exception) {,         priorE = exception;,       } finally {,         CodecUtil.checkFooter(input, priorE);,       },     },     ,     this.version = version;,     this.indexReader = indexReader;, ,     try {,       // Open the data file and read metadata,       final String vectorsStreamFN = IndexFileNames.segmentFileName(segment, segmentSuffix, VECTORS_EXTENSION);,       vectorsStream = d.openInput(vectorsStreamFN, context);,       final String codecNameDat = formatName + CODEC_SFX_DAT;,       int version2 = CodecUtil.checkIndexHeader(vectorsStream, codecNameDat, VERSION_START, VERSION_CURRENT, si.getId(), segmentSuffix);,       if (version != version2) {,         throw new CorruptIndexException("Version mismatch between stored fields index and data: " + version + " != " + version2, vectorsStream);,       },       assert CodecUtil.indexHeaderLength(codecNameDat, segmentSuffix) == vectorsStream.getFilePointer();,       ,       long pos = vectorsStream.getFilePointer();,       // NOTE: data file is too costly to verify checksum against all the bytes on open,,       // but for now we at least verify proper structure of the checksum footer: which looks,       // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption,       // such as file truncation.,       CodecUtil.retrieveChecksum(vectorsStream);,       vectorsStream.seek(pos);, ,       packedIntsVersion = vectorsStream.readVInt();,       chunkSize = vectorsStream.readVInt();,       decompressor = compressionMode.newDecompressor();,       this.reader = new BlockPackedReaderIterator(vectorsStream, packedIntsVersion, BLOCK_SIZE, 0);, ,       success = true;,     } finally {,       if (!success) {,         IOUtils.closeWhileHandlingException(this);,       },     },   }, ,   CompressionMode getCompressionMode() {,     return compressionMode;,   }, ,   int getChunkSize() {,     return chunkSize;,   }, ,   int getPackedIntsVersion() {,     return packedIntsVersion;,   },   ,   int getVersion() {,     return version;,   }, ,   CompressingStoredFieldsIndexReader getIndex() {,     return indexReader;,   }, ,   IndexInput getVectorsStream() {,     return vectorsStream;,   }, ,   /**,    * @throws AlreadyClosedException if this TermVectorsReader is closed,    */,   private void ensureOpen() throws AlreadyClosedException {,     if (closed) {,       throw new AlreadyClosedException("this FieldsReader is closed");,     },   }, ,   @Override,   public void close() throws IOException {,     if (!closed) {,       IOUtils.close(vectorsStream);,       closed = true;,     },   }, ,   @Override,   public TermVectorsReader clone() {,     return new CompressingTermVectorsReader(this);,   }, ,   @Override,   public Fields get(int doc) throws IOException {,     ensureOpen();, ,     // seek to the right place,     {,       final long startPointer = indexReader.getStartPointer(doc);,       vectorsStream.seek(startPointer);,     }, ,     // decode,     // - docBase: first doc ID of the chunk,     // - chunkDocs: number of docs of the chunk,     final int docBase = vectorsStream.readVInt();,     final int chunkDocs = vectorsStream.readVInt();,     if (doc < docBase || doc >= docBase + chunkDocs || docBase + chunkDocs > numDocs) {,       throw new CorruptIndexException("docBase=" + docBase + ",chunkDocs=" + chunkDocs + ",doc=" + doc, vectorsStream);,     }, ,     final int skip; // number of fields to skip,     final int numFields; // number of fields of the document we're looking for,     final int totalFields; // total number of fields of the chunk (sum for all docs),     if (chunkDocs == 1) {,       skip = 0;,       numFields = totalFields = vectorsStream.readVInt();,     } else {,       reader.reset(vectorsStream, chunkDocs);,       int sum = 0;,       for (int i = docBase; i < doc; ++i) {,         sum += reader.next();,       },       skip = sum;,       numFields = (int) reader.next();,       sum += numFields;,       for (int i = doc + 1; i < docBase + chunkDocs; ++i) {,         sum += reader.next();,       },       totalFields = sum;,     }, ,     if (numFields == 0) {,       // no vectors,       return null;,     }, ,     // read field numbers that have term vectors,     final int[] fieldNums;,     {,       final int token = vectorsStream.readByte() & 0xFF;,       assert token != 0; // means no term vectors, cannot happen since we checked for numFields == 0,       final int bitsPerFieldNum = token & 0x1F;,       int totalDistinctFields = token >>> 5;,       if (totalDistinctFields == 0x07) {,         totalDistinctFields += vectorsStream.readVInt();,       },       ++totalDistinctFields;,       final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(vectorsStream, PackedInts.Format.PACKED, packedIntsVersion, totalDistinctFields, bitsPerFieldNum, 1);,       fieldNums = new int[totalDistinctFields];,       for (int i = 0; i < totalDistinctFields; ++i) {,         fieldNums[i] = (int) it.next();,       },     }, ,     // read field numbers and flags,     final int[] fieldNumOffs = new int[numFields];,     final PackedInts.Reader flags;,     {,       final int bitsPerOff = PackedInts.bitsRequired(fieldNums.length - 1);,       final PackedInts.Reader allFieldNumOffs = PackedInts.getReaderNoHeader(vectorsStream, PackedInts.Format.PACKED, packedIntsVersion, totalFields, bitsPerOff);,       switch (vectorsStream.readVInt()) {,         case 0:,           final PackedInts.Reader fieldFlags = PackedInts.getReaderNoHeader(vectorsStream, PackedInts.Format.PACKED, packedIntsVersion, fieldNums.length, FLAGS_BITS);,           PackedInts.Mutable f = PackedInts.getMutable(totalFields, FLAGS_BITS, PackedInts.COMPACT);,           for (int i = 0; i < totalFields; ++i) {,             final int fieldNumOff = (int) allFieldNumOffs.get(i);,             assert fieldNumOff >= 0 && fieldNumOff < fieldNums.length;,             final int fgs = (int) fieldFlags.get(fieldNumOff);,             f.set(i, fgs);,           },           flags = f;,           break;,         case 1:,           flags = PackedInts.getReaderNoHeader(vectorsStream, PackedInts.Format.PACKED, packedIntsVersion, totalFields, FLAGS_BITS);,           break;,         default:,           throw new AssertionError();,       },       for (int i = 0; i < numFields; ++i) {,         fieldNumOffs[i] = (int) allFieldNumOffs.get(skip + i);,       },     }, ,     // number of terms per field for all fields,     final PackedInts.Reader numTerms;,     final int totalTerms;,     {,       final int bitsRequired = vectorsStream.readVInt();,       numTerms = PackedInts.getReaderNoHeader(vectorsStream, PackedInts.Format.PACKED, packedIntsVersion, totalFields, bitsRequired);,       int sum = 0;,       for (int i = 0; i < totalFields; ++i) {,         sum += numTerms.get(i);,       },       totalTerms = sum;,     }, ,     // term lengths,     int docOff = 0, docLen = 0, totalLen;,     final int[] fieldLengths = new int[numFields];,     final int[][] prefixLengths = new int[numFields][];,     final int[][] suffixLengths = new int[numFields][];,     {,       reader.reset(vectorsStream, totalTerms);,       // skip,       int toSkip = 0;,       for (int i = 0; i < skip; ++i) {,         toSkip += numTerms.get(i);,       },       reader.skip(toSkip);,       // read prefix lengths,       for (int i = 0; i < numFields; ++i) {,         final int termCount = (int) numTerms.get(skip + i);,         final int[] fieldPrefixLengths = new int[termCount];,         prefixLengths[i] = fieldPrefixLengths;,         for (int j = 0; j < termCount; ) {,           final LongsRef next = reader.next(termCount - j);,           for (int k = 0; k < next.length; ++k) {,             fieldPrefixLengths[j++] = (int) next.longs[next.offset + k];,           },         },       },       reader.skip(totalTerms - reader.ord());, ,       reader.reset(vectorsStream, totalTerms);,       // skip,       toSkip = 0;,       for (int i = 0; i < skip; ++i) {,         for (int j = 0; j < numTerms.get(i); ++j) {,           docOff += reader.next();,         },       },       for (int i = 0; i < numFields; ++i) {,         final int termCount = (int) numTerms.get(skip + i);,         final int[] fieldSuffixLengths = new int[termCount];,         suffixLengths[i] = fieldSuffixLengths;,         for (int j = 0; j < termCount; ) {,           final LongsRef next = reader.next(termCount - j);,           for (int k = 0; k < next.length; ++k) {,             fieldSuffixLengths[j++] = (int) next.longs[next.offset + k];,           },         },         fieldLengths[i] = sum(suffixLengths[i]);,         docLen += fieldLengths[i];,       },       totalLen = docOff + docLen;,       for (int i = skip + numFields; i < totalFields; ++i) {,         for (int j = 0; j < numTerms.get(i); ++j) {,           totalLen += reader.next();,         },       },     }, ,     // term freqs,     final int[] termFreqs = new int[totalTerms];,     {,       reader.reset(vectorsStream, totalTerms);,       for (int i = 0; i < totalTerms; ) {,         final LongsRef next = reader.next(totalTerms - i);,         for (int k = 0; k < next.length; ++k) {,           termFreqs[i++] = 1 + (int) next.longs[next.offset + k];,         },       },     }, ,     // total number of positions, offsets and payloads,     int totalPositions = 0, totalOffsets = 0, totalPayloads = 0;,     for (int i = 0, termIndex = 0; i < totalFields; ++i) {,       final int f = (int) flags.get(i);,       final int termCount = (int) numTerms.get(i);,       for (int j = 0; j < termCount; ++j) {,         final int freq = termFreqs[termIndex++];,         if ((f & POSITIONS) != 0) {,           totalPositions += freq;,         },         if ((f & OFFSETS) != 0) {,           totalOffsets += freq;,         },         if ((f & PAYLOADS) != 0) {,           totalPayloads += freq;,         },       },       assert i != totalFields - 1 || termIndex == totalTerms : termIndex + " " + totalTerms;,     }, ,     final int[][] positionIndex = positionIndex(skip, numFields, numTerms, termFreqs);,     final int[][] positions, startOffsets, lengths;,     if (totalPositions > 0) {,       positions = readPositions(skip, numFields, flags, numTerms, termFreqs, POSITIONS, totalPositions, positionIndex);,     } else {,       positions = new int[numFields][];,     }, ,     if (totalOffsets > 0) {,       // average number of chars per term,       final float[] charsPerTerm = new float[fieldNums.length];,       for (int i = 0; i < charsPerTerm.length; ++i) {,         charsPerTerm[i] = Float.intBitsToFloat(vectorsStream.readInt());,       },       startOffsets = readPositions(skip, numFields, flags, numTerms, termFreqs, OFFSETS, totalOffsets, positionIndex);,       lengths = readPositions(skip, numFields, flags, numTerms, termFreqs, OFFSETS, totalOffsets, positionIndex);, ,       for (int i = 0; i < numFields; ++i) {,         final int[] fStartOffsets = startOffsets[i];,         final int[] fPositions = positions[i];,         // patch offsets from positions,         if (fStartOffsets != null && fPositions != null) {,           final float fieldCharsPerTerm = charsPerTerm[fieldNumOffs[i]];,           for (int j = 0; j < startOffsets[i].length; ++j) {,             fStartOffsets[j] += (int) (fieldCharsPerTerm * fPositions[j]);,           },         },         if (fStartOffsets != null) {,           final int[] fPrefixLengths = prefixLengths[i];,           final int[] fSuffixLengths = suffixLengths[i];,           final int[] fLengths = lengths[i];,           for (int j = 0, end = (int) numTerms.get(skip + i); j < end; ++j) {,             // delta-decode start offsets and  patch lengths using term lengths,             final int termLength = fPrefixLengths[j] + fSuffixLengths[j];,             lengths[i][positionIndex[i][j]] += termLength;,             for (int k = positionIndex[i][j] + 1; k < positionIndex[i][j + 1]; ++k) {,               fStartOffsets[k] += fStartOffsets[k - 1];,               fLengths[k] += termLength;,             },           },         },       },     } else {,       startOffsets = lengths = new int[numFields][];,     },     if (totalPositions > 0) {,       // delta-decode positions,       for (int i = 0; i < numFields; ++i) {,         final int[] fPositions = positions[i];,         final int[] fpositionIndex = positionIndex[i];,         if (fPositions != null) {,           for (int j = 0, end = (int) numTerms.get(skip + i); j < end; ++j) {,             // delta-decode start offsets,             for (int k = fpositionIndex[j] + 1; k < fpositionIndex[j + 1]; ++k) {,               fPositions[k] += fPositions[k - 1];,             },           },         },       },     }, ,     // payload lengths,     final int[][] payloadIndex = new int[numFields][];,     int totalPayloadLength = 0;,     int payloadOff = 0;,     int payloadLen = 0;,     if (totalPayloads > 0) {,       reader.reset(vectorsStream, totalPayloads);,       // skip,       int termIndex = 0;,       for (int i = 0; i < skip; ++i) {,         final int f = (int) flags.get(i);,         final int termCount = (int) numTerms.get(i);,         if ((f & PAYLOADS) != 0) {,           for (int j = 0; j < termCount; ++j) {,             final int freq = termFreqs[termIndex + j];,             for (int k = 0; k < freq; ++k) {,               final int l = (int) reader.next();,               payloadOff += l;,             },           },         },         termIndex += termCount;,       },       totalPayloadLength = payloadOff;,       // read doc payload lengths,       for (int i = 0; i < numFields; ++i) {,         final int f = (int) flags.get(skip + i);,         final int termCount = (int) numTerms.get(skip + i);,         if ((f & PAYLOADS) != 0) {,           final int totalFreq = positionIndex[i][termCount];,           payloadIndex[i] = new int[totalFreq + 1];,           int posIdx = 0;,           payloadIndex[i][posIdx] = payloadLen;,           for (int j = 0; j < termCount; ++j) {,             final int freq = termFreqs[termIndex + j];,             for (int k = 0; k < freq; ++k) {,               final int payloadLength = (int) reader.next();,               payloadLen += payloadLength;,               payloadIndex[i][posIdx+1] = payloadLen;,               ++posIdx;,             },           },           assert posIdx == totalFreq;,         },         termIndex += termCount;,       },       totalPayloadLength += payloadLen;,       for (int i = skip + numFields; i < totalFields; ++i) {,         final int f = (int) flags.get(i);,         final int termCount = (int) numTerms.get(i);,         if ((f & PAYLOADS) != 0) {,           for (int j = 0; j < termCount; ++j) {,             final int freq = termFreqs[termIndex + j];,             for (int k = 0; k < freq; ++k) {,               totalPayloadLength += reader.next();,             },           },         },         termIndex += termCount;,       },       assert termIndex == totalTerms : termIndex + " " + totalTerms;,     }, ,     // decompress data,     final BytesRef suffixBytes = new BytesRef();,     decompressor.decompress(vectorsStream, totalLen + totalPayloadLength, docOff + payloadOff, docLen + payloadLen, suffixBytes);,     suffixBytes.length = docLen;,     final BytesRef payloadBytes = new BytesRef(suffixBytes.bytes, suffixBytes.offset + docLen, payloadLen);, ,     final int[] fieldFlags = new int[numFields];,     for (int i = 0; i < numFields; ++i) {,       fieldFlags[i] = (int) flags.get(skip + i);,     }, ,     final int[] fieldNumTerms = new int[numFields];,     for (int i = 0; i < numFields; ++i) {,       fieldNumTerms[i] = (int) numTerms.get(skip + i);,     }, ,     final int[][] fieldTermFreqs = new int[numFields][];,     {,       int termIdx = 0;,       for (int i = 0; i < skip; ++i) {,         termIdx += numTerms.get(i);,       },       for (int i = 0; i < numFields; ++i) {,         final int termCount = (int) numTerms.get(skip + i);,         fieldTermFreqs[i] = new int[termCount];,         for (int j = 0; j < termCount; ++j) {,           fieldTermFreqs[i][j] = termFreqs[termIdx++];,         },       },     }, ,     assert sum(fieldLengths) == docLen : sum(fieldLengths) + " != " + docLen;, ,     return new TVFields(fieldNums, fieldFlags, fieldNumOffs, fieldNumTerms, fieldLengths,,         prefixLengths, suffixLengths, fieldTermFreqs,,         positionIndex, positions, startOffsets, lengths,,         payloadBytes, payloadIndex,,         suffixBytes);,   }, ,   // field -> term index -> position index,   private int[][] positionIndex(int skip, int numFields, PackedInts.Reader numTerms, int[] termFreqs) {,     final int[][] positionIndex = new int[numFields][];,     int termIndex = 0;,     for (int i = 0; i < skip; ++i) {,       final int termCount = (int) numTerms.get(i);,       termIndex += termCount;,     },     for (int i = 0; i < numFields; ++i) {,       final int termCount = (int) numTerms.get(skip + i);,       positionIndex[i] = new int[termCount + 1];,       for (int j = 0; j < termCount; ++j) {,         final int freq = termFreqs[termIndex+j];,         positionIndex[i][j + 1] = positionIndex[i][j] + freq;,       },       termIndex += termCount;,     },     return positionIndex;,   }, ,   private int[][] readPositions(int skip, int numFields, PackedInts.Reader flags, PackedInts.Reader numTerms, int[] termFreqs, int flag, final int totalPositions, int[][] positionIndex) throws IOException {,     final int[][] positions = new int[numFields][];,     reader.reset(vectorsStream, totalPositions);,     // skip,     int toSkip = 0;,     int termIndex = 0;,     for (int i = 0; i < skip; ++i) {,       final int f = (int) flags.get(i);,       final int termCount = (int) numTerms.get(i);,       if ((f & flag) != 0) {,         for (int j = 0; j < termCount; ++j) {,           final int freq = termFreqs[termIndex+j];,           toSkip += freq;,         },       },       termIndex += termCount;,     },     reader.skip(toSkip);,     // read doc positions,     for (int i = 0; i < numFields; ++i) {,       final int f = (int) flags.get(skip + i);,       final int termCount = (int) numTerms.get(skip + i);,       if ((f & flag) != 0) {,         final int totalFreq = positionIndex[i][termCount];,         final int[] fieldPositions = new int[totalFreq];,         positions[i] = fieldPositions;,         for (int j = 0; j < totalFreq; ) {,           final LongsRef nextPositions = reader.next(totalFreq - j);,           for (int k = 0; k < nextPositions.length; ++k) {,             fieldPositions[j++] = (int) nextPositions.longs[nextPositions.offset + k];,           },         },       },       termIndex += termCount;,     },     reader.skip(totalPositions - reader.ord());,     return positions;,   }, ,   private class TVFields extends Fields {, ,     private final int[] fieldNums, fieldFlags, fieldNumOffs, numTerms, fieldLengths;,     private final int[][] prefixLengths, suffixLengths, termFreqs, positionIndex, positions, startOffsets, lengths, payloadIndex;,     private final BytesRef suffixBytes, payloadBytes;, ,     public TVFields(int[] fieldNums, int[] fieldFlags, int[] fieldNumOffs, int[] numTerms, int[] fieldLengths,,         int[][] prefixLengths, int[][] suffixLengths, int[][] termFreqs,,         int[][] positionIndex, int[][] positions, int[][] startOffsets, int[][] lengths,,         BytesRef payloadBytes, int[][] payloadIndex,,         BytesRef suffixBytes) {,       this.fieldNums = fieldNums;,       this.fieldFlags = fieldFlags;,       this.fieldNumOffs = fieldNumOffs;,       this.numTerms = numTerms;,       this.fieldLengths = fieldLengths;,       this.prefixLengths = prefixLengths;,       this.suffixLengths = suffixLengths;,       this.termFreqs = termFreqs;,       this.positionIndex = positionIndex;,       this.positions = positions;,       this.startOffsets = startOffsets;,       this.lengths = lengths;,       this.payloadBytes = payloadBytes;,       this.payloadIndex = payloadIndex;,       this.suffixBytes = suffixBytes;,     }, ,     @Override,     public Iterator<String> iterator() {,       return new Iterator<String>() {,         int i = 0;,         @Override,         public boolean hasNext() {,           return i < fieldNumOffs.length;,         },         @Override,         public String next() {,           if (!hasNext()) {,             throw new NoSuchElementException();,           },           final int fieldNum = fieldNums[fieldNumOffs[i++]];,           return fieldInfos.fieldInfo(fieldNum).name;,         },         @Override,         public void remove() {,           throw new UnsupportedOperationException();,         },       };,     }, ,     @Override,     public Terms terms(String field) throws IOException {,       final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);,       if (fieldInfo == null) {,         return null;,       },       int idx = -1;,       for (int i = 0; i < fieldNumOffs.length; ++i) {,         if (fieldNums[fieldNumOffs[i]] == fieldInfo.number) {,           idx = i;,           break;,         },       }, ,       if (idx == -1 || numTerms[idx] == 0) {,         // no term,         return null;,       },       int fieldOff = 0, fieldLen = -1;,       for (int i = 0; i < fieldNumOffs.length; ++i) {,         if (i < idx) {,           fieldOff += fieldLengths[i];,         } else {,           fieldLen = fieldLengths[i];,           break;,         },       },       assert fieldLen >= 0;,       return new TVTerms(numTerms[idx], fieldFlags[idx],,           prefixLengths[idx], suffixLengths[idx], termFreqs[idx],,           positionIndex[idx], positions[idx], startOffsets[idx], lengths[idx],,           payloadIndex[idx], payloadBytes,,           new BytesRef(suffixBytes.bytes, suffixBytes.offset + fieldOff, fieldLen));,     }, ,     @Override,     public int size() {,       return fieldNumOffs.length;,     }, ,   }, ,   private class TVTerms extends Terms {, ,     private final int numTerms, flags;,     private final int[] prefixLengths, suffixLengths, termFreqs, positionIndex, positions, startOffsets, lengths, payloadIndex;,     private final BytesRef termBytes, payloadBytes;, ,     TVTerms(int numTerms, int flags, int[] prefixLengths, int[] suffixLengths, int[] termFreqs,,         int[] positionIndex, int[] positions, int[] startOffsets, int[] lengths,,         int[] payloadIndex, BytesRef payloadBytes,,         BytesRef termBytes) {,       this.numTerms = numTerms;,       this.flags = flags;,       this.prefixLengths = prefixLengths;,       this.suffixLengths = suffixLengths;,       this.termFreqs = termFreqs;,       this.positionIndex = positionIndex;,       this.positions = positions;,       this.startOffsets = startOffsets;,       this.lengths = lengths;,       this.payloadIndex = payloadIndex;,       this.payloadBytes = payloadBytes;,       this.termBytes = termBytes;,     }, ,     @Override,     public TermsEnum iterator(TermsEnum reuse) throws IOException {,       final TVTermsEnum termsEnum;,       if (reuse != null && reuse instanceof TVTermsEnum) {,         termsEnum = (TVTermsEnum) reuse;,       } else {,         termsEnum = new TVTermsEnum();,       },       termsEnum.reset(numTerms, flags, prefixLengths, suffixLengths, termFreqs, positionIndex, positions, startOffsets, lengths,,           payloadIndex, payloadBytes,,           new ByteArrayDataInput(termBytes.bytes, termBytes.offset, termBytes.length));,       return termsEnum;,     }, ,     @Override,     public long size() throws IOException {,       return numTerms;,     }, ,     @Override,     public long getSumTotalTermFreq() throws IOException {,       return -1L;,     }, ,     @Override,     public long getSumDocFreq() throws IOException {,       return numTerms;,     }, ,     @Override,     public int getDocCount() throws IOException {,       return 1;,     }, ,     @Override,     public boolean hasFreqs() {,       return true;,     }, ,     @Override,     public boolean hasOffsets() {,       return (flags & OFFSETS) != 0;,     }, ,     @Override,     public boolean hasPositions() {,       return (flags & POSITIONS) != 0;,     }, ,     @Override,     public boolean hasPayloads() {,       return (flags & PAYLOADS) != 0;,     }, ,   }, ,   private static class TVTermsEnum extends TermsEnum {, ,     private int numTerms, startPos, ord;,     private int[] prefixLengths, suffixLengths, termFreqs, positionIndex, positions, startOffsets, lengths, payloadIndex;,     private ByteArrayDataInput in;,     private BytesRef payloads;,     private final BytesRef term;, ,     private TVTermsEnum() {,       term = new BytesRef(16);,     }, ,     void reset(int numTerms, int flags, int[] prefixLengths, int[] suffixLengths, int[] termFreqs, int[] positionIndex, int[] positions, int[] startOffsets, int[] lengths,,         int[] payloadIndex, BytesRef payloads, ByteArrayDataInput in) {,       this.numTerms = numTerms;,       this.prefixLengths = prefixLengths;,       this.suffixLengths = suffixLengths;,       this.termFreqs = termFreqs;,       this.positionIndex = positionIndex;,       this.positions = positions;,       this.startOffsets = startOffsets;,       this.lengths = lengths;,       this.payloadIndex = payloadIndex;,       this.payloads = payloads;,       this.in = in;,       startPos = in.getPosition();,       reset();,     }, ,     void reset() {,       term.length = 0;,       in.setPosition(startPos);,       ord = -1;,     }, ,     @Override,     public BytesRef next() throws IOException {,       if (ord == numTerms - 1) {,         return null;,       } else {,         assert ord < numTerms;,         ++ord;,       }, ,       // read term,       term.offset = 0;,       term.length = prefixLengths[ord] + suffixLengths[ord];,       if (term.length > term.bytes.length) {,         term.bytes = ArrayUtil.grow(term.bytes, term.length);,       },       in.readBytes(term.bytes, prefixLengths[ord], suffixLengths[ord]);, ,       return term;,     }, ,     @Override,     public SeekStatus seekCeil(BytesRef text),         throws IOException {,       if (ord < numTerms && ord >= 0) {,         final int cmp = term().compareTo(text);,         if (cmp == 0) {,           return SeekStatus.FOUND;,         } else if (cmp > 0) {,           reset();,         },       },       // linear scan,       while (true) {,         final BytesRef term = next();,         if (term == null) {,           return SeekStatus.END;,         },         final int cmp = term.compareTo(text);,         if (cmp > 0) {,           return SeekStatus.NOT_FOUND;,         } else if (cmp == 0) {,           return SeekStatus.FOUND;,         },       },     }, ,     @Override,     public void seekExact(long ord) throws IOException {,       throw new UnsupportedOperationException();,     }, ,     @Override,     public BytesRef term() throws IOException {,       return term;,     }, ,     @Override,     public long ord() throws IOException {,       throw new UnsupportedOperationException();,     }, ,     @Override,     public int docFreq() throws IOException {,       return 1;,     }, ,     @Override,     public long totalTermFreq() throws IOException {,       return termFreqs[ord];,     }, ,     @Override,     public final DocsEnum docs(Bits liveDocs, DocsEnum reuse, int flags) throws IOException {,       final TVDocsEnum docsEnum;,       if (reuse != null && reuse instanceof TVDocsEnum) {,         docsEnum = (TVDocsEnum) reuse;,       } else {,         docsEnum = new TVDocsEnum();,       }, ,       docsEnum.reset(liveDocs, termFreqs[ord], positionIndex[ord], positions, startOffsets, lengths, payloads, payloadIndex);,       return docsEnum;,     }, ,     @Override,     public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, int flags) throws IOException {,       if (positions == null && startOffsets == null) {,         return null;,       },       // TODO: slightly sheisty,       return (DocsAndPositionsEnum) docs(liveDocs, reuse, flags);,     }, ,   }, ,   private static class TVDocsEnum extends DocsAndPositionsEnum {, ,     private Bits liveDocs;,     private int doc = -1;,     private int termFreq;,     private int positionIndex;,     private int[] positions;,     private int[] startOffsets;,     private int[] lengths;,     private final BytesRef payload;,     private int[] payloadIndex;,     private int basePayloadOffset;,     private int i;, ,     TVDocsEnum() {,       payload = new BytesRef();,     }, ,     public void reset(Bits liveDocs, int freq, int positionIndex, int[] positions,,         int[] startOffsets, int[] lengths, BytesRef payloads,,         int[] payloadIndex) {,       this.liveDocs = liveDocs;,       this.termFreq = freq;,       this.positionIndex = positionIndex;,       this.positions = positions;,       this.startOffsets = startOffsets;,       this.lengths = lengths;,       this.basePayloadOffset = payloads.offset;,       this.payload.bytes = payloads.bytes;,       payload.offset = payload.length = 0;,       this.payloadIndex = payloadIndex;, ,       doc = i = -1;,     }, ,     private void checkDoc() {,       if (doc == NO_MORE_DOCS) {,         throw new IllegalStateException("DocsEnum exhausted");,       } else if (doc == -1) {,         throw new IllegalStateException("DocsEnum not started");,       },     }, ,     private void checkPosition() {,       checkDoc();,       if (i < 0) {,         throw new IllegalStateException("Position enum not started");,       } else if (i >= termFreq) {,         throw new IllegalStateException("Read past last position");,       },     }, ,     @Override,     public int nextPosition() throws IOException {,       if (doc != 0) {,         throw new IllegalStateException();,       } else if (i >= termFreq - 1) {,         throw new IllegalStateException("Read past last position");,       }, ,       ++i;, ,       if (payloadIndex != null) {,         payload.offset = basePayloadOffset + payloadIndex[positionIndex + i];,         payload.length = payloadIndex[positionIndex + i + 1] - payloadIndex[positionIndex + i];,       }, ,       if (positions == null) {,         return -1;,       } else {,         return positions[positionIndex + i];,       },     }, ,     @Override,     public int startOffset() throws IOException {,       checkPosition();,       if (startOffsets == null) {,         return -1;,       } else {,         return startOffsets[positionIndex + i];,       },     }, ,     @Override,     public int endOffset() throws IOException {,       checkPosition();,       if (startOffsets == null) {,         return -1;,       } else {,         return startOffsets[positionIndex + i] + lengths[positionIndex + i];,       },     }, ,     @Override,     public BytesRef getPayload() throws IOException {,       checkPosition();,       if (payloadIndex == null || payload.length == 0) {,         return null;,       } else {,         return payload;,       },     }, ,     @Override,     public int freq() throws IOException {,       checkDoc();,       return termFreq;,     }, ,     @Override,     public int docID() {,       return doc;,     }, ,     @Override,     public int nextDoc() throws IOException {,       if (doc == -1 && (liveDocs == null || liveDocs.get(0))) {,         return (doc = 0);,       } else {,         return (doc = NO_MORE_DOCS);,       },     }, ,     @Override,     public int advance(int target) throws IOException {,       return slowAdvance(target);,     }, ,     @Override,     public long cost() {,       return 1;,     },   }, ,   private static int sum(int[] arr) {,     int sum = 0;,     for (int el : arr) {,       sum += el;,     },     return sum;,   }, ,   @Override,   public long ramBytesUsed() {,     return indexReader.ramBytesUsed();,   },   ,   @Override,   public Iterable<Accountable> getChildResources() {,     return Collections.singleton(Accountables.namedAccountable("term vector index", indexReader));,   },   ,   @Override,   public void checkIntegrity() throws IOException {,     CodecUtil.checksumEntireFile(vectorsStream);,   }, ,   @Override,   public String toString() {,     return getClass().getSimpleName() + "(mode=" + compressionMode + ",chunksize=" + chunkSize + ")";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/compressing/CompressingTermVectorsReader.java,endOffset,1018-1018,[        return startOffsets[positionIndex + i] + lengths[positionIndex + i];],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/codecs/compressing/CompressingTermVectorsReader.java,,727-793,[        BytesRef termBytes) {,       this.numTerms = numTerms;,       this.flags = flags;,       this.prefixLengths = prefixLengths;,       this.suffixLengths = suffixLengths;,       this.termFreqs = termFreqs;,       this.positionIndex = positionIndex;,       this.positions = positions;,       this.startOffsets = startOffsets;,       this.lengths = lengths;,       this.payloadIndex = payloadIndex;,       this.payloadBytes = payloadBytes;,       this.termBytes = termBytes;,     }, ,     @Override,     public TermsEnum iterator(TermsEnum reuse) throws IOException {,       final TVTermsEnum termsEnum;,       if (reuse != null && reuse instanceof TVTermsEnum) {,         termsEnum = (TVTermsEnum) reuse;,       } else {,         termsEnum = new TVTermsEnum();,       },       termsEnum.reset(numTerms, flags, prefixLengths, suffixLengths, termFreqs, positionIndex, positions, startOffsets, lengths,,           payloadIndex, payloadBytes,,           new ByteArrayDataInput(termBytes.bytes, termBytes.offset, termBytes.length));,       return termsEnum;,     }, ,     @Override,     public long size() throws IOException {,       return numTerms;,     }, ,     @Override,     public long getSumTotalTermFreq() throws IOException {,       return -1L;,     }, ,     @Override,     public long getSumDocFreq() throws IOException {,       return numTerms;,     }, ,     @Override,     public int getDocCount() throws IOException {,       return 1;,     }, ,     @Override,     public boolean hasFreqs() {,       return true;,     }, ,     @Override,     public boolean hasOffsets() {,       return (flags & OFFSETS) != 0;,     }, ,     @Override,     public boolean hasPositions() {,       return (flags & POSITIONS) != 0;,     }, ,     @Override,     public boolean hasPayloads() {,       return (flags & PAYLOADS) != 0;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/IDVersionPostingsReader.java,decodeTerm,57-57,[    final IDVersionTermState termState = (IDVersionTermState) _termState;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/IDVersionPostingsReader.java,docs,75-75,[    docsEnum.reset(((IDVersionTermState) termState).docID, liveDocs);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/IDVersionPostingsReader.java,docsAndPositions,90-90,[    IDVersionTermState termState = (IDVersionTermState) _termState;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/IDVersionPostingsWriter.java,encodeTerm,156-156,[    IDVersionTermState state = (IDVersionTermState) _state;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/IDVersionPostingsWriter.java,finishTerm,145-145,[    IDVersionTermState state = (IDVersionTermState) _state;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum.java,getVersion,232-232,[    return ((IDVersionTermState) currentFrame.state).idVersion;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum.java,seekExact,378-378,[          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {],,seekExact,574-574,[      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {],,seekExact,491-491,[          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum.java,printSeekState,842-886,[    if (currentFrame == staticFrame) {,       out.println("  no prior seek");,     } else {,       out.println("  prior seek state:");,       int ord = 0;,       boolean isSeekFrame = true;,       while(true) {,         IDVersionSegmentTermsEnumFrame f = getFrame(ord);,         assert f != null;,         final BytesRef prefix = new BytesRef(term.bytes(), 0, f.prefix);,         if (f.nextEnt == -1) {,           out.println("    frame " + (isSeekFrame ? "(seek)" : "(next)") + " ord=" + ord + " fp=" + f.fp + (f.isFloor ? (" (fpOrig=" + f.fpOrig + ")") : "") + " prefixLen=" + f.prefix + " prefix=" + brToString(prefix) + (f.nextEnt == -1 ? "" : (" (of " + f.entCount + ")")) + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " code=" + ((f.fp<<VersionBlockTreeTermsWriter.OUTPUT_FLAGS_NUM_BITS) + (f.hasTerms ? VersionBlockTreeTermsWriter.OUTPUT_FLAG_HAS_TERMS:0) + (f.isFloor ? VersionBlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR:0)) + " isLastInFloor=" + f.isLastInFloor + " mdUpto=" + f.metaDataUpto + " tbOrd=" + f.getTermBlockOrd());,         } else {,           out.println("    frame " + (isSeekFrame ? "(seek, loaded)" : "(next, loaded)") + " ord=" + ord + " fp=" + f.fp + (f.isFloor ? (" (fpOrig=" + f.fpOrig + ")") : "") + " prefixLen=" + f.prefix + " prefix=" + brToString(prefix) + " nextEnt=" + f.nextEnt + (f.nextEnt == -1 ? "" : (" (of " + f.entCount + ")")) + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " code=" + ((f.fp<<VersionBlockTreeTermsWriter.OUTPUT_FLAGS_NUM_BITS) + (f.hasTerms ? VersionBlockTreeTermsWriter.OUTPUT_FLAG_HAS_TERMS:0) + (f.isFloor ? VersionBlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR:0)) + " lastSubFP=" + f.lastSubFP + " isLastInFloor=" + f.isLastInFloor + " mdUpto=" + f.metaDataUpto + " tbOrd=" + f.getTermBlockOrd());,         },         if (fr.index != null) {,           assert !isSeekFrame || f.arc != null: "isSeekFrame=" + isSeekFrame + " f.arc=" + f.arc;,           if (f.prefix > 0 && isSeekFrame && f.arc.label != (term.byteAt(f.prefix-1)&0xFF)) {,             out.println("      broken seek state: arc.label=" + (char) f.arc.label + " vs term byte=" + (char) (term.byteAt(f.prefix-1)&0xFF));,             throw new RuntimeException("seek state is broken");,           },           Pair<BytesRef,Long> output = Util.get(fr.index, prefix);,           if (output == null) {,             out.println("      broken seek state: prefix is not final in index");,             throw new RuntimeException("seek state is broken");,           } else if (isSeekFrame && !f.isFloor) {,             final ByteArrayDataInput reader = new ByteArrayDataInput(output.output1.bytes, output.output1.offset, output.output1.length);,             final long codeOrig = reader.readVLong();,             final long code = (f.fp << VersionBlockTreeTermsWriter.OUTPUT_FLAGS_NUM_BITS) | (f.hasTerms ? VersionBlockTreeTermsWriter.OUTPUT_FLAG_HAS_TERMS:0) | (f.isFloor ? VersionBlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR:0);,             if (codeOrig != code) {,               out.println("      broken seek state: output code=" + codeOrig + " doesn't match frame code=" + code);,               throw new RuntimeException("seek state is broken");,             },           },         },         if (f == currentFrame) {,           break;,         },         if (f.prefix == validIndexPrefix) {,           isSeekFrame = false;,         },         ord++;,       },     },   }],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/IDVersionTermState.java,copyFrom,37-37,[    IDVersionTermState other = (IDVersionTermState) _other;],,
CORRECTNESS,SA_LOCAL_SELF_COMPARISON,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsReader.java,<init>,140-140,[        if (sumTotalTermFreq != -1 && sumTotalTermFreq < sumDocFreq) { // #positions must be >= #postings],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsReader.java,<init>,140-140,[        if (sumTotalTermFreq != -1 && sumTotalTermFreq < sumDocFreq) { // #positions must be >= #postings],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java,finish,836-836,[                                     ((PendingBlock) pending.get(0)).index.getEmptyOutput(),],,finish,814-814,[        assert root.index.getEmptyOutput() != null;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java,writeBlock,609-609,[          maxVersionInBlock = Math.max(maxVersionInBlock, ((IDVersionTermState) state).idVersion);],,writeBlock,643-643,[            maxVersionInBlock = Math.max(maxVersionInBlock, ((IDVersionTermState) state).idVersion);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java,writeBlock,677-677,[            PendingBlock block = (PendingBlock) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java,writeBlock,606-606,[          PendingTerm term = (PendingTerm) ent;],,writeBlock,640-640,[            PendingTerm term = (PendingTerm) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java,writeBlocks,498-498,[          PendingBlock block = (PendingBlock) ent;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java,writeBlocks,487-487,[          PendingTerm term = (PendingTerm) ent;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java,writeBlock,607-607,[          assert StringHelper.startsWith(term.termBytes, prefix): "term.term=" + term.termBytes + " prefix=" + prefix;],,writeBlock,641-641,[            assert StringHelper.startsWith(term.termBytes, prefix): "term.term=" + term.termBytes + " prefix=" + prefix;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/lucene/codecs/lucene50/Lucene50DocValuesConsumer.java,addTermsDict,419-419,[      addressBuffer = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/lucene/codecs/lucene50/Lucene50DocValuesConsumer.java,addTermsDict,420-420,[      termAddresses = null;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/codecs/lucene50/Lucene50DocValuesConsumer.java,,46-585,[class Lucene50DocValuesConsumer extends DocValuesConsumer implements Closeable {, ,   static final int BLOCK_SIZE = 16384;,   ,   // address terms in blocks of 16 terms,   static final int INTERVAL_SHIFT = 4;,   static final int INTERVAL_COUNT = 1 << INTERVAL_SHIFT;,   static final int INTERVAL_MASK = INTERVAL_COUNT - 1;,   ,   // build reverse index from every 1024th term,   static final int REVERSE_INTERVAL_SHIFT = 10;,   static final int REVERSE_INTERVAL_COUNT = 1 << REVERSE_INTERVAL_SHIFT;,   static final int REVERSE_INTERVAL_MASK = REVERSE_INTERVAL_COUNT - 1;,   ,   // for conversion from reverse index to block,   static final int BLOCK_INTERVAL_SHIFT = REVERSE_INTERVAL_SHIFT - INTERVAL_SHIFT;,   static final int BLOCK_INTERVAL_COUNT = 1 << BLOCK_INTERVAL_SHIFT;,   static final int BLOCK_INTERVAL_MASK = BLOCK_INTERVAL_COUNT - 1;, ,   /** Compressed using packed blocks of ints. */,   public static final int DELTA_COMPRESSED = 0;,   /** Compressed by computing the GCD. */,   public static final int GCD_COMPRESSED = 1;,   /** Compressed by giving IDs to unique values. */,   public static final int TABLE_COMPRESSED = 2;,   /** Compressed with monotonically increasing values */,   public static final int MONOTONIC_COMPRESSED = 3;,   /** Compressed with constant value (uses only missing bitset) */,   public static final int CONST_COMPRESSED = 4;,   ,   /** Uncompressed binary, written directly (fixed length). */,   public static final int BINARY_FIXED_UNCOMPRESSED = 0;,   /** Uncompressed binary, written directly (variable length). */,   public static final int BINARY_VARIABLE_UNCOMPRESSED = 1;,   /** Compressed binary with shared prefixes */,   public static final int BINARY_PREFIX_COMPRESSED = 2;, ,   /** Standard storage for sorted set values with 1 level of indirection:,    *  {@code docId -> address -> ord}. */,   public static final int SORTED_WITH_ADDRESSES = 0;,   /** Single-valued sorted set values, encoded as sorted values, so no level,    *  of indirection: {@code docId -> ord}. */,   public static final int SORTED_SINGLE_VALUED = 1;,   ,   /** placeholder for missing offset that means there are no missing values */,   public static final int ALL_LIVE = -1;,   /** placeholder for missing offset that means all values are missing */,   public static final int ALL_MISSING = -2;, ,   IndexOutput data, meta;,   final int maxDoc;,   ,   /** expert: Creates a new writer */,   public Lucene50DocValuesConsumer(SegmentWriteState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {,     boolean success = false;,     try {,       String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);,       data = state.directory.createOutput(dataName, state.context);,       CodecUtil.writeIndexHeader(data, dataCodec, Lucene50DocValuesFormat.VERSION_CURRENT, state.segmentInfo.getId(), state.segmentSuffix);,       String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);,       meta = state.directory.createOutput(metaName, state.context);,       CodecUtil.writeIndexHeader(meta, metaCodec, Lucene50DocValuesFormat.VERSION_CURRENT, state.segmentInfo.getId(), state.segmentSuffix);,       maxDoc = state.segmentInfo.getDocCount();,       success = true;,     } finally {,       if (!success) {,         IOUtils.closeWhileHandlingException(this);,       },     },   },   ,   @Override,   public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {,     addNumericField(field, values, true);,   }, ,   void addNumericField(FieldInfo field, Iterable<Number> values, boolean optimizeStorage) throws IOException {,     long count = 0;,     long minValue = Long.MAX_VALUE;,     long maxValue = Long.MIN_VALUE;,     long gcd = 0;,     long missingCount = 0;,     long zeroCount = 0;,     // TODO: more efficient?,     HashSet<Long> uniqueValues = null;,     if (optimizeStorage) {,       uniqueValues = new HashSet<>();, ,       for (Number nv : values) {,         final long v;,         if (nv == null) {,           v = 0;,           missingCount++;,           zeroCount++;,         } else {,           v = nv.longValue();,           if (v == 0) {,             zeroCount++;,           },         }, ,         if (gcd != 1) {,           if (v < Long.MIN_VALUE / 2 || v > Long.MAX_VALUE / 2) {,             // in that case v - minValue might overflow and make the GCD computation return,             // wrong results. Since these extreme values are unlikely, we just discard,             // GCD computation for them,             gcd = 1;,           } else if (count != 0) { // minValue needs to be set first,             gcd = MathUtil.gcd(gcd, v - minValue);,           },         }, ,         minValue = Math.min(minValue, v);,         maxValue = Math.max(maxValue, v);, ,         if (uniqueValues != null) {,           if (uniqueValues.add(v)) {,             if (uniqueValues.size() > 256) {,               uniqueValues = null;,             },           },         }, ,         ++count;,       },     } else {,       for (Number nv : values) {,         long v = nv.longValue();,         minValue = Math.min(minValue, v);,         maxValue = Math.max(maxValue, v);,         ++count;,       },     },     ,     final long delta = maxValue - minValue;,     final int deltaBitsRequired = DirectWriter.unsignedBitsRequired(delta);,     final int tableBitsRequired = uniqueValues == null,         ? Integer.MAX_VALUE,         : DirectWriter.bitsRequired(uniqueValues.size() - 1);, ,     final int format;,     if (uniqueValues != null ,         && count <= Integer.MAX_VALUE,         && (uniqueValues.size() == 1,            || (uniqueValues.size() == 2 && missingCount > 0 && zeroCount == missingCount))) {,       // either one unique value C or two unique values: "missing" and C,       format = CONST_COMPRESSED;,     } else if (uniqueValues != null && tableBitsRequired < deltaBitsRequired) {,       format = TABLE_COMPRESSED;,     } else if (gcd != 0 && gcd != 1) {,       final long gcdDelta = (maxValue - minValue) / gcd;,       final long gcdBitsRequired = DirectWriter.unsignedBitsRequired(gcdDelta);,       format = gcdBitsRequired < deltaBitsRequired ? GCD_COMPRESSED : DELTA_COMPRESSED;,     } else {,       format = DELTA_COMPRESSED;,     },     meta.writeVInt(field.number);,     meta.writeByte(Lucene50DocValuesFormat.NUMERIC);,     meta.writeVInt(format);,     if (missingCount == 0) {,       meta.writeLong(ALL_LIVE);,     } else if (missingCount == count) {,       meta.writeLong(ALL_MISSING);,     } else {,       meta.writeLong(data.getFilePointer());,       writeMissingBitset(values);,     },     meta.writeLong(data.getFilePointer());,     meta.writeVLong(count);, ,     switch (format) {,       case CONST_COMPRESSED:,         // write the constant (nonzero value in the n=2 case, singleton value otherwise),         meta.writeLong(minValue < 0 ? Collections.min(uniqueValues) : Collections.max(uniqueValues));,         break;,       case GCD_COMPRESSED:,         meta.writeLong(minValue);,         meta.writeLong(gcd);,         final long maxDelta = (maxValue - minValue) / gcd;,         final int bits = DirectWriter.unsignedBitsRequired(maxDelta);,         meta.writeVInt(bits);,         final DirectWriter quotientWriter = DirectWriter.getInstance(data, count, bits);,         for (Number nv : values) {,           long value = nv == null ? 0 : nv.longValue();,           quotientWriter.add((value - minValue) / gcd);,         },         quotientWriter.finish();,         break;,       case DELTA_COMPRESSED:,         final long minDelta = delta < 0 ? 0 : minValue;,         meta.writeLong(minDelta);,         meta.writeVInt(deltaBitsRequired);,         final DirectWriter writer = DirectWriter.getInstance(data, count, deltaBitsRequired);,         for (Number nv : values) {,           long v = nv == null ? 0 : nv.longValue();,           writer.add(v - minDelta);,         },         writer.finish();,         break;,       case TABLE_COMPRESSED:,         final Long[] decode = uniqueValues.toArray(new Long[uniqueValues.size()]);,         Arrays.sort(decode);,         final HashMap<Long,Integer> encode = new HashMap<>();,         meta.writeVInt(decode.length);,         for (int i = 0; i < decode.length; i++) {,           meta.writeLong(decode[i]);,           encode.put(decode[i], i);,         },         meta.writeVInt(tableBitsRequired);,         final DirectWriter ordsWriter = DirectWriter.getInstance(data, count, tableBitsRequired);,         for (Number nv : values) {,           ordsWriter.add(encode.get(nv == null ? 0 : nv.longValue()));,         },         ordsWriter.finish();,         break;,       default:,         throw new AssertionError();,     },     meta.writeLong(data.getFilePointer());,   },   ,   // TODO: in some cases representing missing with minValue-1 wouldn't take up additional space and so on,,   // but this is very simple, and algorithms only check this for values of 0 anyway (doesnt slow down normal decode),   void writeMissingBitset(Iterable<?> values) throws IOException {,     byte bits = 0;,     int count = 0;,     for (Object v : values) {,       if (count == 8) {,         data.writeByte(bits);,         count = 0;,         bits = 0;,       },       if (v != null) {,         bits |= 1 << (count & 7);,       },       count++;,     },     if (count > 0) {,       data.writeByte(bits);,     },   }, ,   @Override,   public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {,     // write the byte[] data,     meta.writeVInt(field.number);,     meta.writeByte(Lucene50DocValuesFormat.BINARY);,     int minLength = Integer.MAX_VALUE;,     int maxLength = Integer.MIN_VALUE;,     final long startFP = data.getFilePointer();,     long count = 0;,     long missingCount = 0;,     for(BytesRef v : values) {,       final int length;,       if (v == null) {,         length = 0;,         missingCount++;,       } else {,         length = v.length;,       },       minLength = Math.min(minLength, length);,       maxLength = Math.max(maxLength, length);,       if (v != null) {,         data.writeBytes(v.bytes, v.offset, v.length);,       },       count++;,     },     meta.writeVInt(minLength == maxLength ? BINARY_FIXED_UNCOMPRESSED : BINARY_VARIABLE_UNCOMPRESSED);,     if (missingCount == 0) {,       meta.writeLong(ALL_LIVE);,     } else if (missingCount == count) {,       meta.writeLong(ALL_MISSING);,     } else {,       meta.writeLong(data.getFilePointer());,       writeMissingBitset(values);,     },     meta.writeVInt(minLength);,     meta.writeVInt(maxLength);,     meta.writeVLong(count);,     meta.writeLong(startFP);,     ,     // if minLength == maxLength, it's a fixed-length byte[], we are done (the addresses are implicit),     // otherwise, we need to record the length fields...,     if (minLength != maxLength) {,       meta.writeLong(data.getFilePointer());,       meta.writeVInt(PackedInts.VERSION_CURRENT);,       meta.writeVInt(BLOCK_SIZE);, ,       final MonotonicBlockPackedWriter writer = new MonotonicBlockPackedWriter(data, BLOCK_SIZE);,       long addr = 0;,       writer.add(addr);,       for (BytesRef v : values) {,         if (v != null) {,           addr += v.length;,         },         writer.add(addr);,       },       writer.finish();,     },   },   ,   /** expert: writes a value dictionary for a sorted/sortedset field */,   private void addTermsDict(FieldInfo field, final Iterable<BytesRef> values) throws IOException {,     // first check if it's a "fixed-length" terms dict,     int minLength = Integer.MAX_VALUE;,     int maxLength = Integer.MIN_VALUE;,     long numValues = 0;,     for (BytesRef v : values) {,       minLength = Math.min(minLength, v.length);,       maxLength = Math.max(maxLength, v.length);,       numValues++;,     },     if (minLength == maxLength) {,       // no index needed: direct addressing by mult,       addBinaryField(field, values);,     } else if (numValues < REVERSE_INTERVAL_COUNT) {,       // low cardinality: waste a few KB of ram, but can't really use fancy index etc,       addBinaryField(field, values);,     } else {,       assert numValues > 0; // we don't have to handle the empty case,       // header,       meta.writeVInt(field.number);,       meta.writeByte(Lucene50DocValuesFormat.BINARY);,       meta.writeVInt(BINARY_PREFIX_COMPRESSED);,       meta.writeLong(-1L);,       // now write the bytes: sharing prefixes within a block,       final long startFP = data.getFilePointer();,       // currently, we have to store the delta from expected for every 1/nth term,       // we could avoid this, but it's not much and less overall RAM than the previous approach!,       RAMOutputStream addressBuffer = new RAMOutputStream();,       MonotonicBlockPackedWriter termAddresses = new MonotonicBlockPackedWriter(addressBuffer, BLOCK_SIZE);,       // buffers up 16 terms,       RAMOutputStream bytesBuffer = new RAMOutputStream();,       // buffers up block header,       RAMOutputStream headerBuffer = new RAMOutputStream();,       BytesRefBuilder lastTerm = new BytesRefBuilder();,       lastTerm.grow(maxLength);,       long count = 0;,       int suffixDeltas[] = new int[INTERVAL_COUNT];,       for (BytesRef v : values) {,         int termPosition = (int) (count & INTERVAL_MASK);,         if (termPosition == 0) {,           termAddresses.add(data.getFilePointer() - startFP);,           // abs-encode first term,           headerBuffer.writeVInt(v.length);,           headerBuffer.writeBytes(v.bytes, v.offset, v.length);,           lastTerm.copyBytes(v);,         } else {,           // prefix-code: we only share at most 255 characters, to encode the length as a single,           // byte and have random access. Larger terms just get less compression.,           int sharedPrefix = Math.min(255, StringHelper.bytesDifference(lastTerm.get(), v));,           bytesBuffer.writeByte((byte) sharedPrefix);,           bytesBuffer.writeBytes(v.bytes, v.offset + sharedPrefix, v.length - sharedPrefix);,           // we can encode one smaller, because terms are unique.,           suffixDeltas[termPosition] = v.length - sharedPrefix - 1;,         },         ,         count++;,         // flush block,         if ((count & INTERVAL_MASK) == 0) {,           flushTermsDictBlock(headerBuffer, bytesBuffer, suffixDeltas);,         },       },       // flush trailing crap,       int leftover = (int) (count & INTERVAL_MASK);,       if (leftover > 0) {,         Arrays.fill(suffixDeltas, leftover, suffixDeltas.length, 0);,         flushTermsDictBlock(headerBuffer, bytesBuffer, suffixDeltas);,       },       final long indexStartFP = data.getFilePointer();,       // write addresses of indexed terms,       termAddresses.finish();,       addressBuffer.writeTo(data);,       addressBuffer = null;,       termAddresses = null;,       meta.writeVInt(minLength);,       meta.writeVInt(maxLength);,       meta.writeVLong(count);,       meta.writeLong(startFP);,       meta.writeLong(indexStartFP);,       meta.writeVInt(PackedInts.VERSION_CURRENT);,       meta.writeVInt(BLOCK_SIZE);,       addReverseTermIndex(field, values, maxLength);,     },   },   ,   // writes term dictionary "block",   // first term is absolute encoded as vint length + bytes.,   // lengths of subsequent N terms are encoded as either N bytes or N shorts.,   // in the double-byte case, the first byte is indicated with -1.,   // subsequent terms are encoded as byte suffixLength + bytes.,   private void flushTermsDictBlock(RAMOutputStream headerBuffer, RAMOutputStream bytesBuffer, int suffixDeltas[]) throws IOException {,     boolean twoByte = false;,     for (int i = 1; i < suffixDeltas.length; i++) {,       if (suffixDeltas[i] > 254) {,         twoByte = true;,       },     },     if (twoByte) {,       headerBuffer.writeByte((byte)255);,       for (int i = 1; i < suffixDeltas.length; i++) {,         headerBuffer.writeShort((short) suffixDeltas[i]);,       },     } else {,       for (int i = 1; i < suffixDeltas.length; i++) {,         headerBuffer.writeByte((byte) suffixDeltas[i]);,       },     },     headerBuffer.writeTo(data);,     headerBuffer.reset();,     bytesBuffer.writeTo(data);,     bytesBuffer.reset();,   },   ,   // writes reverse term index: used for binary searching a term into a range of 64 blocks,   // for every 64 blocks (1024 terms) we store a term, trimming any suffix unnecessary for comparison,   // terms are written as a contiguous byte[], but never spanning 2^15 byte boundaries.,   private void addReverseTermIndex(FieldInfo field, final Iterable<BytesRef> values, int maxLength) throws IOException {,     long count = 0;,     BytesRefBuilder priorTerm = new BytesRefBuilder();,     priorTerm.grow(maxLength);,     BytesRef indexTerm = new BytesRef();,     long startFP = data.getFilePointer();,     PagedBytes pagedBytes = new PagedBytes(15);,     MonotonicBlockPackedWriter addresses = new MonotonicBlockPackedWriter(data, BLOCK_SIZE);,     ,     for (BytesRef b : values) {,       int termPosition = (int) (count & REVERSE_INTERVAL_MASK);,       if (termPosition == 0) {,         int len = StringHelper.sortKeyLength(priorTerm.get(), b);,         indexTerm.bytes = b.bytes;,         indexTerm.offset = b.offset;,         indexTerm.length = len;,         addresses.add(pagedBytes.copyUsingLengthPrefix(indexTerm));,       } else if (termPosition == REVERSE_INTERVAL_MASK) {,         priorTerm.copyBytes(b);,       },       count++;,     },     addresses.finish();,     long numBytes = pagedBytes.getPointer();,     pagedBytes.freeze(true);,     PagedBytesDataInput in = pagedBytes.getDataInput();,     meta.writeLong(startFP);,     data.writeVLong(numBytes);,     data.copyBytes(in, numBytes);,   }, ,   @Override,   public void addSortedField(FieldInfo field, Iterable<BytesRef> values, Iterable<Number> docToOrd) throws IOException {,     meta.writeVInt(field.number);,     meta.writeByte(Lucene50DocValuesFormat.SORTED);,     addTermsDict(field, values);,     addNumericField(field, docToOrd, false);,   }, ,   @Override,   public void addSortedNumericField(FieldInfo field, final Iterable<Number> docToValueCount, final Iterable<Number> values) throws IOException {,     meta.writeVInt(field.number);,     meta.writeByte(Lucene50DocValuesFormat.SORTED_NUMERIC);,     if (isSingleValued(docToValueCount)) {,       meta.writeVInt(SORTED_SINGLE_VALUED);,       // The field is single-valued, we can encode it as NUMERIC,       addNumericField(field, singletonView(docToValueCount, values, null));,     } else {,       meta.writeVInt(SORTED_WITH_ADDRESSES);,       // write the stream of values as a numeric field,       addNumericField(field, values, true);,       // write the doc -> ord count as a absolute index to the stream,       addAddresses(field, docToValueCount);,     },   }, ,   @Override,   public void addSortedSetField(FieldInfo field, Iterable<BytesRef> values, final Iterable<Number> docToOrdCount, final Iterable<Number> ords) throws IOException {,     meta.writeVInt(field.number);,     meta.writeByte(Lucene50DocValuesFormat.SORTED_SET);, ,     if (isSingleValued(docToOrdCount)) {,       meta.writeVInt(SORTED_SINGLE_VALUED);,       // The field is single-valued, we can encode it as SORTED,       addSortedField(field, values, singletonView(docToOrdCount, ords, -1L));,     } else {,       meta.writeVInt(SORTED_WITH_ADDRESSES);, ,       // write the ord -> byte[] as a binary field,       addTermsDict(field, values);, ,       // write the stream of ords as a numeric field,       // NOTE: we could return an iterator that delta-encodes these within a doc,       addNumericField(field, ords, false);, ,       // write the doc -> ord count as a absolute index to the stream,       addAddresses(field, docToOrdCount);,     },   },   ,   // writes addressing information as MONOTONIC_COMPRESSED integer,   private void addAddresses(FieldInfo field, Iterable<Number> values) throws IOException {,     meta.writeVInt(field.number);,     meta.writeByte(Lucene50DocValuesFormat.NUMERIC);,     meta.writeVInt(MONOTONIC_COMPRESSED);,     meta.writeLong(-1L);,     meta.writeLong(data.getFilePointer());,     meta.writeVLong(maxDoc);,     meta.writeVInt(PackedInts.VERSION_CURRENT);,     meta.writeVInt(BLOCK_SIZE);, ,     final MonotonicBlockPackedWriter writer = new MonotonicBlockPackedWriter(data, BLOCK_SIZE);,     long addr = 0;,     writer.add(addr);,     for (Number v : values) {,       addr += v.longValue();,       writer.add(addr);,     },     writer.finish();,     meta.writeLong(data.getFilePointer());,   }, ,   @Override,   public void close() throws IOException {,     boolean success = false;,     try {,       if (meta != null) {,         meta.writeVInt(-1); // write EOF marker,         CodecUtil.writeFooter(meta); // write checksum,       },       if (data != null) {,         CodecUtil.writeFooter(data); // write checksum,       },       success = true;,     } finally {,       if (success) {,         IOUtils.close(data, meta);,       } else {,         IOUtils.closeWhileHandlingException(data, meta);,       },       meta = data = null;,     },   }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,81-798,[class Lucene50DocValuesProducer extends DocValuesProducer implements Closeable {,   private final Map<String,NumericEntry> numerics = new HashMap<>();,   private final Map<String,BinaryEntry> binaries = new HashMap<>();,   private final Map<String,SortedSetEntry> sortedSets = new HashMap<>();,   private final Map<String,SortedSetEntry> sortedNumerics = new HashMap<>();,   private final Map<String,NumericEntry> ords = new HashMap<>();,   private final Map<String,NumericEntry> ordIndexes = new HashMap<>();,   private final int numFields;,   private final AtomicLong ramBytesUsed;,   private final IndexInput data;,   private final int maxDoc;, ,   // memory-resident structures,   private final Map<String,MonotonicBlockPackedReader> addressInstances = new HashMap<>();,   private final Map<String,MonotonicBlockPackedReader> ordIndexInstances = new HashMap<>();,   private final Map<String,ReverseTermsIndex> reverseIndexInstances = new HashMap<>();,   ,   private final boolean merging;,   ,   // clone for merge: when merging we don't do any instances.put()s,   Lucene50DocValuesProducer(Lucene50DocValuesProducer original) throws IOException {,     assert Thread.holdsLock(original);,     numerics.putAll(original.numerics);,     binaries.putAll(original.binaries);,     sortedSets.putAll(original.sortedSets);,     sortedNumerics.putAll(original.sortedNumerics);,     ords.putAll(original.ords);,     ordIndexes.putAll(original.ordIndexes);,     numFields = original.numFields;,     ramBytesUsed = new AtomicLong(original.ramBytesUsed.get());,     data = original.data.clone();,     maxDoc = original.maxDoc;,     ,     addressInstances.putAll(original.addressInstances);,     ordIndexInstances.putAll(original.ordIndexInstances);,     reverseIndexInstances.putAll(original.reverseIndexInstances);,     merging = true;,   },   ,   /** expert: instantiates a new reader */,   Lucene50DocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {,     String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);,     this.maxDoc = state.segmentInfo.getDocCount();,     merging = false;,     ,     int version = -1;,     int numFields = -1;,     ,     // read in the entries from the metadata file.,     try (ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context)) {,       Throwable priorE = null;,       try {,         version = CodecUtil.checkIndexHeader(in, metaCodec, ,                                         Lucene50DocValuesFormat.VERSION_START,,                                         Lucene50DocValuesFormat.VERSION_CURRENT,,                                         state.segmentInfo.getId(),,                                         state.segmentSuffix);,         numFields = readFields(in, state.fieldInfos);,       } catch (Throwable exception) {,         priorE = exception;,       } finally {,         CodecUtil.checkFooter(in, priorE);,       },     },     ,     this.numFields = numFields;,     String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);,     this.data = state.directory.openInput(dataName, state.context);,     boolean success = false;,     try {,       final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, ,                                                  Lucene50DocValuesFormat.VERSION_START,,                                                  Lucene50DocValuesFormat.VERSION_CURRENT,,                                                  state.segmentInfo.getId(),,                                                  state.segmentSuffix);,       if (version != version2) {,         throw new CorruptIndexException("Format versions mismatch: meta=" + version + ", data=" + version2, data);,       },       ,       // NOTE: data file is too costly to verify checksum against all the bytes on open,,       // but for now we at least verify proper structure of the checksum footer: which looks,       // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption,       // such as file truncation.,       CodecUtil.retrieveChecksum(data);, ,       success = true;,     } finally {,       if (!success) {,         IOUtils.closeWhileHandlingException(this.data);,       },     },     ,     ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));,   }, ,   private void readSortedField(FieldInfo info, IndexInput meta) throws IOException {,     // sorted = binary + numeric,     if (meta.readVInt() != info.number) {,       throw new CorruptIndexException("sorted entry for field: " + info.name + " is corrupt", meta);,     },     if (meta.readByte() != Lucene50DocValuesFormat.BINARY) {,       throw new CorruptIndexException("sorted entry for field: " + info.name + " is corrupt", meta);,     },     BinaryEntry b = readBinaryEntry(meta);,     binaries.put(info.name, b);,     ,     if (meta.readVInt() != info.number) {,       throw new CorruptIndexException("sorted entry for field: " + info.name + " is corrupt", meta);,     },     if (meta.readByte() != Lucene50DocValuesFormat.NUMERIC) {,       throw new CorruptIndexException("sorted entry for field: " + info.name + " is corrupt", meta);,     },     NumericEntry n = readNumericEntry(meta);,     ords.put(info.name, n);,   }, ,   private void readSortedSetFieldWithAddresses(FieldInfo info, IndexInput meta) throws IOException {,     // sortedset = binary + numeric (addresses) + ordIndex,     if (meta.readVInt() != info.number) {,       throw new CorruptIndexException("sortedset entry for field: " + info.name + " is corrupt", meta);,     },     if (meta.readByte() != Lucene50DocValuesFormat.BINARY) {,       throw new CorruptIndexException("sortedset entry for field: " + info.name + " is corrupt", meta);,     },     BinaryEntry b = readBinaryEntry(meta);,     binaries.put(info.name, b);, ,     if (meta.readVInt() != info.number) {,       throw new CorruptIndexException("sortedset entry for field: " + info.name + " is corrupt", meta);,     },     if (meta.readByte() != Lucene50DocValuesFormat.NUMERIC) {,       throw new CorruptIndexException("sortedset entry for field: " + info.name + " is corrupt", meta);,     },     NumericEntry n1 = readNumericEntry(meta);,     ords.put(info.name, n1);, ,     if (meta.readVInt() != info.number) {,       throw new CorruptIndexException("sortedset entry for field: " + info.name + " is corrupt", meta);,     },     if (meta.readByte() != Lucene50DocValuesFormat.NUMERIC) {,       throw new CorruptIndexException("sortedset entry for field: " + info.name + " is corrupt", meta);,     },     NumericEntry n2 = readNumericEntry(meta);,     ordIndexes.put(info.name, n2);,   }, ,   private int readFields(IndexInput meta, FieldInfos infos) throws IOException {,     int numFields = 0;,     int fieldNumber = meta.readVInt();,     while (fieldNumber != -1) {,       numFields++;,       FieldInfo info = infos.fieldInfo(fieldNumber);,       if (info == null) {,         // trickier to validate more: because we use multiple entries for "composite" types like sortedset, etc.,         throw new CorruptIndexException("Invalid field number: " + fieldNumber, meta);,       },       byte type = meta.readByte();,       if (type == Lucene50DocValuesFormat.NUMERIC) {,         numerics.put(info.name, readNumericEntry(meta));,       } else if (type == Lucene50DocValuesFormat.BINARY) {,         BinaryEntry b = readBinaryEntry(meta);,         binaries.put(info.name, b);,       } else if (type == Lucene50DocValuesFormat.SORTED) {,         readSortedField(info, meta);,       } else if (type == Lucene50DocValuesFormat.SORTED_SET) {,         SortedSetEntry ss = readSortedSetEntry(meta);,         sortedSets.put(info.name, ss);,         if (ss.format == SORTED_WITH_ADDRESSES) {,           readSortedSetFieldWithAddresses(info, meta);,         } else if (ss.format == SORTED_SINGLE_VALUED) {,           if (meta.readVInt() != fieldNumber) {,             throw new CorruptIndexException("sortedset entry for field: " + info.name + " is corrupt", meta);,           },           if (meta.readByte() != Lucene50DocValuesFormat.SORTED) {,             throw new CorruptIndexException("sortedset entry for field: " + info.name + " is corrupt", meta);,           },           readSortedField(info, meta);,         } else {,           throw new AssertionError();,         },       } else if (type == Lucene50DocValuesFormat.SORTED_NUMERIC) {,         SortedSetEntry ss = readSortedSetEntry(meta);,         sortedNumerics.put(info.name, ss);,         if (meta.readVInt() != fieldNumber) {,           throw new CorruptIndexException("sortednumeric entry for field: " + info.name + " is corrupt", meta);,         },         if (meta.readByte() != Lucene50DocValuesFormat.NUMERIC) {,           throw new CorruptIndexException("sortednumeric entry for field: " + info.name + " is corrupt", meta);,         },         numerics.put(info.name, readNumericEntry(meta));,         if (ss.format == SORTED_WITH_ADDRESSES) {,           if (meta.readVInt() != fieldNumber) {,             throw new CorruptIndexException("sortednumeric entry for field: " + info.name + " is corrupt", meta);,           },           if (meta.readByte() != Lucene50DocValuesFormat.NUMERIC) {,             throw new CorruptIndexException("sortednumeric entry for field: " + info.name + " is corrupt", meta);,           },           NumericEntry ordIndex = readNumericEntry(meta);,           ordIndexes.put(info.name, ordIndex);,         } else if (ss.format != SORTED_SINGLE_VALUED) {,           throw new AssertionError();,         },       } else {,         throw new CorruptIndexException("invalid type: " + type, meta);,       },       fieldNumber = meta.readVInt();,     },     return numFields;,   },   ,   private NumericEntry readNumericEntry(IndexInput meta) throws IOException {,     NumericEntry entry = new NumericEntry();,     entry.format = meta.readVInt();,     entry.missingOffset = meta.readLong();,     entry.offset = meta.readLong();,     entry.count = meta.readVLong();,     switch(entry.format) {,       case CONST_COMPRESSED:,         entry.minValue = meta.readLong();,         if (entry.count > Integer.MAX_VALUE) {,           // currently just a limitation e.g. of bits interface and so on.,           throw new CorruptIndexException("illegal CONST_COMPRESSED count: " + entry.count, meta);,         },         break;,       case GCD_COMPRESSED:,         entry.minValue = meta.readLong();,         entry.gcd = meta.readLong();,         entry.bitsPerValue = meta.readVInt();,         break;,       case TABLE_COMPRESSED:,         final int uniqueValues = meta.readVInt();,         if (uniqueValues > 256) {,           throw new CorruptIndexException("TABLE_COMPRESSED cannot have more than 256 distinct values, got=" + uniqueValues, meta);,         },         entry.table = new long[uniqueValues];,         for (int i = 0; i < uniqueValues; ++i) {,           entry.table[i] = meta.readLong();,         },         entry.bitsPerValue = meta.readVInt();,         break;,       case DELTA_COMPRESSED:,         entry.minValue = meta.readLong();,         entry.bitsPerValue = meta.readVInt();,         break;,       case MONOTONIC_COMPRESSED:,         entry.packedIntsVersion = meta.readVInt();,         entry.blockSize = meta.readVInt();,         break;,       default:,         throw new CorruptIndexException("Unknown format: " + entry.format + ", input=", meta);,     },     entry.endOffset = meta.readLong();,     return entry;,   },   ,   static BinaryEntry readBinaryEntry(IndexInput meta) throws IOException {,     BinaryEntry entry = new BinaryEntry();,     entry.format = meta.readVInt();,     entry.missingOffset = meta.readLong();,     entry.minLength = meta.readVInt();,     entry.maxLength = meta.readVInt();,     entry.count = meta.readVLong();,     entry.offset = meta.readLong();,     switch(entry.format) {,       case BINARY_FIXED_UNCOMPRESSED:,         break;,       case BINARY_PREFIX_COMPRESSED:,         entry.addressesOffset = meta.readLong();,         entry.packedIntsVersion = meta.readVInt();,         entry.blockSize = meta.readVInt();,         entry.reverseIndexOffset = meta.readLong();,         break;,       case BINARY_VARIABLE_UNCOMPRESSED:,         entry.addressesOffset = meta.readLong();,         entry.packedIntsVersion = meta.readVInt();,         entry.blockSize = meta.readVInt();,         break;,       default:,         throw new CorruptIndexException("Unknown format: " + entry.format, meta);,     },     return entry;,   }, ,   SortedSetEntry readSortedSetEntry(IndexInput meta) throws IOException {,     SortedSetEntry entry = new SortedSetEntry();,     entry.format = meta.readVInt();,     if (entry.format != SORTED_SINGLE_VALUED && entry.format != SORTED_WITH_ADDRESSES) {,       throw new CorruptIndexException("Unknown format: " + entry.format, meta);,     },     return entry;,   }, ,   @Override,   public NumericDocValues getNumeric(FieldInfo field) throws IOException {,     NumericEntry entry = numerics.get(field.name);,     return getNumeric(entry);,   },   ,   @Override,   public long ramBytesUsed() {,     return ramBytesUsed.get();,   },   ,   @Override,   public synchronized Iterable<Accountable> getChildResources() {,     List<Accountable> resources = new ArrayList<>();,     resources.addAll(Accountables.namedAccountables("addresses field", addressInstances));,     resources.addAll(Accountables.namedAccountables("ord index field", ordIndexInstances));,     resources.addAll(Accountables.namedAccountables("reverse index field", reverseIndexInstances));,     return Collections.unmodifiableList(resources);,   },   ,   @Override,   public void checkIntegrity() throws IOException {,     CodecUtil.checksumEntireFile(data);,   }, ,   @Override,   public String toString() {,     return getClass().getSimpleName() + "(fields=" + numFields + ")";,   }, ,   LongValues getNumeric(NumericEntry entry) throws IOException {,     switch (entry.format) {,       case CONST_COMPRESSED: {,         final long constant = entry.minValue;,         final Bits live = getLiveBits(entry.missingOffset, (int)entry.count);,         return new LongValues() {,           @Override,           public long get(long index) {,             return live.get((int)index) ? constant : 0;,           },         };,       },       case DELTA_COMPRESSED: {,         RandomAccessInput slice = this.data.randomAccessSlice(entry.offset, entry.endOffset - entry.offset);,         final long delta = entry.minValue;,         final LongValues values = DirectReader.getInstance(slice, entry.bitsPerValue);,         return new LongValues() {,           @Override,           public long get(long id) {,             return delta + values.get(id);,           },         };,       },       case GCD_COMPRESSED: {,         RandomAccessInput slice = this.data.randomAccessSlice(entry.offset, entry.endOffset - entry.offset);,         final long min = entry.minValue;,         final long mult = entry.gcd;,         final LongValues quotientReader = DirectReader.getInstance(slice, entry.bitsPerValue);,         return new LongValues() {,           @Override,           public long get(long id) {,             return min + mult * quotientReader.get(id);,           },         };,       },       case TABLE_COMPRESSED: {,         RandomAccessInput slice = this.data.randomAccessSlice(entry.offset, entry.endOffset - entry.offset);,         final long table[] = entry.table;,         final LongValues ords = DirectReader.getInstance(slice, entry.bitsPerValue);,         return new LongValues() {,           @Override,           public long get(long id) {,             return table[(int) ords.get(id)];,           },         };,       },       default:,         throw new AssertionError();,     },   }, ,   @Override,   public BinaryDocValues getBinary(FieldInfo field) throws IOException {,     BinaryEntry bytes = binaries.get(field.name);,     switch(bytes.format) {,       case BINARY_FIXED_UNCOMPRESSED:,         return getFixedBinary(field, bytes);,       case BINARY_VARIABLE_UNCOMPRESSED:,         return getVariableBinary(field, bytes);,       case BINARY_PREFIX_COMPRESSED:,         return getCompressedBinary(field, bytes);,       default:,         throw new AssertionError();,     },   },   ,   private BinaryDocValues getFixedBinary(FieldInfo field, final BinaryEntry bytes) throws IOException {,     final IndexInput data = this.data.slice("fixed-binary", bytes.offset, bytes.count * bytes.maxLength);, ,     final BytesRef term = new BytesRef(bytes.maxLength);,     final byte[] buffer = term.bytes;,     final int length = term.length = bytes.maxLength;,     ,     return new LongBinaryDocValues() {,       @Override,       public BytesRef get(long id) {,         try {,           data.seek(id * length);,           data.readBytes(buffer, 0, buffer.length);,           return term;,         } catch (IOException e) {,           throw new RuntimeException(e);,         },       },     };,   },   ,   /** returns an address instance for variable-length binary values. */,   private synchronized MonotonicBlockPackedReader getAddressInstance(FieldInfo field, BinaryEntry bytes) throws IOException {,     MonotonicBlockPackedReader addresses = addressInstances.get(field.name);,     if (addresses == null) {,       data.seek(bytes.addressesOffset);,       addresses = MonotonicBlockPackedReader.of(data, bytes.packedIntsVersion, bytes.blockSize, bytes.count+1, false);,       if (!merging) {,         addressInstances.put(field.name, addresses);,         ramBytesUsed.addAndGet(addresses.ramBytesUsed() + RamUsageEstimator.NUM_BYTES_INT);,       },     },     return addresses;,   },   ,   private BinaryDocValues getVariableBinary(FieldInfo field, final BinaryEntry bytes) throws IOException {,     final MonotonicBlockPackedReader addresses = getAddressInstance(field, bytes);, ,     final IndexInput data = this.data.slice("var-binary", bytes.offset, bytes.addressesOffset - bytes.offset);,     final BytesRef term = new BytesRef(Math.max(0, bytes.maxLength));,     final byte buffer[] = term.bytes;,     ,     return new LongBinaryDocValues() {      ,       @Override,       public BytesRef get(long id) {,         long startAddress = addresses.get(id);,         long endAddress = addresses.get(id+1);,         int length = (int) (endAddress - startAddress);,         try {,           data.seek(startAddress);,           data.readBytes(buffer, 0, length);,           term.length = length;,           return term;,         } catch (IOException e) {,           throw new RuntimeException(e);,         },       },     };,   },   ,   /** returns an address instance for prefix-compressed binary values. */,   private synchronized MonotonicBlockPackedReader getIntervalInstance(FieldInfo field, BinaryEntry bytes) throws IOException {,     MonotonicBlockPackedReader addresses = addressInstances.get(field.name);,     if (addresses == null) {,       data.seek(bytes.addressesOffset);,       final long size = (bytes.count + INTERVAL_MASK) >>> INTERVAL_SHIFT;,       addresses = MonotonicBlockPackedReader.of(data, bytes.packedIntsVersion, bytes.blockSize, size, false);,       if (!merging) {,         addressInstances.put(field.name, addresses);,         ramBytesUsed.addAndGet(addresses.ramBytesUsed() + RamUsageEstimator.NUM_BYTES_INT);,       },     },     return addresses;,   },   ,   /** returns a reverse lookup instance for prefix-compressed binary values. */,   private synchronized ReverseTermsIndex getReverseIndexInstance(FieldInfo field, BinaryEntry bytes) throws IOException {,     ReverseTermsIndex index = reverseIndexInstances.get(field.name);,     if (index == null) {,       index = new ReverseTermsIndex();,       data.seek(bytes.reverseIndexOffset);,       long size = (bytes.count + REVERSE_INTERVAL_MASK) >>> REVERSE_INTERVAL_SHIFT;,       index.termAddresses = MonotonicBlockPackedReader.of(data, bytes.packedIntsVersion, bytes.blockSize, size, false);,       long dataSize = data.readVLong();,       PagedBytes pagedBytes = new PagedBytes(15);,       pagedBytes.copy(data, dataSize);,       index.terms = pagedBytes.freeze(true);,       if (!merging) {,         reverseIndexInstances.put(field.name, index);,         ramBytesUsed.addAndGet(index.ramBytesUsed());,       },     },     return index;,   }, ,   private BinaryDocValues getCompressedBinary(FieldInfo field, final BinaryEntry bytes) throws IOException {,     final MonotonicBlockPackedReader addresses = getIntervalInstance(field, bytes);,     final ReverseTermsIndex index = getReverseIndexInstance(field, bytes);,     assert addresses.size() > 0; // we don't have to handle empty case,     IndexInput slice = data.slice("terms", bytes.offset, bytes.addressesOffset - bytes.offset);,     return new CompressedBinaryDocValues(bytes, addresses, index, slice);,   }, ,   @Override,   public SortedDocValues getSorted(FieldInfo field) throws IOException {,     final int valueCount = (int) binaries.get(field.name).count;,     final BinaryDocValues binary = getBinary(field);,     NumericEntry entry = ords.get(field.name);,     final LongValues ordinals = getNumeric(entry);,     return new SortedDocValues() {, ,       @Override,       public int getOrd(int docID) {,         return (int) ordinals.get(docID);,       }, ,       @Override,       public BytesRef lookupOrd(int ord) {,         return binary.get(ord);,       }, ,       @Override,       public int getValueCount() {,         return valueCount;,       }, ,       @Override,       public int lookupTerm(BytesRef key) {,         if (binary instanceof CompressedBinaryDocValues) {,           return (int) ((CompressedBinaryDocValues)binary).lookupTerm(key);,         } else {,           return super.lookupTerm(key);,         },       }, ,       @Override,       public TermsEnum termsEnum() {,         if (binary instanceof CompressedBinaryDocValues) {,           return ((CompressedBinaryDocValues)binary).getTermsEnum();,         } else {,           return super.termsEnum();,         },       },     };,   },   ,   /** returns an address instance for sortedset ordinal lists */,   private synchronized MonotonicBlockPackedReader getOrdIndexInstance(FieldInfo field, NumericEntry entry) throws IOException {,     MonotonicBlockPackedReader instance = ordIndexInstances.get(field.name);,     if (instance == null) {,       data.seek(entry.offset);,       instance = MonotonicBlockPackedReader.of(data, entry.packedIntsVersion, entry.blockSize, entry.count+1, false);,       if (!merging) {,         ordIndexInstances.put(field.name, instance);,         ramBytesUsed.addAndGet(instance.ramBytesUsed() + RamUsageEstimator.NUM_BYTES_INT);,       },     },     return instance;,   },   ,   @Override,   public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {,     SortedSetEntry ss = sortedNumerics.get(field.name);,     NumericEntry numericEntry = numerics.get(field.name);,     final LongValues values = getNumeric(numericEntry);,     if (ss.format == SORTED_SINGLE_VALUED) {,       final Bits docsWithField = getLiveBits(numericEntry.missingOffset, maxDoc);,       return DocValues.singleton(values, docsWithField);,     } else if (ss.format == SORTED_WITH_ADDRESSES) {,       final MonotonicBlockPackedReader ordIndex = getOrdIndexInstance(field, ordIndexes.get(field.name));,       ,       return new SortedNumericDocValues() {,         long startOffset;,         long endOffset;,         ,         @Override,         public void setDocument(int doc) {,           startOffset = ordIndex.get(doc);,           endOffset = ordIndex.get(doc+1L);,         }, ,         @Override,         public long valueAt(int index) {,           return values.get(startOffset + index);,         }, ,         @Override,         public int count() {,           return (int) (endOffset - startOffset);,         },       };,     } else {,       throw new AssertionError();,     },   }, ,   @Override,   public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {,     SortedSetEntry ss = sortedSets.get(field.name);,     if (ss.format == SORTED_SINGLE_VALUED) {,       final SortedDocValues values = getSorted(field);,       return DocValues.singleton(values);,     } else if (ss.format != SORTED_WITH_ADDRESSES) {,       throw new AssertionError();,     }, ,     final long valueCount = binaries.get(field.name).count;,     // we keep the byte[]s and list of ords on disk, these could be large,     final LongBinaryDocValues binary = (LongBinaryDocValues) getBinary(field);,     final LongValues ordinals = getNumeric(ords.get(field.name));,     // but the addresses to the ord stream are in RAM,     final MonotonicBlockPackedReader ordIndex = getOrdIndexInstance(field, ordIndexes.get(field.name));,     ,     return new RandomAccessOrds() {,       long startOffset;,       long offset;,       long endOffset;,       ,       @Override,       public long nextOrd() {,         if (offset == endOffset) {,           return NO_MORE_ORDS;,         } else {,           long ord = ordinals.get(offset);,           offset++;,           return ord;,         },       }, ,       @Override,       public void setDocument(int docID) {,         startOffset = offset = ordIndex.get(docID);,         endOffset = ordIndex.get(docID+1L);,       }, ,       @Override,       public BytesRef lookupOrd(long ord) {,         return binary.get(ord);,       }, ,       @Override,       public long getValueCount() {,         return valueCount;,       },       ,       @Override,       public long lookupTerm(BytesRef key) {,         if (binary instanceof CompressedBinaryDocValues) {,           return ((CompressedBinaryDocValues)binary).lookupTerm(key);,         } else {,           return super.lookupTerm(key);,         },       }, ,       @Override,       public TermsEnum termsEnum() {,         if (binary instanceof CompressedBinaryDocValues) {,           return ((CompressedBinaryDocValues)binary).getTermsEnum();,         } else {,           return super.termsEnum();,         },       }, ,       @Override,       public long ordAt(int index) {,         return ordinals.get(startOffset + index);,       }, ,       @Override,       public int cardinality() {,         return (int) (endOffset - startOffset);,       },     };,   },   ,   private Bits getLiveBits(final long offset, final int count) throws IOException {,     if (offset == ALL_MISSING) {,       return new Bits.MatchNoBits(count);,     } else if (offset == ALL_LIVE) {,       return new Bits.MatchAllBits(count);,     } else {,       int length = (int) ((count + 7L) >>> 3);,       final RandomAccessInput in = data.randomAccessSlice(offset, length);,       return new Bits() {,         @Override,         public boolean get(int index) {,           try {,             return (in.readByte(index >> 3) & (1 << (index & 7))) != 0;,           } catch (IOException e) {,             throw new RuntimeException(e);,           },         }, ,         @Override,         public int length() {,           return count;,         },       };,     },   }, ,   @Override,   public Bits getDocsWithField(FieldInfo field) throws IOException {,     switch(field.getDocValuesType()) {,       case SORTED_SET:,         return DocValues.docsWithValue(getSortedSet(field), maxDoc);,       case SORTED_NUMERIC:,         return DocValues.docsWithValue(getSortedNumeric(field), maxDoc);,       case SORTED:,         return DocValues.docsWithValue(getSorted(field), maxDoc);,       case BINARY:,         BinaryEntry be = binaries.get(field.name);,         return getLiveBits(be.missingOffset, maxDoc);,       case NUMERIC:,         NumericEntry ne = numerics.get(field.name);,         return getLiveBits(ne.missingOffset, maxDoc);,       default:,         throw new AssertionError();,     },   }, ,   @Override,   public synchronized DocValuesProducer getMergeInstance() throws IOException {,     return new Lucene50DocValuesProducer(this);,   }, ,   @Override,   public void close() throws IOException {,     data.close();,   }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,408-411,[        return new LongValues() {,           @Override,           public long get(long index) {,             return live.get((int)index) ? constant : 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,752-764,[      return new Bits() {,         @Override,         public boolean get(int index) {,           try {,             return (in.readByte(index >> 3) & (1 << (index & 7))) != 0;,           } catch (IOException e) {,             throw new RuntimeException(e);,           },         }, ,         @Override,         public int length() {,           return count;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,419-422,[        return new LongValues() {,           @Override,           public long get(long id) {,             return delta + values.get(id);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,431-434,[        return new LongValues() {,           @Override,           public long get(long id) {,             return min + mult * quotientReader.get(id);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,442-445,[        return new LongValues() {,           @Override,           public long get(long id) {,             return table[(int) ords.get(id)];],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,578-609,[    return new SortedDocValues() {, ,       @Override,       public int getOrd(int docID) {,         return (int) ordinals.get(docID);,       }, ,       @Override,       public BytesRef lookupOrd(int ord) {,         return binary.get(ord);,       }, ,       @Override,       public int getValueCount() {,         return valueCount;,       }, ,       @Override,       public int lookupTerm(BytesRef key) {,         if (binary instanceof CompressedBinaryDocValues) {,           return (int) ((CompressedBinaryDocValues)binary).lookupTerm(key);,         } else {,           return super.lookupTerm(key);,         },       }, ,       @Override,       public TermsEnum termsEnum() {,         if (binary instanceof CompressedBinaryDocValues) {,           return ((CompressedBinaryDocValues)binary).getTermsEnum();,         } else {,           return super.termsEnum();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,640-657,[      return new SortedNumericDocValues() {,         long startOffset;,         long endOffset;,         ,         @Override,         public void setDocument(int doc) {,           startOffset = ordIndex.get(doc);,           endOffset = ordIndex.get(doc+1L);,         }, ,         @Override,         public long valueAt(int index) {,           return values.get(startOffset + index);,         }, ,         @Override,         public int count() {,           return (int) (endOffset - startOffset);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,682-739,[    return new RandomAccessOrds() {,       long startOffset;,       long offset;,       long endOffset;,       ,       @Override,       public long nextOrd() {,         if (offset == endOffset) {,           return NO_MORE_ORDS;,         } else {,           long ord = ordinals.get(offset);,           offset++;,           return ord;,         },       }, ,       @Override,       public void setDocument(int docID) {,         startOffset = offset = ordIndex.get(docID);,         endOffset = ordIndex.get(docID+1L);,       }, ,       @Override,       public BytesRef lookupOrd(long ord) {,         return binary.get(ord);,       }, ,       @Override,       public long getValueCount() {,         return valueCount;,       },       ,       @Override,       public long lookupTerm(BytesRef key) {,         if (binary instanceof CompressedBinaryDocValues) {,           return ((CompressedBinaryDocValues)binary).lookupTerm(key);,         } else {,           return super.lookupTerm(key);,         },       }, ,       @Override,       public TermsEnum termsEnum() {,         if (binary instanceof CompressedBinaryDocValues) {,           return ((CompressedBinaryDocValues)binary).getTermsEnum();,         } else {,           return super.termsEnum();,         },       }, ,       @Override,       public long ordAt(int index) {,         return ordinals.get(startOffset + index);,       }, ,       @Override,       public int cardinality() {,         return (int) (endOffset - startOffset);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/codecs/lucene50/Lucene50DocValuesProducer.java,,340-340,[    entry.minLength = meta.readVInt();],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java,read,155-155,[      return new FieldInfos(infos);],,read,115-115,[      FieldInfo infos[] = null;],,read,120-120,[                                     segmentInfo.getId(), segmentSuffix);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java,newLiveDocs,75-75,[    FixedBitSet fbs = (FixedBitSet) existing;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java,writeLiveDocs,112-112,[    FixedBitSet fbs = (FixedBitSet) bits;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/lucene50/Lucene50NormsConsumer.java,,297-300,[    writeNormsField(field, new Iterable<Number>() {,       @Override,       public Iterator<Number> iterator() {,         return new FilterIterator<Number, Number>(values.iterator()) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/lucene50/Lucene50PostingsFormat.java,copyFrom,481-481,[      IntBlockTermState other = (IntBlockTermState) _other;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/lucene50/Lucene50PostingsReader.java,decodeTerm,158-158,[    final IntBlockTermState termState = (IntBlockTermState) _termState;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/lucene50/Lucene50PostingsReader.java,docs,206-206,[    return docsEnum.reset(liveDocs, (IntBlockTermState) termState, flags);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/lucene50/Lucene50PostingsReader.java,docsAndPositions,230-230,[      return docsAndPositionsEnum.reset(liveDocs, (IntBlockTermState) termState);],,docsAndPositions,241-241,[      return everythingEnum.reset(liveDocs, (IntBlockTermState) termState, flags);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/lucene50/Lucene50PostingsWriter.java,encodeTerm,431-431,[    IntBlockTermState state = (IntBlockTermState)_state;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/lucene50/Lucene50PostingsWriter.java,finishTerm,317-317,[    IntBlockTermState state = (IntBlockTermState) _state;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java,addNumericFieldValues,125-136,[      switch(byteWidth) {,       case 1:,         data.writeByte((byte) v);,         break;,       case 2:,         data.writeShort((short) v);,         break;,       case 4:,         data.writeInt((int) v);,         break;,       case 8:,         data.writeLong(v);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java,,301-306,[    return new Iterable<Number>() {,       @Override,       public Iterator<Number> iterator() {,         final Iterator<Number> iter = counts.iterator();,         ,         return new Iterator<Number>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesProducer.java,,306-309,[        ret.numerics = new NumericDocValues() {,           @Override,           public long get(int idx) {,             return values[idx];],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesProducer.java,,322-325,[        ret.numerics = new NumericDocValues() {,           @Override,           public long get(int idx) {,             return values[idx];],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesProducer.java,,338-341,[        ret.numerics = new NumericDocValues() {,           @Override,           public long get(int idx) {,             return values[idx];],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesProducer.java,,354-357,[        ret.numerics = new NumericDocValues() {,           @Override,           public long get(int idx) {,             return values[idx];],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesProducer.java,,382-390,[    return new BinaryDocValues() {,       final BytesRef term = new BytesRef();, ,       @Override,       public BytesRef get(int docID) {,         term.bytes = bytes;,         term.offset = address[docID];,         term.length = address[docID+1] - term.offset;,         return term;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesProducer.java,,432-446,[    return new SortedDocValues() {, ,       @Override,       public int getOrd(int docID) {,         return (int) docToOrd.get(docID);,       }, ,       @Override,       public BytesRef lookupOrd(int ord) {,         return values.get(ord);,       }, ,       @Override,       public int getValueCount() {,         return count;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesProducer.java,,484-501,[      return new SortedNumericDocValues() {,         int valueStart;,         int valueLimit;,         ,         @Override,         public void setDocument(int doc) {,           valueStart = (int) docToAddress.get(doc);,           valueLimit = (int) docToAddress.get(doc+1);,         },         ,         @Override,         public long valueAt(int index) {,           return values.get(valueStart + index);,         },         ,         @Override,         public int count() {,           return valueLimit - valueStart;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/DirectDocValuesProducer.java,,538-575,[      return new RandomAccessOrds() {,         int ordStart;,         int ordUpto;,         int ordLimit;,         ,         @Override,         public long nextOrd() {,           if (ordUpto == ordLimit) {,             return NO_MORE_ORDS;,           } else {,             return ords.get(ordUpto++);,           },         },         ,         @Override,         public void setDocument(int docID) {,           ordStart = ordUpto = (int) docToOrdAddress.get(docID);,           ordLimit = (int) docToOrdAddress.get(docID+1);,         },         ,         @Override,         public BytesRef lookupOrd(long ord) {,           return values.get((int) ord);,         },         ,         @Override,         public long getValueCount() {,           return entry.values.count;,         },         ,         @Override,         public long ordAt(int index) {,           return ords.get(ordStart + index);,         },         ,         @Override,         public int cardinality() {,           return ordLimit - ordStart;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/memory/DirectPostingsFormat.java,seekExact,823-823,[        termOrd = (int) ((OrdTermState) state).ord;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/codecs/memory/FSTOrdTermsReader.java,,571-577,[        Frame() {,           this.arc = new FST.Arc<>();,           this.state = -1;,         }, ,         public String toString() {,           return "arc=" + arc + " state=" + state;],,
CORRECTNESS,EC_UNRELATED_TYPES,org/apache/lucene/codecs/memory/FSTTermsReader.java,seekCeil,529-529,[          return term.equals(target) ? SeekStatus.FOUND : SeekStatus.NOT_FOUND;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/codecs/memory/FSTTermsReader.java,,443-449,[        Frame() {,           this.fstArc = new FST.Arc<>();,           this.fsaState = -1;,         }, ,         public String toString() {,           return "arc=" + fstArc + " state=" + fsaState;],,
STYLE,SA_LOCAL_DOUBLE_ASSIGNMENT,org/apache/lucene/codecs/memory/FSTTermsWriter.java,write,171-171,[      TermsWriter termsWriter = termsWriter = new TermsWriter(fieldInfo);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesConsumer.java,,446-449,[      addBinaryField(field, new Iterable<BytesRef>() {,         @Override,         public Iterator<BytesRef> iterator() {,           return new SortedSetIterator(docToOrdCount.iterator(), ords.iterator());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,344-347,[        return new NumericDocValues() {,           @Override,           public long get(int docID) {,             return decode[(int)ordsReader.get(docID)];],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,359-362,[        return new NumericDocValues() {,           @Override,           public long get(int docID) {,             return minDelta + deltaReader.get(docID);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,383-386,[        return new NumericDocValues() {,           @Override,           public long get(int docID) {,             return min + mult * quotientReader.get(docID);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,414-420,[      return new BinaryDocValues() {,         final BytesRef term = new BytesRef();, ,         @Override,         public BytesRef get(int docID) {,           bytesReader.fillSlice(term, fixedLength * (long)docID, fixedLength);,           return term;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,424-432,[      return new BinaryDocValues() {,         final BytesRef term = new BytesRef();, ,         @Override,         public BytesRef get(int docID) {,           long startAddress = docID == 0 ? 0 : addresses.get(docID-1);,           long endAddress = addresses.get(docID);,           bytesReader.fillSlice(term, startAddress, (int) (endAddress - startAddress));,           return term;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,486-529,[    return new SortedDocValues() {,       final BytesRefBuilder term = new BytesRefBuilder();, ,       @Override,       public int getOrd(int docID) {,         return (int) docToOrd.get(docID);,       }, ,       @Override,       public BytesRef lookupOrd(int ord) {,         try {,           in.setPosition(0);,           fst.getFirstArc(firstArc);,           IntsRef output = Util.getByOutput(fst, ord, in, firstArc, scratchArc, scratchInts);,           return Util.toBytesRef(output, term);,         } catch (IOException bogus) {,           throw new RuntimeException(bogus);,         },       }, ,       @Override,       public int lookupTerm(BytesRef key) {,         try {,           InputOutput<Long> o = fstEnum.seekCeil(key);,           if (o == null) {,             return -getValueCount()-1;,           } else if (o.input.equals(key)) {,             return o.output.intValue();,           } else {,             return (int) -o.output-1;,           },         } catch (IOException bogus) {,           throw new RuntimeException(bogus);,         },       }, ,       @Override,       public int getValueCount() {,         return (int)entry.numOrds;,       }, ,       @Override,       public TermsEnum termsEnum() {,         return new FSTTermsEnum(fst);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,560-577,[        return new SortedNumericDocValues() {,           long startOffset;,           long endOffset;,           ,           @Override,           public void setDocument(int doc) {,             startOffset = (int) addr.get(doc);,             endOffset = (int) addr.get(doc+1L);,           }, ,           @Override,           public long valueAt(int index) {,             return longValues.get(startOffset + index);,           }, ,           @Override,           public int count() {,             return (int) (endOffset - startOffset);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,581-598,[        return new SortedNumericDocValues() {,           int startOffset;,           int endOffset;,         ,           @Override,           public void setDocument(int doc) {,             startOffset = (int) addr.get(doc);,             endOffset = (int) addr.get(doc+1);,           }, ,           @Override,           public long valueAt(int index) {,             return values.get(startOffset + index);,           }, ,           @Override,           public int count() {,             return (endOffset - startOffset);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,638-695,[    return new SortedSetDocValues() {,       final BytesRefBuilder term = new BytesRefBuilder();,       BytesRef ref;,       long currentOrd;, ,       @Override,       public long nextOrd() {,         if (input.eof()) {,           return NO_MORE_ORDS;,         } else {,           currentOrd += input.readVLong();,           return currentOrd;,         },       },       ,       @Override,       public void setDocument(int docID) {,         ref = docToOrds.get(docID);,         input.reset(ref.bytes, ref.offset, ref.length);,         currentOrd = 0;,       }, ,       @Override,       public BytesRef lookupOrd(long ord) {,         try {,           in.setPosition(0);,           fst.getFirstArc(firstArc);,           IntsRef output = Util.getByOutput(fst, ord, in, firstArc, scratchArc, scratchInts);,           return Util.toBytesRef(output, term);,         } catch (IOException bogus) {,           throw new RuntimeException(bogus);,         },       }, ,       @Override,       public long lookupTerm(BytesRef key) {,         try {,           InputOutput<Long> o = fstEnum.seekCeil(key);,           if (o == null) {,             return -getValueCount()-1;,           } else if (o.input.equals(key)) {,             return o.output.intValue();,           } else {,             return -o.output-1;,           },         } catch (IOException bogus) {,           throw new RuntimeException(bogus);,         },       }, ,       @Override,       public long getValueCount() {,         return entry.numOrds;,       }, ,       @Override,       public TermsEnum termsEnum() {,         return new FSTTermsEnum(fst);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java,,823-823,[    final BytesRefBuilder scratchBytes = new BytesRefBuilder();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/memory/MemoryPostingsFormat.java,,1006-1051,[    return new FieldsProducer() {,       @Override,       public Iterator<String> iterator() {,         return Collections.unmodifiableSet(fields.keySet()).iterator();,       }, ,       @Override,       public Terms terms(String field) {,         return fields.get(field);,       },       ,       @Override,       public int size() {,         return fields.size();,       }, ,       @Override,       public void close() {,         // Drop ref to FST:,         for(TermsReader termsReader : fields.values()) {,           termsReader.fst = null;,         },       }, ,       @Override,       public long ramBytesUsed() {,         long sizeInBytes = 0;,         for(Map.Entry<String,TermsReader> entry: fields.entrySet()) {,           sizeInBytes += (entry.getKey().length() * RamUsageEstimator.NUM_BYTES_CHAR);,           sizeInBytes += entry.getValue().ramBytesUsed();,         },         return sizeInBytes;,       }, ,       @Override,       public Iterable<Accountable> getChildResources() {,         return Accountables.namedAccountables("field", fields);,       }, ,       @Override,       public String toString() {,         return "MemoryPostings(fields=" + fields.size() + ")";,       }, ,       @Override,       public void checkIntegrity() throws IOException {}],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/memory/MemoryPostingsFormat.java,decodeMetaData,760-760,[        buffer.reset(current.output.bytes, current.output.offset, current.output.length);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/memory/MemoryPostingsFormat.java,term,847-847,[      return current.input;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/codecs/memory/MemoryPostingsFormat.java,,125-125,[      this.acceptableOverheadRatio = acceptableOverheadRatio;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/codecs/memory/MemoryPostingsFormat.java,,124-124,[      this.doPackFST = doPackFST;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java,,63-63,[  private final String SEED_EXT = "sd";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java,,73-76,[      this.seedRandom = new Random(0L) {,         @Override,         protected int next(int arg0) {,           throw new IllegalStateException("Please use MockRandomPostingsFormat(Random)");],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java,,496-496,[    int posUpto = 0;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java,docID,532-532,[      return current.docID;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java,freq,527-527,[      return current.positions.length;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java,,118-118,[      this.field = field;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java,addPosition,397-397,[      current.positions[posUpto] = position;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java,finishDoc,409-409,[      assert posUpto == current.positions.length;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java,startDoc,390-390,[      term.docs.add(current);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat.java,getCompoundReader,69-69,[    long tablePos = -1; ],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat.java,,105-155,[    return new Directory() {,       ,       private int getIndex(String name) throws IOException {,         int index = Arrays.binarySearch(fileNames, name);,         if (index < 0) {,           throw new FileNotFoundException("No sub-file found (fileName=" + name + " files: " + Arrays.toString(fileNames) + ")");,         },         return index;,       },       ,       @Override,       public String[] listAll() throws IOException {,         ensureOpen();,         return fileNames.clone();,       },       ,       @Override,       public long fileLength(String name) throws IOException {,         ensureOpen();,         int index = getIndex(name);,         return endOffsets[index] - startOffsets[index];,       },       ,       @Override,       public IndexInput openInput(String name, IOContext context) throws IOException {,         ensureOpen();,         int index = getIndex(name);,         return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);,       },       ,       @Override,       public void close() throws IOException {,         in.close();,       },       ,       // write methods: disabled,       ,       @Override,       public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); },       ,       @Override,       public void sync(Collection<String> names) { throw new UnsupportedOperationException(); },       ,       @Override,       public void deleteFile(String name) { throw new UnsupportedOperationException(); },       ,       @Override,       public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); },       ,       @Override,       public Lock makeLock(String name) { throw new UnsupportedOperationException(); }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,getNumeric,158-158,[    assert field != null: "field=" + fieldInfo.name + " fields=" + fields;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,get,174-174,[          in.seek(field.dataStartFilePointer + (1+field.pattern.length()+2)*docID);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,get,200-200,[          in.seek(field.dataStartFilePointer + (1+field.pattern.length()+2)*index);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,get,237-237,[          in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength+2)*docID);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,get,267-267,[          in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength+2)*index);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,getOrd,316-316,[          in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + docID * (1 + field.ordPattern.length()));],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,lookupOrd,334-334,[          in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,,362-386,[    return new SortedNumericDocValues() {,       long values[];, ,       @Override,       public void setDocument(int doc) {,         String csv = binary.get(doc).utf8ToString();,         if (csv.length() == 0) {,           values = new long[0];,         } else {,           String s[] = csv.split(",");,           values = new long[s.length];,           for (int i = 0; i < values.length; i++) {,             values[i] = Long.parseLong(s[i]);,           },         },       }, ,       @Override,       public long valueAt(int index) {,         return values[index];,       }, ,       @Override,       public int count() {,         return values.length;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,count,386-386,[        return values.length;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java,setDocument,423-423,[          in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + docID * (1 + field.ordPattern.length()));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/codecs/simpletext/SimpleTextDocValuesWriter.java,,278-286,[    doAddBinary(field, new Iterable<BytesRef>() {     ,       @Override,       public Iterator<BytesRef> iterator() {,         final StringBuilder builder = new StringBuilder();,         final BytesRefBuilder scratch = new BytesRefBuilder();,         final Iterator<Number> counts = docToValueCount.iterator();,         final Iterator<Number> numbers = values.iterator();,         ,         return new Iterator<BytesRef>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/codecs/simpletext/SimpleTextFieldsReader.java,,337-493,[  private class SimpleTextDocsAndPositionsEnum extends DocsAndPositionsEnum {,     private final IndexInput inStart;,     private final IndexInput in;,     private int docID = -1;,     private int tf;,     private Bits liveDocs;,     private final BytesRefBuilder scratch = new BytesRefBuilder();,     private final BytesRefBuilder scratch2 = new BytesRefBuilder();,     private final CharsRefBuilder scratchUTF16 = new CharsRefBuilder();,     private final CharsRefBuilder scratchUTF16_2 = new CharsRefBuilder();,     private BytesRef payload;,     private long nextDocStart;,     private boolean readOffsets;,     private boolean readPositions;,     private int startOffset;,     private int endOffset;,     private int cost;, ,     public SimpleTextDocsAndPositionsEnum() {,       this.inStart = SimpleTextFieldsReader.this.in;,       this.in = inStart.clone();,     }, ,     public boolean canReuse(IndexInput in) {,       return in == inStart;,     }, ,     public SimpleTextDocsAndPositionsEnum reset(long fp, Bits liveDocs, IndexOptions indexOptions, int docFreq) {,       this.liveDocs = liveDocs;,       nextDocStart = fp;,       docID = -1;,       readPositions = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;,       readOffsets = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;,       if (!readOffsets) {,         startOffset = -1;,         endOffset = -1;,       },       cost = docFreq;,       return this;,     }, ,     @Override,     public int docID() {,       return docID;,     }, ,     @Override,     public int freq() throws IOException {,       return tf;,     }, ,     @Override,     public int nextDoc() throws IOException {,       boolean first = true;,       in.seek(nextDocStart);,       long posStart = 0;,       while(true) {,         final long lineStart = in.getFilePointer();,         SimpleTextUtil.readLine(in, scratch);,         //System.out.println("NEXT DOC: " + scratch.utf8ToString());,         if (StringHelper.startsWith(scratch.get(), DOC)) {,           if (!first && (liveDocs == null || liveDocs.get(docID))) {,             nextDocStart = lineStart;,             in.seek(posStart);,             return docID;,           },           scratchUTF16.copyUTF8Bytes(scratch.bytes(), DOC.length, scratch.length()-DOC.length);,           docID = ArrayUtil.parseInt(scratchUTF16.chars(), 0, scratchUTF16.length());,           tf = 0;,           first = false;,         } else if (StringHelper.startsWith(scratch.get(), FREQ)) {,           scratchUTF16.copyUTF8Bytes(scratch.bytes(), FREQ.length, scratch.length()-FREQ.length);,           tf = ArrayUtil.parseInt(scratchUTF16.chars(), 0, scratchUTF16.length());,           posStart = in.getFilePointer();,         } else if (StringHelper.startsWith(scratch.get(), POS)) {,           // skip,         } else if (StringHelper.startsWith(scratch.get(), START_OFFSET)) {,           // skip,         } else if (StringHelper.startsWith(scratch.get(), END_OFFSET)) {,           // skip,         } else if (StringHelper.startsWith(scratch.get(), PAYLOAD)) {,           // skip,         } else {,           assert StringHelper.startsWith(scratch.get(), TERM) || StringHelper.startsWith(scratch.get(), FIELD) || StringHelper.startsWith(scratch.get(), END);,           if (!first && (liveDocs == null || liveDocs.get(docID))) {,             nextDocStart = lineStart;,             in.seek(posStart);,             return docID;,           },           return docID = NO_MORE_DOCS;,         },       },     }, ,     @Override,     public int advance(int target) throws IOException {,       // Naive -- better to index skip data,       return slowAdvance(target);,     }, ,     @Override,     public int nextPosition() throws IOException {,       final int pos;,       if (readPositions) {,         SimpleTextUtil.readLine(in, scratch);,         assert StringHelper.startsWith(scratch.get(), POS): "got line=" + scratch.get().utf8ToString();,         scratchUTF16_2.copyUTF8Bytes(scratch.bytes(), POS.length, scratch.length()-POS.length);,         pos = ArrayUtil.parseInt(scratchUTF16_2.chars(), 0, scratchUTF16_2.length());,       } else {,         pos = -1;,       }, ,       if (readOffsets) {,         SimpleTextUtil.readLine(in, scratch);,         assert StringHelper.startsWith(scratch.get(), START_OFFSET): "got line=" + scratch.get().utf8ToString();,         scratchUTF16_2.copyUTF8Bytes(scratch.bytes(), START_OFFSET.length, scratch.length()-START_OFFSET.length);,         startOffset = ArrayUtil.parseInt(scratchUTF16_2.chars(), 0, scratchUTF16_2.length());,         SimpleTextUtil.readLine(in, scratch);,         assert StringHelper.startsWith(scratch.get(), END_OFFSET): "got line=" + scratch.get().utf8ToString();,         scratchUTF16_2.grow(scratch.length()-END_OFFSET.length);,         scratchUTF16_2.copyUTF8Bytes(scratch.bytes(), END_OFFSET.length, scratch.length()-END_OFFSET.length);,         endOffset = ArrayUtil.parseInt(scratchUTF16_2.chars(), 0, scratchUTF16_2.length());,       }, ,       final long fp = in.getFilePointer();,       SimpleTextUtil.readLine(in, scratch);,       if (StringHelper.startsWith(scratch.get(), PAYLOAD)) {,         final int len = scratch.length() - PAYLOAD.length;,         scratch2.grow(len);,         System.arraycopy(scratch.bytes(), PAYLOAD.length, scratch2.bytes(), 0, len);,         scratch2.setLength(len);,         payload = scratch2.get();,       } else {,         payload = null;,         in.seek(fp);,       },       return pos;,     }, ,     @Override,     public int startOffset() throws IOException {,       return startOffset;,     }, ,     @Override,     public int endOffset() throws IOException {,       return endOffset;,     }, ,     @Override,     public BytesRef getPayload() {,       return payload;,     },     ,     @Override,     public long cost() {,       return cost;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/codecs/simpletext/SimpleTextFieldsReader.java,,238-333,[  private class SimpleTextDocsEnum extends DocsEnum {,     private final IndexInput inStart;,     private final IndexInput in;,     private boolean omitTF;,     private int docID = -1;,     private int tf;,     private Bits liveDocs;,     private final BytesRefBuilder scratch = new BytesRefBuilder();,     private final CharsRefBuilder scratchUTF16 = new CharsRefBuilder();,     private int cost;,     ,     public SimpleTextDocsEnum() {,       this.inStart = SimpleTextFieldsReader.this.in;,       this.in = this.inStart.clone();,     }, ,     public boolean canReuse(IndexInput in) {,       return in == inStart;,     }, ,     public SimpleTextDocsEnum reset(long fp, Bits liveDocs, boolean omitTF, int docFreq) throws IOException {,       this.liveDocs = liveDocs;,       in.seek(fp);,       this.omitTF = omitTF;,       docID = -1;,       tf = 1;,       cost = docFreq;,       return this;,     }, ,     @Override,     public int docID() {,       return docID;,     }, ,     @Override,     public int freq() throws IOException {,       return tf;,     }, ,     @Override,     public int nextDoc() throws IOException {,       if (docID == NO_MORE_DOCS) {,         return docID;,       },       boolean first = true;,       int termFreq = 0;,       while(true) {,         final long lineStart = in.getFilePointer();,         SimpleTextUtil.readLine(in, scratch);,         if (StringHelper.startsWith(scratch.get(), DOC)) {,           if (!first && (liveDocs == null || liveDocs.get(docID))) {,             in.seek(lineStart);,             if (!omitTF) {,               tf = termFreq;,             },             return docID;,           },           scratchUTF16.copyUTF8Bytes(scratch.bytes(), DOC.length, scratch.length()-DOC.length);,           docID = ArrayUtil.parseInt(scratchUTF16.chars(), 0, scratchUTF16.length());,           termFreq = 0;,           first = false;,         } else if (StringHelper.startsWith(scratch.get(), FREQ)) {,           scratchUTF16.copyUTF8Bytes(scratch.bytes(), FREQ.length, scratch.length()-FREQ.length);,           termFreq = ArrayUtil.parseInt(scratchUTF16.chars(), 0, scratchUTF16.length());,         } else if (StringHelper.startsWith(scratch.get(), POS)) {,           // skip termFreq++;,         } else if (StringHelper.startsWith(scratch.get(), START_OFFSET)) {,           // skip,         } else if (StringHelper.startsWith(scratch.get(), END_OFFSET)) {,           // skip,         } else if (StringHelper.startsWith(scratch.get(), PAYLOAD)) {,           // skip,         } else {,           assert StringHelper.startsWith(scratch.get(), TERM) || StringHelper.startsWith(scratch.get(), FIELD) || StringHelper.startsWith(scratch.get(), END): "scratch=" + scratch.get().utf8ToString();,           if (!first && (liveDocs == null || liveDocs.get(docID))) {,             in.seek(lineStart);,             if (!omitTF) {,               tf = termFreq;,             },             return docID;,           },           return docID = NO_MORE_DOCS;,         },       },     }, ,     @Override,     public int advance(int target) throws IOException {,       // Naive -- better to index skip data,       return slowAdvance(target);,     },     ,     @Override,     public long cost() {,       return cost;],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/lucene/codecs/simpletext/SimpleTextFieldsReader.java,,170-170,[      assert !ended;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/codecs/simpletext/SimpleTextFieldsReader.java,,503-503,[      this.docFreq = docFreq;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/codecs/simpletext/SimpleTextFieldsReader.java,,502-502,[      this.docsStart = docsStart;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/simpletext/SimpleTextLiveDocsFormat.java,newLiveDocs,63-63,[    final SimpleTextBits bits = (SimpleTextBits) existing;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/codecs/simpletext/SimpleTextLiveDocsFormat.java,writeLiveDocs,113-113,[    BitSet set = ((SimpleTextBits) bits).bits;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat.java,write,208-208,[      int numFiles = files == null ? 0 : files.size();],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/codecs/simpletext/SimpleTextStoredFieldsReader.java,clone,178-181,[    if (in == null) {,       throw new AlreadyClosedException("this FieldsReader is closed");,     },     return new SimpleTextStoredFieldsReader(offsets, in.clone(), fieldInfos);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/codecs/simpletext/SimpleTextStoredFieldsWriter.java,,65-65,[    this.directory = directory;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/codecs/simpletext/SimpleTextStoredFieldsWriter.java,,66-66,[    this.segment = segment;],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/codecs/simpletext/SimpleTextTermVectorsReader.java,clone,214-217,[    if (in == null) {,       throw new AlreadyClosedException("this TermVectorsReader is closed");,     },     return new SimpleTextTermVectorsReader(offsets, in.clone());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/codecs/simpletext/SimpleTextTermVectorsReader.java,,247-263,[    SimpleTVFields(SortedMap<String,SimpleTVTerms> fields) {,       this.fields = fields;,     }, ,     @Override,     public Iterator<String> iterator() {,       return Collections.unmodifiableSet(fields.keySet()).iterator();,     }, ,     @Override,     public Terms terms(String field) throws IOException {,       return fields.get(field);,     }, ,     @Override,     public int size() {,       return fields.size();],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java,equals,238-254,[    if (other == this) {,       return true;,     },     ,     if (other instanceof CharTermAttributeImpl) {,       final CharTermAttributeImpl o = ((CharTermAttributeImpl) other);,       if (termLength != o.termLength),         return false;,       for(int i=0;i<termLength;i++) {,         if (termBuffer[i] != o.termBuffer[i]) {,           return false;,         },       },       return true;,     },     ,     return false;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java,equals,238-254,[    if (other == this) {,       return true;,     },     ,     if (other instanceof CharTermAttributeImpl) {,       final CharTermAttributeImpl o = ((CharTermAttributeImpl) other);,       if (termLength != o.termLength),         return false;,       for(int i=0;i<termLength;i++) {,         if (termBuffer[i] != o.termBuffer[i]) {,           return false;,         },       },       return true;,     },     ,     return false;],,
STYLE,NP_DEREFERENCE_OF_READLINE_VALUE,org/apache/lucene/demo/SearchFiles.java,doPagingSearch,212-212,[          if (line.length() == 0 || line.charAt(0)=='q') {],,doPagingSearch,166-166,[        if (line.length() == 0 || line.charAt(0) == 'n') {],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/demo/facet/RangeFacetsExample.java,index,69-69,[      long then = nowSec - i * 1000;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/lucene/demo/xmlparser/FormBasedXmlQueryDemo.java,openExampleIndex,139-139,[    BufferedReader br = new BufferedReader(new InputStreamReader(dataIn, StandardCharsets.UTF_8));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/demo/xmlparser/FormBasedXmlQueryDemo.java,doPost,128-128,[    catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/demo/xmlparser/FormBasedXmlQueryDemo.java,init,88-88,[    } catch (Exception e) {],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/document/DateTools.java,round,167-169,[        calInstance.set(Calendar.MONTH, 0);,       case MONTH:,         calInstance.set(Calendar.DAY_OF_MONTH, 1);],,round,169-171,[        calInstance.set(Calendar.DAY_OF_MONTH, 1);,       case DAY:,         calInstance.set(Calendar.HOUR_OF_DAY, 0);],,round,171-173,[        calInstance.set(Calendar.HOUR_OF_DAY, 0);,       case HOUR:,         calInstance.set(Calendar.MINUTE, 0);],,round,173-175,[        calInstance.set(Calendar.MINUTE, 0);,       case MINUTE:,         calInstance.set(Calendar.SECOND, 0);],,round,175-177,[        calInstance.set(Calendar.SECOND, 0);,       case SECOND:,         calInstance.set(Calendar.MILLISECOND, 0);],,round,177-180,[        calInstance.set(Calendar.MILLISECOND, 0);,       case MILLISECOND:,         // don't cut off anything,         break;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/document/Document.java,,312-315,[    return new FilterIterator<StorableField, Field>(fields.iterator()) {,       @Override,       protected boolean predicateFunction(Field field) {,         return field.type.stored() || field.type.docValuesType() != DocValuesType.NONE;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/document/Document.java,,321-324,[    return new FilterIterator<IndexableField, Field>(fields.iterator()) {,       @Override,       protected boolean predicateFunction(Field field) {,         return field.type.indexOptions() != IndexOptions.NONE;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/expressions/js/JavascriptCompiler.java,getAntlrComputedExpressionTree,493-493,[        throw (ParseException)exception.getCause();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptCompiler.java,unusedTestCompile,160-160,[    double ret = f.doubleVal(2);],,
CORRECTNESS,NP_ALWAYS_NULL,org/apache/lucene/expressions/js/JavascriptCompiler.java,unusedTestCompile,160-160,[    double ret = f.doubleVal(2);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/expressions/js/JavascriptCompiler.java,unusedTestCompile,160-160,[    double ret = f.doubleVal(2);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/expressions/js/JavascriptCompiler.java,unusedTestCompile,159-161,[    FunctionValues f = null;,     double ret = f.doubleVal(2);,   }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptLexer.java,mARRAY,759-775,[      switch (alt3) {,         case 1 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:345:7: '[' STRING ']',           {,           match('['); ,           mSTRING(); , ,           match(']'); ,           },           break;,         case 2 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:346:7: '[' DECIMALINTEGER ']',           {,           match('['); ,           mDECIMALINTEGER(); , ,           match(']'); ],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptLexer.java,mDECIMAL,1183-1187,[          switch (alt12) {,             case 1 :,               // src/java/org/apache/lucene/expressions/js/Javascript.g:378:43: EXPONENT,               {,               mEXPONENT(); ],,mDECIMAL,1240-1244,[          switch (alt14) {,             case 1 :,               // src/java/org/apache/lucene/expressions/js/Javascript.g:379:28: EXPONENT,               {,               mEXPONENT(); ],,mDECIMAL,1264-1268,[          switch (alt15) {,             case 1 :,               // src/java/org/apache/lucene/expressions/js/Javascript.g:380:22: EXPONENT,               {,               mEXPONENT(); ],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptLexer.java,mHEX,1381-1392,[      switch (alt18) {,         case 1 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:388:8: '0x',           {,           match("0x"); , ,           },           break;,         case 2 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:388:13: '0X',           {,           match("0X"); ],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptLexer.java,mTokens,1937-2158,[    switch (alt24) {,       case 1 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:10: AT_ADD,         {,         mAT_ADD(); , ,         },         break;,       case 2 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:17: AT_BIT_AND,         {,         mAT_BIT_AND(); , ,         },         break;,       case 3 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:28: AT_BIT_NOT,         {,         mAT_BIT_NOT(); , ,         },         break;,       case 4 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:39: AT_BIT_OR,         {,         mAT_BIT_OR(); , ,         },         break;,       case 5 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:49: AT_BIT_SHL,         {,         mAT_BIT_SHL(); , ,         },         break;,       case 6 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:60: AT_BIT_SHR,         {,         mAT_BIT_SHR(); , ,         },         break;,       case 7 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:71: AT_BIT_SHU,         {,         mAT_BIT_SHU(); , ,         },         break;,       case 8 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:82: AT_BIT_XOR,         {,         mAT_BIT_XOR(); , ,         },         break;,       case 9 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:93: AT_BOOL_AND,         {,         mAT_BOOL_AND(); , ,         },         break;,       case 10 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:105: AT_BOOL_NOT,         {,         mAT_BOOL_NOT(); , ,         },         break;,       case 11 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:117: AT_BOOL_OR,         {,         mAT_BOOL_OR(); , ,         },         break;,       case 12 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:128: AT_COLON,         {,         mAT_COLON(); , ,         },         break;,       case 13 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:137: AT_COMMA,         {,         mAT_COMMA(); , ,         },         break;,       case 14 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:146: AT_COMP_EQ,         {,         mAT_COMP_EQ(); , ,         },         break;,       case 15 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:157: AT_COMP_GT,         {,         mAT_COMP_GT(); , ,         },         break;,       case 16 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:168: AT_COMP_GTE,         {,         mAT_COMP_GTE(); , ,         },         break;,       case 17 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:180: AT_COMP_LT,         {,         mAT_COMP_LT(); , ,         },         break;,       case 18 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:191: AT_COMP_LTE,         {,         mAT_COMP_LTE(); , ,         },         break;,       case 19 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:203: AT_COMP_NEQ,         {,         mAT_COMP_NEQ(); , ,         },         break;,       case 20 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:215: AT_COND_QUE,         {,         mAT_COND_QUE(); , ,         },         break;,       case 21 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:227: AT_DIVIDE,         {,         mAT_DIVIDE(); , ,         },         break;,       case 22 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:237: AT_DOT,         {,         mAT_DOT(); , ,         },         break;,       case 23 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:244: AT_LPAREN,         {,         mAT_LPAREN(); , ,         },         break;,       case 24 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:254: AT_MODULO,         {,         mAT_MODULO(); , ,         },         break;,       case 25 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:264: AT_MULTIPLY,         {,         mAT_MULTIPLY(); , ,         },         break;,       case 26 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:276: AT_RPAREN,         {,         mAT_RPAREN(); , ,         },         break;,       case 27 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:286: AT_SUBTRACT,         {,         mAT_SUBTRACT(); , ,         },         break;,       case 28 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:298: VARIABLE,         {,         mVARIABLE(); , ,         },         break;,       case 29 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:307: WS,         {,         mWS(); , ,         },         break;,       case 30 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:310: DECIMAL,         {,         mDECIMAL(); , ,         },         break;,       case 31 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:318: OCTAL,         {,         mOCTAL(); , ,         },         break;,       case 32 :,         // src/java/org/apache/lucene/expressions/js/Javascript.g:1:324: HEX,         {,         mHEX(); ],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/expressions/js/JavascriptLexer.java,,2208-2221,[    public DFA16(BaseRecognizer recognizer) {,       this.recognizer = recognizer;,       this.decisionNumber = 16;,       this.eot = DFA16_eot;,       this.eof = DFA16_eof;,       this.min = DFA16_min;,       this.max = DFA16_max;,       this.accept = DFA16_accept;,       this.special = DFA16_special;,       this.transition = DFA16_transition;,     },     @Override,     public String getDescription() {,       return "377:1: DECIMAL : ( DECIMALINTEGER AT_DOT ( DECIMALDIGIT )* ( EXPONENT )? | AT_DOT ( DECIMALDIGIT )+ ( EXPONENT )? | DECIMALINTEGER ( EXPONENT )? );";],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,postfix,1587-1587,[          RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,unary_operator,1436-1436,[          RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,arguments,1781-1781,[      AT_LPAREN54=(Token)match(input,AT_LPAREN,FOLLOW_AT_LPAREN_in_arguments1237); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,arguments,1831-1831,[      AT_RPAREN58=(Token)match(input,AT_RPAREN,FOLLOW_AT_RPAREN_in_arguments1253); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,conditional,322-322,[          AT_COLON6=(Token)match(input,AT_COLON,FOLLOW_AT_COLON_in_conditional765); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,expression,243-243,[      EOF2=(Token)match(input,EOF,FOLLOW_EOF_in_expression739); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,primary,1718-1718,[          AT_LPAREN51=(Token)match(input,AT_LPAREN,FOLLOW_AT_LPAREN_in_primary1214); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,primary,1725-1725,[          AT_RPAREN53=(Token)match(input,AT_RPAREN,FOLLOW_AT_RPAREN_in_primary1219); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,unary,1324-1324,[          AT_ADD39=(Token)match(input,AT_ADD,FOLLOW_AT_ADD_in_unary1092); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,additive,1111-1111,[          set33=input.LT(1);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,arguments,1811-1811,[              AT_COMMA56=(Token)match(input,AT_COMMA,FOLLOW_AT_COMMA_in_arguments1244); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,equality,832-832,[          set24=input.LT(1);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,multiplicative,1204-1204,[          set36=input.LT(1);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,relational,925-925,[          set27=input.LT(1);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/expressions/js/JavascriptParser.java,shift,1018-1018,[          set30=input.LT(1);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/expressions/js/JavascriptParser.java,postfix,1586-1586,[          retval.tree = root_0;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/expressions/js/JavascriptParser.java,unary_operator,1435-1435,[          retval.tree = root_0;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/expressions/js/JavascriptParser.java,<init>,1587-1587,[          RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/expressions/js/JavascriptParser.java,<init>,1436-1436,[          RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptParser.java,conditional,308-327,[      switch (alt1) {,         case 1 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:255:19: AT_COND_QUE ^ conditional AT_COLON ! conditional,           {,           AT_COND_QUE4=(Token)match(input,AT_COND_QUE,FOLLOW_AT_COND_QUE_in_conditional760); ,           AT_COND_QUE4_tree = (CommonTree)adaptor.create(AT_COND_QUE4);,           root_0 = (CommonTree)adaptor.becomeRoot(AT_COND_QUE4_tree, root_0);, ,           pushFollow(FOLLOW_conditional_in_conditional763);,           conditional5=conditional();,           state._fsp--;, ,           adaptor.addChild(root_0, conditional5.getTree());, ,           AT_COLON6=(Token)match(input,AT_COLON,FOLLOW_AT_COLON_in_conditional765); ,           pushFollow(FOLLOW_conditional_in_conditional768);,           conditional7=conditional();,           state._fsp--;, ,           adaptor.addChild(root_0, conditional7.getTree());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptParser.java,postfix,1553-1609,[      switch (alt14) {,         case 1 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:311:7: primary,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           pushFollow(FOLLOW_primary_in_postfix1160);,           primary46=primary();,           state._fsp--;, ,           adaptor.addChild(root_0, primary46.getTree());, ,           },           break;,         case 2 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:312:7: VARIABLE arguments,           {,           VARIABLE47=(Token)match(input,VARIABLE,FOLLOW_VARIABLE_in_postfix1168);  ,           stream_VARIABLE.add(VARIABLE47);, ,           pushFollow(FOLLOW_arguments_in_postfix1170);,           arguments48=arguments();,           state._fsp--;, ,           stream_arguments.add(arguments48.getTree());,           // AST REWRITE,           // elements: VARIABLE, arguments,           // token labels: ,           // rule labels: retval,           // token list labels: ,           // rule list labels: ,           // wildcard labels: ,           retval.tree = root_0;,           RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);, ,           root_0 = (CommonTree)adaptor.nil();,           // 312:26: -> ^( AT_CALL VARIABLE ( arguments )? ),           {,             // src/java/org/apache/lucene/expressions/js/Javascript.g:312:29: ^( AT_CALL VARIABLE ( arguments )? ),             {,             CommonTree root_1 = (CommonTree)adaptor.nil();,             root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(AT_CALL, "AT_CALL"), root_1);,             adaptor.addChild(root_1, stream_VARIABLE.nextNode());,             // src/java/org/apache/lucene/expressions/js/Javascript.g:312:48: ( arguments )?,             if ( stream_arguments.hasNext() ) {,               adaptor.addChild(root_1, stream_arguments.nextTree());,             },             stream_arguments.reset();, ,             adaptor.addChild(root_0, root_1);,             }, ,           }, , ,           retval.tree = root_0;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptParser.java,primary,1685-1725,[      switch (alt15) {,         case 1 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:316:7: VARIABLE,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           VARIABLE49=(Token)match(input,VARIABLE,FOLLOW_VARIABLE_in_primary1198); ,           VARIABLE49_tree = (CommonTree)adaptor.create(VARIABLE49);,           adaptor.addChild(root_0, VARIABLE49_tree);, ,           },           break;,         case 2 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:317:7: numeric,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           pushFollow(FOLLOW_numeric_in_primary1206);,           numeric50=numeric();,           state._fsp--;, ,           adaptor.addChild(root_0, numeric50.getTree());, ,           },           break;,         case 3 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:318:7: AT_LPAREN ! conditional AT_RPAREN !,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           AT_LPAREN51=(Token)match(input,AT_LPAREN,FOLLOW_AT_LPAREN_in_primary1214); ,           pushFollow(FOLLOW_conditional_in_primary1217);,           conditional52=conditional();,           state._fsp--;, ,           adaptor.addChild(root_0, conditional52.getTree());, ,           AT_RPAREN53=(Token)match(input,AT_RPAREN,FOLLOW_AT_RPAREN_in_primary1219); ],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptParser.java,unary,1303-1348,[      switch (alt12) {,         case 1 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:299:7: postfix,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           pushFollow(FOLLOW_postfix_in_unary1084);,           postfix38=postfix();,           state._fsp--;, ,           adaptor.addChild(root_0, postfix38.getTree());, ,           },           break;,         case 2 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:300:7: AT_ADD ! unary,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           AT_ADD39=(Token)match(input,AT_ADD,FOLLOW_AT_ADD_in_unary1092); ,           pushFollow(FOLLOW_unary_in_unary1095);,           unary40=unary();,           state._fsp--;, ,           adaptor.addChild(root_0, unary40.getTree());, ,           },           break;,         case 3 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:301:7: unary_operator ^ unary,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           pushFollow(FOLLOW_unary_operator_in_unary1103);,           unary_operator41=unary_operator();,           state._fsp--;, ,           root_0 = (CommonTree)adaptor.becomeRoot(unary_operator41.getTree(), root_0);,           pushFollow(FOLLOW_unary_in_unary1106);,           unary42=unary();,           state._fsp--;, ,           adaptor.addChild(root_0, unary42.getTree());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/expressions/js/JavascriptParser.java,unary_operator,1421-1469,[      switch (alt13) {,         case 1 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:305:7: AT_SUBTRACT,           {,           AT_SUBTRACT43=(Token)match(input,AT_SUBTRACT,FOLLOW_AT_SUBTRACT_in_unary_operator1123);  ,           stream_AT_SUBTRACT.add(AT_SUBTRACT43);, ,           // AST REWRITE,           // elements: ,           // token labels: ,           // rule labels: retval,           // token list labels: ,           // rule list labels: ,           // wildcard labels: ,           retval.tree = root_0;,           RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);, ,           root_0 = (CommonTree)adaptor.nil();,           // 305:19: -> AT_NEGATE,           {,             adaptor.addChild(root_0, (CommonTree)adaptor.create(AT_NEGATE, "AT_NEGATE"));,           }, , ,           retval.tree = root_0;, ,           },           break;,         case 2 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:306:7: AT_BIT_NOT,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           AT_BIT_NOT44=(Token)match(input,AT_BIT_NOT,FOLLOW_AT_BIT_NOT_in_unary_operator1135); ,           AT_BIT_NOT44_tree = (CommonTree)adaptor.create(AT_BIT_NOT44);,           adaptor.addChild(root_0, AT_BIT_NOT44_tree);, ,           },           break;,         case 3 :,           // src/java/org/apache/lucene/expressions/js/Javascript.g:307:7: AT_BOOL_NOT,           {,           root_0 = (CommonTree)adaptor.nil();, , ,           AT_BOOL_NOT45=(Token)match(input,AT_BOOL_NOT,FOLLOW_AT_BOOL_NOT_in_unary_operator1143); ,           AT_BOOL_NOT45_tree = (CommonTree)adaptor.create(AT_BOOL_NOT45);,           adaptor.addChild(root_0, AT_BOOL_NOT45_tree);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/expressions/js/VariableContext.java,,67-67,[    integer = i;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/expressions/js/VariableContext.java,,66-66,[    text = s;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/expressions/js/VariableContext.java,,65-65,[    type = c;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/facet/DrillSidewaysScorer.java,compareTo,684-697,[      if (disi == null) {,         if (other.disi == null) {,           return 0;,         } else {,           return 1;,         },       } else if (other.disi == null) {,         return -1;,       } else if (disi.cost() < other.disi.cost()) {,         return -1;,       } else if (disi.cost() > other.disi.cost()) {,         return 1;,       } else {,         return 0;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/facet/DrillSidewaysScorer.java,score,84-84,[      dim.sidewaysLeafCollector = dim.sidewaysCollector.getLeafCollector(context);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/facet/FacetResult.java,<init>,47-47,[    this.labelValues = labelValues;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/facet/FacetResult.java,<init>,45-45,[    this.path = path;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/facet/FacetsCollector.java,<init>,100-100,[      this.scores = scores;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/facet/range/DoubleRange.java,,57-57,[    this.maxInclusive = maxInclusive;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/facet/range/DoubleRange.java,,56-56,[    this.minInclusive = minInclusive;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/facet/range/DoubleRangeFacetCounts.java,count,119-119,[          doc++;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/facet/range/LongRangeCounter.java,,262-262,[      this.leafIndex = leafIndex;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/facet/range/LongRangeFacetCounts.java,count,99-99,[          doc++;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/facet/sortedset/SortedSetDocValuesFacetCounts.java,,279-287,[                     new Comparator<FacetResult>() {,                        @Override,                        public int compare(FacetResult a, FacetResult b) {,                          if (a.value.intValue() > b.value.intValue()) {,                            return -1;,                          } else if (b.value.intValue() > a.value.intValue()) {,                            return 1;,                          } else {,                            return a.dim.compareTo(b.dim);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/lucene/facet/taxonomy/LRUHashMap.java,,52-108,[public class LRUHashMap<K,V> extends LinkedHashMap<K,V> {, ,   private int maxSize;, ,   /**,    * Create a new hash map with a bounded size and with least recently,    * used entries removed.,    * @param maxSize,    *     the maximum size (in number of entries) to which the map can grow,    *     before the least recently used entries start being removed.<BR>,    *      Setting maxSize to a very large value, like,    *      {@link Integer#MAX_VALUE} is allowed, but is less efficient than,    *      using {@link java.util.HashMap} because our class needs,    *      to keep track of the use order (via an additional doubly-linked,    *      list) which is not used when the map's size is always below the,    *      maximum size. ,    */,   public LRUHashMap(int maxSize) {,     super(16, 0.75f, true);,     this.maxSize = maxSize;,   }, ,   /**,    * Return the max size,    */,   public int getMaxSize() {,     return maxSize;,   }, ,   /**,    * setMaxSize() allows changing the map's maximal number of elements,    * which was defined at construction time.,    * <P>,    * Note that if the map is already larger than maxSize, the current ,    * implementation does not shrink it (by removing the oldest elements);,    * Rather, the map remains in its current size as new elements are,    * added, and will only start shrinking (until settling again on the,    * give maxSize) if existing elements are explicitly deleted.  ,    */,   public void setMaxSize(int maxSize) {,     this.maxSize = maxSize;,   }, ,   // We override LinkedHashMap's removeEldestEntry() method. This method,   // is called every time a new entry is added, and if we return true,   // here, the eldest element will be deleted automatically. In our case,,   // we return true if the size of the map grew beyond our limit - ignoring,   // what is that eldest element that we'll be deleting.,   @Override,   protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {,     return size() > maxSize;,   }, ,   @SuppressWarnings("unchecked"),   @Override,   public LRUHashMap<K,V> clone() {,     return (LRUHashMap<K,V>) super.clone();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/facet/taxonomy/OrdinalMappingLeafReader.java,<init>,122-122,[    this.ordinalMap = ordinalMap;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource.java,,135-141,[      return new DoubleDocValues(this) {,         @Override,         public double doubleVal(int document) {,           try {,             return scorer.score();,           } catch (IOException exception) {,             throw new RuntimeException(exception);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/lucene/facet/taxonomy/TaxonomyReader.java,decRef,174-191,[    ensureOpen();,     final int rc = refCount.decrementAndGet();,     if (rc == 0) {,       boolean success = false;,       try {,         doClose();,         closed = true;,         success = true;,       } finally {,         if (!success) {,           // Put reference back on failure,           refCount.incrementAndGet();,         },       },     } else if (rc < 0) {,       throw new IllegalStateException("too many decRef calls: refCount is " + rc + " after decrement");,     },   }],,decref,504-507,[    if (refcount.decrementAndGet() == 0) {,       close();,     },   }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/lucene/facet/taxonomy/TaxonomyReader.java,getRefCount,237-237,[    return refCount.get();],,getRefcount,43-43,[    return refcount.get();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/lucene/facet/taxonomy/TaxonomyReader.java,incRef,257-259,[    ensureOpen();,     refCount.incrementAndGet();,   }],,incref,493-497,[    int result = refcount.incrementAndGet();,     if (result <= 1) {,       throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "incref on a closed log: " + this);,     },   }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java,,655-655,[    cacheMissesUntilFill = i;],,,662-662,[    if (cacheMisses.get() < cacheMissesUntilFill) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java,,987-987,[    return indexEpoch;],,,601-601,[    m.put(INDEX_EPOCH, Long.toString(indexEpoch, 16));],,,624-624,[    if (epochStr == null || Long.parseLong(epochStr, 16) != indexEpoch) {],,,962-962,[    ++indexEpoch;],,,589-589,[    if (epochStr == null || Long.parseLong(epochStr, 16) != indexEpoch) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java,findCategory,392-392,[            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java,getMap,903-903,[        return map;],,getMap,922-922,[      return map;],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java,getMap,906-906,[      DataInputStream in = new DataInputStream(new BufferedInputStream(],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java,getMap,861-861,[      return map;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java,addMapping,855-855,[      map[origOrdinal] = newOrdinal;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/facet/taxonomy/directory/TaxonomyIndexArrays.java,,200-200,[    return children;],,,87-87,[      children = new int[parents.length];],,,91-91,[        System.arraycopy(copyFrom.children(), 0, children, 0, copyFrom.children().length);],,,106-106,[      children[i] = TaxonomyReader.INVALID_ORDINAL;],,,118-118,[      siblings[i] = children[parents[i]];],,,119-119,[      children[parents[i]] = i;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/facet/taxonomy/directory/TaxonomyIndexArrays.java,,215-215,[    return siblings;],,,88-88,[      siblings = new int[parents.length];],,,92-92,[        System.arraycopy(copyFrom.siblings(), 0, siblings, 0, copyFrom.siblings().length);],,,112-112,[      siblings[0] = TaxonomyReader.INVALID_ORDINAL;],,,118-118,[      siblings[i] = children[parents[i]];],,
BAD_PRACTICE,CN_IDIOM,org/apache/lucene/facet/taxonomy/writercache/CharBlockArray.java,,47-50,[    Block(int size) {,       this.chars = new char[size];,       this.length = 0;,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/facet/taxonomy/writercache/CollisionMap.java,,189-231,[  private class EntryIterator implements Iterator<Entry> {,     Entry next;    // next entry to return,     int index;        // current slot ,     Entry[] ents;,     ,     EntryIterator(Entry[] entries, int size) {,       this.ents = entries;,       Entry[] t = entries;,       int i = t.length;,       Entry n = null;,       if (size != 0) { // advance to first entry,         while (i > 0 && (n = t[--i]) == null) {,           // advance,         },       },       this.next = n;,       this.index = i;,     }, ,     @Override,     public boolean hasNext() {,       return this.next != null;,     }, ,     @Override,     public Entry next() { ,       Entry e = this.next;,       if (e == null) throw new NoSuchElementException();, ,       Entry n = e.next;,       Entry[] t = ents;,       int i = this.index;,       while (n == null && i > 0) {,         n = t[--i];,       },       this.index = i;,       this.next = n;,       return  e;,     }, ,     @Override,     public void remove() {,       throw new UnsupportedOperationException();],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/facet/taxonomy/writercache/CompactLabelToOrdinal.java,flush,442-442,[      DataOutputStream dos = new DataOutputStream(os);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/lucene/facet/taxonomy/writercache/LruTaxonomyWriterCache.java,put,101-101,[    boolean ret = cache.put(categoryPath, new Integer(ordinal));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/lucene/facet/taxonomy/writercache/NameHashIntCacheLRU.java,key,39-39,[    return new Long(name.longHashCode());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/lucene/facet/taxonomy/writercache/NameHashIntCacheLRU.java,key,44-44,[    return new Long(name.subpath(prefixLen).longHashCode());],,
PERFORMANCE,DM_NEXTINT_VIA_NEXTDOUBLE,org/apache/lucene/index/BaseCompoundFormatTestCase.java,createRandomFile,637-637,[      byte b = (byte) (Math.random() * 256);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/BaseCompoundFormatTestCase.java,,140-144,[    Directory dir = new FilterDirectory(newDirectory()) {,       @Override,       public IndexOutput createOutput(String name, IOContext context) throws IOException {,         assertSame(myContext, context);,         return super.createOutput(name, context);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,testBytesTwoDocumentsMerged,528-528,[    BytesRef scratch = new BytesRef();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,testSortedBytes,595-595,[    BytesRef scratch = new BytesRef();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,testSortedBytesTwoDocuments,630-630,[    BytesRef scratch = new BytesRef();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,testThreeFieldsMixed2,329-329,[    BytesRef scratch = new BytesRef();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,run,2438-2438,[          } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,,2417-2441,[      threads[i] = new Thread() {,         @Override,         public void run() {,           try {,             startingGun.await();,             for (LeafReaderContext context : ir.leaves()) {,               LeafReader r = context.reader();,               BinaryDocValues binaries = r.getBinaryDocValues("dvBin");,               SortedDocValues sorted = r.getSortedDocValues("dvSorted");,               NumericDocValues numerics = r.getNumericDocValues("dvNum");,               for (int j = 0; j < r.maxDoc(); j++) {,                 BytesRef binaryValue = r.document(j).getBinaryValue("storedBin");,                 BytesRef scratch = binaries.get(j);,                 assertEquals(binaryValue, scratch);,                 scratch = sorted.get(j);,                 assertEquals(binaryValue, scratch);,                 String expected = r.document(j).get("storedNum");,                 assertEquals(Long.parseLong(expected), numerics.get(j));,               },             },             TestUtil.checkReader(ir);,           } catch (Exception e) {,             throw new RuntimeException(e);,           },         }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,run,2612-2612,[          } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,,2532-2615,[      threads[i] = new Thread() {,         @Override,         public void run() {,           try {,             startingGun.await();,             for (LeafReaderContext context : ir.leaves()) {,               LeafReader r = context.reader();,               BinaryDocValues binaries = r.getBinaryDocValues("dvBin");,               Bits binaryBits = r.getDocsWithField("dvBin");,               SortedDocValues sorted = r.getSortedDocValues("dvSorted");,               Bits sortedBits = r.getDocsWithField("dvSorted");,               NumericDocValues numerics = r.getNumericDocValues("dvNum");,               Bits numericBits = r.getDocsWithField("dvNum");,               SortedSetDocValues sortedSet = r.getSortedSetDocValues("dvSortedSet");,               Bits sortedSetBits = r.getDocsWithField("dvSortedSet");,               SortedNumericDocValues sortedNumeric = r.getSortedNumericDocValues("dvSortedNumeric");,               Bits sortedNumericBits = r.getDocsWithField("dvSortedNumeric");,               for (int j = 0; j < r.maxDoc(); j++) {,                 BytesRef binaryValue = r.document(j).getBinaryValue("storedBin");,                 if (binaryValue != null) {,                   if (binaries != null) {,                     BytesRef scratch = binaries.get(j);,                     assertEquals(binaryValue, scratch);,                     scratch = sorted.get(j);,                     assertEquals(binaryValue, scratch);,                     assertTrue(binaryBits.get(j));,                     assertTrue(sortedBits.get(j));,                   },                 } else if (binaries != null) {,                   assertFalse(binaryBits.get(j));,                   assertFalse(sortedBits.get(j));,                   assertEquals(-1, sorted.getOrd(j));,                 },                ,                 String number = r.document(j).get("storedNum");,                 if (number != null) {,                   if (numerics != null) {,                     assertEquals(Long.parseLong(number), numerics.get(j));,                   },                 } else if (numerics != null) {,                   assertFalse(numericBits.get(j));,                   assertEquals(0, numerics.get(j));,                 },                 ,                 String values[] = r.document(j).getValues("storedSortedSet");,                 if (values.length > 0) {,                   assertNotNull(sortedSet);,                   sortedSet.setDocument(j);,                   for (int k = 0; k < values.length; k++) {,                     long ord = sortedSet.nextOrd();,                     assertTrue(ord != SortedSetDocValues.NO_MORE_ORDS);,                     BytesRef value = sortedSet.lookupOrd(ord);,                     assertEquals(values[k], value.utf8ToString());,                   },                   assertEquals(SortedSetDocValues.NO_MORE_ORDS, sortedSet.nextOrd());,                   assertTrue(sortedSetBits.get(j));,                 } else if (sortedSet != null) {,                   sortedSet.setDocument(j);,                   assertEquals(SortedSetDocValues.NO_MORE_ORDS, sortedSet.nextOrd());,                   assertFalse(sortedSetBits.get(j));,                 },                 ,                 String numValues[] = r.document(j).getValues("storedSortedNumeric");,                 if (numValues.length > 0) {,                   assertNotNull(sortedNumeric);,                   sortedNumeric.setDocument(j);,                   assertEquals(numValues.length, sortedNumeric.count());,                   for (int k = 0; k < numValues.length; k++) {,                     long v = sortedNumeric.valueAt(k);,                     assertEquals(numValues[k], Long.toString(v));,                   },                   assertTrue(sortedNumericBits.get(j));,                 } else if (sortedNumeric != null) {,                   sortedNumeric.setDocument(j);,                   assertEquals(0, sortedNumeric.count());,                   assertFalse(sortedNumericBits.get(j));,                 },               },             },             TestUtil.checkReader(ir);,           } catch (Exception e) {,             throw new RuntimeException(e);,           },         }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,run,2677-2677,[            } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/BaseDocValuesFormatTestCase.java,,2667-2680,[        threads[tid] = new Thread() {,           @Override,           public void run() {,             try {,               ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);,               PrintStream infoStream = new PrintStream(bos, false, IOUtils.UTF_8);,               startingGun.await();,               for (LeafReaderContext leaf : r.leaves()) {,                 CheckIndex.testDocValues(leaf.reader(), infoStream, true);,               },             } catch (Exception e) {,               throw new RuntimeException();,             },           }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/BaseMergePolicyTestCase.java,,40-47,[    final MergeScheduler mergeScheduler = new SerialMergeScheduler() {,       @Override,       synchronized public void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {,         if (!mayMerge.get() && writer.getNextMerge() != null) {,           throw new AssertionError();,         },         super.merge(writer, trigger, newMergesFound);,       }],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/index/BasePostingsFormatTestCase.java,testTermsOneThread,1297-1297,[          for(BytesRef term2 : fields.get(field).keySet()) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/index/BasePostingsFormatTestCase.java,,170-170,[      this.options = options;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/BasePostingsFormatTestCase.java,next,608-608,[      if (iterator.hasNext()) {],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java,testBigDocuments,684-684,[    if (dir instanceof MockDirectoryWrapper) {],,
STYLE,UC_USELESS_OBJECT,org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java,testNumericField,248-248,[    final NumericType[] typeAnswers = new NumericType[numDocs];],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java,run,461-461,[            } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java,,434-465,[      readThreads.add(new Thread() {, ,         int[] queries;, ,         {,           queries = new int[readsPerThread];,           for (int i = 0; i < queries.length; ++i) {,             queries[i] = random().nextInt(numDocs);,           },         }, ,         @Override,         public void run() {,           for (int q : queries) {,             final Query query = new TermQuery(new Term("fld", "" + q));,             try {,               final TopDocs topDocs = searcher.search(query, 1);,               if (topDocs.totalHits != 1) {,                 throw new IllegalStateException("Expected 1 hit, got " + topDocs.totalHits);,               },               final StoredDocument sdoc = rd.document(topDocs.scoreDocs[0].doc);,               if (sdoc == null || sdoc.get("fld") == null) {,                 throw new IllegalStateException("Could not find document " + q);,               },               if (!Integer.toString(q).equals(sdoc.get("fld"))) {,                 throw new IllegalStateException("Expected " + q + ", but got " + sdoc.get("fld"));,               },             } catch (Exception e) {,               ex.compareAndSet(null, e);,             },           },         }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,assertEquals,514-514,[          } catch (Exception e) {],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,assertEquals,466-466,[        assertEquals(0, docsAndPositionsEnum.nextDoc());],,assertEquals,469-469,[        if (docsAndPositionsEnum != null) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,copyTo,157-157,[      OffsetAttribute t = (OffsetAttribute) target;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,,327-356,[  protected class RandomDocument {, ,     private final String[] fieldNames;,     private final FieldType[] fieldTypes;,     private final RandomTokenStream[] tokenStreams;, ,     protected RandomDocument(int fieldCount, int maxTermCount, Options options, String[] fieldNames, String[] sampleTerms, BytesRef[] sampleTermBytes) {,       if (fieldCount > fieldNames.length) {,         throw new IllegalArgumentException();,       },       this.fieldNames = new String[fieldCount];,       fieldTypes = new FieldType[fieldCount];,       tokenStreams = new RandomTokenStream[fieldCount];,       Arrays.fill(fieldTypes, fieldType(options));,       final Set<String> usedFileNames = new HashSet<>();,       for (int i = 0; i < fieldCount; ++i) {,         do {,           this.fieldNames[i] = RandomPicks.randomFrom(random(), fieldNames);,         } while (usedFileNames.contains(this.fieldNames[i]));,         usedFileNames.add(this.fieldNames[i]);,         tokenStreams[i] = new RandomTokenStream(TestUtil.nextInt(random(), 1, maxTermCount), sampleTerms, sampleTermBytes);,       },     }, ,     public Document toDocument() {,       final Document doc = new Document();,       for (int i = 0; i < fieldNames.length; ++i) {,         doc.add(new Field(fieldNames[i], tokenStreams[i], fieldTypes[i]));,       },       return doc;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,getEndOffsets,297-297,[      return endOffsets;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,getPayloads,301-301,[      return payloads;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,getPositionsIncrements,289-289,[      return positionsIncrements;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,getStartOffsets,293-293,[      return startOffsets;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,getTermBytes,285-285,[      return termBytes;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/BaseTermVectorsFormatTestCase.java,getTerms,281-281,[      return terms;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/index/BinaryDocValuesFieldUpdates.java,merge,171-171,[    BinaryDocValuesFieldUpdates otherUpdates = (BinaryDocValuesFieldUpdates) other;],,
STYLE,INT_VACUOUS_COMPARISON,org/apache/lucene/index/BinaryDocValuesFieldUpdates.java,merge,173-173,[    if (newSize > Integer.MAX_VALUE) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/BinaryDocValuesFieldUpdates.java,,142-162,[    new InPlaceMergeSorter() {,       @Override,       protected void swap(int i, int j) {,         long tmpDoc = docs.get(j);,         docs.set(j, docs.get(i));,         docs.set(i, tmpDoc);,         ,         long tmpOffset = offsets.get(j);,         offsets.set(j, offsets.get(i));,         offsets.set(i, tmpOffset);, ,         long tmpLength = lengths.get(j);,         lengths.set(j, lengths.get(i));,         lengths.set(i, tmpLength);,       },       ,       @Override,       protected int compare(int i, int j) {,         int x = (int) docs.get(i);,         int y = (int) docs.get(j);,         return (x < y) ? -1 : ((x == y) ? 0 : 1);],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/lucene/index/BufferedUpdates.java,,173-173,[      String s = "gen=" + gen;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/index/BufferedUpdatesStream.java,applyDocValuesUpdates,500-500,[        DocsEnum docsEnum = termsEnum.docs(rld.getLiveDocs(), docs, DocsEnum.FLAG_NONE);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/index/BufferedUpdatesStream.java,applyTermDeletes,416-416,[        DocsEnum docsEnum = termsEnum.docs(rld.getLiveDocs(), docs, DocsEnum.FLAG_NONE);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/index/BufferedUpdatesStream.java,applyQueryDeletes,538-538,[      if (docs != null) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/BufferedUpdatesStream.java,,133-133,[      this.gen = gen;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/index/CheckIndex.java,checkIndex,512-512,[      format = input.readInt();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/index/CheckIndex.java,checkFields,1012-1012,[          throw new RuntimeException("field=\"" + field + "\": invalid term: term=" + term + ", minTerm=" + minTerm);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/index/CheckIndex.java,checkFields,1155-1155,[            final DocsEnum docsNoDel = termsEnum.docs(null, docsAndFreqs);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/index/CheckIndex.java,checkFields,1304-1304,[        if (fieldTerms != null) {],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/index/CheckIndex.java,testTermVectors,1931-1931,[                  if (postingsHasFreq && postingsDocs2.freq() != tf) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,507-507,[      result.cantOpenSegments = true;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,520-520,[      result.missingSegmentVersion = true;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,531-531,[    result.numSegments = numSegments;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,530-530,[    result.segmentsFileName = segmentsFileName;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,568-568,[      result.toolOutOfDate = true;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,532-532,[    result.userData = sis.getUserData();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,736-736,[    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/CheckIndex.java,doMain,2212-2212,[          System.out.println("Wrote new segments file \"" + result.newSegments.getSegmentsFileName() + "\"");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/CheckIndex.java,exorciseIndex,2039-2039,[    result.newSegments.changed();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,230-230,[      public long totFields = 0L;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,606-606,[        segInfoStat.codec = codec;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,608-608,[        segInfoStat.compound = info.info.getUseCompoundFile();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,626-626,[          segInfoStat.deletionsGen = info.getDelGen();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,614-614,[        segInfoStat.diagnostics = diagnostics;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,590-590,[      segInfoStat.docCount = info.info.getDocCount();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,621-621,[          segInfoStat.hasDeletions = false;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,589-589,[      segInfoStat.name = info.info.name;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,610-610,[        segInfoStat.numFiles = info.files().size();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/CheckIndex.java,,633-633,[        segInfoStat.openReaderPassed = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/ConcurrentMergeScheduler.java,,609-609,[    throw new MergePolicy.MergeException(exc, dir);],,,370-370,[    dir = writer.getDirectory();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/ConcurrentMergeScheduler.java,,469-469,[    writer.merge(merge);],,,283-283,[    writer.infoStream.message("CMS", message);],,,438-438,[    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {],,,275-275,[    return writer != null && writer.infoStream.isEnabled("CMS");],,,299-299,[      boolean spins = IOUtils.spins(writer.getDirectory());],,,298-298,[      assert writer != null;],,,365-365,[    this.writer = writer;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/index/DefaultIndexingChain.java,compareTo,553-553,[      return this.fieldInfo.name.compareTo(other.fieldInfo.name);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/index/DocHelper.java,,182-182,[  public static Map<String,IndexableField> lazy= new HashMap<>();],,
MT_CORRECTNESS,UL_UNRELEASED_LOCK_EXCEPTION_PATH,org/apache/lucene/index/DocumentsWriterDeleteQueue.java,freezeGlobalBuffer,213-213,[    globalBufferLock.lock();],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/index/DocumentsWriterFlushControl.java,<init>,82-82,[    this.hardMaxBytesPerDWPT = config.getRAMPerThreadHardLimitMB() * 1024 * 1024;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/DocumentsWriterFlushControl.java,,569-569,[        perThreadPool.reset(perThread, closed); // make this state inactive],,,248-248,[    final boolean stall = ((activeBytes + flushBytes) > limit)  &&],,,292-292,[      perThreadPool.reset(state, closed);],,,331-331,[            dwpt = perThreadPool.reset(perThread, closed);],,,310-310,[      dwpt = perThreadPool.reset(perThread, closed);],,,383-383,[    if (!closed) {],,,384-384,[      this.closed = true;],,,497-497,[          if (closed && next.isActive()) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/DocumentsWriterFlushControl.java,,695-695,[              + " netBytes: " + netBytes() + " flushBytes: " + flushBytes()],,,556-556,[    assert fullFlush;],,,618-618,[     fullFlush = false;],,,363-363,[      fullFlush = this.fullFlush;],,,592-592,[    assert fullFlush;],,,602-602,[      fullFlush = false;],,,657-657,[    return fullFlush;],,,188-188,[      if (fullFlush) {],,,307-307,[      assert fullFlush : "can not block if fullFlush == false";],,,482-482,[      assert !fullFlush : "called DWFC#markForFullFlush() while full flush is still running";],,,484-484,[      fullFlush = true;],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/index/DocumentsWriterFlushControl.java,nextPendingFlush,368-368,[      for (int i = 0; i < limit && numPending > 0; i++) {],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/DocumentsWriterFlushControl.java,checkoutAndBlock,311-311,[      numPending--;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/DocumentsWriterFlushControl.java,internalTryCheckOutForFlush,335-335,[            numPending--; // write access synced],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/DocumentsWriterFlushControl.java,setFlushPending,277-277,[      numPending++; // write access synced],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/lucene/index/DocumentsWriterFlushControl.java,next,407-407,[        return perThreadPool.getThreadState(i++);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/index/DocumentsWriterFlushQueue.java,finishFlush,206-206,[          if (bufferedUpdates != null && bufferedUpdates.any()) {],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/lucene/index/DocumentsWriterPerThread.java,flush,390-390,[    segmentInfo.setDocCount(numDocsInRAM);],,flush,453-453,[      assert segmentInfo != null;],,
CORRECTNESS,UR_UNINIT_READ,org/apache/lucene/index/DocumentsWriterPerThread.java,<init>,176-176,[    assert numDocsInRAM == 0 : "num docs " + numDocsInRAM;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/DefaultIndexingChain.java,processDocument,296-296,[      for (IndexableField field : docState.doc.indexableFields()) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/index/DocumentsWriterPerThread.java,,104-104,[      this.fieldInfos = fieldInfos;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/DocumentsWriterPerThreadPool.java,newThreadState,186-186,[        numThreadStatesActive++; // increment will publish the ThreadState],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/lucene/index/DocumentsWriterPerThread.java,,49-582,[class DocumentsWriterPerThread {, ,   /**,    * The IndexingChain must define the {@link #getChain(DocumentsWriterPerThread)} method,    * which returns the DocConsumer that the DocumentsWriter calls to process the,    * documents.,    */,   abstract static class IndexingChain {,     abstract DocConsumer getChain(DocumentsWriterPerThread documentsWriterPerThread) throws IOException;,   },   , ,   static final IndexingChain defaultIndexingChain = new IndexingChain() {, ,     @Override,     DocConsumer getChain(DocumentsWriterPerThread documentsWriterPerThread) throws IOException {,       return new DefaultIndexingChain(documentsWriterPerThread);,     },   };, ,   static class DocState {,     final DocumentsWriterPerThread docWriter;,     Analyzer analyzer;,     InfoStream infoStream;,     Similarity similarity;,     int docID;,     IndexDocument doc;, ,     DocState(DocumentsWriterPerThread docWriter, InfoStream infoStream) {,       this.docWriter = docWriter;,       this.infoStream = infoStream;,     }, ,     public void testPoint(String name) {,       docWriter.testPoint(name);,     }, ,     public void clear() {,       // don't hold onto doc nor analyzer, in case it is,       // largish:,       doc = null;,       analyzer = null;,     },   }, ,   static class FlushedSegment {,     final SegmentCommitInfo segmentInfo;,     final FieldInfos fieldInfos;,     final FrozenBufferedUpdates segmentUpdates;,     final MutableBits liveDocs;,     final int delCount;, ,     private FlushedSegment(SegmentCommitInfo segmentInfo, FieldInfos fieldInfos,,                            BufferedUpdates segmentUpdates, MutableBits liveDocs, int delCount) {,       this.segmentInfo = segmentInfo;,       this.fieldInfos = fieldInfos;,       this.segmentUpdates = segmentUpdates != null && segmentUpdates.any() ? new FrozenBufferedUpdates(segmentUpdates, true) : null;,       this.liveDocs = liveDocs;,       this.delCount = delCount;,     },   }, ,   /** Called if we hit an exception at a bad time (when,    *  updating the index files) and must discard all,    *  currently buffered docs.  This resets our state,,    *  discarding any docs added since last flush. */,   void abort() {,     //System.out.println(Thread.currentThread().getName() + ": now abort seg=" + segmentInfo.name);,     aborted = true;,     try {,       if (infoStream.isEnabled("DWPT")) {,         infoStream.message("DWPT", "now abort");,       },       try {,         consumer.abort();,       } catch (Throwable t) {,       }, ,       pendingUpdates.clear();,     } finally {,       if (infoStream.isEnabled("DWPT")) {,         infoStream.message("DWPT", "done abort");,       },     },   },   private final static boolean INFO_VERBOSE = false;,   final Codec codec;,   final TrackingDirectoryWrapper directory;,   final Directory directoryOrig;,   final DocState docState;,   final DocConsumer consumer;,   final Counter bytesUsed;,   ,   SegmentWriteState flushState;,   // Updates for our still-in-RAM (to be flushed next) segment,   final BufferedUpdates pendingUpdates;,   private final SegmentInfo segmentInfo;     // Current segment we are working on,   boolean aborted = false;   // True if we aborted, ,   private final FieldInfos.Builder fieldInfos;,   private final InfoStream infoStream;,   private int numDocsInRAM;,   final DocumentsWriterDeleteQueue deleteQueue;,   private final DeleteSlice deleteSlice;,   private final NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);,   final Allocator byteBlockAllocator;,   final IntBlockPool.Allocator intBlockAllocator;,   private final AtomicLong pendingNumDocs;,   private final LiveIndexWriterConfig indexWriterConfig;,   private final boolean enableTestPoints;,   ,   public DocumentsWriterPerThread(String segmentName, Directory directory, LiveIndexWriterConfig indexWriterConfig, InfoStream infoStream, DocumentsWriterDeleteQueue deleteQueue,,                                   FieldInfos.Builder fieldInfos, AtomicLong pendingNumDocs, boolean enableTestPoints) throws IOException {,     this.directoryOrig = directory;,     this.directory = new TrackingDirectoryWrapper(directory);,     this.fieldInfos = fieldInfos;,     this.indexWriterConfig = indexWriterConfig;,     this.infoStream = infoStream;,     this.codec = indexWriterConfig.getCodec();,     this.docState = new DocState(this, infoStream);,     this.docState.similarity = indexWriterConfig.getSimilarity();,     this.pendingNumDocs = pendingNumDocs;,     bytesUsed = Counter.newCounter();,     byteBlockAllocator = new DirectTrackingAllocator(bytesUsed);,     pendingUpdates = new BufferedUpdates();,     intBlockAllocator = new IntBlockAllocator(bytesUsed);,     this.deleteQueue = deleteQueue;,     assert numDocsInRAM == 0 : "num docs " + numDocsInRAM;,     pendingUpdates.clear();,     deleteSlice = deleteQueue.newSlice();,    ,     segmentInfo = new SegmentInfo(directoryOrig, Version.LATEST, segmentName, -1, false, codec, null, StringHelper.randomId(), new HashMap<>());,     assert numDocsInRAM == 0;,     if (INFO_VERBOSE && infoStream.isEnabled("DWPT")) {,       infoStream.message("DWPT", Thread.currentThread().getName() + " init seg=" + segmentName + " delQueue=" + deleteQueue);  ,     },     // this should be the last call in the ctor ,     // it really sucks that we need to pull this within the ctor and pass this ref to the chain!,     consumer = indexWriterConfig.getIndexingChain().getChain(this);,     this.enableTestPoints = enableTestPoints;,   },   ,   public FieldInfos.Builder getFieldInfosBuilder() {,     return fieldInfos;,   }, ,   final void testPoint(String message) {,     if (enableTestPoints) {,       assert infoStream.isEnabled("TP"); // don't enable unless you need them.,       infoStream.message("TP", message);,     },   }, ,   /** Anything that will add N docs to the index should reserve first to,    *  make sure it's allowed. */,   private void reserveDoc() {,     if (pendingNumDocs.incrementAndGet() > IndexWriter.getActualMaxDocs()) {,       // Reserve failed,       pendingNumDocs.decrementAndGet();,       throw new IllegalStateException("number of documents in the index cannot exceed " + IndexWriter.getActualMaxDocs());,     },   }, ,   public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {,     testPoint("DocumentsWriterPerThread addDocument start");,     assert deleteQueue != null;,     docState.doc = doc;,     docState.analyzer = analyzer;,     docState.docID = numDocsInRAM;,     if (INFO_VERBOSE && infoStream.isEnabled("DWPT")) {,       infoStream.message("DWPT", Thread.currentThread().getName() + " update delTerm=" + delTerm + " docID=" + docState.docID + " seg=" + segmentInfo.name);,     },     // Even on exception, the document is still added (but marked,     // deleted), so we don't need to un-reserve at that point.,     // Aborting exceptions will actually "lose" more than one,     // document, so the counter will be "wrong" in that case, but,     // it's very hard to fix (we can't easily distinguish aborting,     // vs non-aborting exceptions):,     reserveDoc();,     boolean success = false;,     try {,       try {,         consumer.processDocument();,       } finally {,         docState.clear();,       },       success = true;,     } finally {,       if (!success) {,         // mark document as deleted,         deleteDocID(docState.docID);,         numDocsInRAM++;,       },     },     finishDocument(delTerm);,   }, ,   public int updateDocuments(Iterable<? extends IndexDocument> docs, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {,     testPoint("DocumentsWriterPerThread addDocuments start");,     assert deleteQueue != null;,     docState.analyzer = analyzer;,     if (INFO_VERBOSE && infoStream.isEnabled("DWPT")) {,       infoStream.message("DWPT", Thread.currentThread().getName() + " update delTerm=" + delTerm + " docID=" + docState.docID + " seg=" + segmentInfo.name);,     },     int docCount = 0;,     boolean allDocsIndexed = false;,     try {,       ,       for(IndexDocument doc : docs) {,         // Even on exception, the document is still added (but marked,         // deleted), so we don't need to un-reserve at that point.,         // Aborting exceptions will actually "lose" more than one,         // document, so the counter will be "wrong" in that case, but,         // it's very hard to fix (we can't easily distinguish aborting,         // vs non-aborting exceptions):,         reserveDoc();,         docState.doc = doc;,         docState.docID = numDocsInRAM;,         docCount++;, ,         boolean success = false;,         try {,           consumer.processDocument();,           success = true;,         } finally {,           if (!success) {,             // Incr here because finishDocument will not,             // be called (because an exc is being thrown):,             numDocsInRAM++;,           },         },         finishDocument(null);,       },       allDocsIndexed = true;, ,       // Apply delTerm only after all indexing has,       // succeeded, but apply it only to docs prior to when,       // this batch started:,       if (delTerm != null) {,         deleteQueue.add(delTerm, deleteSlice);,         assert deleteSlice.isTailItem(delTerm) : "expected the delete term as the tail item";,         deleteSlice.apply(pendingUpdates, numDocsInRAM-docCount);,       }, ,     } finally {,       if (!allDocsIndexed && !aborted) {,         // the iterator threw an exception that is not aborting ,         // go and mark all docs from this block as deleted,         int docID = numDocsInRAM-1;,         final int endDocID = docID - docCount;,         while (docID > endDocID) {,           deleteDocID(docID);,           docID--;,         },       },       docState.clear();,     }, ,     return docCount;,   },   ,   private void finishDocument(Term delTerm) {,     /*,      * here we actually finish the document in two steps 1. push the delete into,      * the queue and update our slice. 2. increment the DWPT private document,      * id.,      * ,      * the updated slice we get from 1. holds all the deletes that have occurred,      * since we updated the slice the last time.,      */,     boolean applySlice = numDocsInRAM != 0;,     if (delTerm != null) {,       deleteQueue.add(delTerm, deleteSlice);,       assert deleteSlice.isTailItem(delTerm) : "expected the delete term as the tail item";,     } else  {,       applySlice &= deleteQueue.updateSlice(deleteSlice);,     },     ,     if (applySlice) {,       deleteSlice.apply(pendingUpdates, numDocsInRAM);,     } else { // if we don't need to apply we must reset!,       deleteSlice.reset();,     },     ++numDocsInRAM;,   }, ,   // Buffer a specific docID for deletion. Currently only,   // used when we hit an exception when adding a document,   void deleteDocID(int docIDUpto) {,     pendingUpdates.addDocID(docIDUpto);,     // NOTE: we do not trigger flush here.  This is,     // potentially a RAM leak, if you have an app that tries,     // to add docs but every single doc always hits a,     // non-aborting exception.  Allowing a flush here gets,     // very messy because we are only invoked when handling,     // exceptions so to do this properly, while handling an,     // exception we'd have to go off and flush new deletes,     // which is risky (likely would hit some other,     // confounding exception).,   }, ,   /**,    * Returns the number of delete terms in this {@link DocumentsWriterPerThread},    */,   public int numDeleteTerms() {,     // public for FlushPolicy,     return pendingUpdates.numTermDeletes.get();,   }, ,   /**,    * Returns the number of RAM resident documents in this {@link DocumentsWriterPerThread},    */,   public int getNumDocsInRAM() {,     // public for FlushPolicy,     return numDocsInRAM;,   }, ,   ,   /**,    * Prepares this DWPT for flushing. This method will freeze and return the,    * {@link DocumentsWriterDeleteQueue}s global buffer and apply all pending,    * deletes to this DWPT.,    */,   FrozenBufferedUpdates prepareFlush() {,     assert numDocsInRAM > 0;,     final FrozenBufferedUpdates globalUpdates = deleteQueue.freezeGlobalBuffer(deleteSlice);,     /* deleteSlice can possibly be null if we have hit non-aborting exceptions during indexing and never succeeded ,     adding a document. */,     if (deleteSlice != null) {,       // apply all deletes before we flush and release the delete slice,       deleteSlice.apply(pendingUpdates, numDocsInRAM);,       assert deleteSlice.isEmpty();,       deleteSlice.reset();,     },     return globalUpdates;,   }, ,   /** Flush all pending docs to a new segment */,   FlushedSegment flush() throws IOException, AbortingException {,     assert numDocsInRAM > 0;,     assert deleteSlice.isEmpty() : "all deletes must be applied in prepareFlush";,     segmentInfo.setDocCount(numDocsInRAM);,     final SegmentWriteState flushState = new SegmentWriteState(infoStream, directory, segmentInfo, fieldInfos.finish(),,         pendingUpdates, new IOContext(new FlushInfo(numDocsInRAM, bytesUsed())));,     final double startMBUsed = bytesUsed() / 1024. / 1024.;, ,     // Apply delete-by-docID now (delete-byDocID only,     // happens when an exception is hit processing that,     // doc, eg if analyzer has some problem w/ the text):,     if (pendingUpdates.docIDs.size() > 0) {,       flushState.liveDocs = codec.liveDocsFormat().newLiveDocs(numDocsInRAM);,       for(int delDocID : pendingUpdates.docIDs) {,         flushState.liveDocs.clear(delDocID);,       },       flushState.delCountOnFlush = pendingUpdates.docIDs.size();,       pendingUpdates.bytesUsed.addAndGet(-pendingUpdates.docIDs.size() * BufferedUpdates.BYTES_PER_DEL_DOCID);,       pendingUpdates.docIDs.clear();,     }, ,     if (aborted) {,       if (infoStream.isEnabled("DWPT")) {,         infoStream.message("DWPT", "flush: skip because aborting is set");,       },       return null;,     }, ,     if (infoStream.isEnabled("DWPT")) {,       infoStream.message("DWPT", "flush postings as segment " + flushState.segmentInfo.name + " numDocs=" + numDocsInRAM);,     }, ,     try {,       consumer.flush(flushState);,       pendingUpdates.terms.clear();,       segmentInfo.setFiles(new HashSet<>(directory.getCreatedFiles()));, ,       final SegmentCommitInfo segmentInfoPerCommit = new SegmentCommitInfo(segmentInfo, 0, -1L, -1L, -1L);,       if (infoStream.isEnabled("DWPT")) {,         infoStream.message("DWPT", "new segment has " + (flushState.liveDocs == null ? 0 : flushState.delCountOnFlush) + " deleted docs");,         infoStream.message("DWPT", "new segment has " +,                            (flushState.fieldInfos.hasVectors() ? "vectors" : "no vectors") + "; " +,                            (flushState.fieldInfos.hasNorms() ? "norms" : "no norms") + "; " + ,                            (flushState.fieldInfos.hasDocValues() ? "docValues" : "no docValues") + "; " + ,                            (flushState.fieldInfos.hasProx() ? "prox" : "no prox") + "; " + ,                            (flushState.fieldInfos.hasFreq() ? "freqs" : "no freqs"));,         infoStream.message("DWPT", "flushedFiles=" + segmentInfoPerCommit.files());,         infoStream.message("DWPT", "flushed codec=" + codec);,       }, ,       final BufferedUpdates segmentDeletes;,       if (pendingUpdates.queries.isEmpty() && pendingUpdates.numericUpdates.isEmpty() && pendingUpdates.binaryUpdates.isEmpty()) {,         pendingUpdates.clear();,         segmentDeletes = null;,       } else {,         segmentDeletes = pendingUpdates;,       }, ,       if (infoStream.isEnabled("DWPT")) {,         final double newSegmentSize = segmentInfoPerCommit.sizeInBytes()/1024./1024.;,         infoStream.message("DWPT", "flushed: segment=" + segmentInfo.name + ,                 " ramUsed=" + nf.format(startMBUsed) + " MB" +,                 " newFlushedSize(includes docstores)=" + nf.format(newSegmentSize) + " MB" +,                 " docs/MB=" + nf.format(flushState.segmentInfo.getDocCount() / newSegmentSize));,       }, ,       assert segmentInfo != null;, ,       FlushedSegment fs = new FlushedSegment(segmentInfoPerCommit, flushState.fieldInfos,,                                              segmentDeletes, flushState.liveDocs, flushState.delCountOnFlush);,       sealFlushedSegment(fs);, ,       return fs;,     } catch (Throwable th) {,       abort();,       throw AbortingException.wrap(th);,     },   },   ,   private final Set<String> filesToDelete = new HashSet<>();,   ,   public Set<String> pendingFilesToDelete() {,     return filesToDelete;,   },   /**,    * Seals the {@link SegmentInfo} for the new flushed segment and persists,    * the deleted documents {@link MutableBits}.,    */,   void sealFlushedSegment(FlushedSegment flushedSegment) throws IOException {,     assert flushedSegment != null;, ,     SegmentCommitInfo newSegment = flushedSegment.segmentInfo;, ,     IndexWriter.setDiagnostics(newSegment.info, IndexWriter.SOURCE_FLUSH);,     ,     IOContext context = new IOContext(new FlushInfo(newSegment.info.getDocCount(), newSegment.sizeInBytes()));, ,     boolean success = false;,     try {,       ,       if (indexWriterConfig.getUseCompoundFile()) {,         filesToDelete.addAll(IndexWriter.createCompoundFile(infoStream, directory, MergeState.CheckAbort.NONE, newSegment.info, context));,         newSegment.info.setUseCompoundFile(true);,       }, ,       // Have codec write SegmentInfo.  Must do this after,       // creating CFS so that 1) .si isn't slurped into CFS,,       // and 2) .si reflects useCompoundFile=true change,       // above:,       codec.segmentInfoFormat().write(directory, newSegment.info, context);, ,       // TODO: ideally we would freeze newSegment here!!,       // because any changes after writing the .si will be,       // lost... , ,       // Must write deleted docs after the CFS so we don't,       // slurp the del file into CFS:,       if (flushedSegment.liveDocs != null) {,         final int delCount = flushedSegment.delCount;,         assert delCount > 0;,         if (infoStream.isEnabled("DWPT")) {,           infoStream.message("DWPT", "flush: write " + delCount + " deletes gen=" + flushedSegment.segmentInfo.getDelGen());,         }, ,         // TODO: we should prune the segment if it's 100%,         // deleted... but merge will also catch it., ,         // TODO: in the NRT case it'd be better to hand,         // this del vector over to the,         // shortly-to-be-opened SegmentReader and let it,         // carry the changes; there's no reason to use,         // filesystem as intermediary here.,           ,         SegmentCommitInfo info = flushedSegment.segmentInfo;,         Codec codec = info.info.getCodec();,         codec.liveDocsFormat().writeLiveDocs(flushedSegment.liveDocs, directory, info, delCount, context);,         newSegment.setDelCount(delCount);,         newSegment.advanceDelGen();,       }, ,       success = true;,     } finally {,       if (!success) {,         if (infoStream.isEnabled("DWPT")) {,           infoStream.message("DWPT",,                              "hit exception creating compound file for newly flushed segment " + newSegment.info.name);,         },       },     },   }, ,   /** Get current segment info we are writing. */,   SegmentInfo getSegmentInfo() {,     return segmentInfo;,   }, ,   long bytesUsed() {,     return bytesUsed.get() + pendingUpdates.bytesUsed.get();,   }, ,   /* Initial chunks size of the shared byte[] blocks used to,      store postings data */,   final static int BYTE_BLOCK_NOT_MASK = ~BYTE_BLOCK_MASK;, ,   /* if you increase this, you must fix field cache impl for,    * getTerms/getTermsIndex requires <= 32768 */,   final static int MAX_TERM_LENGTH_UTF8 = BYTE_BLOCK_SIZE-2;, , ,   private static class IntBlockAllocator extends IntBlockPool.Allocator {,     private final Counter bytesUsed;,     ,     public IntBlockAllocator(Counter bytesUsed) {,       super(IntBlockPool.INT_BLOCK_SIZE);,       this.bytesUsed = bytesUsed;,     },     ,     /* Allocate another int[] from the shared pool */,     @Override,     public int[] getIntBlock() {,       int[] b = new int[IntBlockPool.INT_BLOCK_SIZE];,       bytesUsed.addAndGet(IntBlockPool.INT_BLOCK_SIZE,           * RamUsageEstimator.NUM_BYTES_INT);,       return b;,     },     ,     @Override,     public void recycleIntBlocks(int[][] blocks, int offset, int length) {,       bytesUsed.addAndGet(-(length * (IntBlockPool.INT_BLOCK_SIZE * RamUsageEstimator.NUM_BYTES_INT)));,     },     ,   },   ,   @Override,   public String toString() {,     return "DocumentsWriterPerThread [pendingDeletes=" + pendingUpdates],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/lucene/index/DocumentsWriterPerThreadPool.java,,52-127,[  @SuppressWarnings("serial"),   final static class ThreadState extends ReentrantLock {,     DocumentsWriterPerThread dwpt;,     // TODO this should really be part of DocumentsWriterFlushControl,     // write access guarded by DocumentsWriterFlushControl,     volatile boolean flushPending = false;,     // TODO this should really be part of DocumentsWriterFlushControl,     // write access guarded by DocumentsWriterFlushControl,     long bytesUsed = 0;,     // guarded by Reentrant lock,     private boolean isActive = true;, ,     ThreadState(DocumentsWriterPerThread dpwt) {,       this.dwpt = dpwt;,     },     ,     /**,      * Resets the internal {@link DocumentsWriterPerThread} with the given one. ,      * if the given DWPT is <code>null</code> this ThreadState is marked as inactive and should not be used,      * for indexing anymore.,      * @see #isActive()  ,      */,   ,     private void deactivate() {,       assert this.isHeldByCurrentThread();,       isActive = false;,       reset();,     },     ,     private void reset() {,       assert this.isHeldByCurrentThread();,       this.dwpt = null;,       this.bytesUsed = 0;,       this.flushPending = false;,     },     ,     /**,      * Returns <code>true</code> if this ThreadState is still open. This will,      * only return <code>false</code> iff the DW has been closed and this,      * ThreadState is already checked out for flush.,      */,     boolean isActive() {,       assert this.isHeldByCurrentThread();,       return isActive;,     },     ,     boolean isInitialized() {,       assert this.isHeldByCurrentThread();,       return isActive() && dwpt != null;,     },     ,     /**,      * Returns the number of currently active bytes in this ThreadState's,      * {@link DocumentsWriterPerThread},      */,     public long getBytesUsedPerThread() {,       assert this.isHeldByCurrentThread();,       // public for FlushPolicy,       return bytesUsed;,     },     ,     /**,      * Returns this {@link ThreadState}s {@link DocumentsWriterPerThread},      */,     public DocumentsWriterPerThread getDocumentsWriterPerThread() {,       assert this.isHeldByCurrentThread();,       // public for FlushPolicy,       return dwpt;,     },     ,     /**,      * Returns <code>true</code> iff this {@link ThreadState} is marked as flush,      * pending otherwise <code>false</code>,      */,     public boolean isFlushPending() {,       return flushPending;],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/lucene/index/DocumentsWriterStallControl.java,waitIfStalled,74-74,[            wait();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/DefaultIndexingChain.java,invert,624-624,[            int startOffset = invertState.offset + invertState.offsetAttribute.startOffset();],,invert,668-668,[        invertState.offset += invertState.offsetAttribute.endOffset();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/DefaultIndexingChain.java,invert,667-667,[        invertState.position += invertState.posIncrAttribute.getPositionIncrement();],,invert,610-610,[          int posIncr = invertState.posIncrAttribute.getPositionIncrement();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/DefaultIndexingChain.java,invert,649-649,[            BytesRef bigTerm = invertState.termAttribute.getBytesRef();],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/index/FilteredTermsEnum.java,next,240-244,[          doSeek = true;,           // term accepted, but we need to seek so fall-through,         case YES:,           // term accepted,           return actualTerm;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/index/FreqProxFields.java,<init>,146-146,[      postingsArray = (FreqProxPostingsArray) terms.postingsArray;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/FreqProxFields.java,,301-304,[      return new TermState() {,         @Override,         public void copyFrom(TermState other) {,           throw new UnsupportedOperationException();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/index/FreqProxTermsWriterPerField.java,newPostingsArray,192-192,[    freqProxPostingsArray = (FreqProxPostingsArray) postingsArray;],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/lucene/index/FrozenBufferedUpdates.java,next,155-157,[            QueryAndLimit ret = new QueryAndLimit(queries[upto], queryLimits[upto]);,             upto++;,             return ret;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/index/IndexFileDeleter.java,<init>,146-146,[    long currentGen = segmentInfos.getGeneration();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/index/IndexFileDeleter.java,DecRef,776-777,[      assert count > 0: Thread.currentThread().getName() + ": RefCount is 0 pre-decrement for file \"" + fileName + "\"";,       return --count;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/index/IndexFileDeleter.java,IncRef,767-772,[      if (!initDone) {,         initDone = true;,       } else {,         assert count > 0: Thread.currentThread().getName() + ": RefCount is 0 pre-increment for file \"" + fileName + "\"";,       },       return ++count;],,
BAD_PRACTICE,DM_EXIT,org/apache/lucene/index/IndexUpgrader.java,parseArgs,91-91,[          System.exit(1);],,
BAD_PRACTICE,DM_EXIT,org/apache/lucene/index/IndexUpgrader.java,printUsage,67-67,[    System.exit(1);],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/lucene/index/IndexWriter.java,mergeMiddle,4085-4085,[        infoStream.message("IW", String.format(Locale.ROOT, "merged segment size=%.3f MB vs estimate=%.3f MB", merge.info.sizeInBytes()/1024./1024., merge.estimatedMergeBytes/1024/1024.));],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/IndexWriter.java,,4198-4198,[    return keepFullyDeletedSegments;],,,4194-4194,[    keepFullyDeletedSegments = v;],,,3396-3396,[    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;],,,3402-3402,[    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;],,,3392-3392,[        infoStream.message("IW", "merged segment " + merge.info + " is 100% deleted" +  (keepFullyDeletedSegments ? "" : "; skipping insert"));],,,3047-3047,[    if (!keepFullyDeletedSegments && result.allDeleted != null) {],,,3713-3713,[    if (!keepFullyDeletedSegments && result.allDeleted != null) {],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/index/IndexWriter.java,deletePendingFiles,4490-4491,[    deleter.deletePendingFiles();,   }],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/IndexWriter.java,changed,2246-2246,[    changeCount++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/IndexWriter.java,checkpointNoSIS,2240-2240,[    changeCount++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/IndexWriter.java,deleteAll,2127-2127,[            ++changeCount;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/IndexWriter.java,newSegmentName,1570-1570,[      changeCount++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/index/IndexWriter.java,setCommitData,2793-2793,[    ++changeCount;],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/lucene/index/IndexWriter.java,doWait,4182-4182,[      wait(1000);],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/index/IndexWriter.java,dropAll,571-571,[          } else if (priorE == null) {],,dropAll,569-569,[          if (doSave) {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/index/IndexWriterConfig.java,,94-94,[  public static long WRITE_LOCK_TIMEOUT = 1000;],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/lucene/index/LiveIndexWriterConfig.java,getMaxBufferedDocs,277-277,[    return maxBufferedDocs;],,setMaxBufferedDocs,259-267,[    if (maxBufferedDocs != IndexWriterConfig.DISABLE_AUTO_FLUSH && maxBufferedDocs < 2) {,       throw new IllegalArgumentException("maxBufferedDocs must at least be 2 when enabled");,     },     if (maxBufferedDocs == IndexWriterConfig.DISABLE_AUTO_FLUSH,         && ramBufferSizeMB == IndexWriterConfig.DISABLE_AUTO_FLUSH) {,       throw new IllegalArgumentException("at least one of ramBufferSize and maxBufferedDocs must be enabled");,     },     this.maxBufferedDocs = maxBufferedDocs;,     return this;],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/lucene/index/LiveIndexWriterConfig.java,getRAMBufferSizeMB,231-231,[    return ramBufferSizeMB;],,setRAMBufferSizeMB,218-226,[    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH && ramBufferSizeMB <= 0.0) {,       throw new IllegalArgumentException("ramBufferSize should be > 0.0 MB when enabled");,     },     if (ramBufferSizeMB == IndexWriterConfig.DISABLE_AUTO_FLUSH,         && maxBufferedDocs == IndexWriterConfig.DISABLE_AUTO_FLUSH) {,       throw new IllegalArgumentException("at least one of ramBufferSize and maxBufferedDocs must be enabled");,     },     this.ramBufferSizeMB = ramBufferSizeMB;,     return this;],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/lucene/index/LogMergePolicy.java,findMerges,488-488,[        message("seg=" + writer.segString(info) + " level=" + infoLevel.level + " size=" + String.format(Locale.ROOT, "%.3f MB", segBytes/1024/1024.) + extra, writer);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/index/LogMergePolicy.java,compareTo,444-444,[      return Float.compare(other.level, level);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/index/LogMergePolicy.java,,438-438,[      this.index = index;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/index/MappedMultiFields.java,docs,117-117,[      MultiDocsEnum docsEnum = (MultiDocsEnum) in.docs(liveDocs, mappingDocsEnum.multiDocsEnum, flags);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/index/MappedMultiFields.java,docsAndPositions,134-134,[      MultiDocsAndPositionsEnum docsAndPositionsEnum = (MultiDocsAndPositionsEnum) in.docsAndPositions(liveDocs, mappingDocsAndPositionsEnum.multiDocsAndPositionsEnum, flags);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MappingMultiDocsAndPositionsEnum.java,cost,142-142,[    for (EnumWithSlice enumWithSlice : subs) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MappingMultiDocsAndPositionsEnum.java,nextDoc,91-91,[          final int reader = subs[upto].slice.readerIndex;],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/lucene/index/MergePolicy.java,getMaxCFSSegmentSizeMB,526-526,[    return maxCFSSegmentSize/1024/1024.;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/MergePolicy.java,,258-258,[      if (aborted) {],,,193-193,[      aborted = true;],,,199-199,[      return aborted;],,,205-205,[      if (aborted) {],,,217-217,[        if (aborted) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/MergeState.java,,157-175,[    return new NormsProducer() {, ,       @Override,       public NumericDocValues getNorms(FieldInfo field) throws IOException {,         return reader.getNormValues(field.name);,       }, ,       @Override,       public void checkIntegrity() throws IOException {,         // We already checkIntegrity the entire reader up front in SegmentMerger,       }, ,       @Override,       public void close() {,       }, ,       @Override,       public long ramBytesUsed() {,         return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/MergeState.java,,181-224,[    return new DocValuesProducer() {, ,       @Override,       public NumericDocValues getNumeric(FieldInfo field) throws IOException {  ,         return reader.getNumericDocValues(field.name);,       }, ,       @Override,       public BinaryDocValues getBinary(FieldInfo field) throws IOException {,         return reader.getBinaryDocValues(field.name);,       }, ,       @Override,       public SortedDocValues getSorted(FieldInfo field) throws IOException {,         return reader.getSortedDocValues(field.name);,       }, ,       @Override,       public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {,         return reader.getSortedNumericDocValues(field.name);,       }, ,       @Override,       public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {,         return reader.getSortedSetDocValues(field.name);,       }, ,       @Override,       public Bits getDocsWithField(FieldInfo field) throws IOException {,         return reader.getDocsWithField(field.name);,       }, ,       @Override,       public void checkIntegrity() throws IOException {,         // We already checkIntegrity the entire reader up front in SegmentMerger,       }, ,       @Override,       public void close() {,       }, ,       @Override,       public long ramBytesUsed() {,         return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/MergeState.java,,287-314,[    return new FieldsProducer() {,       @Override,       public Iterator<String> iterator() {,         return fields.iterator();,       }, ,       @Override,       public Terms terms(String field) throws IOException {,         return fields.terms(field);,       }, ,       @Override,       public int size() {,         return fields.size();,       }, ,       @Override,       public void checkIntegrity() throws IOException {,         // We already checkIntegrity the entire reader up front in SegmentMerger,       }, ,       @Override,       public void close() {,       }, ,       @Override,       public long ramBytesUsed() {,         return 0;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/index/MockRandomMergePolicy.java,findMerges,56-56,[    int numSegments = segmentInfos.size();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MultiDocValues.java,count,288-288,[          return current.count();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MultiDocValues.java,valueAt,283-283,[          return current.valueAt(index);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MultiDocValues.java,nextOrd,719-719,[        return currentGlobalOrds.get(segmentOrd);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/MultiDocValues.java,,582-585,[            segmentToGlobalOrds[i] = new LongValues() {,               @Override,               public long get(long ord) {,                 return ord + newDeltas.get((int) ord);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/MultiDocValues.java,,590-593,[            segmentToGlobalOrds[i] = new LongValues() {,               @Override,               public long get(long ord) {,                 return ord + deltas.get(ord);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/MultiDocsAndPositionsEnum.java,getSubs,78-78,[    return subs;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MappingMultiDocsAndPositionsEnum.java,cost,143-143,[      cost += enumWithSlice.docsAndPositionsEnum.cost();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MultiDocsAndPositionsEnum.java,cost,185-185,[      cost += subs[i].docsAndPositionsEnum.cost();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/MultiDocsEnum.java,getSubs,80-80,[    return subs;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MappingMultiDocsEnum.java,cost,123-123,[      cost += enumWithSlice.docsEnum.cost();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/MultiDocsEnum.java,cost,146-146,[      cost += subs[i].docsEnum.cost();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/index/MultiFields.java,<init>,184-184,[    this.subSlices = subSlices;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/index/MultiFields.java,<init>,183-183,[    this.subs = subs;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/index/MultiPassIndexSplitter.java,main,144-144,[        } catch (Exception e) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/MultiTerms.java,getSubSlices,78-78,[    return subSlices;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/MultiTerms.java,getSubTerms,73-73,[    return subs;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/index/MultiTerms.java,<init>,51-51,[    this.subSlices = subSlices;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/index/MultiTerms.java,<init>,50-50,[    this.subs = subs;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/MultiTermsEnum.java,getMatchArray,70-70,[    return top;],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/lucene/index/NoDeletionPolicy.java,clone,44-44,[    return this;],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/lucene/index/NoMergeScheduler.java,clone,47-47,[    return this;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/NormValuesWriter.java,,73-76,[                               new Iterable<Number>() {,                                  @Override,                                  public Iterator<Number> iterator() {,                                    return new NumericIterator(maxDoc, values);],,
STYLE,INT_VACUOUS_COMPARISON,org/apache/lucene/index/NumericDocValuesFieldUpdates.java,merge,147-147,[    if (size  + otherUpdates.size > Integer.MAX_VALUE) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/NumericDocValuesFieldUpdates.java,,120-136,[    new InPlaceMergeSorter() {,       @Override,       protected void swap(int i, int j) {,         long tmpDoc = docs.get(j);,         docs.set(j, docs.get(i));,         docs.set(i, tmpDoc);,         ,         long tmpVal = values.get(j);,         values.set(j, values.get(i));,         values.set(i, tmpVal);,       },       ,       @Override,       protected int compare(int i, int j) {,         int x = (int) docs.get(i);,         int y = (int) docs.get(j);,         return (x < y) ? -1 : ((x == y) ? 0 : 1);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/index/ParallelLeafReader.java,getParallelReaders,328-328,[    return parallelReaders;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/index/ParallelLeafReader.java,,161-182,[    final Map<String,Terms> fields = new TreeMap<>();,     ,     ParallelFields() {,     },     ,     void addField(String fieldName, Terms terms) {,       fields.put(fieldName, terms);,     },     ,     @Override,     public Iterator<String> iterator() {,       return Collections.unmodifiableSet(fields.keySet()).iterator();,     },     ,     @Override,     public Terms terms(String field) {,       return fields.get(field);,     },     ,     @Override,     public int size() {,       return fields.size();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/PerThreadPKLookup.java,,49-52,[    Collections.sort(leaves, new Comparator<LeafReaderContext>() {,         @Override,         public int compare(LeafReaderContext c1, LeafReaderContext c2) {,           return c2.reader().numDocs() - c1.reader().numDocs();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/index/PersistentSnapshotDeletionPolicy.java,release,161-161,[        } catch (Exception e) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/index/PersistentSnapshotDeletionPolicy.java,snapshot,136-136,[        } catch (Exception e) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/PersistentSnapshotDeletionPolicy.java,,223-223,[    if (nextWriteGen == 0) {],,,226-226,[      return SNAPSHOTS_PREFIX + (nextWriteGen-1);],,,181-181,[    String fileName = SNAPSHOTS_PREFIX + nextWriteGen;],,,203-203,[    if (nextWriteGen > 0) {],,,209-209,[    nextWriteGen++;],,,204-204,[      String lastSaveFile = SNAPSHOTS_PREFIX + (nextWriteGen-1);],,,287-287,[      nextWriteGen = 1+genLoaded;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/index/PrefixCodedTerms.java,,53-95,[  class PrefixCodedTermsIterator implements Iterator<Term> {,     final IndexInput input;,     String field = "";,     BytesRefBuilder bytes = new BytesRefBuilder();,     Term term = new Term(field, bytes.get());, ,     PrefixCodedTermsIterator() {,       try {,         input = new RAMInputStream("PrefixCodedTermsIterator", buffer);,       } catch (IOException e) {,         throw new RuntimeException(e);,       },     }, ,     @Override,     public boolean hasNext() {,       return input.getFilePointer() < input.length();,     },     ,     @Override,     public Term next() {,       assert hasNext();,       try {,         int code = input.readVInt();,         if ((code & 1) != 0) {,           // new field,           field = input.readString();,         },         int prefix = code >>> 1;,         int suffix = input.readVInt();,         bytes.grow(prefix + suffix);,         input.readBytes(bytes.bytes(), prefix, suffix);,         bytes.setLength(prefix + suffix);,         term.set(field, bytes.get());,         return term;,       } catch (IOException e) {,         throw new RuntimeException(e);,       },     },     ,     @Override,     public void remove() {,       throw new UnsupportedOperationException();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/RandomIndexWriter.java,,117-121,[      w.addDocuments(new Iterable<IndexDocument>() {, ,         @Override,         public Iterator<IndexDocument> iterator() {,           return new Iterator<IndexDocument>() {],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/lucene/index/RandomIndexWriter.java,next,136-140,[              if (done) {,                 throw new IllegalStateException();,               },               done = true;,               return doc;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/RandomIndexWriter.java,,186-190,[      w.updateDocuments(t, new Iterable<IndexDocument>() {, ,         @Override,         public Iterator<IndexDocument> iterator() {,           return new Iterator<IndexDocument>() {],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/lucene/index/RandomIndexWriter.java,next,205-209,[              if (done) {,                 throw new IllegalStateException();,               },               done = true;,               return doc;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/ReadersAndUpdates.java,,135-135,[      if (liveDocs == null) {],,,136-136,[        liveDocs = reader.getLiveDocs();],,,191-191,[    if (liveDocs != null) {],,,192-192,[      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);],,,259-259,[    assert liveDocs.length() == info.info.getDocCount();],,,272-272,[      codec.liveDocsFormat().writeLiveDocs((MutableBits)liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);],,,582-582,[      SegmentReader newReader = new SegmentReader(info, reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);],,,233-233,[    return liveDocs;],,,151-151,[    assert liveDocs != null;],,,155-155,[    final boolean didDelete = liveDocs.get(docID);],,,153-153,[    assert docID >= 0 && docID < liveDocs.length() : "out of bounds: docid=" + docID + " liveDocsLength=" + liveDocs.length() + " seg=" + info.info.name + " docCount=" + info.info.getDocCount();],,,157-157,[      ((MutableBits) liveDocs).clear(docID);],,,211-211,[      if (liveDocs == null) {],,,215-215,[        liveDocs = liveDocsFormat.newLiveDocs(liveDocs);],,,213-213,[        liveDocs = liveDocsFormat.newLiveDocs(info.info.getDocCount());],,,223-223,[    return liveDocs;],,,115-115,[    if (liveDocs != null) {],,,118-118,[        if (liveDocs.get(docID)) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/index/ReadersAndUpdates.java,,132-132,[    if (reader == null) {],,,141-141,[    reader.incRef();],,,142-142,[    return reader;],,,134-134,[      reader = new SegmentReader(info, context);],,,136-136,[        liveDocs = reader.getLiveDocs();],,,185-185,[    if (reader == null) {],,,192-192,[      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);],,,196-196,[      reader.incRef();],,,195-195,[      assert reader.getLiveDocs() == null;],,,197-197,[      return reader;],,,187-187,[      assert reader != null;],,,168-168,[    if (reader != null) {],,,171-171,[        reader.decRef();],,,173-173,[        reader = null;],,,480-480,[      final SegmentReader reader = this.reader == null ? new SegmentReader(info, IOContext.READONCE) : this.reader;],,,520-520,[        if (reader != this.reader) {],,,581-581,[    if (reader != null) {],,,582-582,[      SegmentReader newReader = new SegmentReader(info, reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);],,,585-585,[        reader.decRef();],,,586-586,[        reader = newReader;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/ReadersAndUpdates.java,,317-325,[        fieldsConsumer.addNumericField(fieldInfo, new Iterable<Number>() {,           final NumericDocValues currentValues = reader.getNumericDocValues(field);,           final Bits docsWithField = reader.getDocsWithField(field);,           final int maxDoc = reader.maxDoc();,           final NumericDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();,           @Override,           public Iterator<Number> iterator() {,             updatesIter.reset();,             return new Iterator<Number>() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/ReadersAndUpdates.java,,390-398,[        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {,           final BinaryDocValues currentValues = reader.getBinaryDocValues(field);,           final Bits docsWithField = reader.getDocsWithField(field);,           final int maxDoc = reader.maxDoc();,           final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();,           @Override,           public Iterator<BytesRef> iterator() {,             updatesIter.reset();,             return new Iterator<BytesRef>() {],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/lucene/index/SegmentCommitInfo.java,clone,343-359,[    SegmentCommitInfo other = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, docValuesGen);,     // Not clear that we need to carry over nextWriteDelGen,     // (i.e. do we ever clone after a failed write and,     // before the next successful write?), but just do it to,     // be safe:,     other.nextWriteDelGen = nextWriteDelGen;,     other.nextWriteFieldInfosGen = nextWriteFieldInfosGen;,     other.nextWriteDocValuesGen = nextWriteDocValuesGen;,     ,     // deep clone,     for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {,       other.dvUpdatesFiles.put(e.getKey(), new HashSet<>(e.getValue()));,     },     ,     other.fieldInfosFiles.addAll(fieldInfosFiles);,     ,     return other;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/SegmentCoreReaders.java,,87-90,[  final CloseableThreadLocal<Map<String,Object>> normsLocal = new CloseableThreadLocal<Map<String,Object>>() {,     @Override,     protected Map<String,Object> initialValue() {,       return new HashMap<>();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/index/SegmentDocValues.java,decRef,93-93,[    if (t != null) {],,decRef,88-88,[        if (t != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/lucene/index/SegmentDocValues.java,decRef,93-93,[    if (t != null) {],,decRef,88-88,[        if (t != null) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/index/SegmentInfo.java,<init>,106-106,[    this.id = id;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/index/SegmentInfos.java,write,375-375,[        if (segmentID == null) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/index/SegmentInfos.java,run,519-519,[      long lastGen = -1;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/SegmentReader.java,,67-70,[  final CloseableThreadLocal<Map<String,Object>> docValuesLocal = new CloseableThreadLocal<Map<String,Object>>() {,     @Override,     protected Map<String,Object> initialValue() {,       return new HashMap<>();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/SegmentReader.java,,74-77,[  final CloseableThreadLocal<Map<String,Bits>> docsWithFieldLocal = new CloseableThreadLocal<Map<String,Bits>>() {,     @Override,     protected Map<String,Bits> initialValue() {,       return new HashMap<>();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/index/SlowCompositeReaderWrapper.java,getSortedSetDocValues,179-179,[    assert map != null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/SortedDocValuesWriter.java,,135-138,[                              new Iterable<Number>() {,                                 @Override,                                 public Iterator<Number> iterator() {,                                   return new OrdsIterator(ordMap, maxDoc, ords);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/SortedNumericDocValuesWriter.java,,113-116,[                              new Iterable<Number>() {,                                 @Override,                                 public Iterator<Number> iterator() {,                                   return new CountIterator(valueCounts);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/SortedNumericDocValuesWriter.java,,121-124,[                              new Iterable<Number>() {,                                 @Override,                                 public Iterator<Number> iterator() {,                                   return new ValuesIterator(values);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/index/SortedSetDocValuesWriter.java,addOneValue,135-135,[      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * RamUsageEstimator.NUM_BYTES_INT);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/SortedSetDocValuesWriter.java,,175-178,[                              new Iterable<Number>() {,                                 @Override,                                 public Iterator<Number> iterator() {,                                   return new OrdCountIterator(maxDoc, ordCounts);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/SortedSetDocValuesWriter.java,,183-186,[                              new Iterable<Number>() {,                                 @Override,                                 public Iterator<Number> iterator() {,                                   return new OrdsIterator(ordMap, maxCountPerDoc, ords, ordCounts);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/lucene/index/Sorter.java,getID,256-256,[    return sort.toString();],,getId,217-217,[      return id;],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/index/Sorter.java,isConsistent,77-77,[      if (i != oldID || newID < 0 || newID >= maxDoc) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/SortingLeafReader.java,restore,406-406,[          freqs[j] = tmpFreqs[i];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/SortingMergePolicy.java,map,162-162,[          final int newWithDeletes = docMap.oldToNew(oldWithDeletes);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/index/SuppressingConcurrentMergeScheduler.java,handleMergeException,35-35,[        super.handleMergeException(exc);],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/lucene/index/TermVectorsConsumer.java,flush,59-59,[      int numDocs = state.segmentInfo.getDocCount();],,flush,64-64,[        assert state.segmentInfo != null;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/index/TermVectorsConsumerPerField.java,newPostingsArray,247-247,[    termVectorsPostingsArray = (TermVectorsPostingsArray) postingsArray;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/Terms.java,,66-72,[      return new AutomatonTermsEnum(iterator(null), compiled) {,         @Override,         protected BytesRef nextSeekTerm(BytesRef term) throws IOException {,           if (term == null) {,             term = startTerm;,           },           return super.nextSeekTerm(term);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/TermsEnum.java,,205-208,[    return new TermState() {,       @Override,       public void copyFrom(TermState other) {,         throw new UnsupportedOperationException();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/index/TermsHash.java,,49-49,[    this.trackAllocations = trackAllocations; ],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/index/TermsHashPerField.java,compareTo,279-279,[    return fieldInfo.name.compareTo(other.fieldInfo.name);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/index/TermsHashPerField.java,init,246-246,[        bytesUsed.addAndGet(perField.postingsArray.size * perField.postingsArray.bytesPerPosting());],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/lucene/index/TermsHashPerField.java,clear,268-268,[      return null;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java,runTest,516-516,[    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java,run,220-220,[                    doc.removeField("packID");],,run,196-196,[                      if (doc == null) {],,run,197-197,[                        break;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java,warm,469-469,[        warmed.put(((SegmentReader) reader).core, Boolean.TRUE);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java,,491-498,[      conf.setInfoStream(new PrintStreamInfoStream(System.out) {,           @Override,           public void message(String component, String message) {,             if ("TP".equals(component)) {,               return; // ignore test points!,             },             super.message(component, message);,           }],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/lucene/index/TieredMergePolicy.java,findMerges,306-306,[        message("  seg=" + writer.segString(info) + " size=" + String.format(Locale.ROOT, "%.3f", segBytes/1024/1024.) + " MB" + extra, writer);],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/lucene/index/TieredMergePolicy.java,getMaxMergedSegmentMB,153-153,[    return maxMergedSegmentBytes/1024/1024.;],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/lucene/index/TieredMergePolicy.java,toString,644-644,[    sb.append("maxMergedSegmentMB=").append(maxMergedSegmentBytes/1024/1024.).append(", ");],,toString,645-645,[    sb.append("floorSegmentMB=").append(floorSegmentBytes/1024/1024.).append(", ");],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/index/memory/MemoryIndex.java,<init>,239-239,[    final int maxBufferedIntBlocks = (int) ((maxReusedBytes - (maxBufferedByteBlocks*ByteBlockPool.BYTE_BLOCK_SIZE))/(IntBlockPool.INT_BLOCK_SIZE * RamUsageEstimator.NUM_BYTES_INT));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/index/memory/MemoryIndex.java,addField,469-469,[    } catch (Exception e) { // can never happen],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/memory/MemoryIndex.java,,293-312,[    return new TokenStream() {,       private Iterator<T> iter = keywords.iterator();,       private int start = 0;,       private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);,       private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);,       ,       @Override,       public boolean incrementToken() {,         if (!iter.hasNext()) return false;,         ,         T obj = iter.next();,         if (obj == null) ,           throw new IllegalArgumentException("keyword must not be null");,         ,         String term = obj.toString();,         clearAttributes();,         termAtt.setEmpty().append(term);,         offsetAtt.setOffset(start, start+termAtt.length());,         start += term.length() + 1; // separate words by 1 (blank) character,         return true;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/index/memory/MemoryIndex.java,,542-557,[      searcher.search(query, new SimpleCollector() {,         private Scorer scorer;, ,         @Override,         public void collect(int doc) throws IOException {,           scores[0] = scorer.score();,         }, ,         @Override,         public void setScorer(Scorer scorer) {,           this.scorer = scorer;,         }, ,         @Override,         public boolean acceptsDocsOutOfOrder() {,           return true;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/index/memory/MemoryIndex.java,collect,547-547,[          scores[0] = scorer.score();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/index/memory/MemoryIndex.java,getInfo,755-755,[      return fields.get(fieldName);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/index/memory/MemoryIndex.java,seekExact,989-989,[        this.seekExact(((OrdTermState)state).ord);],,
BAD_PRACTICE,VA_FORMAT_STRING_USES_NEWLINE,org/apache/lucene/misc/GetTermInfo.java,getTermInfo,53-53,[    System.out.printf(Locale.ROOT, "%s:%s \t totalTF = %,d \t doc freq = %,d \n",],,
BAD_PRACTICE,VA_FORMAT_STRING_USES_NEWLINE,org/apache/lucene/misc/HighFreqTerms.java,main,80-80,[      System.out.printf(Locale.ROOT, "%s:%s \t totalTF = %,d \t docFreq = %,d \n",],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/misc/HighFreqTerms.java,,135-146,[  public static final class DocFreqComparator implements Comparator<TermStats> {,     ,     @Override,     public int compare(TermStats a, TermStats b) {,       int res = Long.compare(a.docFreq, b.docFreq);,       if (res == 0) {,         res = a.field.compareTo(b.field);,         if (res == 0) {,           res = a.termtext.compareTo(b.termtext);,         },       },       return res;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/misc/HighFreqTerms.java,,153-164,[  public static final class TotalTermFreqComparator implements Comparator<TermStats> {,     ,     @Override,     public int compare(TermStats a, TermStats b) {,       int res = Long.compare(a.totalTermFreq, b.totalTermFreq);,       if (res == 0) {,         res = a.field.compareTo(b.field);,         if (res == 0) {,           res = a.termtext.compareTo(b.termtext);,         },       },       return res;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/mockfile/DisableFsyncFS.java,,46-48,[    return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {,       @Override,       public void force(boolean metaData) throws IOException {}],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/mockfile/DisableFsyncFS.java,,54-56,[    return new FilterAsynchronousFileChannel(super.newAsynchronousFileChannel(path, options, executor, attrs)) {,       @Override,       public void force(boolean metaData) throws IOException {}],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/lucene/mockfile/FilterFileChannel.java,implCloseChannel,148-148,[        method.setAccessible(true);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/mockfile/FilterFileStore.java,,52-52,[    this.scheme = Objects.requireNonNull(scheme);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/mockfile/FilterPath.java,compareTo,38-38,[public class FilterPath implements Path {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/mockfile/VerboseFS.java,,262-262,[      this.dir = dir;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queries/CommonTermsQuery.java,equals,403-403,[    if (lowFreqMinNrShouldMatch != other.lowFreqMinNrShouldMatch) return false;],,equals,404-404,[    if (highFreqMinNrShouldMatch != other.highFreqMinNrShouldMatch) return false;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/queries/CustomScoreProvider.java,,47-47,[    this.context = context;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/queries/CustomScoreQuery.java,getScoringQueries,391-391,[    return scoringQueries;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queries/CustomScoreQuery.java,equals,155-155,[    if (this.getBoost() != other.getBoost() ||],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/queries/CustomScoreQuery.java,,287-353,[  private class CustomScorer extends Scorer {,     private final float qWeight;,     private final Scorer subQueryScorer;,     private final Scorer[] valSrcScorers;,     private final CustomScoreProvider provider;,     private final float[] vScores; // reused in score() to avoid allocating this array for each doc, ,     // constructor,     private CustomScorer(CustomScoreProvider provider, CustomWeight w, float qWeight,,         Scorer subQueryScorer, Scorer[] valSrcScorers) {,       super(w);,       this.qWeight = qWeight;,       this.subQueryScorer = subQueryScorer;,       this.valSrcScorers = valSrcScorers;,       this.vScores = new float[valSrcScorers.length];,       this.provider = provider;,     }, ,     @Override,     public int nextDoc() throws IOException {,       int doc = subQueryScorer.nextDoc();,       if (doc != NO_MORE_DOCS) {,         for (Scorer valSrcScorer : valSrcScorers) {,           valSrcScorer.advance(doc);,         },       },       return doc;,     }, ,     @Override,     public int docID() {,       return subQueryScorer.docID();,     },     ,     /*(non-Javadoc) @see org.apache.lucene.search.Scorer#score() */,     @Override,     public float score() throws IOException {,       for (int i = 0; i < valSrcScorers.length; i++) {,         vScores[i] = valSrcScorers[i].score();,       },       return qWeight * provider.customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);,     }, ,     @Override,     public int freq() throws IOException {,       return subQueryScorer.freq();,     }, ,     @Override,     public Collection<ChildScorer> getChildren() {,       return Collections.singleton(new ChildScorer(subQueryScorer, "CUSTOM"));,     }, ,     @Override,     public int advance(int target) throws IOException {,       int doc = subQueryScorer.advance(target);,       if (doc != NO_MORE_DOCS) {,         for (Scorer valSrcScorer : valSrcScorers) {,           valSrcScorer.advance(doc);,         },       },       return doc;,     }, ,     @Override,     public long cost() {,       return subQueryScorer.cost();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queries/CustomScoreQuery.java,doExplain,252-252,[      return explain == null ? new Explanation(0.0f, "no matching docs") : explain;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/TermFilter.java,,69-77,[    return new DocIdSet() {,       @Override,       public DocIdSetIterator iterator() throws IOException {,         return termsEnum.docs(acceptDocs, null, DocsEnum.FLAG_NONE);,       }, ,       @Override,       public long ramBytesUsed() {,         return 0L;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queries/function/BoostedQuery.java,,75-75,[      this.searcher = searcher;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queries/function/FunctionQuery.java,equals,204-204,[    return this.getBoost() == other.getBoost()],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/queries/function/FunctionQuery.java,,69-69,[      this.searcher = searcher;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/queries/function/ValueSource.java,compareBottom,148-148,[      return Double.compare(bottom, docVals.doubleVal(doc));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/queries/function/ValueSource.java,compareTop,179-179,[      final double docValue = docVals.doubleVal(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/queries/function/ValueSource.java,copy,153-153,[      values[slot] = docVals.doubleVal(doc);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/queries/function/docvalues/DocTermsIndexDocValues.java,,42-42,[  protected final MutableValueStr val = new MutableValueStr();],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/DocFreqValueSource.java,equals,167-169,[    if (this.getClass() != o.getClass()) return false;,     DocFreqValueSource other = (DocFreqValueSource)o;,     return this.indexedField.equals(other.indexedField) && this.indexedBytes.equals(other.indexedBytes);],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/DoubleFieldSource.java,equals,85-85,[    if (o.getClass() != DoubleFieldSource.class) return false;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/DoubleFieldSource.java,equals,85-87,[    if (o.getClass() != DoubleFieldSource.class) return false;,     DoubleFieldSource other = (DoubleFieldSource) o;,     return super.equals(other);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/function/valuesource/DoubleFieldSource.java,,52-65,[    return new DoubleDocValues(this) {,       @Override,       public double doubleVal(int doc) {,         return Double.longBitsToDouble(arr.get(doc));,       }, ,       @Override,       public boolean exists(int doc) {,         return arr.get(doc) != 0 || valid.get(doc);,       }, ,       @Override,       public ValueFiller getValueFiller() {,         return new ValueFiller() {],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/DualFloatFunction.java,equals,96-99,[    if (this.getClass() != o.getClass()) return false;,     DualFloatFunction other = (DualFloatFunction)o;,     return this.a.equals(other.a),         && this.b.equals(other.b);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queries/function/valuesource/EnumFieldSource.java,getRangeScorer,132-132,[          if (!includeLower && lower < Integer.MAX_VALUE) lower++;],,getRangeScorer,138-138,[          if (!includeUpper && upper > Integer.MIN_VALUE) upper--;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queries/function/valuesource/EnumFieldSource.java,,104-104,[      final MutableValueInt val = new MutableValueInt();],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/FloatFieldSource.java,equals,86-86,[    if (o.getClass() !=  FloatFieldSource.class) return false;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/FloatFieldSource.java,equals,86-88,[    if (o.getClass() !=  FloatFieldSource.class) return false;,     FloatFieldSource other = (FloatFieldSource)o;,     return super.equals(other);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/function/valuesource/FloatFieldSource.java,,52-65,[    return new FloatDocValues(this) {,       @Override,       public float floatVal(int doc) {,         return Float.intBitsToFloat((int)arr.get(doc));,       }, ,       @Override,       public boolean exists(int doc) {,         return arr.get(doc) != 0 || valid.get(doc);,       }, ,       @Override,       public ValueFiller getValueFiller() {,         return new ValueFiller() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/function/valuesource/IfFunction.java,,52-117,[    return new FunctionValues() {,       @Override,       public byte byteVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.byteVal(doc) : falseVals.byteVal(doc);,       }, ,       @Override,       public short shortVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.shortVal(doc) : falseVals.shortVal(doc);,       }, ,       @Override,       public float floatVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.floatVal(doc) : falseVals.floatVal(doc);,       }, ,       @Override,       public int intVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.intVal(doc) : falseVals.intVal(doc);,       }, ,       @Override,       public long longVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.longVal(doc) : falseVals.longVal(doc);,       }, ,       @Override,       public double doubleVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.doubleVal(doc) : falseVals.doubleVal(doc);,       }, ,       @Override,       public String strVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.strVal(doc) : falseVals.strVal(doc);,       }, ,       @Override,       public boolean boolVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.boolVal(doc) : falseVals.boolVal(doc);,       }, ,       @Override,       public boolean bytesVal(int doc, BytesRefBuilder target) {,         return ifVals.boolVal(doc) ? trueVals.bytesVal(doc, target) : falseVals.bytesVal(doc, target);,       }, ,       @Override,       public Object objectVal(int doc) {,         return ifVals.boolVal(doc) ? trueVals.objectVal(doc) : falseVals.objectVal(doc);,       }, ,       @Override,       public boolean exists(int doc) {,         return ifVals.boolVal(doc) ? trueVals.exists(doc) : falseVals.exists(doc);,       }, ,       @Override,       public ValueFiller getValueFiller() {,         // TODO: we need types of trueSource / falseSource to handle this,         // for now, use float.,         return super.getValueFiller();,       }, ,       @Override,       public String toString(int doc) {,         return "if(" + ifVals.toString(doc) + ',' + trueVals.toString(doc) + ',' + falseVals.toString(doc) + ')';],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/IntFieldSource.java,equals,93-93,[    if (o.getClass() !=  IntFieldSource.class) return false;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/IntFieldSource.java,equals,93-95,[    if (o.getClass() !=  IntFieldSource.class) return false;,     IntFieldSource other = (IntFieldSource)o;,     return super.equals(other);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/function/valuesource/IntFieldSource.java,,53-73,[    return new IntDocValues(this) {,       final MutableValueInt val = new MutableValueInt();, ,       @Override,       public int intVal(int doc) {,         return (int) arr.get(doc);,       }, ,       @Override,       public String strVal(int doc) {,         return Integer.toString(intVal(doc));,       }, ,       @Override,       public boolean exists(int doc) {,         return arr.get(doc) != 0 || valid.get(doc);,       }, ,       @Override,       public ValueFiller getValueFiller() {,         return new ValueFiller() {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queries/function/valuesource/IntFieldSource.java,,54-54,[      final MutableValueInt val = new MutableValueInt();],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java,equals,86-86,[    if (o.getClass() !=  JoinDocFreqValueSource.class) return false;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java,equals,86-89,[    if (o.getClass() !=  JoinDocFreqValueSource.class) return false;,     JoinDocFreqValueSource other = (JoinDocFreqValueSource)o;,     if( !qfield.equals( other.qfield ) ) return false;,     return super.equals(other);],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/LinearFloatFunction.java,equals,88-88,[    if (LinearFloatFunction.class != o.getClass()) return false;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queries/function/valuesource/LinearFloatFunction.java,equals,90-90,[    return  this.slope == other.slope],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/LinearFloatFunction.java,equals,88-92,[    if (LinearFloatFunction.class != o.getClass()) return false;,     LinearFloatFunction other = (LinearFloatFunction)o;,     return  this.slope == other.slope,          && this.intercept == other.intercept,          && this.source.equals(other.source);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/LongFieldSource.java,equals,117-119,[    if (o.getClass() != this.getClass()) return false;,     LongFieldSource other = (LongFieldSource) o;,     return super.equals(other);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/MaxDocValueSource.java,equals,56-56,[    return this.getClass() == o.getClass();],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/MultiBoolFunction.java,equals,100-102,[    if (this.getClass() != o.getClass()) return false;,     MultiBoolFunction other = (MultiBoolFunction)o;,     return this.sources.equals(other.sources);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queries/function/valuesource/MultiFloatFunction.java,<init>,38-38,[    this.sources = sources;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/MultiFloatFunction.java,equals,108-111,[    if (this.getClass() != o.getClass()) return false;,     MultiFloatFunction other = (MultiFloatFunction)o;,     return this.name().equals(other.name()),             && Arrays.equals(this.sources, other.sources);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/MultiFunction.java,equals,149-151,[    if (this.getClass() != o.getClass()) return false;,     MultiFunction other = (MultiFunction)o;,     return this.sources.equals(other.sources);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queries/function/valuesource/MultiFunction.java,<init>,104-104,[      this.valsArr = valsArr;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/NormValueSource.java,equals,81-84,[    if (this.getClass() != o.getClass()) {,       return false;,     },     return this.field.equals(((NormValueSource)o).field);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/function/valuesource/NormValueSource.java,,71-74,[    return new FloatDocValues(this) {,       @Override,       public float floatVal(int doc) {,         return similarity.decodeNormValue(norms.get(doc));],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/NumDocsValueSource.java,equals,51-51,[    return this.getClass() == o.getClass();],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/lucene/queries/function/valuesource/QueryValueSource.java,createWeight,115-115,[      vs.createWeight(fcontext, weightSearcher);],,createWeight,108-108,[        weightSearcher = new IndexSearcher(ReaderUtil.getTopLevelContext(readerContext));],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queries/function/valuesource/QueryValueSource.java,,102-102,[    this.fcontext = fcontext;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/queries/function/valuesource/QueryValueSource.java,objectVal,186-186,[       return exists(doc) ? scorer.score() : null;],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/QueryValueSource.java,equals,65-65,[    if (QueryValueSource.class != o.getClass()) return false;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queries/function/valuesource/QueryValueSource.java,equals,67-67,[    return this.q.equals(other.q) && this.defVal==other.defVal;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/QueryValueSource.java,equals,65-67,[    if (QueryValueSource.class != o.getClass()) return false;,     QueryValueSource other = (QueryValueSource)o;,     return this.q.equals(other.q) && this.defVal==other.defVal;],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/RangeMapFloatFunction.java,equals,99-99,[    if (RangeMapFloatFunction.class != o.getClass()) return false;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queries/function/valuesource/RangeMapFloatFunction.java,equals,101-101,[    return  this.min == other.min],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/RangeMapFloatFunction.java,equals,99-105,[    if (RangeMapFloatFunction.class != o.getClass()) return false;,     RangeMapFloatFunction other = (RangeMapFloatFunction)o;,     return  this.min == other.min,          && this.max == other.max,          && this.target.equals(other.target),          && this.source.equals(other.source),          && (this.defaultVal == other.defaultVal || (this.defaultVal != null && this.defaultVal.equals(other.defaultVal)));],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/ReciprocalFloatFunction.java,equals,105-105,[    if (ReciprocalFloatFunction.class != o.getClass()) return false;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queries/function/valuesource/ReciprocalFloatFunction.java,equals,107-107,[    return this.m == other.m],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/ReciprocalFloatFunction.java,equals,105-110,[    if (ReciprocalFloatFunction.class != o.getClass()) return false;,     ReciprocalFloatFunction other = (ReciprocalFloatFunction)o;,     return this.m == other.m,             && this.a == other.a,             && this.b == other.b,             && this.source.equals(other.source);],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java,equals,153-153,[    if (ScaleFloatFunction.class != o.getClass()) return false;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java,equals,155-155,[    return this.min == other.min],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java,equals,153-157,[    if (ScaleFloatFunction.class != o.getClass()) return false;,     ScaleFloatFunction other = (ScaleFloatFunction)o;,     return this.min == other.min,          && this.max == other.max,          && this.source.equals(other.source);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/SimpleBoolFunction.java,equals,74-76,[    if (this.getClass() != o.getClass()) return false;,     SimpleBoolFunction other = (SimpleBoolFunction)o;,     return this.source.equals(other.source);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/SingleFunction.java,equals,49-52,[    if (this.getClass() != o.getClass()) return false;,     SingleFunction other = (SingleFunction)o;,     return this.name().equals(other.name()),          && this.source.equals(other.source);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/function/valuesource/SortedSetFieldSource.java,,55-63,[    return new DocTermsIndexDocValues(this, view) {,       @Override,       protected String toTerm(String readableValue) {,         return readableValue;,       }, ,       @Override,       public Object objectVal(int doc) {,         return strVal(doc);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/SumTotalTermFreqValueSource.java,equals,89-91,[    if (this.getClass() != o.getClass()) return false;,     SumTotalTermFreqValueSource other = (SumTotalTermFreqValueSource)o;,     return this.indexedField.equals(other.indexedField);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/function/valuesource/SumTotalTermFreqValueSource.java,,74-77,[    context.put(this, new LongDocValues(this) {,       @Override,       public long longVal(int doc) {,         return ttf;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/queries/function/valuesource/TotalTermFreqValueSource.java,equals,93-95,[    if (this.getClass() != o.getClass()) return false;,     TotalTermFreqValueSource other = (TotalTermFreqValueSource)o;,     return this.indexedField.equals(other.indexedField) && this.indexedBytes.equals(other.indexedBytes);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/queries/function/valuesource/TotalTermFreqValueSource.java,,78-81,[    context.put(this, new LongDocValues(this) {,       @Override,       public long longVal(int doc) {,         return ttf;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/queries/mlt/MoreLikeThis.java,getFieldNames,461-461,[    return fieldNames;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queries/mlt/MoreLikeThis.java,setFieldNames,473-473,[    this.fieldNames = fieldNames;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queries/mlt/MoreLikeThis.java,,191-191,[  public static final String[] DEFAULT_FIELD_NAMES = new String[]{"contents"};],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/queries/mlt/MoreLikeThis.java,createQueue,658-658,[      int tf = words.get(word).x; // term freq in the source doc],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/queries/mlt/MoreLikeThis.java,retrieveTerms,763-763,[        Collection<Object> fieldValues = fields.get(field);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queries/mlt/MoreLikeThis.java,,958-958,[      this.docFreq = docFreq;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queries/mlt/MoreLikeThis.java,,957-957,[      this.idf = idf;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queries/mlt/MoreLikeThis.java,,959-959,[      this.tf = tf;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/queries/mlt/MoreLikeThisQuery.java,getMoreLikeFields,129-129,[    return moreLikeFields;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queries/mlt/MoreLikeThisQuery.java,<init>,56-56,[    this.moreLikeFields = moreLikeFields;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queries/mlt/MoreLikeThisQuery.java,setMoreLikeFields,133-133,[    this.moreLikeFields = moreLikeFields;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/FastCharStream.java,BeginToken,82-83,[    tokenStart = bufferPosition;,     return readChar();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/FastCharStream.java,Done,106-109,[      input.close();,     } catch (IOException e) {,     },   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/FastCharStream.java,GetImage,93-93,[    return new String(buffer, tokenStart, bufferPosition - tokenStart);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/FastCharStream.java,GetSuffix,98-100,[    char[] value = new char[len];,     System.arraycopy(buffer, bufferPosition - len, value, 0, len);,     return value;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java,<init>,94-94,[    this.fields = fields;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queryparser/classic/ParseException.java,<init>,36-36,[    expectedTokenSequences = expectedTokenSequencesVal;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queryparser/classic/ParseException.java,<init>,37-37,[    tokenImage = tokenImageVal;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/lucene/queryparser/classic/ParseException.java,initialise,117-117,[      retval += " \"";],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParser.java,Clause,215-268,[  Token fieldToken=null, boost=null;,     if (jj_2_1(2)) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case TERM:,         fieldToken = jj_consume_token(TERM);,         jj_consume_token(COLON);,                                field=discardEscapeChar(fieldToken.image);,         break;,       case STAR:,         jj_consume_token(STAR);,         jj_consume_token(COLON);,                       field="*";,         break;,       default:,         jj_la1[5] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     } else {,       ;,     },     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case BAREOPER:,     case STAR:,     case QUOTED:,     case TERM:,     case PREFIXTERM:,     case WILDTERM:,     case REGEXPTERM:,     case RANGEIN_START:,     case RANGEEX_START:,     case NUMBER:,       q = Term(field);,       break;,     case LPAREN:,       jj_consume_token(LPAREN);,       q = Query(field);,       jj_consume_token(RPAREN);,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[6] = jj_gen;,         ;,       },       break;,     default:,       jj_la1[7] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },        {if (true) return handleBoost(q, boost);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParser.java,Conjunction,97-120,[  int ret = CONJ_NONE;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case AND:,     case OR:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case AND:,         jj_consume_token(AND);,             ret = CONJ_AND;,         break;,       case OR:,         jj_consume_token(OR);,               ret = CONJ_OR;,         break;,       default:,         jj_la1[0] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[1] = jj_gen;,       ;,     },     {if (true) return ret;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParser.java,Modifiers,125-153,[  int ret = MOD_NONE;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case NOT:,     case PLUS:,     case MINUS:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case PLUS:,         jj_consume_token(PLUS);,               ret = MOD_REQ;,         break;,       case MINUS:,         jj_consume_token(MINUS);,                  ret = MOD_NOT;,         break;,       case NOT:,         jj_consume_token(NOT);,                ret = MOD_NOT;,         break;,       default:,         jj_la1[2] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[3] = jj_gen;,       ;,     },     {if (true) return ret;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParser.java,Query,167-208,[  List<BooleanClause> clauses = new ArrayList<>();,   Query q, firstQuery=null;,   int conj, mods;,     mods = Modifiers();,     q = Clause(field);,     addClause(clauses, CONJ_NONE, mods, q);,     if (mods == MOD_NONE),         firstQuery=q;,     label_1:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case AND:,       case OR:,       case NOT:,       case PLUS:,       case MINUS:,       case BAREOPER:,       case LPAREN:,       case STAR:,       case QUOTED:,       case TERM:,       case PREFIXTERM:,       case WILDTERM:,       case REGEXPTERM:,       case RANGEIN_START:,       case RANGEEX_START:,       case NUMBER:,         ;,         break;,       default:,         jj_la1[4] = jj_gen;,         break label_1;,       },       conj = Conjunction();,       mods = Modifiers();,       q = Clause(field);,       addClause(clauses, conj, mods, q);,     },       if (clauses.size() == 1 && firstQuery != null),         {if (true) return firstQuery;},       else {,   {if (true) return getBooleanQuery(clauses);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParser.java,ReInit,531-537,[    token_source.ReInit(stream);,     token = new Token();,     jj_ntk = -1;,     jj_gen = 0;,     for (int i = 0; i < 21; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParser.java,ReInit,551-557,[    token_source = tm;,     token = new Token();,     jj_ntk = -1;,     jj_gen = 0;,     for (int i = 0; i < 21; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParser.java,Term,273-459,[  Token term, boost=null, fuzzySlop=null, goop1, goop2;,   boolean prefix = false;,   boolean wildcard = false;,   boolean fuzzy = false;,   boolean regexp = false;,   boolean startInc=false;,   boolean endInc=false;,   Query q;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case BAREOPER:,     case STAR:,     case TERM:,     case PREFIXTERM:,     case WILDTERM:,     case REGEXPTERM:,     case NUMBER:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case TERM:,         term = jj_consume_token(TERM);,         break;,       case STAR:,         term = jj_consume_token(STAR);,                        wildcard=true;,         break;,       case PREFIXTERM:,         term = jj_consume_token(PREFIXTERM);,                              prefix=true;,         break;,       case WILDTERM:,         term = jj_consume_token(WILDTERM);,                            wildcard=true;,         break;,       case REGEXPTERM:,         term = jj_consume_token(REGEXPTERM);,                              regexp=true;,         break;,       case NUMBER:,         term = jj_consume_token(NUMBER);,         break;,       case BAREOPER:,         term = jj_consume_token(BAREOPER);,                            term.image = term.image.substring(0,1);,         break;,       default:,         jj_la1[8] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case FUZZY_SLOP:,         fuzzySlop = jj_consume_token(FUZZY_SLOP);,                                 fuzzy=true;,         break;,       default:,         jj_la1[9] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,         case FUZZY_SLOP:,           fuzzySlop = jj_consume_token(FUZZY_SLOP);,                                                          fuzzy=true;,           break;,         default:,           jj_la1[10] = jj_gen;,           ;,         },         break;,       default:,         jj_la1[11] = jj_gen;,         ;,       },        q = handleBareTokenQuery(field, term, fuzzySlop, prefix, wildcard, fuzzy, regexp);,       break;,     case RANGEIN_START:,     case RANGEEX_START:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGEIN_START:,         jj_consume_token(RANGEIN_START);,                             startInc=true;,         break;,       case RANGEEX_START:,         jj_consume_token(RANGEEX_START);,         break;,       default:,         jj_la1[12] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_GOOP:,         goop1 = jj_consume_token(RANGE_GOOP);,         break;,       case RANGE_QUOTED:,         goop1 = jj_consume_token(RANGE_QUOTED);,         break;,       default:,         jj_la1[13] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_TO:,         jj_consume_token(RANGE_TO);,         break;,       default:,         jj_la1[14] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_GOOP:,         goop2 = jj_consume_token(RANGE_GOOP);,         break;,       case RANGE_QUOTED:,         goop2 = jj_consume_token(RANGE_QUOTED);,         break;,       default:,         jj_la1[15] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGEIN_END:,         jj_consume_token(RANGEIN_END);,                           endInc=true;,         break;,       case RANGEEX_END:,         jj_consume_token(RANGEEX_END);,         break;,       default:,         jj_la1[16] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[17] = jj_gen;,         ;,       },           boolean startOpen=false;,           boolean endOpen=false;,           if (goop1.kind == RANGE_QUOTED) {,             goop1.image = goop1.image.substring(1, goop1.image.length()-1);,           } else if ("*".equals(goop1.image)) {,             startOpen=true;,           },           if (goop2.kind == RANGE_QUOTED) {,             goop2.image = goop2.image.substring(1, goop2.image.length()-1);,           } else if ("*".equals(goop2.image)) {,             endOpen=true;,           },           q = getRangeQuery(field, startOpen ? null : discardEscapeChar(goop1.image), endOpen ? null : discardEscapeChar(goop2.image), startInc, endInc);,       break;,     case QUOTED:,       term = jj_consume_token(QUOTED);,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case FUZZY_SLOP:,         fuzzySlop = jj_consume_token(FUZZY_SLOP);,         break;,       default:,         jj_la1[18] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[19] = jj_gen;,         ;,       },          q = handleQuotedTerm(field, term, fuzzySlop);,       break;,     default:,       jj_la1[20] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     {if (true) return handleBoost(q, boost);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParser.java,TopLevelQuery,160-162,[    q = Query(field);,     jj_consume_token(0);,     {if (true) return q;}],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/queryparser/classic/QueryParser.java,jj_rescan_token,717-718,[          switch (i) {,             case 0: jj_3_1(); break;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/queryparser/classic/QueryParserBase.java,handleBareFuzzy,865-865,[    } catch (Exception ignored) { }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/queryparser/classic/QueryParserBase.java,getRangeQuery,529-529,[    } catch (Exception e) { }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/queryparser/classic/QueryParserBase.java,handleBoost,894-894,[      catch (Exception ignored) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/queryparser/classic/QueryParserBase.java,handleQuotedTerm,882-882,[      catch (Exception ignored) { }],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queryparser/classic/QueryParserBase.java,handleBareFuzzy,868-868,[    } else if (fms >= 1.0f && fms != (int) fms) {],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/lucene/queryparser/classic/QueryParserBase.java,getRangeQuery,532-532,[      Date d2 = df.parse(part2);],,getRangeQuery,519-519,[      part2 = part2==null ? null : part2.toLowerCase(locale);],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/lucene/queryparser/classic/QueryParserBase.java,getRangeQuery,528-528,[      part1 = DateTools.dateToString(df.parse(part1), resolution);],,getRangeQuery,518-518,[      part1 = part1==null ? null : part1.toLowerCase(locale);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/queryparser/classic/QueryParserBase.java,getRangeQuery,546-546,[    } catch (Exception e) { }],,
MALICIOUS_CODE,MS_OOI_PKGPROTECT,org/apache/lucene/queryparser/classic/QueryParserConstants.java,,84-84,[  String[] tokenImage = {],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,jjMoveNfa_2,424-429,[                  if ((0x97ffffff87ffffffL & l) == 0L),                      break;,                   if (kind > 23),                      kind = 23;,                   jjCheckNAddTwoStates(33, 34);,                   break;],,jjMoveNfa_2,431-436,[                  if ((0x97ffffff87ffffffL & l) == 0L),                      break;,                   if (kind > 23),                      kind = 23;,                   jjCheckNAddTwoStates(33, 34);,                   break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,jjMoveNfa_2,508-513,[                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2)),                      break;,                   if (kind > 23),                      kind = 23;,                   jjCheckNAddTwoStates(33, 34);,                   break;],,jjMoveNfa_2,571-576,[                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2)),                      break;,                   if (kind > 23),                      kind = 23;,                   jjCheckNAddTwoStates(33, 34);,                   break;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,jjMoveNfa_0,692-692,[         int i1 = hiByte >> 6;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,jjMoveNfa_0,694-694,[         int i2 = (curChar & 0xff) >> 6;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,jjMoveNfa_0,680-680,[         long l = 1L << (curChar & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,jjMoveNfa_0,693-693,[         long l1 = 1L << (hiByte & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,jjMoveNfa_0,695-695,[         long l2 = 1L << (curChar & 077);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,,970-970,[public static final int[] jjnewLexState = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,,957-957,[public static final String[] jjstrLiteralImages = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,,963-963,[public static final String[] lexStateNames = {],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,ReInit,998-1002,[   jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,ReInit,1014-1016,[   ReInit(stream);,    SwitchTo(lexState);, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,SwitchTo,1021-1025,[   if (lexState >= 3 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,ReInitRounds,1006-1009,[   jjround = 0x80000001;,    for (i = 49; i-- > 0;),       jjrounds[i] = 0x80000000;, }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,getNextToken,1078-1093,[   switch(curLexState),    {,      case 0:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_0();,        break;,      case 1:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_1();,        break;,      case 2:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_2();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,jjStartNfa_2,33-33,[   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/queryparser/classic/QueryParserTokenManager.java,,22-22,[  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/classic/TokenMgrError.java,LexicalError,108-112,[    return("Lexical error at line " +,           errorLine + ", column " +,           errorColumn + ".  Encountered: " +,           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +,           "after : \"" + addEscapes(errorAfter) + "\"");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java,rewrite,262-262,[            + contents.getClass().getName()],,
BAD_PRACTICE,SE_BAD_FIELD_STORE,org/apache/lucene/queryparser/flexible/core/QueryNodeException.java,,45-45,[  protected Message message = new MessageImpl(QueryParserMessages.EMPTY_MESSAGE);],,
BAD_PRACTICE,ISC_INSTANTIATE_STATIC_CLASS,org/apache/lucene/queryparser/flexible/core/config/ConfigurationKey.java,newInstance,39-39,[    return new ConfigurationKey<>();],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/lucene/queryparser/flexible/core/nodes/AnyQueryNode.java,<init>,53-53,[          if (clause instanceof FieldableNode) {],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/lucene/queryparser/flexible/core/nodes/AnyQueryNode.java,<init>,49-49,[          if (clause instanceof QueryNodeImpl) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queryparser/flexible/core/nodes/BoostQueryNode.java,getValueString,90-90,[    if (f == f.longValue())],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queryparser/flexible/core/nodes/PhraseSlopQueryNode.java,getValueString,58-58,[    if (f == f.longValue())],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queryparser/flexible/core/nodes/ProximityQueryNode.java,,58-58,[    int pDistance = 0;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/queryparser/flexible/core/nodes/ProximityQueryNode.java,,60-60,[    Type pType = null;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queryparser/flexible/core/nodes/SlopQueryNode.java,getValueString,67-67,[    if (f == f.longValue())],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessorImpl.java,,248-248,[  private static class ChildrenList extends ArrayList<QueryNode> {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/queryparser/flexible/messages/MessageImpl.java,getArguments,44-44,[    return this.arguments;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/flexible/messages/NLS.java,getResourceBundleObject,114-114,[          if (obj != null)],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/AnyQueryNodeBuilder.java,build,45-45,[    AnyQueryNode andNode = (AnyQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/BooleanQueryNodeBuilder.java,build,52-52,[    BooleanQueryNode booleanNode = (BooleanQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/BoostQueryNodeBuilder.java,build,40-40,[    BoostQueryNode boostNode = (BoostQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/FieldQueryNodeBuilder.java,build,37-37,[    FieldQueryNode fieldNode = (FieldQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/FuzzyQueryNodeBuilder.java,build,37-37,[    FuzzyQueryNode fuzzyNode = (FuzzyQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/GroupQueryNodeBuilder.java,build,39-39,[    GroupQueryNode groupNode = (GroupQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/ModifierQueryNodeBuilder.java,build,39-39,[    ModifierQueryNode modifierNode = (ModifierQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java,build,45-45,[    MultiPhraseQueryNode phraseNode = (MultiPhraseQueryNode) queryNode;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java,build,72-72,[        List<Term> termList = positionTermMap.get(positionIncrement);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/NumericRangeQueryNodeBuilder.java,build,49-49,[    NumericRangeQueryNode numericRangeNode = (NumericRangeQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/PhraseQueryNodeBuilder.java,build,42-42,[    TokenizedPhraseQueryNode phraseNode = (TokenizedPhraseQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/PrefixWildcardQueryNodeBuilder.java,build,41-41,[    PrefixWildcardQueryNode wildcardNode = (PrefixWildcardQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/RegexpQueryNodeBuilder.java,build,39-39,[    RegexpQueryNode regexpNode = (RegexpQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/SlopQueryNodeBuilder.java,build,42-42,[    SlopQueryNode phraseSlopNode = (SlopQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/StandardBooleanQueryNodeBuilder.java,build,54-54,[    StandardBooleanQueryNode booleanNode = (StandardBooleanQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/TermRangeQueryNodeBuilder.java,build,41-41,[    TermRangeQueryNode rangeNode = (TermRangeQueryNode) queryNode;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/queryparser/flexible/standard/builders/WildcardQueryNodeBuilder.java,build,40-40,[    WildcardQueryNode wildcardNode = (WildcardQueryNode) queryNode;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/lucene/queryparser/flexible/standard/config/NumericConfig.java,equals,142-155,[    if (obj == this) return true;,     ,     if (obj instanceof NumericConfig) {,       NumericConfig other = (NumericConfig) obj;,       ,       if (this.precisionStep == other.precisionStep,           && this.type == other.type,           && (this.format == other.format || (this.format.equals(other.format)))) {,         return true;,       },       ,     },     ,     return false;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/FastCharStream.java,BeginToken,82-83,[    tokenStart = bufferPosition;,     return readChar();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/FastCharStream.java,Done,106-109,[      input.close();,     } catch (IOException e) {,     },   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/FastCharStream.java,GetImage,93-93,[    return new String(buffer, tokenStart, bufferPosition - tokenStart);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/FastCharStream.java,GetSuffix,98-100,[    char[] value = new char[len];,     System.arraycopy(buffer, bufferPosition - len, value, 0, len);,     return value;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java,<init>,39-39,[     this.expectedTokenSequences = expectedTokenSequencesVal;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java,<init>,40-40,[     this.tokenImage = tokenImageVal;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/lucene/queryparser/flexible/standard/parser/ParseException.java,initialise,120-120,[      retval += " \"";],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Term,570-570,[           } catch (Exception ignored) { }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Clause,498-498,[      } catch (Exception ignored) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Term,573-573,[          } else if (fms >= 1.0f && fms != (int) fms) {],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Clause,313-505,[  Token fieldToken=null, boost=null, operator=null, term=null;,   FieldQueryNode qLower, qUpper;,   boolean lowerInclusive, upperInclusive;, ,   boolean group = false;,     if (jj_2_2(3)) {,       fieldToken = jj_consume_token(TERM);,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case OP_COLON:,       case OP_EQUAL:,         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,         case OP_COLON:,           jj_consume_token(OP_COLON);,           break;,         case OP_EQUAL:,           jj_consume_token(OP_EQUAL);,           break;,         default:,           jj_la1[7] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },                                  field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);,         q = Term(field);,         break;,       case OP_LESSTHAN:,       case OP_LESSTHANEQ:,       case OP_MORETHAN:,       case OP_MORETHANEQ:,         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,         case OP_LESSTHAN:,           operator = jj_consume_token(OP_LESSTHAN);,           break;,         case OP_LESSTHANEQ:,           operator = jj_consume_token(OP_LESSTHANEQ);,           break;,         case OP_MORETHAN:,           operator = jj_consume_token(OP_MORETHAN);,           break;,         case OP_MORETHANEQ:,           operator = jj_consume_token(OP_MORETHANEQ);,           break;,         default:,           jj_la1[8] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },                                                                                                                field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);,         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,         case TERM:,           term = jj_consume_token(TERM);,           break;,         case QUOTED:,           term = jj_consume_token(QUOTED);,           break;,         case NUMBER:,           term = jj_consume_token(NUMBER);,           break;,         default:,           jj_la1[9] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         if (term.kind == QUOTED) {,             term.image = term.image.substring(1, term.image.length()-1);,         },         switch (operator.kind) {,             case OP_LESSTHAN:,               lowerInclusive = true;,               upperInclusive = false;, ,                qLower = new FieldQueryNode(field,,                                          "*", term.beginColumn, term.endColumn);,             qUpper = new FieldQueryNode(field,,                                  EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);, ,                 break;,             case OP_LESSTHANEQ:,               lowerInclusive = true;,               upperInclusive = true;, ,                 qLower = new FieldQueryNode(field,,                                          "*", term.beginColumn, term.endColumn);,                 qUpper = new FieldQueryNode(field,,                                          EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);,                 break;,             case OP_MORETHAN:,               lowerInclusive = false;,               upperInclusive = true;, ,                 qLower = new FieldQueryNode(field,,                                          EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);,                 qUpper = new FieldQueryNode(field,,                                          "*", term.beginColumn, term.endColumn);,                 break;,             case OP_MORETHANEQ:,               lowerInclusive = true;,               upperInclusive = true;, ,                 qLower = new FieldQueryNode(field,,                                          EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);,                 qUpper = new FieldQueryNode(field,,                                          "*", term.beginColumn, term.endColumn);,                 break;,             default:,                 {if (true) throw new Error("Unhandled case: operator="+operator.toString());},         },         q = new TermRangeQueryNode(qLower, qUpper, lowerInclusive, upperInclusive);,         break;,       default:,         jj_la1[10] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     } else {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case LPAREN:,       case QUOTED:,       case TERM:,       case REGEXPTERM:,       case RANGEIN_START:,       case RANGEEX_START:,       case NUMBER:,         if (jj_2_1(2)) {,           fieldToken = jj_consume_token(TERM);,           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,           case OP_COLON:,             jj_consume_token(OP_COLON);,             break;,           case OP_EQUAL:,             jj_consume_token(OP_EQUAL);,             break;,           default:,             jj_la1[11] = jj_gen;,             jj_consume_token(-1);,             throw new ParseException();,           },                                  field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);,         } else {,           ;,         },         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,         case QUOTED:,         case TERM:,         case REGEXPTERM:,         case RANGEIN_START:,         case RANGEEX_START:,         case NUMBER:,           q = Term(field);,           break;,         case LPAREN:,           jj_consume_token(LPAREN);,           q = Query(field);,           jj_consume_token(RPAREN);,           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,           case CARAT:,             jj_consume_token(CARAT);,             boost = jj_consume_token(NUMBER);,             break;,           default:,             jj_la1[12] = jj_gen;,             ;,           },                                                                  group=true;,           break;,         default:,           jj_la1[13] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[14] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },       if (boost != null) {,       float f = (float)1.0;,       try {,         f = Float.valueOf(boost.image).floatValue();,         // avoid boosting null queries, such as those caused by stop words,           if (q != null) {,             q = new BoostQueryNode(q, f);,           },       } catch (Exception ignored) {,         /* Should this be handled somehow? (defaults to "no boost", if,              * boost number is invalid),              */,       },       },       if (group) { q = new GroupQueryNode(q);},       {if (true) return q;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,ConjQuery,233-256,[  Vector<QueryNode> clauses = null;,     first = ModClause(field);,     label_3:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case AND:,         ;,         break;,       default:,         jj_la1[6] = jj_gen;,         break label_3;,       },       jj_consume_token(AND);,       c = ModClause(field);,      if (clauses == null) {,          clauses = new Vector<>();,          clauses.addElement(first);,      },      clauses.addElement(c);,     },     if (clauses != null) {,       {if (true) return new AndQueryNode(clauses);},     } else {,         {if (true) return first;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Conjunction,84-107,[  int ret = CONJ_NONE;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case AND:,     case OR:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case AND:,         jj_consume_token(AND);,             ret = CONJ_AND;,         break;,       case OR:,         jj_consume_token(OR);,               ret = CONJ_OR;,         break;,       default:,         jj_la1[0] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[1] = jj_gen;,       ;,     },     {if (true) return ret;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,DisjQuery,203-226,[  Vector<QueryNode> clauses = null;,     first = ConjQuery(field);,     label_2:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case OR:,         ;,         break;,       default:,         jj_la1[5] = jj_gen;,         break label_2;,       },       jj_consume_token(OR);,       c = ConjQuery(field);,      if (clauses == null) {,          clauses = new Vector<>();,          clauses.addElement(first);,      },      clauses.addElement(c);,     },     if (clauses != null) {,       {if (true) return new OrQueryNode(clauses);},     } else {,         {if (true) return first;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,ModClause,302-307,[    mods = Modifiers();,     q = Clause(field);,         if (mods != ModifierQueryNode.Modifier.MOD_NONE) {,            q = new ModifierQueryNode(q, mods);,         },         {if (true) return q;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Modifiers,112-140,[  ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case NOT:,     case PLUS:,     case MINUS:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case PLUS:,         jj_consume_token(PLUS);,               ret = ModifierQueryNode.Modifier.MOD_REQ;,         break;,       case MINUS:,         jj_consume_token(MINUS);,                  ret = ModifierQueryNode.Modifier.MOD_NOT;,         break;,       case NOT:,         jj_consume_token(NOT);,                ret = ModifierQueryNode.Modifier.MOD_NOT;,         break;,       default:,         jj_la1[2] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[3] = jj_gen;,       ;,     },     {if (true) return ret;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Query,164-196,[  Vector<QueryNode> clauses = null;,   QueryNode c, first=null;,     first = DisjQuery(field);,     label_1:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case NOT:,       case PLUS:,       case MINUS:,       case LPAREN:,       case QUOTED:,       case TERM:,       case REGEXPTERM:,       case RANGEIN_START:,       case RANGEEX_START:,       case NUMBER:,         ;,         break;,       default:,         jj_la1[4] = jj_gen;,         break label_1;,       },       c = DisjQuery(field);,        if (clauses == null) {,            clauses = new Vector<>();,            clauses.addElement(first);,         },         clauses.addElement(c);,     },         if (clauses != null) {,         {if (true) return new BooleanQueryNode(clauses);},       } else {,           {if (true) return first;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,ReInit,887-893,[    token_source.ReInit(stream);,     token = new Token();,     jj_ntk = -1;,     jj_gen = 0;,     for (int i = 0; i < 28; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,ReInit,907-913,[    token_source = tm;,     token = new Token();,     jj_ntk = -1;,     jj_gen = 0;,     for (int i = 0; i < 28; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Term,510-717,[  Token term, boost=null, fuzzySlop=null, goop1, goop2;,   boolean fuzzy = false;,   boolean regexp = false;,   boolean startInc=false;,   boolean endInc=false;,   QueryNode q =null;,   FieldQueryNode qLower, qUpper;,   float defaultMinSimilarity = org.apache.lucene.search.FuzzyQuery.defaultMinSimilarity;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case TERM:,     case REGEXPTERM:,     case NUMBER:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case TERM:,         term = jj_consume_token(TERM);,                     q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);,         break;,       case REGEXPTERM:,         term = jj_consume_token(REGEXPTERM);,                              regexp=true;,         break;,       case NUMBER:,         term = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[15] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case FUZZY_SLOP:,         fuzzySlop = jj_consume_token(FUZZY_SLOP);,                                 fuzzy=true;,         break;,       default:,         jj_la1[16] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,         case FUZZY_SLOP:,           fuzzySlop = jj_consume_token(FUZZY_SLOP);,                                                          fuzzy=true;,           break;,         default:,           jj_la1[17] = jj_gen;,           ;,         },         break;,       default:,         jj_la1[18] = jj_gen;,         ;,       },        if (fuzzy) {,            float fms = defaultMinSimilarity;,            try {,             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();,            } catch (Exception ignored) { },            if(fms < 0.0f){,                 {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));},           } else if (fms >= 1.0f && fms != (int) fms) {,             {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));},           },           q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);,        } else if (regexp) {,          String re = term.image.substring(1, term.image.length()-1);,          q = new RegexpQueryNode(field, re, 0, re.length());,        },       break;,     case RANGEIN_START:,     case RANGEEX_START:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGEIN_START:,         jj_consume_token(RANGEIN_START);,                             startInc=true;,         break;,       case RANGEEX_START:,         jj_consume_token(RANGEEX_START);,         break;,       default:,         jj_la1[19] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_GOOP:,         goop1 = jj_consume_token(RANGE_GOOP);,         break;,       case RANGE_QUOTED:,         goop1 = jj_consume_token(RANGE_QUOTED);,         break;,       default:,         jj_la1[20] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_TO:,         jj_consume_token(RANGE_TO);,         break;,       default:,         jj_la1[21] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_GOOP:,         goop2 = jj_consume_token(RANGE_GOOP);,         break;,       case RANGE_QUOTED:,         goop2 = jj_consume_token(RANGE_QUOTED);,         break;,       default:,         jj_la1[22] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGEIN_END:,         jj_consume_token(RANGEIN_END);,                           endInc=true;,         break;,       case RANGEEX_END:,         jj_consume_token(RANGEEX_END);,         break;,       default:,         jj_la1[23] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[24] = jj_gen;,         ;,       },           if (goop1.kind == RANGE_QUOTED) {,             goop1.image = goop1.image.substring(1, goop1.image.length()-1);,           },           if (goop2.kind == RANGE_QUOTED) {,             goop2.image = goop2.image.substring(1, goop2.image.length()-1);,           }, ,           qLower = new FieldQueryNode(field,,                                    EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);,       qUpper = new FieldQueryNode(field,,                                    EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);,           q = new TermRangeQueryNode(qLower, qUpper, startInc ? true : false, endInc ? true : false);,       break;,     case QUOTED:,       term = jj_consume_token(QUOTED);,                       q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length()-1)), term.beginColumn + 1, term.endColumn - 1);,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case FUZZY_SLOP:,         fuzzySlop = jj_consume_token(FUZZY_SLOP);,         break;,       default:,         jj_la1[25] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[26] = jj_gen;,         ;,       },          int phraseSlop = 0;, ,          if (fuzzySlop != null) {,            try {,              phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();,              q = new SlopQueryNode(q, phraseSlop);,            },            catch (Exception ignored) {,             /* Should this be handled somehow? (defaults to "no PhraseSlop", if,            * slop number is invalid),            */,            },          },       break;,     default:,       jj_la1[27] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     if (boost != null) {,       float f = (float)1.0;,       try {,         f = Float.valueOf(boost.image).floatValue();,         // avoid boosting null queries, such as those caused by stop words,           if (q != null) {,             q = new BoostQueryNode(q, f);,           },       } catch (Exception ignored) {,         /* Should this be handled somehow? (defaults to "no boost", if,            * boost number is invalid),            */,       },     },       {if (true) return q;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,TopLevelQuery,147-149,[    q = Query(field);,     jj_consume_token(0);,      {if (true) return q;}],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,Term,691-691,[           catch (Exception ignored) {],,Term,711-711,[      } catch (Exception ignored) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.java,jj_rescan_token,1073-1075,[          switch (i) {,             case 0: jj_3_1(); break;,             case 1: jj_3_2(); break;],,
MALICIOUS_CODE,MS_OOI_PKGPROTECT,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserConstants.java,,86-86,[  String[] tokenImage = {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,jjMoveNfa_0,498-498,[         int i1 = hiByte >> 6;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,jjMoveNfa_0,500-500,[         int i2 = (curChar & 0xff) >> 6;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,jjMoveNfa_0,486-486,[         long l = 1L << (curChar & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,jjMoveNfa_0,499-499,[         long l1 = 1L << (hiByte & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,jjMoveNfa_0,501-501,[         long l2 = 1L << (curChar & 077);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,,774-774,[public static final int[] jjnewLexState = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,,761-761,[public static final String[] jjstrLiteralImages = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,,767-767,[public static final String[] lexStateNames = {],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,ReInit,802-806,[   jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,ReInit,818-820,[   ReInit(stream);,    SwitchTo(lexState);, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,SwitchTo,825-829,[   if (lexState >= 3 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,ReInitRounds,810-813,[   jjround = 0x80000001;,    for (i = 33; i-- > 0;),       jjrounds[i] = 0x80000000;, }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,getNextToken,882-897,[   switch(curLexState),    {,      case 0:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_0();,        break;,      case 1:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_1();,        break;,      case 2:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_2();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java,,48-48,[  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/flexible/standard/parser/TokenMgrError.java,LexicalError,108-112,[    return("Lexical error at line " +,           errorLine + ", column " +,           errorColumn + ".  Encountered: " +,           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +,           "after : \"" + addEscapes(errorAfter) + "\"");],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor.java,postProcessNode,251-251,[              if (q instanceof BooleanQueryNode) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/flexible/standard/processors/BooleanQuery2ModifierNodeProcessor.java,processChildren,99-99,[        child = processIteration(child);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/flexible/standard/processors/BoostQueryNodeProcessor.java,postProcessNode,56-56,[        if (fieldConfig != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/flexible/standard/processors/MultiFieldQueryNodeProcessor.java,preProcessNode,89-89,[        if (fields != null && fields.length > 0) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/flexible/standard/processors/NumericQueryNodeProcessor.java,postProcessNode,81-81,[        if (fieldConfig != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/flexible/standard/processors/NumericRangeQueryNodeProcessor.java,postProcessNode,74-74,[        if (fieldConfig != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/flexible/standard/processors/TermRangeQueryNodeProcessor.java,postProcessNode,96-96,[      if (fieldConfig != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/queryparser/flexible/standard/processors/TermRangeQueryNodeProcessor.java,postProcessNode,138-138,[      } catch (Exception e) {],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/lucene/queryparser/simple/SimpleQueryParser.java,buildQueryTree,419-419,[      if (state.not % 2 == 1) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/simple/SimpleQueryParser.java,newFuzzyQuery,534-534,[      if (q != null) {],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/FastCharStream.java,BeginToken,79-80,[    tokenStart = bufferPosition;,     return readChar();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/FastCharStream.java,Done,103-106,[      input.close();,     } catch (IOException e) {,     },   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/FastCharStream.java,GetImage,90-90,[    return new String(buffer, tokenStart, bufferPosition - tokenStart);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/FastCharStream.java,GetSuffix,95-97,[    char[] value = new char[len];,     System.arraycopy(buffer, bufferPosition - len, value, 0, len);,     return value;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queryparser/surround/parser/ParseException.java,<init>,36-36,[    expectedTokenSequences = expectedTokenSequencesVal;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queryparser/surround/parser/ParseException.java,<init>,37-37,[    tokenImage = tokenImageVal;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/lucene/queryparser/surround/parser/ParseException.java,initialise,117-117,[      retval += " \"";],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,AndQuery,226-248,[  ArrayList<SrndQuery> queries = null;,   Token oprt = null;,     q = NotQuery();,     label_3:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case AND:,         ;,         break;,       default:,         jj_la1[1] = jj_gen;,         break label_3;,       },       oprt = jj_consume_token(AND);,                    /* keep only last used operator */,       if (queries == null) {,         queries = new ArrayList<>();,         queries.add(q);,       },       q = NotQuery();,       queries.add(q);,     },    {if (true) return (queries == null) ? q : getAndQuery(queries, true /* infix */, oprt);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,FieldsQuery,168-170,[    fieldNames = OptionalFields();,     q = OrQuery();,    {if (true) return (fieldNames == null) ? q : getFieldsQuery(q, fieldNames);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,FieldsQueryList,404-423,[  ArrayList<SrndQuery> queries = new ArrayList<>();,     jj_consume_token(LPAREN);,     q = FieldsQuery();,                      queries.add(q);,     label_7:,     while (true) {,       jj_consume_token(COMMA);,       q = FieldsQuery();,                               queries.add(q);,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[7] = jj_gen;,         break label_7;,       },     },     jj_consume_token(RPAREN);,    {if (true) return queries;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,NotQuery,254-276,[  ArrayList<SrndQuery> queries = null;,   Token oprt = null;,     q = NQuery();,     label_4:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case NOT:,         ;,         break;,       default:,         jj_la1[2] = jj_gen;,         break label_4;,       },       oprt = jj_consume_token(NOT);,                     /* keep only last used operator */,       if (queries == null) {,         queries = new ArrayList<>();,         queries.add(q);,       },       q = NQuery();,       queries.add(q);,     },    {if (true) return (queries == null) ? q : getNotQuery(queries, oprt);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,OptionalFields,176-192,[  ArrayList<String> fieldNames = null;,     label_1:,     while (true) {,       if (jj_2_1(2)) {,         ;,       } else {,         break label_1;,       },       // to the colon,           fieldName = jj_consume_token(TERM);,       jj_consume_token(COLON);,       if (fieldNames == null) {,         fieldNames = new ArrayList<>();,       },       fieldNames.add(fieldName.image);,     },    {if (true) return fieldNames;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,OptionalWeights,471-496,[  Token weight=null;,     label_8:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         ;,         break;,       default:,         jj_la1[9] = jj_gen;,         break label_8;,       },       jj_consume_token(CARAT);,       weight = jj_consume_token(NUMBER);,       float f;,       try {,         f = Float.valueOf(weight.image).floatValue();,       } catch (Exception floatExc) {,         {if (true) throw new ParseException(boostErrorMessage + weight.image + " (" + floatExc + ")");},       },       if (f <= 0.0) {,         {if (true) throw new ParseException(boostErrorMessage + weight.image);},       },       q.setWeight(f * q.getWeight()); /* left associative, fwiw */, ,     },   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,OrQuery,198-220,[  ArrayList<SrndQuery> queries = null;,   Token oprt = null;,     q = AndQuery();,     label_2:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case OR:,         ;,         break;,       default:,         jj_la1[0] = jj_gen;,         break label_2;,       },       oprt = jj_consume_token(OR);,                   /* keep only last used operator */,       if (queries == null) {,         queries = new ArrayList<>();,         queries.add(q);,       },       q = AndQuery();,       queries.add(q);,     },    {if (true) return (queries == null) ? q : getOrQuery(queries, true /* infix */, oprt);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,PrefixOperatorQuery,369-397,[    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case OR:,       oprt = jj_consume_token(OR);,       /* prefix OR */,           queries = FieldsQueryList();,      {if (true) return getOrQuery(queries, false /* not infix */, oprt);},       break;,     case AND:,       oprt = jj_consume_token(AND);,       /* prefix AND */,           queries = FieldsQueryList();,      {if (true) return getAndQuery(queries, false /* not infix */, oprt);},       break;,     case N:,       oprt = jj_consume_token(N);,       /* prefix N */,           queries = FieldsQueryList();,      {if (true) return getDistanceQuery(queries, false /* not infix */, oprt, false /* not ordered */);},       break;,     case W:,       oprt = jj_consume_token(W);,       /* prefix W */,           queries = FieldsQueryList();,      {if (true) return getDistanceQuery(queries, false  /* not infix */, oprt, true /* ordered */);},       break;,     default:,       jj_la1[6] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,PrimaryQuery,337-362,[    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case LPAREN:,       jj_consume_token(LPAREN);,       q = FieldsQuery();,       jj_consume_token(RPAREN);,       break;,     case OR:,     case AND:,     case W:,     case N:,       q = PrefixOperatorQuery();,       break;,     case TRUNCQUOTED:,     case QUOTED:,     case SUFFIXTERM:,     case TRUNCTERM:,     case TERM:,       q = SimpleTerm();,       break;,     default:,       jj_la1[5] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     OptionalWeights(q);,    {if (true) return q;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,ReInit,545-551,[    token_source.ReInit(stream);,     token = new Token();,     jj_ntk = -1;,     jj_gen = 0;,     for (int i = 0; i < 10; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,ReInit,565-571,[    token_source = tm;,     token = new Token();,     jj_ntk = -1;,     jj_gen = 0;,     for (int i = 0; i < 10; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,SimpleTerm,429-465,[    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case TERM:,       term = jj_consume_token(TERM);,      {if (true) return getTermQuery(term.image, false /* not quoted */);},       break;,     case QUOTED:,       term = jj_consume_token(QUOTED);,      {if (true) return getTermQuery(term.image.substring(1, term.image.length()-1), true /* quoted */);},       break;,     case SUFFIXTERM:,       term = jj_consume_token(SUFFIXTERM);,                         /* ending in * */,       if (! allowedSuffix(term.image)) {,         {if (true) throw new ParseException(truncationErrorMessage + term.image);},       },       {if (true) return getPrefixQuery(term.image.substring(0, term.image.length()-1), false /* not quoted */);},       break;,     case TRUNCTERM:,       term = jj_consume_token(TRUNCTERM);,                        /* with at least one * or ? */,       if (! allowedTruncation(term.image)) {,         {if (true) throw new ParseException(truncationErrorMessage + term.image);},       },       {if (true) return getTruncQuery(term.image);},       break;,     case TRUNCQUOTED:,       term = jj_consume_token(TRUNCQUOTED);,                          /* eg. "9b-b,m"* */,       if ((term.image.length() - 3) < minimumPrefixLength) {,         {if (true) throw new ParseException(truncationErrorMessage + term.image);},       },       {if (true) return getPrefixQuery(term.image.substring(1, term.image.length()-2), true /* quoted */);},       break;,     default:,       jj_la1[8] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParser.java,TopSrndQuery,159-161,[    q = FieldsQuery();,     jj_consume_token(0);,    {if (true) return q;}],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/queryparser/surround/parser/QueryParser.java,jj_rescan_token,728-729,[          switch (i) {,             case 0: jj_3_1(); break;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,54-54,[  final char anyChar = '?';],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,50-50,[  final String boostErrorMessage = "Cannot handle boost value: ";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,58-58,[  final char carat = '^'; /* weight operator */],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,57-57,[  final char comma = ','; /* prefix list separator */],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,56-56,[  final char fieldOperator = ':';],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,48-48,[  final int minimumCharsInTrunc = 3;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,47-47,[  final int minimumPrefixLength = 3;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,55-55,[  final char quote = '"';],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,49-49,[  final String truncationErrorMessage = "Too unrestrictive truncation: ";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/parser/QueryParser.java,,53-53,[  final char truncator = '*';],,
MALICIOUS_CODE,MS_OOI_PKGPROTECT,org/apache/lucene/queryparser/surround/parser/QueryParserConstants.java,,64-64,[  String[] tokenImage = {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,jjMoveNfa_0,472-472,[         int i1 = hiByte >> 6;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,jjMoveNfa_0,474-474,[         int i2 = (curChar & 0xff) >> 6;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,jjMoveNfa_0,460-460,[         long l = 1L << (curChar & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,jjMoveNfa_0,473-473,[         long l1 = 1L << (hiByte & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,jjMoveNfa_0,475-475,[         long l2 = 1L << (curChar & 077);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,,526-526,[public static final int[] jjnewLexState = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,,515-515,[public static final String[] jjstrLiteralImages = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,,520-520,[public static final String[] lexStateNames = {],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,ReInit,553-557,[   jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,ReInit,569-571,[   ReInit(stream);,    SwitchTo(lexState);, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,SwitchTo,576-580,[   if (lexState >= 2 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,ReInitRounds,561-564,[   jjround = 0x80000001;,    for (i = 38; i-- > 0;),       jjrounds[i] = 0x80000000;, }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,getNextToken,633-643,[   switch(curLexState),    {,      case 0:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_0();,        break;,      case 1:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_1();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,jjStartNfa_1,35-35,[   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java,,24-24,[  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/queryparser/surround/parser/TokenMgrError.java,LexicalError,108-112,[    return("Lexical error at line " +,           errorLine + ", column " +,           errorColumn + ".  Encountered: " +,           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +,           "after : \"" + addEscapes(errorAfter) + "\"");],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java,,58-58,[    return queriesMade >= maxBasicQueries;],,,46-46,[  public int getNrQueriesMade() {return queriesMade;}],,,64-64,[    queriesMade++;],,,51-51,[    return getClass().getName()],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/lucene/queryparser/surround/query/FieldsQuery.java,,32-32,[  private final String OrOperatorName = "OR"; /* for expanded queries, not normally visible */],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java,makeSpanClause,121-121,[      sq.setBoost(weightBySpanQuery.get(sq).floatValue());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java,visitMatchingTerms,112-112,[          if (text != null && StringHelper.startsWith(text, prefixRef)) {],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java,visitMatchingTerms,111-111,[        while(text != null) {],,visitMatchingTerms,112-112,[          if (text != null && StringHelper.startsWith(text, prefixRef)) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/queryparser/xml/CoreParser.java,,41-41,[  public static int maxNumCachedFilters = 20;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/queryparser/xml/CoreParser.java,,64-64,[    this.analyzer = analyzer;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/queryparser/xml/CoreParser.java,,65-65,[    this.parser = parser;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/DOMUtils.java,getAttributeOrFail,53-53,[    if (null == v) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/DOMUtils.java,getAttribute,134-134,[    return (result == null) || ("".equals(result)) ? deflt : Float.parseFloat(result);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/DOMUtils.java,getAttribute,139-139,[    return (result == null) || ("".equals(result)) ? deflt : Integer.parseInt(result);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/DOMUtils.java,getAttribute,129-129,[    return (result == null) || ("".equals(result)) ? deflt : result;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/DOMUtils.java,getAttribute,145-145,[    return (result == null) || ("".equals(result)) ? deflt : Boolean.valueOf(result);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/DOMUtils.java,getAttributeWithInheritance,96-96,[    if ((result == null) || ("".equals(result))) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/DOMUtils.java,getText,71-71,[    if (null != v)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/DOMUtils.java,getNonBlankTextOrFail,73-73,[    if (null == v || 0 == v.length()) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/queryparser/xml/DOMUtils.java,getTextBuffer,168-178,[      switch (kid.getNodeType()) {,         case Node.TEXT_NODE: {,           sb.append(kid.getNodeValue());,           break;,         },         case Node.ELEMENT_NODE: {,           getTextBuffer(kid, sb);,           break;,         },         case Node.ENTITY_REFERENCE_NODE: {,           getTextBuffer(kid, sb);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/builders/BooleanQueryBuilder.java,getOccursValue,81-81,[          if (occs != null) {],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/lucene/queryparser/xml/builders/CachedFilterBuilder.java,,103-111,[      super(maxsize * 4 / 3 + 1, 0.75f, true);,       this.maxsize = maxsize;,     }, ,     protected int maxsize;, ,     @Override,     protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {,       return size() > maxsize;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/queryparser/xml/builders/LikeThisQueryBuilder.java,<init>,50-50,[    this.defaultFieldNames = defaultFieldNames;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/lucene/queryparser/xml/builders/LikeThisQueryBuilder.java,getQuery,91-91,[    MoreLikeThisQuery mlt = new MoreLikeThisQuery(DOMUtils.getText(e), fields, analyzer, fields[0]);],,getQuery,73-73,[    if ((stopWords != null) && (fields != null)) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/builders/LikeThisQueryBuilder.java,getQuery,60-60,[    if ((fieldsList != null) && (fieldsList.trim().length() > 0)) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/queryparser/xml/builders/LikeThisQueryBuilder.java,getQuery,73-73,[    if ((stopWords != null) && (fields != null)) {],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/replicator/IndexAndTaxonomyRevision.java,compareTo,47-47,[public class IndexAndTaxonomyRevision implements Revision {],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/replicator/IndexRevision.java,compareTo,51-51,[public class IndexRevision implements Revision {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/replicator/LocalReplicator.java,,181-181,[    return expirationThresholdMilllis;],,,188-188,[    if (session != null && session.isExpired(expirationThresholdMilllis)) {],,,117-117,[      if (token.isExpired(expirationThresholdMilllis)) {],,,243-243,[    this.expirationThresholdMilllis = expirationThreshold;],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/lucene/replicator/LocalReplicator.java,getExpirationThreshold,181-181,[    return expirationThresholdMilllis;],,setExpirationThreshold,242-245,[    ensureOpen();,     this.expirationThresholdMilllis = expirationThreshold;,     checkExpiredSessions();,   }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/replicator/ReplicationClient.java,doUpdate,259-259,[      if (session != null) {],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/lucene/replicator/RevisionFile.java,equals,45-45,[    RevisionFile other = (RevisionFile) obj;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/replicator/RevisionFile.java,equals,45-46,[    RevisionFile other = (RevisionFile) obj;,     return fileName.equals(other.fileName) && size == other.size;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/replicator/http/HttpClientBase.java,consume,219-219,[          } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/replicator/http/HttpClientBase.java,,190-224,[    return new InputStream() {,       private boolean consumed = false;,       @Override,       public int read() throws IOException {,         final int res = in.read();,         consume(res);,         return res;,       },       @Override,       public void close() throws IOException {,         in.close();,         consume(-1);,       },       @Override,       public int read(byte[] b) throws IOException {,         final int res = in.read(b);,         consume(res);,         return res;,       },       @Override,       public int read(byte[] b, int off, int len) throws IOException {,         final int res = in.read(b, off, len);,         consume(res);,         return res;,       },       private void consume(int minusOne) {,         if (!consumed && minusOne == -1) {,           try {,             EntityUtils.consume(entity);,           } catch (Exception e) {,             // ignored on purpose,           },           consumed = true;,         },       }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/replicator/http/HttpReplicator.java,,97-100,[    doAction(response, new Callable<Object>() {,       @Override,       public Object call() throws Exception {,         return null; // do not remove this call: as it is still validating for us!],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/replicator/http/ReplicationService.java,perform,180-180,[    } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/sandbox/queries/DuplicateFilter.java,correctBits,115-115,[              int lastDoc = doc;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java,,131-175,[    {,       fieldName = name;,       minSimilarity = similarity;,       prefixLength = length;,       this.queryString = queryString;,     }, ,     @Override,     public int hashCode() {,       final int prime = 31;,       int result = 1;,       result = prime * result,           + ((fieldName == null) ? 0 : fieldName.hashCode());,       result = prime * result + Float.floatToIntBits(minSimilarity);,       result = prime * result + prefixLength;,       result = prime * result,           + ((queryString == null) ? 0 : queryString.hashCode());,       return result;,     }, ,     @Override,     public boolean equals(Object obj) {,       if (this == obj),         return true;,       if (obj == null),         return false;,       if (getClass() != obj.getClass()),         return false;,       FieldVals other = (FieldVals) obj;,       if (fieldName == null) {,         if (other.fieldName != null),           return false;,       } else if (!fieldName.equals(other.fieldName)),         return false;,       if (Float.floatToIntBits(minSimilarity) != Float,           .floatToIntBits(other.minSimilarity)),         return false;,       if (prefixLength != other.prefixLength),         return false;,       if (queryString == null) {,         if (other.queryString != null),           return false;,       } else if (!queryString.equals(other.queryString)),         return false;,       return true;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java,lessThan,352-352,[          if (termA.score== termB.score)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/sandbox/queries/SlowCollatedStringComparator.java,compareBottom,72-72,[    final BytesRef term = currentDocTerms.get(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/sandbox/queries/SlowCollatedStringComparator.java,compareTop,133-133,[    final BytesRef term = currentDocTerms.get(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/sandbox/queries/SlowCollatedStringComparator.java,copy,87-87,[    final BytesRef term = currentDocTerms.get(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/sandbox/queries/SlowCollatedStringComparator.java,compareBottom,73-73,[    final String val2 = term.length == 0 && docsWithField.get(doc) == false ? null : term.utf8ToString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/sandbox/queries/SlowCollatedStringComparator.java,compareTop,135-135,[    if (term.length == 0 && docsWithField.get(doc) == false) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/sandbox/queries/SlowCollatedStringComparator.java,copy,88-88,[    if (term.length == 0 && docsWithField.get(doc) == false) {],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/sandbox/queries/SlowFuzzyTermsEnum.java,accept,141-141,[              (raw == false && similarity > minSimilarity)) {],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/lucene/sandbox/queries/regex/JakartaRegexpCapabilities.java,<clinit>,50-50,[      prefixField.setAccessible(true);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/sandbox/queries/regex/JakartaRegexpCapabilities.java,<clinit>,45-45,[    } catch (Exception e) {],,<clinit>,51-51,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/sandbox/queries/regex/JakartaRegexpCapabilities.java,prefix,165-165,[      } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/sandbox/queries/regex/JakartaRegexpCapabilities.java,,115-167,[  class JakartaRegexMatcher implements RegexCapabilities.RegexMatcher {,     ,     private RE regexp;,     private final CharsRefBuilder utf16 = new CharsRefBuilder();,     private final CharacterIterator utf16wrapper = new CharacterIterator() {, ,       @Override,       public char charAt(int pos) {,         return utf16.charAt(pos);,       }, ,       @Override,       public boolean isEnd(int pos) {,         return pos >= utf16.length();,       }, ,       @Override,       public String substring(int beginIndex) {,         return substring(beginIndex, utf16.length());,       }, ,       @Override,       public String substring(int beginIndex, int endIndex) {,         return new String(utf16.chars(), beginIndex, endIndex - beginIndex);,       },       ,     };,     ,     public JakartaRegexMatcher(String regex, int flags) {,       regexp = new RE(regex, flags);,     },     ,     @Override,     public boolean match(BytesRef term) {,       utf16.copyUTF8Bytes(term);,       return regexp.match(utf16wrapper, 0);,     }, ,     @Override,     public String prefix() {,       try {,         final char[] prefix;,         if (getPrefixMethod != null) {,           prefix = (char[]) getPrefixMethod.invoke(regexp.getProgram());,         } else if (prefixField != null) {,           prefix = (char[]) prefixField.get(regexp.getProgram());,         } else {,           return null;,         },         return prefix == null ? null : new String(prefix);,       } catch (Exception e) {,         // if we cannot get the prefix, return none,         return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/sandbox/queries/regex/JavaUtilRegexCapabilities.java,,108-124,[    private final CharsRefBuilder utf16 = new CharsRefBuilder();,     ,     public JavaUtilRegexMatcher(String regex, int flags) {,       this.pattern = Pattern.compile(regex, flags);,       this.matcher = this.pattern.matcher(utf16.get());,     },     ,     @Override,     public boolean match(BytesRef term) {,       utf16.copyUTF8Bytes(term);,       utf16.get();,       return matcher.reset().matches();,     }, ,     @Override,     public String prefix() {,       return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/AssertingIndexSearcher.java,,60-69,[    return new AssertingWeight(random, w) {, ,       @Override,       public void normalize(float norm, float topLevelBoost) {,         throw new IllegalStateException("Weight already normalized.");,       }, ,       @Override,       public float getValueForNormalization() {,         throw new IllegalStateException("Weight already normalized.");],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/AssertingQuery.java,clone,75-75,[    return wrap(new Random(random.nextLong()), in.clone());],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/search/BaseExplanationTestCase.java,,89-89,[  protected static final String[] docFields = {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/BlockJoinComparatorSource.java,parent,184-184,[        return parentBits.nextSetBit(doc);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/BooleanQuery.java,equals,647-647,[    return this.getBoost() == other.getBoost()],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/lucene/search/BooleanScorer.java,score,256-256,[    } while (current != null || more);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/search/BooleanScorer.java,,177-177,[    this.weight = weight;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/BooleanScorer.java,collect,78-78,[        bucket.score = scorer.score();            // initialize score],,collect,85-85,[        bucket.score += scorer.score();           // increment score],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/search/BooleanScorer.java,,155-155,[      this.prohibited = prohibited;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/CachingCollector.java,postCollect,184-184,[      final ScoreCachingLeafCollector coll = (ScoreCachingLeafCollector) collector;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/CachingCollector.java,buffer,291-291,[      scores[docCount] = scorer.score();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/search/CheckHits.java,,42-42,[  public static float EXPLAIN_SCORE_TOLERANCE_DELTA = 0.001f;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/search/CheckHits.java,,50-50,[  public static float EXPLAIN_SCORE_TOLERANCE_MINIMUM = 1e-6f;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/ConjunctionScorer.java,,47-50,[    ArrayUtil.timSort(docsAndFreqs, new Comparator<DocsAndFreqs>() {,       @Override,       public int compare(DocsAndFreqs o1, DocsAndFreqs o2) {,         return Long.compare(o1.cost, o2.cost);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/search/ControlledRealTimeReopenThread.java,,243-243,[      refreshStartGen = writer.getAndIncrementGeneration();],,,95-95,[    searchingGen = refreshStartGen;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/lucene/search/ControlledRealTimeReopenThread.java,run,223-223,[            reopenCond.awaitNanos(sleepNS);],,
MT_CORRECTNESS,UL_UNRELEASED_LOCK_EXCEPTION_PATH,org/apache/lucene/search/ControlledRealTimeReopenThread.java,waitForGeneration,166-166,[      reopenLock.lock();],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/DisjunctionMaxQuery.java,equals,288-288,[    return this.getBoost() == other.getBoost()],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/DocTermOrdsRewriteMethod.java,,90-134,[      TermsEnum termsEnum = query.getTermsEnum(new Terms() {,         ,         @Override,         public TermsEnum iterator(TermsEnum reuse) {,           return docTermOrds.termsEnum();,         }, ,         @Override,         public long getSumTotalTermFreq() {,           return -1;,         }, ,         @Override,         public long getSumDocFreq() {,           return -1;,         }, ,         @Override,         public int getDocCount() {,           return -1;,         }, ,         @Override,         public long size() {,           return -1;,         }, ,         @Override,         public boolean hasFreqs() {,           return false;,         }, ,         @Override,         public boolean hasOffsets() {,           return false;,         }, ,         @Override,         public boolean hasPositions() {,           return false;,         },         ,         @Override,         public boolean hasPayloads() {,           return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/DocTermOrdsRewriteMethod.java,,148-159,[      return new DocValuesDocIdSet(context.reader().maxDoc(), acceptDocs) {,         @Override,         protected final boolean matchDoc(int doc) throws ArrayIndexOutOfBoundsException {,           docTermOrds.setDocument(doc);,           long ord;,           // TODO: we could track max bit set and early terminate (since they come in sorted order),           while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {,             if (termSet.get(ord)) {,               return true;,             },           },           return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/DocValuesRewriteMethod.java,,90-134,[      TermsEnum termsEnum = query.getTermsEnum(new Terms() {,         ,         @Override,         public TermsEnum iterator(TermsEnum reuse) {,           return fcsi.termsEnum();,         }, ,         @Override,         public long getSumTotalTermFreq() {,           return -1;,         }, ,         @Override,         public long getSumDocFreq() {,           return -1;,         }, ,         @Override,         public int getDocCount() {,           return -1;,         }, ,         @Override,         public long size() {,           return -1;,         }, ,         @Override,         public boolean hasFreqs() {,           return false;,         }, ,         @Override,         public boolean hasOffsets() {,           return false;,         }, ,         @Override,         public boolean hasPositions() {,           return false;,         },         ,         @Override,         public boolean hasPayloads() {,           return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/DocValuesRewriteMethod.java,,151-158,[      return new DocValuesDocIdSet(context.reader().maxDoc(), acceptDocs) {,         @Override,         protected final boolean matchDoc(int doc) throws ArrayIndexOutOfBoundsException {,           int ord = fcsi.getOrd(doc);,           if (ord == -1) {,             return false;,           },           return termSet.get(ord);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/DocValuesTermsFilter.java,,116-124,[    return new DocValuesDocIdSet(context.reader().maxDoc(), acceptDocs) {,       @Override,       protected final boolean matchDoc(int doc) {,         int ord = fcsi.getOrd(doc);,         if (ord == -1) {,           // missing,           return false;,         } else {,           return bits.get(ord);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/search/EarlyTerminatingSortingCollector.java,,111-111,[    this.sort = sort;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/lucene/search/Explanation.java,getDetails,72-72,[      return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/FieldComparator.java,compareBottom,572-572,[      float score = scorer.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/FieldComparator.java,compareTop,625-625,[      float docValue = scorer.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/FieldComparator.java,copy,579-579,[      scores[slot] = scorer.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/FieldComparator.java,compareBottom,984-984,[      final BytesRef comparableBytes = getComparableBytes(doc, docTerms.get(doc));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/FieldComparator.java,compareTop,1064-1064,[      final BytesRef comparableBytes = getComparableBytes(doc, docTerms.get(doc));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/FieldComparator.java,copy,990-990,[      final BytesRef comparableBytes = getComparableBytes(doc, docTerms.get(doc));],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/FieldDoc.java,<init>,61-61,[    this.fields = fields;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/FieldDoc.java,<init>,67-67,[    this.fields = fields;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/FieldValueFilter.java,,88-91,[      return new DocValuesDocIdSet(context.reader().maxDoc(), acceptDocs) {,         @Override,         protected final boolean matchDoc(int doc) {,           return !docsWithField.get(doc);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/FieldValueFilter.java,,103-106,[      return new DocValuesDocIdSet(context.reader().maxDoc(), acceptDocs) {,         @Override,         protected final boolean matchDoc(int doc) {,           return docsWithField.get(doc);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/search/FieldValueHitQueue.java,getComparators,175-175,[    return comparators;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/search/FieldValueHitQueue.java,getReverseMul,179-179,[    return reverseMul;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/FuzzyTermsEnum.java,<init>,102-102,[    if (minSimilarity >= 1.0f && minSimilarity != (int)minSimilarity)],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/FuzzyTermsEnum.java,next,246-246,[    if (term != null && (bottom != this.bottom || bottomTerm != this.bottomTerm)) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/HitQueue.java,lessThan,77-77,[    if (hitA.score == hitB.score)],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/search/IndexSearcher.java,search,574-574,[    return (TopFieldDocs) collector.topDocs();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/search/IndexSearcher.java,search,549-549,[      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/search/LRUFilterCache.java,get,124-124,[      hitCount += 1;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/search/LRUFilterCache.java,get,111-111,[      missCount += 1;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/search/LRUFilterCache.java,get,117-117,[      missCount += 1;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/lucene/search/LRUFilterCache.java,get,122-122,[      missCount += 1;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/MatchAllDocsQuery.java,equals,157-157,[    return this.getBoost() == other.getBoost();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/MatchAllDocsQuery.java,,37-83,[    private int doc = -1;,     private final int maxDoc;,     private final Bits liveDocs;, ,     MatchAllScorer(IndexReader reader, Bits liveDocs, Weight w, float score) {,       super(w);,       this.liveDocs = liveDocs;,       this.score = score;,       maxDoc = reader.maxDoc();,     }, ,     @Override,     public int docID() {,       return doc;,     }, ,     @Override,     public int nextDoc() throws IOException {,       doc++;,       while(liveDocs != null && doc < maxDoc && !liveDocs.get(doc)) {,         doc++;,       },       if (doc == maxDoc) {,         doc = NO_MORE_DOCS;,       },       return doc;,     },     ,     @Override,     public float score() {,       return score;,     }, ,     @Override,     public int freq() {,       return 1;,     }, ,     @Override,     public int advance(int target) throws IOException {,       doc = target-1;,       return nextDoc();,     }, ,     @Override,     public long cost() {,       return maxDoc;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/MaxNonCompetitiveBoostAttributeImpl.java,copyTo,58-58,[    final MaxNonCompetitiveBoostAttributeImpl t = (MaxNonCompetitiveBoostAttributeImpl) target;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/MinShouldMatchSumScorer.java,,92-95,[    ArrayUtil.timSort(sortedSubScorers, new Comparator<Scorer>() {,       @Override,       public int compare(Scorer o1, Scorer o2) {,         return Long.signum(o2.cost() - o1.cost());],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/MultiPhraseQuery.java,equals,361-361,[    return this.getBoost() == other.getBoost()],,
CORRECTNESS,DMI_INVOKING_HASHCODE_ON_ARRAY,org/apache/lucene/search/NGramPhraseQuery.java,hashCode,96-96,[      ^ getPositions().hashCode()],,
CORRECTNESS,DMI_INVOKING_HASHCODE_ON_ARRAY,org/apache/lucene/search/NGramPhraseQuery.java,hashCode,95-95,[      ^ getTerms().hashCode()],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/PhraseQuery.java,equals,384-384,[    return (this.getBoost() == other.getBoost())],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/PositiveScoresOnlyCollector.java,,38-53,[    return new FilterLeafCollector(super.getLeafCollector(context)) {, ,       private Scorer scorer;, ,       @Override,       public void setScorer(Scorer scorer) throws IOException {,         this.scorer = new ScoreCachingWrappingScorer(scorer);,         in.setScorer(this.scorer);,       }, ,       @Override,       public void collect(int doc) throws IOException {,         if (scorer.score() > 0) {,           in.collect(doc);,         },       }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/PositiveScoresOnlyCollector.java,collect,50-50,[        if (scorer.score() > 0) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/QueryRescorer.java,,54-57,[                new Comparator<ScoreDoc>() {,                   @Override,                   public int compare(ScoreDoc a, ScoreDoc b) {,                     return a.doc - b.doc;],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/lucene/search/QueryRescorer.java,compare,121-121,[                    } else if (a.score < b.score) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/QueryRescorer.java,,115-126,[                new Comparator<ScoreDoc>() {,                   @Override,                   public int compare(ScoreDoc a, ScoreDoc b) {,                     // Sort by score descending, then docID ascending:,                     if (a.score > b.score) {,                       return -1;,                     } else if (a.score < b.score) {,                       return 1;,                     } else {,                       // This subtraction can't overflow int,                       // because docIDs are >= 0:,                       return a.doc - b.doc;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/QueryUtils.java,collect,261-261,[            float score = sc.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/QueryUtils.java,collect,367-367,[        float score = scorer.score();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/QueryWrapperFilter.java,,56-64,[    return new DocIdSet() {,       @Override,       public DocIdSetIterator iterator() throws IOException {,         return weight.scorer(privateContext, acceptDocs);,       }, ,       @Override,       public long ramBytesUsed() {,         return 0L;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/RandomOrderCollector.java,flush,78-78,[      fakeScorer.doc = docIDs[i];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/RandomOrderCollector.java,collect,89-89,[    scores[buffered] = scorer.score();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/ReferenceManager.java,acquire,104-104,[        assert ref != null;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/lucene/search/ReqOptSumScorer.java,<init>,43-43,[    super(reqScorer.weight);],,<init>,44-44,[    assert reqScorer != null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/search/Scorer.java,,99-99,[      this.relationship = relationship;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/ScoringRewrite.java,collect,144-144,[        assert array.boost[pos] == boostAtt.getBoost() : "boost should be equal in all segment TermsEnums";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/ScoringRewrite.java,collect,147-147,[        array.boost[e] = boostAtt.getBoost();],,collect,144-144,[        assert array.boost[pos] == boostAtt.getBoost() : "boost should be equal in all segment TermsEnums";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/ScoringRewrite.java,collect,138-138,[      final TermState state = termsEnum.termState();],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/search/SearcherLifetimeManager.java,compareTo,121-121,[      return Double.compare(other.recordTimeSec, recordTimeSec);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/ShardSearchingTestBase.java,<init>,224-224,[        this.nodeVersions = nodeVersions;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/search/ShardSearchingTestBase.java,,640-640,[      this.searcher = searcher;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/search/ShardSearchingTestBase.java,,641-641,[      this.version = version;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/lucene/search/SloppyPhraseScorer.java,repeatingTerms,449-449,[        Integer cnt = cnt0==null ? new Integer(1) : new Integer(1+cnt0.intValue());],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/lucene/search/SloppyPhraseScorer.java,<init>,60-60,[    pq = new PhraseQueue(postings.length);],,<init>,59-59,[    this.numPostings = postings==null ? 0 : postings.length;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/SloppyPhraseScorer.java,,363-366,[    Comparator<PhrasePositions> cmprtr = new Comparator<PhrasePositions>() {,       @Override,       public int compare(PhrasePositions pp1, PhrasePositions pp2) {,         return pp1.offset - pp2.offset;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/search/Sort.java,getSort,158-158,[    return fields;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/SortRescorer.java,,47-50,[                new Comparator<ScoreDoc>() {,                   @Override,                   public int compare(ScoreDoc a, ScoreDoc b) {,                     return a.doc - b.doc;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/TermAutomatonQuery.java,equals,261-261,[    return (this.getBoost() == other.getBoost())],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/search/TermAutomatonQuery.java,,351-351,[      this.searcher = searcher;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/TermQuery.java,equals,202-202,[    return (this.getBoost() == other.getBoost())],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/search/TermRangeFilter.java,Less,66-66,[      return new TermRangeFilter(fieldName, null, upperTerm, false, true);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/lucene/search/TermRangeFilter.java,More,74-74,[      return new TermRangeFilter(fieldName, lowerTerm, null, true, false);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/TopDocs.java,<init>,58-58,[    this.scoreDocs = scoreDocs;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/TopFieldCollector.java,collect,557-557,[      final float score = scorer.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/TopFieldCollector.java,collect,628-628,[      final float score = scorer.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/TopFieldCollector.java,collect,291-291,[      final float score = scorer.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/TopFieldCollector.java,collect,343-343,[      final float score = scorer.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/TopFieldCollector.java,collect,958-958,[          score = scorer.score();],,collect,896-896,[        score = scorer.score();],,collect,978-978,[          score = scorer.score();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/TopFieldDocs.java,<init>,37-37,[    this.fields = fields;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/TopScoreDocCollector.java,collect,93-93,[      if (score > after.score || (score == after.score && doc <= afterDoc)) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/TopScoreDocCollector.java,collect,186-186,[      if (score > after.score || (score == after.score && doc <= afterDoc)) {],,collect,195-195,[      if (score == pqTop.score && doc > pqTop.doc) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/TopScoreDocCollector.java,collect,151-151,[      if (score == pqTop.score && doc > pqTop.doc) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/TopTermsRewrite.java,collect,118-118,[          if (boost == t.boost && bytes.compareTo(t.bytes.get()) > 0)],,collect,126-126,[          assert t.boost == boost : "boost should be equal in all segment TermsEnums";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/TopTermsRewrite.java,collect,106-106,[        final float boost = boostAtt.getBoost();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/TopTermsRewrite.java,collect,130-130,[          st.bytes.copyBytes(bytes);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/TopTermsRewrite.java,collect,122-122,[        final TermState state = termsEnum.termState();],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/search/TopTermsRewrite.java,compareTo,202-205,[      if (this.boost == other.boost),         return other.bytes.get().compareTo(this.bytes.get());,       else,         return Float.compare(this.boost, other.boost);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/TopTermsRewrite.java,compareTo,202-202,[      if (this.boost == other.boost)],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/lucene/search/UsageTrackingFilterCachingPolicy.java,<init>,96-96,[    if (minFrequencyOtherFilters < minFrequencyCheapFilters || minFrequencyOtherFilters < minFrequencyCheapFilters) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/AbstractAllGroupHeadsCollector.java,collect,112-112,[      final int c = reversed[compIDX] * groupHead.compare(compIDX, doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java,collect,218-218,[        segmentFacetCounts[facetFieldNumTerms]++;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java,process,255-255,[      segmentFacetCounts[facetOrd]++;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java,collect,102-102,[      segmentFacetCounts[facetOrd+1]++;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/search/grouping/SearchGroup.java,equals,51-64,[    if (this == o) return true;,     if (o == null || getClass() != o.getClass()) return false;, ,     SearchGroup<?> that = (SearchGroup<?>) o;, ,     if (groupValue == null) {,       if (that.groupValue != null) {,         return false;,       },     } else if (!groupValue.equals(that.groupValue)) {,       return false;,     }, ,     return true;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/grouping/GroupDocs.java,<init>,60-60,[    this.groupSortValues = groupSortValues;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/grouping/GroupDocs.java,<init>,58-58,[    this.scoreDocs = scoreDocs;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/search/grouping/SearchGroup.java,,154-190,[  private static class GroupComparator<T> implements Comparator<MergedGroup<T>> {, ,     public final FieldComparator[] comparators;,     public final int[] reversed;, ,     public GroupComparator(Sort groupSort) throws IOException {,       final SortField[] sortFields = groupSort.getSort();,       comparators = new FieldComparator<?>[sortFields.length];,       reversed = new int[sortFields.length];,       for (int compIDX = 0; compIDX < sortFields.length; compIDX++) {,         final SortField sortField = sortFields[compIDX];,         comparators[compIDX] = sortField.getComparator(1, compIDX);,         reversed[compIDX] = sortField.getReverse() ? -1 : 1;,       },     }, ,     @Override,     @SuppressWarnings({"unchecked","rawtypes"}),     public int compare(MergedGroup<T> group, MergedGroup<T> other) {,       if (group == other) {,         return 0;,       },       //System.out.println("compare group=" + group + " other=" + other);,       final Object[] groupValues = group.topValues;,       final Object[] otherValues = other.topValues;,       //System.out.println("  groupValues=" + groupValues + " otherValues=" + otherValues);,       for (int compIDX = 0;compIDX < comparators.length; compIDX++) {,         final int c = reversed[compIDX] * comparators[compIDX].compareValues(groupValues[compIDX],,                                                                              otherValues[compIDX]);,         if (c != 0) {,           return c;,         },       }, ,       // Tie break by min shard index:,       assert group.minShardIndex != other.minShardIndex;,       return group.minShardIndex - other.minShardIndex;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/grouping/TopGroups.java,<init>,54-54,[    this.groupSort = groupSort;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/grouping/TopGroups.java,<init>,58-58,[    this.groups = groups;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/grouping/TopGroups.java,<init>,55-55,[    this.withinGroupSort = withinGroupSort;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionAllGroupHeadsCollector.java,retrieveGroupHeadAndAddIfNotExist,75-75,[    filler.fillValue(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionAllGroupHeadsCollector.java,retrieveGroupHeadAndAddIfNotExist,78-78,[      MutableValue groupValue = mval.duplicate();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionAllGroupsCollector.java,collect,71-71,[    filler.fillValue(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionAllGroupsCollector.java,collect,73-73,[      groups.add(mval.duplicate());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionDistinctValuesCollector.java,collect,67-67,[      countFiller.fillValue(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionDistinctValuesCollector.java,collect,68-68,[      groupCount.uniqueValues.add(countMval.duplicate());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionDistinctValuesCollector.java,collect,64-64,[    groupFiller.fillValue(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionFirstPassGroupingCollector.java,getDocGroupValue,66-66,[    filler.fillValue(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/function/FunctionSecondPassGroupingCollector.java,retrieveGroup,69-69,[    filler.fillValue(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java,retrieveGroupHeadAndAddIfNotExist,427-427,[        groupHead = segmentGroupHeads[key+1];],,retrieveGroupHeadAndAddIfNotExist,423-423,[        segmentGroupHeads[key+1] = groupHead;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java,retrieveGroupHeadAndAddIfNotExist,268-268,[        groupHead = segmentGroupHeads[key+1];],,retrieveGroupHeadAndAddIfNotExist,264-264,[        segmentGroupHeads[key+1] = groupHead;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java,retrieveGroupHeadAndAddIfNotExist,559-559,[        groupHead = segmentGroupHeads[key+1];],,retrieveGroupHeadAndAddIfNotExist,555-555,[        segmentGroupHeads[key+1] = groupHead;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermDistinctValuesCollector.java,collect,77-77,[    int countOrd = countFieldTermIndex.getOrd(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermDistinctValuesCollector.java,collect,71-71,[    int slot = ordSet.find(groupFieldTermIndex.getOrd(doc));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermDistinctValuesCollector.java,collect,86-86,[      gc.ords = Arrays.copyOf(gc.ords, gc.ords.length + 1);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermFirstPassGroupingCollector.java,getDocGroupValue,66-66,[    final int ord = index.getOrd(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java,collect,234-234,[      while ((ord = facetFieldDocTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {],,collect,231-231,[      facetFieldDocTermOrds.setDocument(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java,process,270-270,[        facetValue = BytesRef.deepCopyOf(facetFieldDocTermOrds.lookupOrd(facetOrd));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java,collect,90-90,[      int facetOrd = facetFieldTermsIndex.getOrd(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java,createSegmentResult,172-172,[      return new SegmentResult(segmentFacetCounts, segmentTotalCount, facetFieldTermsIndex.termsEnum(), startFacetOrd, endFacetOrd);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/grouping/term/TermSecondPassGroupingCollector.java,retrieveGroup,73-73,[    int slot = ordSet.find(index.getOrd(doc));],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/highlight/Highlighter.java,lessThan,525-525,[    if (fragA.getScore() == fragB.getScore())],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/search/highlight/Highlighter.java,getBestTextFragments,353-353,[        catch (Exception e)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/highlight/Highlighter.java,getBestTextFragments,346-346,[      if (tokenStream != null)],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/search/highlight/QueryTermScorer.java,,37-37,[  TextFragment currentTextFragment = null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/highlight/TermVectorLeafReader.java,,50-66,[    fields = new Fields() {,       @Override,       public Iterator<String> iterator() {,         return Collections.singletonList(field).iterator();,       }, ,       @Override,       public Terms terms(String fld) throws IOException {,         if (!field.equals(fld)) {,           return null;,         },         return terms;,       }, ,       @Override,       public int size() {,         return 1;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java,,625-643,[  @SuppressWarnings("serial"),   protected static class PositionCheckingMap<K> extends HashMap<K,WeightedSpanTerm> {, ,     @Override,     public void putAll(Map<? extends K,? extends WeightedSpanTerm> m) {,       for (Map.Entry<? extends K,? extends WeightedSpanTerm> entry : m.entrySet()),         this.put(entry.getKey(), entry.getValue());,     }, ,     @Override,     public WeightedSpanTerm put(K key, WeightedSpanTerm value) {,       WeightedSpanTerm prev = super.put(key, value);,       if (prev == null) return prev;,       WeightedSpanTerm prevTerm = prev;,       WeightedSpanTerm newTerm = value;,       if (!prevTerm.positionSensitive) {,         newTerm.positionSensitive = false;,       },       return prev;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/join/BitDocIdSetCachingWrapperFilter.java,,43-59,[    this.filter = new CachingWrapperFilter(filter, FilterCachingPolicy.ALWAYS_CACHE) {,       @Override,       protected BitDocIdSet docIdSetToCache(DocIdSet docIdSet, LeafReader reader) throws IOException {,         if (docIdSet == null || docIdSet instanceof BitDocIdSet) {,           // this is different from CachingWrapperFilter: even when the DocIdSet is,           // cacheable, we convert it to a BitSet since we require all the,           // cached filters to be BitSets,           return (BitDocIdSet) docIdSet;,         }, ,         final DocIdSetIterator it = docIdSet.iterator();,         if (it == null) {,           return null;,         },         BitDocIdSet.Builder builder = new BitDocIdSet.Builder(reader.maxDoc());,         builder.or(it);,         return builder.build();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/search/join/FakeScorer.java,,30-30,[  int freq = 1;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/search/join/TermsCollector.java,,66-66,[    final BytesRef scratch = new BytesRef();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/join/TermsCollector.java,collect,75-75,[      docTermOrds.setDocument(doc);],,collect,78-78,[        final BytesRef term = docTermOrds.lookupOrd(ord);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/search/join/TermsCollector.java,,92-92,[    final BytesRef spare = new BytesRef();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/join/TermsCollector.java,collect,101-101,[      final BytesRef term = fromDocTerms.get(doc);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/search/join/TermsIncludingScoreQuery.java,explain,280-280,[            docId = tempDocId;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/search/join/TermsIncludingScoreQuery.java,,226-226,[      this.cost = cost;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/search/join/TermsWithScoreCollector.java,collect,199-204,[        switch (scoreMode) {,           case Total:,             scoreSums[termID] += scorer.score();,             break;,           case Max:,             scoreSums[termID] = Math.max(scoreSums[termID], scorer.score());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/search/join/TermsWithScoreCollector.java,collect,115-121,[        switch (scoreMode) {,           case Total:,             scoreSums[ord] = scoreSums[ord] + current;,             break;,           case Max:,             if (current > existing) {,               scoreSums[ord] = current;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/join/TermsWithScoreCollector.java,collect,101-101,[      int ord = collectedTerms.add(fromDocTerms.get(doc));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/join/TermsWithScoreCollector.java,collect,142-142,[        int ord = collectedTerms.add(fromDocTerms.get(doc));],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/join/ToChildBlockJoinQuery.java,clone,377-377,[    return new ToChildBlockJoinQuery(origParentQuery.clone(),],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/lucene/search/join/ToChildBlockJoinQuery.java,hashCode,370-370,[    hash = prime * hash + new Boolean(doScores).hashCode();],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/search/SortField.java,equals,280-287,[    if (this == o) return true;,     if (!(o instanceof SortField)) return false;,     final SortField other = (SortField)o;,     return (,       StringHelper.equals(other.field, this.field),       && other.type == this.type,       && other.reverse == this.reverse,       && (other.comparatorSource == null ? this.comparatorSource == null : other.comparatorSource.equals(this.comparatorSource))],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/payloads/PayloadNearQuery.java,clone,80-89,[    int sz = clauses.size();,     SpanQuery[] newClauses = new SpanQuery[sz];, ,     for (int i = 0; i < sz; i++) {,       newClauses[i] = (SpanQuery) clauses.get(i).clone();,     },     PayloadNearQuery boostingNearQuery = new PayloadNearQuery(newClauses, slop,,         inOrder, function);,     boostingNearQuery.setBoost(getBoost());,     return boostingNearQuery;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/payloads/PayloadNearQuery.java,scorer,159-159,[      if (scorer != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/payloads/PayloadTermQuery.java,scorer,180-180,[      if (scorer != null) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/search/postingshighlight/Passage.java,getMatchEnds,149-149,[    return matchEnds;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/search/postingshighlight/Passage.java,getMatchStarts,138-138,[    return matchStarts;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/search/postingshighlight/Passage.java,getMatchTerms,158-158,[    return matchTerms;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/postingshighlight/Passage.java,,67-85,[    new InPlaceMergeSorter() {,       @Override,       protected void swap(int i, int j) {,         int temp = starts[i];,         starts[i] = starts[j];,         starts[j] = temp;,         ,         temp = ends[i];,         ends[i] = ends[j];,         ends[j] = temp;,         ,         BytesRef tempTerm = terms[i];,         terms[i] = terms[j];,         terms[j] = tempTerm;,       }, ,       @Override,       protected int compare(int i, int j) {,         return Integer.compare(starts[i], starts[j]);],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/lucene/search/postingshighlight/PostingsHighlighter.java,loadFieldValues,429-429,[        contents[j][i] = visitor.getValue(j).toString();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/lucene/search/postingshighlight/PostingsHighlighter.java,highlightDoc,672-672,[    return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/postingshighlight/PostingsHighlighter.java,,365-379,[    new InPlaceMergeSorter() {, ,       @Override,       protected void swap(int i, int j) {,         String tmp = fields[i];,         fields[i] = fields[j];,         fields[j] = tmp;,         int tmp2 = maxPassages[i];,         maxPassages[i] = maxPassages[j];,         maxPassages[j] = tmp2;,       }, ,       @Override,       protected int compare(int i, int j) {,         return fields[i].compareTo(fields[j]);],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/lucene/search/postingshighlight/PostingsHighlighter.java,compare,582-582,[        } else if (left.score > right.score) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/postingshighlight/PostingsHighlighter.java,,577-585,[    PriorityQueue<Passage> passageQueue = new PriorityQueue<>(n, new Comparator<Passage>() {,       @Override,       public int compare(Passage left, Passage right) {,         if (left.score < right.score) {,           return -1;,         } else if (left.score > right.score) {,           return 1;,         } else {,           return left.startOffset - right.startOffset;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/postingshighlight/PostingsHighlighter.java,,631-634,[          Arrays.sort(passages, new Comparator<Passage>() {,             @Override,             public int compare(Passage left, Passage right) {,               return left.startOffset - right.startOffset;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/search/postingshighlight/PostingsHighlighter.java,compareTo,714-722,[        int off = dp.startOffset();,         int otherOff = other.dp.startOffset();,         if (off == otherOff) {,           return id - other.id;,         } else {,           return Integer.compare(off, otherOff);,         },       } catch (IOException e) {,         throw new RuntimeException(e);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/BM25Similarity.java,simScorer,216-216,[    BM25Stats bm25stats = (BM25Stats) stats;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/search/similarities/BasicModelP.java,,32-32,[  protected static double LOG2_E = log2(Math.E);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/search/similarities/BasicStats.java,,138-138,[    this.topLevelBoost = topLevelBoost;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/LMDirichletSimilarity.java,explain,81-81,[    weightExpl.setValue((float)Math.log(1 + freq /],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/LMDirichletSimilarity.java,score,66-66,[    float score = stats.getTotalBoost() * (float)(Math.log(1 + freq /],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/LMJelinekMercerSimilarity.java,score,54-54,[    return stats.getTotalBoost() *],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/LMSimilarity.java,fillBasicStats,67-67,[    LMStats lmStats = (LMStats) stats;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/MultiSimilarity.java,simScorer,63-63,[      subScorers[i] = sims[i].simScorer(((MultiStats)stats).subStats[i], context);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/similarities/MultiSimilarity.java,<init>,42-42,[    this.sims = sims;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/PerFieldSimilarityWrapper.java,simScorer,58-58,[    PerFieldSimWeight perFieldWeight = (PerFieldSimWeight) weight;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/similarities/PerFieldSimilarityWrapper.java,simScorer,59-59,[    return perFieldWeight.delegate.simScorer(perFieldWeight.delegateWeight, context);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/similarities/PerFieldSimilarityWrapper.java,getValueForNormalization,73-73,[      return delegateWeight.getValueForNormalization();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/similarities/PerFieldSimilarityWrapper.java,normalize,78-78,[      delegateWeight.normalize(queryNorm, topLevelBoost);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/SimilarityBase.java,simScorer,205-205,[      BasicStats basicstats = (BasicStats) stats;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/search/similarities/TFIDFSimilarity.java,simScorer,697-697,[    IDFStats idfstats = (IDFStats) stats;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spans/FieldMaskingSpanQuery.java,equals,148-148,[            && (this.getBoost() == other.getBoost())],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/search/spans/NearSpansOrdered.java,getSubSpans,127-127,[    return subSpans;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/search/spans/NearSpansUnordered.java,getSubSpans,159-159,[    return subSpans;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/spans/NearSpansUnordered.java,,58-68,[  private class CellQueue extends PriorityQueue<SpansCell> {,     public CellQueue(int size) {,       super(size);,     },     ,     @Override,     protected final boolean lessThan(SpansCell spans1, SpansCell spans2) {,       if (spans1.doc() == spans2.doc()) {,         return docSpansOrdered(spans1, spans2);,       } else {,         return spans1.doc() < spans2.doc();],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/spans/SpanFirstQuery.java,clone,65-67,[    SpanFirstQuery spanFirstQuery = new SpanFirstQuery((SpanQuery) match.clone(), end);,     spanFirstQuery.setBoost(getBoost());,     return spanFirstQuery;],,
CORRECTNESS,EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC,org/apache/lucene/search/spans/SpanFirstQuery.java,equals,72-78,[    if (this == o) return true;,     if (!(o instanceof SpanFirstQuery)) return false;, ,     SpanFirstQuery other = (SpanFirstQuery)o;,     return this.end == other.end,          && this.match.equals(other.match),          && this.getBoost() == other.getBoost();],,equals,88-94,[    if (this == o) return true;,     if (!(o instanceof SpanPositionRangeQuery)) return false;, ,     SpanPositionRangeQuery other = (SpanPositionRangeQuery)o;,     return this.end == other.end && this.start == other.start,          && this.match.equals(other.match),          && this.getBoost() == other.getBoost();],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spans/SpanFirstQuery.java,equals,78-78,[         && this.getBoost() == other.getBoost();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java,,213-229,[      delegate = new TopTermsRewrite<SpanOrQuery>(size) {,         @Override,         protected int getMaxSize() {,           return Integer.MAX_VALUE;,         },     ,         @Override,         protected SpanOrQuery getTopLevelQuery() {,           return new SpanOrQuery();,         }, ,         @Override,         protected void addClause(SpanOrQuery topLevel, Term term, int docFreq, float boost, TermContext states) {,           final SpanTermQuery q = new SpanTermQuery(term);,           q.setBoost(boost);,           topLevel.addClause(q);,         }],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java,clone,92-94,[    SpanNearPayloadCheckQuery result = new SpanNearPayloadCheckQuery((SpanNearQuery) match.clone(), payloadToMatch);,     result.setBoost(getBoost());,     return result;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java,equals,105-105,[            && this.getBoost() == other.getBoost();],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/spans/SpanNearQuery.java,clone,159-167,[    int sz = clauses.size();,     SpanQuery[] newClauses = new SpanQuery[sz];, ,     for (int i = 0; i < sz; i++) {,       newClauses[i] = (SpanQuery) clauses.get(i).clone();,     },     SpanNearQuery spanNearQuery = new SpanNearQuery(newClauses, slop, inOrder);,     spanNearQuery.setBoost(getBoost());,     return spanNearQuery;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spans/SpanNearQuery.java,equals,182-182,[    return getBoost() == spanNearQuery.getBoost();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/search/spans/SpanNearQuery.java,,41-196,[public class SpanNearQuery extends SpanQuery implements Cloneable {,   protected List<SpanQuery> clauses;,   protected int slop;,   protected boolean inOrder;, ,   protected String field;,   private boolean collectPayloads;, ,   /** Construct a SpanNearQuery.  Matches spans matching a span from each,    * clause, with up to <code>slop</code> total unmatched positions between,    * them.,    * <br>When <code>inOrder</code> is true, the spans from each clause,    * must be in the same order as in <code>clauses</code> and must be non-overlapping.,    * <br>When <code>inOrder</code> is false, the spans from each clause,    * need not be ordered and may overlap.,    * @param clauses the clauses to find near each other,    * @param slop The slop value,    * @param inOrder true if order is important,    */,   public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder) {,     this(clauses, slop, inOrder, true);     ,   },   ,   public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder, boolean collectPayloads) {, ,     // copy clauses array into an ArrayList,     this.clauses = new ArrayList<>(clauses.length);,     for (int i = 0; i < clauses.length; i++) {,       SpanQuery clause = clauses[i];,       if (field == null) {                               // check field,         field = clause.getField();,       } else if (clause.getField() != null && !clause.getField().equals(field)) {,         throw new IllegalArgumentException("Clauses must have same field.");,       },       this.clauses.add(clause);,     },     this.collectPayloads = collectPayloads;,     this.slop = slop;,     this.inOrder = inOrder;,   }, ,   /** Return the clauses whose spans are matched. */,   public SpanQuery[] getClauses() {,     return clauses.toArray(new SpanQuery[clauses.size()]);,   }, ,   /** Return the maximum number of intervening unmatched positions permitted.*/,   public int getSlop() { return slop; }, ,   /** Return true if matches are required to be in-order.*/,   public boolean isInOrder() { return inOrder; }, ,   @Override,   public String getField() { return field; },   ,   @Override,   public void extractTerms(Set<Term> terms) {,     for (final SpanQuery clause : clauses) {,       clause.extractTerms(terms);,     },   }  ,   , ,   @Override,   public String toString(String field) {,     StringBuilder buffer = new StringBuilder();,     buffer.append("spanNear([");,     Iterator<SpanQuery> i = clauses.iterator();,     while (i.hasNext()) {,       SpanQuery clause = i.next();,       buffer.append(clause.toString(field));,       if (i.hasNext()) {,         buffer.append(", ");,       },     },     buffer.append("], ");,     buffer.append(slop);,     buffer.append(", ");,     buffer.append(inOrder);,     buffer.append(")");,     buffer.append(ToStringUtils.boost(getBoost()));,     return buffer.toString();,   }, ,   @Override,   public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException {,     if (clauses.size() == 0)                      // optimize 0-clause case,       return new SpanOrQuery(getClauses()).getSpans(context, acceptDocs, termContexts);, ,     if (clauses.size() == 1)                      // optimize 1-clause case,       return clauses.get(0).getSpans(context, acceptDocs, termContexts);, ,     return inOrder,             ? (Spans) new NearSpansOrdered(this, context, acceptDocs, termContexts, collectPayloads),             : (Spans) new NearSpansUnordered(this, context, acceptDocs, termContexts);,   }, ,   @Override,   public Query rewrite(IndexReader reader) throws IOException {,     SpanNearQuery clone = null;,     for (int i = 0 ; i < clauses.size(); i++) {,       SpanQuery c = clauses.get(i);,       SpanQuery query = (SpanQuery) c.rewrite(reader);,       if (query != c) {                     // clause rewrote: must clone,         if (clone == null),           clone = this.clone();,         clone.clauses.set(i,query);,       },     },     if (clone != null) {,       return clone;                        // some clauses rewrote,     } else {,       return this;                         // no clauses rewrote,     },   },   ,   @Override,   public SpanNearQuery clone() {,     int sz = clauses.size();,     SpanQuery[] newClauses = new SpanQuery[sz];, ,     for (int i = 0; i < sz; i++) {,       newClauses[i] = (SpanQuery) clauses.get(i).clone();,     },     SpanNearQuery spanNearQuery = new SpanNearQuery(newClauses, slop, inOrder);,     spanNearQuery.setBoost(getBoost());,     return spanNearQuery;,   }, ,   /** Returns true iff <code>o</code> is equal to this. */,   @Override,   public boolean equals(Object o) {,     if (this == o) return true;,     if (!(o instanceof SpanNearQuery)) return false;, ,     final SpanNearQuery spanNearQuery = (SpanNearQuery) o;, ,     if (inOrder != spanNearQuery.inOrder) return false;,     if (slop != spanNearQuery.slop) return false;,     if (!clauses.equals(spanNearQuery.clauses)) return false;, ,     return getBoost() == spanNearQuery.getBoost();,   }, ,   @Override,   public int hashCode() {,     int result;,     result = clauses.hashCode();,     // Mix bits before folding in things like boost, since it could cancel the,     // last element of clauses.  This particular mix also serves to,     // differentiate SpanNearQuery hashcodes from others.,     result ^= (result << 14) | (result >>> 19);  // reversible,     result += Float.floatToRawIntBits(getBoost());,     result += slop;,     result ^= (inOrder ? 0x99AFD3BD : 0);,     return result;],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/spans/SpanNotQuery.java,clone,99-102,[    SpanNotQuery spanNotQuery = new SpanNotQuery((SpanQuery)include.clone(),,           (SpanQuery) exclude.clone(), pre, post);,     spanNotQuery.setBoost(getBoost());,     return  spanNotQuery;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/search/spans/SpanNotQuery.java,,36-248,[public class SpanNotQuery extends SpanQuery implements Cloneable {,   private SpanQuery include;,   private SpanQuery exclude;,   private final int pre;,   private final int post;, ,   /** Construct a SpanNotQuery matching spans from <code>include</code> which,    * have no overlap with spans from <code>exclude</code>.*/,   public SpanNotQuery(SpanQuery include, SpanQuery exclude) {,      this(include, exclude, 0, 0);,   }, ,   ,   /** Construct a SpanNotQuery matching spans from <code>include</code> which,    * have no overlap with spans from <code>exclude</code> within ,    * <code>dist</code> tokens of <code>include</code>. */,   public SpanNotQuery(SpanQuery include, SpanQuery exclude, int dist) {,      this(include, exclude, dist, dist);,   },   ,   /** Construct a SpanNotQuery matching spans from <code>include</code> which,    * have no overlap with spans from <code>exclude</code> within ,    * <code>pre</code> tokens before or <code>post</code> tokens of <code>include</code>. */,   public SpanNotQuery(SpanQuery include, SpanQuery exclude, int pre, int post) {,     this.include = include;,     this.exclude = exclude;,     this.pre = (pre >=0) ? pre : 0;,     this.post = (post >= 0) ? post : 0;, ,     if (include.getField() != null && exclude.getField() != null && !include.getField().equals(exclude.getField())),       throw new IllegalArgumentException("Clauses must have same field.");,   }, ,   /** Return the SpanQuery whose matches are filtered. */,   public SpanQuery getInclude() { return include; }, ,   /** Return the SpanQuery whose matches must not overlap those returned. */,   public SpanQuery getExclude() { return exclude; }, ,   @Override,   public String getField() { return include.getField(); }, ,   @Override,   public void extractTerms(Set<Term> terms) { include.extractTerms(terms); }, ,   @Override,   public String toString(String field) {,     StringBuilder buffer = new StringBuilder();,     buffer.append("spanNot(");,     buffer.append(include.toString(field));,     buffer.append(", ");,     buffer.append(exclude.toString(field));,     buffer.append(", ");,     buffer.append(Integer.toString(pre));,     buffer.append(", ");,     buffer.append(Integer.toString(post));,     buffer.append(")");,     buffer.append(ToStringUtils.boost(getBoost()));,     return buffer.toString();,   }, ,   @Override,   public SpanNotQuery clone() {,     SpanNotQuery spanNotQuery = new SpanNotQuery((SpanQuery)include.clone(),,           (SpanQuery) exclude.clone(), pre, post);,     spanNotQuery.setBoost(getBoost());,     return  spanNotQuery;,   }, ,   @Override,   public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {,     return new Spans() {,         private Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);,         private boolean moreInclude = true;, ,         private Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);,         private boolean moreExclude = excludeSpans.next();, ,         @Override,         public boolean next() throws IOException {,           if (moreInclude)                        // move to next include,             moreInclude = includeSpans.next();, ,           while (moreInclude && moreExclude) {, ,             if (includeSpans.doc() > excludeSpans.doc()) // skip exclude,               moreExclude = excludeSpans.skipTo(includeSpans.doc());, ,             while (moreExclude                    // while exclude is before,                    && includeSpans.doc() == excludeSpans.doc(),                    && excludeSpans.end() <= includeSpans.start() - pre) {,               moreExclude = excludeSpans.next();  // increment exclude,             }, ,             if (!moreExclude                      // if no intersection,                 || includeSpans.doc() != excludeSpans.doc(),                 || includeSpans.end()+post <= excludeSpans.start()),               break;                              // we found a match, ,             moreInclude = includeSpans.next();    // intersected: keep scanning,           },           return moreInclude;,         }, ,         @Override,         public boolean skipTo(int target) throws IOException {,           if (moreInclude)                        // skip include,             moreInclude = includeSpans.skipTo(target);, ,           if (!moreInclude),             return false;, ,           if (moreExclude                         // skip exclude,               && includeSpans.doc() > excludeSpans.doc()),             moreExclude = excludeSpans.skipTo(includeSpans.doc());, ,           while (moreExclude                      // while exclude is before,                  && includeSpans.doc() == excludeSpans.doc(),                  && excludeSpans.end() <= includeSpans.start()-pre) {,             moreExclude = excludeSpans.next();    // increment exclude,           }, ,           if (!moreExclude                      // if no intersection,                 || includeSpans.doc() != excludeSpans.doc(),                 || includeSpans.end()+post <= excludeSpans.start()),             return true;                          // we found a match, ,           return next();                          // scan to next match,         }, ,         @Override,         public int doc() { return includeSpans.doc(); },         @Override,         public int start() { return includeSpans.start(); },         @Override,         public int end() { return includeSpans.end(); }, ,       // TODO: Remove warning after API has been finalized,       @Override,       public Collection<byte[]> getPayload() throws IOException {,         ArrayList<byte[]> result = null;,         if (includeSpans.isPayloadAvailable()) {,           result = new ArrayList<>(includeSpans.getPayload());,         },         return result;,       }, ,       // TODO: Remove warning after API has been finalized,       @Override,       public boolean isPayloadAvailable() throws IOException {,         return includeSpans.isPayloadAvailable();,       }, ,       @Override,       public long cost() {,         return includeSpans.cost();,       }, ,       @Override,       public String toString() {,           return "spans(" + SpanNotQuery.this.toString() + ")";,         }, ,       };,   }, ,   @Override,   public Query rewrite(IndexReader reader) throws IOException {,     SpanNotQuery clone = null;, ,     SpanQuery rewrittenInclude = (SpanQuery) include.rewrite(reader);,     if (rewrittenInclude != include) {,       clone = this.clone();,       clone.include = rewrittenInclude;,     },     SpanQuery rewrittenExclude = (SpanQuery) exclude.rewrite(reader);,     if (rewrittenExclude != exclude) {,       if (clone == null) clone = this.clone();,       clone.exclude = rewrittenExclude;,     }, ,     if (clone != null) {,       return clone;                        // some clauses rewrote,     } else {,       return this;                         // no clauses rewrote,     },   }, ,     /** Returns true iff <code>o</code> is equal to this. */,   @Override,   public boolean equals(Object o) {,     if (!super.equals(o)),       return false;, ,     SpanNotQuery other = (SpanNotQuery)o;,     return this.include.equals(other.include),             && this.exclude.equals(other.exclude),             && this.pre == other.pre ,             && this.post == other.post;,   }, ,   @Override,   public int hashCode() {,     int h = super.hashCode();,     h = Integer.rotateLeft(h, 1);,     h ^= include.hashCode();,     h = Integer.rotateLeft(h, 1);,     h ^= exclude.hashCode();,     h = Integer.rotateLeft(h, 1);,     h ^= pre;,     h = Integer.rotateLeft(h, 1);,     h ^= post;,     return h;],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/spans/SpanOrQuery.java,clone,80-88,[    int sz = clauses.size();,     SpanQuery[] newClauses = new SpanQuery[sz];, ,     for (int i = 0; i < sz; i++) {,       newClauses[i] = (SpanQuery) clauses.get(i).clone();,     },     SpanOrQuery soq = new SpanOrQuery(newClauses);,     soq.setBoost(getBoost());,     return soq;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spans/SpanOrQuery.java,equals,136-136,[    return getBoost() == that.getBoost();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/search/spans/SpanOrQuery.java,,39-172,[public class SpanOrQuery extends SpanQuery implements Cloneable {,   private List<SpanQuery> clauses;,   private String field;, ,   /** Construct a SpanOrQuery merging the provided clauses. */,   public SpanOrQuery(SpanQuery... clauses) {, ,     // copy clauses array into an ArrayList,     this.clauses = new ArrayList<>(clauses.length);,     for (int i = 0; i < clauses.length; i++) {,       addClause(clauses[i]);,     },   }, ,   /** Adds a clause to this query */,   public final void addClause(SpanQuery clause) {,     if (field == null) {,       field = clause.getField();,     } else if (clause.getField() != null && !clause.getField().equals(field)) {,       throw new IllegalArgumentException("Clauses must have same field.");,     },     this.clauses.add(clause);,   },   ,   /** Return the clauses whose spans are matched. */,   public SpanQuery[] getClauses() {,     return clauses.toArray(new SpanQuery[clauses.size()]);,   }, ,   @Override,   public String getField() { return field; }, ,   @Override,   public void extractTerms(Set<Term> terms) {,     for(final SpanQuery clause: clauses) {,       clause.extractTerms(terms);,     },   },   ,   @Override,   public SpanOrQuery clone() {,     int sz = clauses.size();,     SpanQuery[] newClauses = new SpanQuery[sz];, ,     for (int i = 0; i < sz; i++) {,       newClauses[i] = (SpanQuery) clauses.get(i).clone();,     },     SpanOrQuery soq = new SpanOrQuery(newClauses);,     soq.setBoost(getBoost());,     return soq;,   }, ,   @Override,   public Query rewrite(IndexReader reader) throws IOException {,     SpanOrQuery clone = null;,     for (int i = 0 ; i < clauses.size(); i++) {,       SpanQuery c = clauses.get(i);,       SpanQuery query = (SpanQuery) c.rewrite(reader);,       if (query != c) {                     // clause rewrote: must clone,         if (clone == null),           clone = this.clone();,         clone.clauses.set(i,query);,       },     },     if (clone != null) {,       return clone;                        // some clauses rewrote,     } else {,       return this;                         // no clauses rewrote,     },   }, ,   @Override,   public String toString(String field) {,     StringBuilder buffer = new StringBuilder();,     buffer.append("spanOr([");,     Iterator<SpanQuery> i = clauses.iterator();,     while (i.hasNext()) {,       SpanQuery clause = i.next();,       buffer.append(clause.toString(field));,       if (i.hasNext()) {,         buffer.append(", ");,       },     },     buffer.append("])");,     buffer.append(ToStringUtils.boost(getBoost()));,     return buffer.toString();,   }, ,   @Override,   public boolean equals(Object o) {,     if (this == o) return true;,     if (o == null || getClass() != o.getClass()) return false;, ,     final SpanOrQuery that = (SpanOrQuery) o;, ,     if (!clauses.equals(that.clauses)) return false;, ,     return getBoost() == that.getBoost();,   }, ,   @Override,   public int hashCode() {,     int h = clauses.hashCode();,     h ^= (h << 10) | (h >>> 23);,     h ^= Float.floatToRawIntBits(getBoost());,     return h;,   }, , ,   private class SpanQueue extends PriorityQueue<Spans> {,     public SpanQueue(int size) {,       super(size);,     }, ,     @Override,     protected final boolean lessThan(Spans spans1, Spans spans2) {,       if (spans1.doc() == spans2.doc()) {,         if (spans1.start() == spans2.start()) {,           return spans1.end() < spans2.end();,         } else {,           return spans1.start() < spans2.start();,         },       } else {,         return spans1.doc() < spans2.doc();,       },     },   }, ,   @Override,   public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {,     if (clauses.size() == 1)                      // optimize 1-clause case,       return (clauses.get(0)).getSpans(context, acceptDocs, termContexts);, ,     return new Spans() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/spans/SpanOrQuery.java,,148-162,[  private class SpanQueue extends PriorityQueue<Spans> {,     public SpanQueue(int size) {,       super(size);,     }, ,     @Override,     protected final boolean lessThan(Spans spans1, Spans spans2) {,       if (spans1.doc() == spans2.doc()) {,         if (spans1.start() == spans2.start()) {,           return spans1.end() < spans2.end();,         } else {,           return spans1.start() < spans2.start();,         },       } else {,         return spans1.doc() < spans2.doc();],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/spans/SpanPayloadCheckQuery.java,clone,94-96,[    SpanPayloadCheckQuery result = new SpanPayloadCheckQuery((SpanQuery) match.clone(), payloadToMatch);,     result.setBoost(getBoost());,     return result;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spans/SpanPayloadCheckQuery.java,equals,107-107,[         && this.getBoost() == other.getBoost();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/search/spans/SpanPositionCheckQuery.java,,41-115,[  public SpanPositionCheckQuery(SpanQuery match) {,     this.match = match;,   }, ,   /**,    * @return the SpanQuery whose matches are filtered.,    *,    * */,   public SpanQuery getMatch() { return match; }, , , ,   @Override,   public String getField() { return match.getField(); }, , , ,   @Override,   public void extractTerms(Set<Term> terms) {,     match.extractTerms(terms);,   }, ,   /** ,    * Return value for {@link SpanPositionCheckQuery#acceptPosition(Spans)}.,    */,   protected static enum AcceptStatus {,     /** Indicates the match should be accepted */,     YES,,     ,     /** Indicates the match should be rejected */,     NO,,     ,     /** ,      * Indicates the match should be rejected, and the enumeration should advance,      * to the next document.,      */,     NO_AND_ADVANCE ,   };,   ,   /**,    * Implementing classes are required to return whether the current position is a match for the passed in,    * "match" {@link org.apache.lucene.search.spans.SpanQuery}.,    *,    * This is only called if the underlying {@link org.apache.lucene.search.spans.Spans#next()} for the,    * match is successful,    *,    *,    * @param spans The {@link org.apache.lucene.search.spans.Spans} instance, positioned at the spot to check,    * @return whether the match is accepted, rejected, or rejected and should move to the next doc.,    *,    * @see org.apache.lucene.search.spans.Spans#next(),    *,    */,   protected abstract AcceptStatus acceptPosition(Spans spans) throws IOException;, ,   @Override,   public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException {,     return new PositionCheckSpan(context, acceptDocs, termContexts);,   }, , ,   @Override,   public Query rewrite(IndexReader reader) throws IOException {,     SpanPositionCheckQuery clone = null;, ,     SpanQuery rewritten = (SpanQuery) match.rewrite(reader);,     if (rewritten != match) {,       clone = (SpanPositionCheckQuery) this.clone();,       clone.match = rewritten;,     }, ,     if (clone != null) {,       return clone;                        // some clauses rewrote,     } else {,       return this;                         // no clauses rewrote],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/search/spans/SpanPositionRangeQuery.java,clone,81-83,[    SpanPositionRangeQuery result = new SpanPositionRangeQuery((SpanQuery) match.clone(), start, end);,     result.setBoost(getBoost());,     return result;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spans/SpanPositionRangeQuery.java,equals,94-94,[         && this.getBoost() == other.getBoost();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/search/spell/CombineSuggestion.java,<init>,40-40,[    this.originalTermIndexes = originalTermIndexes;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spell/DirectSpellChecker.java,setMaxQueryFrequency,225-225,[    if (maxQueryFrequency >= 1f && maxQueryFrequency != (int) maxQueryFrequency)],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spell/DirectSpellChecker.java,setThresholdFrequency,184-184,[    if (thresholdFrequency >= 1f && thresholdFrequency != (int) thresholdFrequency)],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/spell/DirectSpellChecker.java,compareTo,507-507,[      if (this.boost == other.boost)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/search/spell/DirectSpellChecker.java,compareTo,505-505,[      if (term.bytesEquals(other.term))],,compareTo,508-508,[        return other.term.compareTo(this.term);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/search/spell/HighFrequencyDictionary.java,,65-121,[    private final BytesRefBuilder spare = new BytesRefBuilder();,     private final TermsEnum termsEnum;,     private int minNumDocs;,     private long freq;, ,     HighFrequencyIterator() throws IOException {,       Terms terms = MultiFields.getTerms(reader, field);,       if (terms != null) {,         termsEnum = terms.iterator(null);,       } else {,         termsEnum = null;,       },       minNumDocs = (int)(thresh * (float)reader.numDocs());,     }, ,     private boolean isFrequent(int freq) {,       return freq >= minNumDocs;,     },     ,     @Override,     public long weight() {,       return freq;,     }, ,     @Override,     public BytesRef next() throws IOException {,       if (termsEnum != null) {,         BytesRef next;,         while((next = termsEnum.next()) != null) {,           if (isFrequent(termsEnum.docFreq())) {,             freq = termsEnum.docFreq();,             spare.copyBytes(next);,             return spare.get();,           },         },       },       return  null;,     }, ,     @Override,     public BytesRef payload() {,       return null;,     }, ,     @Override,     public boolean hasPayloads() {,       return false;,     }, ,     @Override,     public Set<BytesRef> contexts() {,       return null;,     }, ,     @Override,     public boolean hasContexts() {,       return false;],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/lucene/search/spell/SuggestWordFrequencyComparator.java,compare,48-48,[    if (first.score < second.score) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/search/spell/SuggestWordFrequencyComparator.java,,26-52,[public class SuggestWordFrequencyComparator implements Comparator<SuggestWord> {,   ,   /**,    * Creates a new comparator that will compare by {@link SuggestWord#freq},,    * then by {@link SuggestWord#score}, then by {@link SuggestWord#string}.,    */,   public SuggestWordFrequencyComparator() {}, ,   @Override,   public int compare(SuggestWord first, SuggestWord second) {,     // first criteria: the frequency,     if (first.freq > second.freq) {,       return 1;,     },     if (first.freq < second.freq) {,       return -1;,     }, ,     // second criteria (if first criteria is equal): the score,     if (first.score > second.score) {,       return 1;,     },     if (first.score < second.score) {,       return -1;,     },     // third criteria: term text,     return second.string.compareTo(first.string);],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/lucene/search/spell/SuggestWordScoreComparator.java,compare,40-40,[    if (first.score < second.score) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/search/spell/SuggestWordScoreComparator.java,,26-53,[public class SuggestWordScoreComparator implements Comparator<SuggestWord> {,   ,   /**,    * Creates a new comparator that will compare by {@link SuggestWord#score},,    * then by {@link SuggestWord#freq}, then by {@link SuggestWord#string}.,    */,   public SuggestWordScoreComparator() {}, ,   @Override,   public int compare(SuggestWord first, SuggestWord second) {,     // first criteria: the distance,     if (first.score > second.score) {,       return 1;,     },     if (first.score < second.score) {,       return -1;,     }, ,     // second criteria (if first criteria is equal): the popularity,     if (first.freq > second.freq) {,       return 1;,     }, ,     if (first.freq < second.freq) {,       return -1;,     },     // third criteria: term text,     return second.string.compareTo(first.string);],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/lucene/search/spell/WordBreakSpellChecker.java,generateBreakUpSuggestions,287-287,[            suggestions.poll();],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/lucene/search/spell/WordBreakSpellChecker.java,suggestWordCombinations,239-239,[                suggestions.poll();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/lucene/search/spell/WordBreakSpellChecker.java,generateBreakUpSuggestions,285-285,[          suggestions.offer(suggestion);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/lucene/search/spell/WordBreakSpellChecker.java,suggestWordCombinations,237-237,[              suggestions.offer(suggestion);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/spell/WordBreakSpellChecker.java,,474-485,[  private class CombinationsThenFreqComparator implements,       Comparator<CombineSuggestionWrapper> {,     @Override,     public int compare(CombineSuggestionWrapper o1, CombineSuggestionWrapper o2) {,       if (o1.numCombinations != o2.numCombinations) {,         return o2.numCombinations - o1.numCombinations;,       },       if (o1.combineSuggestion.suggestion.freq != o2.combineSuggestion.suggestion.freq) {,         return o1.combineSuggestion.suggestion.freq,             - o2.combineSuggestion.suggestion.freq;,       },       return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/spell/WordBreakSpellChecker.java,,512-515,[        int numCombinations) {,       this.combineSuggestion = combineSuggestion;,       this.numCombinations = numCombinations;,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/spell/WordBreakSpellChecker.java,,446-456,[  private class LengthThenMaxFreqComparator implements,       Comparator<SuggestWordArrayWrapper> {,     @Override,     public int compare(SuggestWordArrayWrapper o1, SuggestWordArrayWrapper o2) {,       if (o1.suggestWords.length != o2.suggestWords.length) {,         return o2.suggestWords.length - o1.suggestWords.length;,       },       if (o1.freqMax != o2.freqMax) {,         return o1.freqMax - o2.freqMax;,       },       return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/spell/WordBreakSpellChecker.java,,460-470,[  private class LengthThenSumFreqComparator implements,       Comparator<SuggestWordArrayWrapper> {,     @Override,     public int compare(SuggestWordArrayWrapper o1, SuggestWordArrayWrapper o2) {,       if (o1.suggestWords.length != o2.suggestWords.length) {,         return o2.suggestWords.length - o1.suggestWords.length;,       },       if (o1.freqSum != o2.freqSum) {,         return o1.freqSum - o2.freqSum;,       },       return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/spell/WordBreakSpellChecker.java,,494-504,[    SuggestWordArrayWrapper(SuggestWord[] suggestWords) {,       this.suggestWords = suggestWords;,       int aFreqSum = 0;,       int aFreqMax = 0;,       for (SuggestWord sw : suggestWords) {,         aFreqSum += sw.freq;,         aFreqMax = Math.max(aFreqMax, sw.freq);,       },       this.freqSum = aFreqSum;,       this.freqMax = aFreqMax;,     }],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/search/suggest/Lookup.java,,127-142,[  private static class CharSequenceComparator implements Comparator<CharSequence> {, ,     @Override,     public int compare(CharSequence o1, CharSequence o2) {,       final int l1 = o1.length();,       final int l2 = o2.length();,       ,       final int aStop = Math.min(l1, l2);,       for (int i = 0; i < aStop; i++) {,         int diff = o1.charAt(i) - o2.charAt(i);,         if (diff != 0) {,           return diff;,         },       },       // One is a prefix of the other, or, they are equal:,       return l1 - l2;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/search/suggest/Lookup.java,compareTo,118-118,[      return CHARSEQUENCE_COMPARATOR.compare(key, o.key);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java,lookup,523-523,[      TopFieldDocs hits = (TopFieldDocs) c.topDocs();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java,lookup,422-422,[    Set<String> matchedTokens = new HashSet<>();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java,lookup,464-464,[        if (lastQuery != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java,lookup,440-440,[        if (lastToken != null) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java,,358-416,[  private static class AnalyzingComparator implements Comparator<BytesRef> {, ,     private final boolean hasPayloads;, ,     public AnalyzingComparator(boolean hasPayloads) {,       this.hasPayloads = hasPayloads;,     }, ,     private final ByteArrayDataInput readerA = new ByteArrayDataInput();,     private final ByteArrayDataInput readerB = new ByteArrayDataInput();,     private final BytesRef scratchA = new BytesRef();,     private final BytesRef scratchB = new BytesRef();, ,     @Override,     public int compare(BytesRef a, BytesRef b) {, ,       // First by analyzed form:,       readerA.reset(a.bytes, a.offset, a.length);,       scratchA.length = readerA.readShort();,       scratchA.bytes = a.bytes;,       scratchA.offset = readerA.getPosition();, ,       readerB.reset(b.bytes, b.offset, b.length);,       scratchB.bytes = b.bytes;,       scratchB.length = readerB.readShort();,       scratchB.offset = readerB.getPosition();, ,       int cmp = scratchA.compareTo(scratchB);,       if (cmp != 0) {,         return cmp;,       },       readerA.skipBytes(scratchA.length);,       readerB.skipBytes(scratchB.length);, ,       // Next by cost:,       long aCost = readerA.readInt();,       long bCost = readerB.readInt();,       assert decodeWeight(aCost) >= 0;,       assert decodeWeight(bCost) >= 0;,       if (aCost < bCost) {,         return -1;,       } else if (aCost > bCost) {,         return 1;,       }, ,       // Finally by surface form:,       if (hasPayloads) {,         scratchA.length = readerA.readShort();,         scratchB.length = readerB.readShort();,         scratchA.offset = readerA.getPosition();,         scratchB.offset = readerB.getPosition();,       } else {,         scratchA.offset = readerA.getPosition();,         scratchB.offset = readerB.getPosition();,         scratchA.length = a.length - scratchA.offset;,         scratchB.length = b.length - scratchB.offset;,       },    ,       return scratchA.compareTo(scratchB);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java,,67-67,[  public static int DEFAULT_NUM_FACTOR = 10;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java,,62-62,[  protected static double LINEAR_COEF = 0.10;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java,,288-300,[  private static class LookUpComparator implements Comparator<Lookup.LookupResult> {, ,     @Override,     public int compare(Lookup.LookupResult o1, Lookup.LookupResult o2) {,       // order on weight,       if (o1.value > o2.value) {,         return 1;,       } else if (o1.value < o2.value) {,         return -1;,       }, ,       // otherwise on alphabetic order,       return CHARSEQUENCE_COMPARATOR.compare(o1.key, o2.key);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java,,715-724,[      Collections.sort(results, new Comparator<LookupResult>() {,         @Override,         public int compare(LookupResult a, LookupResult b) {,           if (a.value > b.value) {,             return -1;,           } else if (a.value < b.value) {,             return 1;,           } else {,             // Tie break by UTF16 sort order:,             return ((String) a.key).compareTo((String) b.key);],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java,,224-264,[  private static class AnalyzingComparator implements Comparator<BytesRef> {, ,     private final ByteArrayDataInput readerA = new ByteArrayDataInput();,     private final ByteArrayDataInput readerB = new ByteArrayDataInput();,     private final BytesRef scratchA = new BytesRef();,     private final BytesRef scratchB = new BytesRef();, ,     @Override,     public int compare(BytesRef a, BytesRef b) {,       readerA.reset(a.bytes, a.offset, a.length);,       readerB.reset(b.bytes, b.offset, b.length);, ,       // By token:,       scratchA.length = readerA.readShort();,       scratchA.bytes = a.bytes;,       scratchA.offset = readerA.getPosition();, ,       scratchB.bytes = b.bytes;,       scratchB.length = readerB.readShort();,       scratchB.offset = readerB.getPosition();, ,       int cmp = scratchA.compareTo(scratchB);,       if (cmp != 0) {,         return cmp;,       },       readerA.skipBytes(scratchA.length);,       readerB.skipBytes(scratchB.length);, ,       // By length (smaller surface forms sorted first):,       cmp = a.length - b.length;,       if (cmp != 0) {,         return cmp;,       }, ,       // By surface form:,       scratchA.offset = readerA.getPosition();,       scratchA.length = a.length - scratchA.offset;,       scratchB.offset = readerB.getPosition();,       scratchB.length = b.length - scratchB.offset;, ,       return scratchA.compareTo(scratchB);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/suggest/fst/ExternalRefSorter.java,,111-137,[    private BytesRef scratch = new BytesRef();,     ,     public ByteSequenceIterator(OfflineSorter.ByteSequencesReader reader) {,       this.reader = reader;,     },     ,     @Override,     public BytesRef next() throws IOException {,       if (scratch == null) {,         return null;,       },       boolean success = false;,       try {,         byte[] next = reader.read();,         if (next != null) {,           scratch.bytes = next;,           scratch.length = next.length;,           scratch.offset = 0;,         } else {,           IOUtils.close(reader);,           scratch = null;,         },         success = true;,         return scratch;,       } finally {,         if (!success) {,           IOUtils.closeWhileHandlingException(reader);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/search/suggest/fst/FSTCompletion.java,compareTo,63-63,[      return this.utf8.compareTo(o.utf8);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/search/suggest/fst/FSTCompletionLookup.java,,81-331,[  private static int INVALID_BUCKETS_COUNT = -1;,   ,   /**,    * Shared tail length for conflating in the created automaton. Setting this,    * to larger values ({@link Integer#MAX_VALUE}) will create smaller (or minimal) ,    * automata at the cost of RAM for keeping nodes hash in the {@link FST}. ,    *  ,    * <p>Empirical pick.,    */,   private final static int sharedTailLength = 5;, ,   private int buckets;,   private boolean exactMatchFirst;, ,   /**,    * Automaton used for completions with higher weights reordering.,    */,   private FSTCompletion higherWeightsCompletion;, ,   /**,    * Automaton used for normal completions.,    */,   private FSTCompletion normalCompletion;, ,   /** Number of entries the lookup was built with */,   private long count = 0;, ,   /**,    * This constructor prepares for creating a suggested FST using the,    * {@link #build(InputIterator)} method. The number of weight,    * discretization buckets is set to {@link FSTCompletion#DEFAULT_BUCKETS} and,    * exact matches are promoted to the top of the suggestions list.,    */,   public FSTCompletionLookup() {,     this(FSTCompletion.DEFAULT_BUCKETS, true);,   }, ,   /**,    * This constructor prepares for creating a suggested FST using the,    * {@link #build(InputIterator)} method.,    * ,    * @param buckets,    *          The number of weight discretization buckets (see,    *          {@link FSTCompletion} for details).,    * ,    * @param exactMatchFirst,    *          If <code>true</code> exact matches are promoted to the top of the,    *          suggestions list. Otherwise they appear in the order of,    *          discretized weight and alphabetical within the bucket.,    */,   public FSTCompletionLookup(int buckets, boolean exactMatchFirst) {,     this.buckets = buckets;,     this.exactMatchFirst = exactMatchFirst;,   }, ,   /**,    * This constructor takes a pre-built automaton.,    * ,    *  @param completion ,    *          An instance of {@link FSTCompletion}.,    *  @param exactMatchFirst,    *          If <code>true</code> exact matches are promoted to the top of the,    *          suggestions list. Otherwise they appear in the order of,    *          discretized weight and alphabetical within the bucket.,    */,   public FSTCompletionLookup(FSTCompletion completion, boolean exactMatchFirst) {,     this(INVALID_BUCKETS_COUNT, exactMatchFirst);,     this.normalCompletion = new FSTCompletion(,         completion.getFST(), false, exactMatchFirst);,     this.higherWeightsCompletion =  new FSTCompletion(,         completion.getFST(), true, exactMatchFirst);,   }, ,   @Override,   public void build(InputIterator iterator) throws IOException {,     if (iterator.hasPayloads()) {,       throw new IllegalArgumentException("this suggester doesn't support payloads");,     },     if (iterator.hasContexts()) {,       throw new IllegalArgumentException("this suggester doesn't support contexts");,     },     Path tempInput = Files.createTempFile(,         OfflineSorter.defaultTempDir(), FSTCompletionLookup.class.getSimpleName(), ".input");,     Path tempSorted = Files.createTempFile(,         OfflineSorter.defaultTempDir(), FSTCompletionLookup.class.getSimpleName(), ".sorted");, ,     OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);,     OfflineSorter.ByteSequencesReader reader = null;,     ExternalRefSorter sorter = null;, ,     // Push floats up front before sequences to sort them. For now, assume they are non-negative.,     // If negative floats are allowed some trickery needs to be done to find their byte order.,     boolean success = false;,     count = 0;,     try {,       byte [] buffer = new byte [0];,       ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);,       BytesRef spare;,       while ((spare = iterator.next()) != null) {,         if (spare.length + 4 >= buffer.length) {,           buffer = ArrayUtil.grow(buffer, spare.length + 4);,         }, ,         output.reset(buffer);,         output.writeInt(encodeWeight(iterator.weight()));,         output.writeBytes(spare.bytes, spare.offset, spare.length);,         writer.write(buffer, 0, output.getPosition());,       },       writer.close();, ,       // We don't know the distribution of scores and we need to bucket them, so we'll sort,       // and divide into equal buckets.,       SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);,       Files.delete(tempInput);,       FSTCompletionBuilder builder = new FSTCompletionBuilder(,           buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);, ,       final int inputLines = info.lines;,       reader = new OfflineSorter.ByteSequencesReader(tempSorted);,       long line = 0;,       int previousBucket = 0;,       int previousScore = 0;,       ByteArrayDataInput input = new ByteArrayDataInput();,       BytesRefBuilder tmp1 = new BytesRefBuilder();,       BytesRef tmp2 = new BytesRef();,       while (reader.read(tmp1)) {,         input.reset(tmp1.bytes());,         int currentScore = input.readInt();, ,         int bucket;,         if (line > 0 && currentScore == previousScore) {,           bucket = previousBucket;,         } else {,           bucket = (int) (line * buckets / inputLines);,         },         previousScore = currentScore;,         previousBucket = bucket;, ,         // Only append the input, discard the weight.,         tmp2.bytes = tmp1.bytes();,         tmp2.offset = input.getPosition();,         tmp2.length = tmp1.length() - input.getPosition();,         builder.add(tmp2, bucket);, ,         line++;,         count++;,       }, ,       // The two FSTCompletions share the same automaton.,       this.higherWeightsCompletion = builder.build();,       this.normalCompletion = new FSTCompletion(,           higherWeightsCompletion.getFST(), false, exactMatchFirst);,       ,       success = true;,     } finally {,       IOUtils.closeWhileHandlingException(reader, writer, sorter);, ,       if (success) {,         Files.delete(tempSorted);,       } else {,         IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);,       },     },   },   ,   /** weight -&gt; cost */,   private static int encodeWeight(long value) {,     if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {,       throw new UnsupportedOperationException("cannot encode value: " + value);,     },     return (int)value;,   }, ,   @Override,   public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, boolean higherWeightsFirst, int num) {,     if (contexts != null) {,       throw new IllegalArgumentException("this suggester doesn't support contexts");,     },     final List<Completion> completions;,     if (higherWeightsFirst) {,       completions = higherWeightsCompletion.lookup(key, num);,     } else {,       completions = normalCompletion.lookup(key, num);,     },     ,     final ArrayList<LookupResult> results = new ArrayList<>(completions.size());,     CharsRefBuilder spare = new CharsRefBuilder();,     for (Completion c : completions) {,       spare.copyUTF8Bytes(c.utf8);,       results.add(new LookupResult(spare.toString(), c.bucket));,     },     return results;,   }, ,   /**,    * Returns the bucket (weight) as a Long for the provided key if it exists,,    * otherwise null if it does not.,    */,   public Object get(CharSequence key) {,     final int bucket = normalCompletion.getBucket(key);,     return bucket == -1 ? null : Long.valueOf(bucket);,   }, , ,   @Override,   public synchronized boolean store(DataOutput output) throws IOException {,     output.writeVLong(count);,     if (this.normalCompletion == null || normalCompletion.getFST() == null) ,       return false;,     normalCompletion.getFST().save(output);,     return true;,   }, ,   @Override,   public synchronized boolean load(DataInput input) throws IOException {,     count = input.readVLong();,     this.higherWeightsCompletion = new FSTCompletion(new FST<>(,         input, NoOutputs.getSingleton()));,     this.normalCompletion = new FSTCompletion(,         higherWeightsCompletion.getFST(), false, exactMatchFirst);,     return true;,   }, ,   @Override,   public long ramBytesUsed() {,     long mem = RamUsageEstimator.shallowSizeOf(this) + RamUsageEstimator.shallowSizeOf(normalCompletion) + RamUsageEstimator.shallowSizeOf(higherWeightsCompletion);,     if (normalCompletion != null) {,       mem += normalCompletion.getFST().ramBytesUsed();,     },     if (higherWeightsCompletion != null && (normalCompletion == null || normalCompletion.getFST() != higherWeightsCompletion.getFST())) {,       // the fst should be shared between the 2 completion instances, don't count it twice,       mem += higherWeightsCompletion.getFST().ramBytesUsed();,     },     return mem;,   }, ,   @Override,   public Iterable<Accountable> getChildResources() {,     List<Accountable> resources = new ArrayList<>();,     if (normalCompletion != null) {,       resources.add(Accountables.namedAccountable("fst", normalCompletion.getFST()));,     },     if (higherWeightsCompletion != null && (normalCompletion == null || normalCompletion.getFST() != higherWeightsCompletion.getFST())) {,       resources.add(Accountables.namedAccountable("higher weights fst", higherWeightsCompletion.getFST()));,     },     return resources;,   }, ,   @Override,   public long getCount() {,     return count;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/search/suggest/fst/WFSTCompletionLookup.java,build,107-107,[    BytesRef scratch = new BytesRef();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/suggest/fst/WFSTCompletionLookup.java,,263-286,[  private final class WFSTInputIterator extends SortedInputIterator {, ,     WFSTInputIterator(InputIterator source) throws IOException {,       super(source);,       assert source.hasPayloads() == false;,     }, ,     @Override,     protected void encode(ByteSequencesWriter writer, ByteArrayDataOutput output, byte[] buffer, BytesRef spare, BytesRef payload, Set<BytesRef> contexts, long weight) throws IOException {,       if (spare.length + 4 >= buffer.length) {,         buffer = ArrayUtil.grow(buffer, spare.length + 4);,       },       output.reset(buffer);,       output.writeBytes(spare.bytes, spare.offset, spare.length);,       output.writeInt(encodeWeight(weight));,       writer.write(buffer, 0, output.getPosition());,     },     ,     @Override,     protected long decode(BytesRef scratch, ByteArrayDataInput tmpInput) {,       scratch.length -= 4; // int,       // skip suggestion:,       tmpInput.reset(scratch.bytes, scratch.offset+scratch.length, 4);,       return tmpInput.readInt();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/search/suggest/jaspell/JaspellLookup.java,,45-214,[  JaspellTernarySearchTrie trie = new JaspellTernarySearchTrie();,   private boolean usePrefix = true;,   private int editDistance = 2;, ,   /** Number of entries the lookup was built with */,   private long count = 0;,   ,   /** ,    * Creates a new empty trie ,    * @see #build(InputIterator),    * */,   public JaspellLookup() {}, ,   @Override,   public void build(InputIterator iterator) throws IOException {,     if (iterator.hasPayloads()) {,       throw new IllegalArgumentException("this suggester doesn't support payloads");,     },     if (iterator.hasContexts()) {,       throw new IllegalArgumentException("this suggester doesn't support contexts");,     },     count = 0;,     trie = new JaspellTernarySearchTrie();,     trie.setMatchAlmostDiff(editDistance);,     BytesRef spare;,     final CharsRefBuilder charsSpare = new CharsRefBuilder();, ,     while ((spare = iterator.next()) != null) {,       final long weight = iterator.weight();,       if (spare.length == 0) {,         continue;,       },       charsSpare.copyUTF8Bytes(spare);,       trie.put(charsSpare.toString(), Long.valueOf(weight));,       count++;,     },   }, ,   /** ,    * Adds a new node if <code>key</code> already exists,,    * otherwise replaces its value.,    * <p>,    * This method always returns false.,    */,   public boolean add(CharSequence key, Object value) {,     trie.put(key, value);,     // XXX,     return false;,   }, ,   /**,    * Returns the value for the specified key, or null,    * if the key does not exist.,    */,   public Object get(CharSequence key) {,     return trie.get(key);,   }, ,   @Override,   public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {,     if (contexts != null) {,       throw new IllegalArgumentException("this suggester doesn't support contexts");,     },     List<LookupResult> res = new ArrayList<>();,     List<String> list;,     int count = onlyMorePopular ? num * 2 : num;,     if (usePrefix) {,       list = trie.matchPrefix(key, count);,     } else {,       list = trie.matchAlmost(key, count);,     },     if (list == null || list.size() == 0) {,       return res;,       ,     },     int maxCnt = Math.min(num, list.size());,     if (onlyMorePopular) {,       LookupPriorityQueue queue = new LookupPriorityQueue(num);,       for (String s : list) {,         long freq = ((Number)trie.get(s)).longValue();,         queue.insertWithOverflow(new LookupResult(new CharsRef(s), freq));,       },       for (LookupResult lr : queue.getResults()) {,         res.add(lr);,       },     } else {,       for (int i = 0; i < maxCnt; i++) {,         String s = list.get(i);,         long freq = ((Number)trie.get(s)).longValue();,         res.add(new LookupResult(new CharsRef(s), freq));,       }      ,     },     return res;,   }, ,   private static final byte LO_KID = 0x01;,   private static final byte EQ_KID = 0x02;,   private static final byte HI_KID = 0x04;,   private static final byte HAS_VALUE = 0x08;,  ,   private void readRecursively(DataInput in, TSTNode node) throws IOException {,     node.splitchar = in.readString().charAt(0);,     byte mask = in.readByte();,     if ((mask & HAS_VALUE) != 0) {,       node.data = Long.valueOf(in.readLong());,     },     if ((mask & LO_KID) != 0) {,       TSTNode kid = trie.new TSTNode('\0', node);,       node.relatives[TSTNode.LOKID] = kid;,       readRecursively(in, kid);,     },     if ((mask & EQ_KID) != 0) {,       TSTNode kid = trie.new TSTNode('\0', node);,       node.relatives[TSTNode.EQKID] = kid;,       readRecursively(in, kid);,     },     if ((mask & HI_KID) != 0) {,       TSTNode kid = trie.new TSTNode('\0', node);,       node.relatives[TSTNode.HIKID] = kid;,       readRecursively(in, kid);,     },   }, ,   private void writeRecursively(DataOutput out, TSTNode node) throws IOException {,     if (node == null) {,       return;,     },     out.writeString(new String(new char[] {node.splitchar}, 0, 1));,     byte mask = 0;,     if (node.relatives[TSTNode.LOKID] != null) mask |= LO_KID;,     if (node.relatives[TSTNode.EQKID] != null) mask |= EQ_KID;,     if (node.relatives[TSTNode.HIKID] != null) mask |= HI_KID;,     if (node.data != null) mask |= HAS_VALUE;,     out.writeByte(mask);,     if (node.data != null) {,       out.writeLong(((Number)node.data).longValue());,     },     writeRecursively(out, node.relatives[TSTNode.LOKID]);,     writeRecursively(out, node.relatives[TSTNode.EQKID]);,     writeRecursively(out, node.relatives[TSTNode.HIKID]);,   }, ,   @Override,   public boolean store(DataOutput output) throws IOException {,     output.writeVLong(count);,     TSTNode root = trie.getRoot();,     if (root == null) { // empty tree,       return false;,     },     writeRecursively(output, root);,     return true;,   }, ,   @Override,   public boolean load(DataInput input) throws IOException {,     count = input.readVLong();,     TSTNode root = trie.new TSTNode('\0', null);,     readRecursively(input, root);,     trie.setRoot(root);,     return true;,   }, ,   @Override,   public long ramBytesUsed() {,     return trie.ramBytesUsed();,   },   ,   @Override,   public long getCount() {,     return count;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/lucene/search/suggest/jaspell/JaspellTernarySearchTrie.java,<init>,236-236,[    Float occur, one = new Float(1);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/lucene/search/suggest/jaspell/JaspellTernarySearchTrie.java,getAndIncrement,421-421,[      aux = new Float(1);],,getAndIncrement,423-423,[      aux = new Float(aux.intValue() + 1);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/lucene/search/suggest/jaspell/JaspellTernarySearchTrie.java,<init>,231-231,[      in = new BufferedReader(IOUtils.getDecodingReader(new GZIPInputStream(],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/suggest/jaspell/JaspellTernarySearchTrie.java,<init>,249-249,[      if (key.length() > 0 && rootNode != null) {],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/search/suggest/jaspell/JaspellTernarySearchTrie.java,deleteNodeRecursion,384-384,[    if (!hikidNull) {],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/search/suggest/jaspell/JaspellTernarySearchTrie.java,deleteNodeRecursion,381-381,[    if (!lokidNull) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/lucene/search/suggest/jaspell/JaspellTernarySearchTrie.java,,83-111,[    protected final TSTNode[] relatives = new TSTNode[4];, ,     /** The char used in the split. */,     protected char splitchar;, ,     /**,      * Constructor method.,      * ,      *@param splitchar,      *          The char used in the split.,      *@param parent,      *          The parent node.,      */,     protected TSTNode(char splitchar, TSTNode parent) {,       this.splitchar = splitchar;,       relatives[PARENT] = parent;,     }, ,     @Override,     public long ramBytesUsed() {,       long mem = RamUsageEstimator.shallowSizeOf(this) + RamUsageEstimator.shallowSizeOf(relatives);,       // We don't need to add parent since our parent added itself:,       for (int i=1;i<4;i++) {,         TSTNode node = relatives[i];,         if (node != null) {,           mem += node.ramBytesUsed();,         },       },       return mem;],,
STYLE,IM_AVERAGE_COMPUTATION_COULD_OVERFLOW,org/apache/lucene/search/suggest/tst/TSTAutocomplete.java,balancedTree,48-48,[    int mid = (lo + hi) / 2;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/suggest/tst/TSTLookup.java,get,99-99,[    if (list == null || list.isEmpty()) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/search/suggest/tst/TSTLookup.java,lookup,130-130,[    if (list == null || list.size() == 0) {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java,,59-59,[  public static final String[] COLORED_POST_TAGS = { "</b>" };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java,,50-50,[  public static final String[] COLORED_PRE_TAGS = {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java,createFragments,129-129,[      return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java,,152-163,[    reader.document(docId, new StoredFieldVisitor() {,         ,         @Override,         public void stringField(FieldInfo fieldInfo, String value) {,           FieldType ft = new FieldType(TextField.TYPE_STORED);,           ft.setStoreTermVectors(fieldInfo.hasVectors());,           fields.add(new Field(fieldInfo.name, value, ft));,         }, ,         @Override,         public Status needsField(FieldInfo fieldInfo) {,           return fieldInfo.name.equals(fieldName) ? Status.YES : Status.NO;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java,,293-297,[    Collections.sort(result, new Comparator<WeightedFragInfo>() {, ,       @Override,       public int compare(FieldFragList.WeightedFragInfo info1, FieldFragList.WeightedFragInfo info2) {,         return info1.getStartOffset() - info2.getStartOffset();],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/search/vectorhighlight/FieldPhraseList.java,equals,386-386,[      if (getBoost() != other.getBoost()) {],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/lucene/search/vectorhighlight/ScoreOrderFragmentsBuilder.java,compare,74-74,[      else if( o1.getTotalBoost() < o2.getTotalBoost() ) return 1;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/search/vectorhighlight/ScoreOrderFragmentsBuilder.java,,69-80,[  public static class ScoreComparator implements Comparator<WeightedFragInfo> {, ,     @Override,     public int compare( WeightedFragInfo o1, WeightedFragInfo o2 ) {,       if( o1.getTotalBoost() > o2.getTotalBoost() ) return -1;,       else if( o1.getTotalBoost() < o2.getTotalBoost() ) return 1;,       // if same score then check startOffset,       else{,         if( o1.getStartOffset() < o2.getStartOffset() ) return -1;,         else if( o1.getStartOffset() > o2.getStartOffset() ) return 1;,       },       return 0;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/search/vectorhighlight/SimpleBoundaryScanner.java,,31-31,[  public static final Character[] DEFAULT_BOUNDARY_CHARS = {'.', ',', '!', '?', ' ', '\t', '\n'};],,
STYLE,QF_QUESTIONABLE_FOR_LOOP,org/apache/lucene/search/vectorhighlight/SimpleBoundaryScanner.java,findEndOffset,83-83,[    for( offset = start; offset < buffer.length() && count > 0; count-- ){],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/spatial/bbox/BBoxStrategy.java,makeContains,294-294,[        if (bbox.getMinX() == bbox.getMaxX() && Math.abs(bbox.getMinX()) == 180) {],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/spatial/prefix/AbstractPrefixTreeFilter.java,equals,55-64,[    if (this == o) return true;,     if (!getClass().equals(o.getClass())) return false;, ,     AbstractPrefixTreeFilter that = (AbstractPrefixTreeFilter) o;, ,     if (detailLevel != that.detailLevel) return false;,     if (!fieldName.equals(that.fieldName)) return false;,     if (!queryShape.equals(that.queryShape)) return false;, ,     return true;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java,addIntersectingChildren,220-220,[      if (cell.getLevel() >= detailLevel)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java,getDocIdSet,184-184,[        curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java,scan,280-280,[        if (!curVNode.cell.isPrefixOf(scanCell))],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java,addIntersectingChildren,250-250,[        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));],,addIntersectingChildren,219-219,[      Cell cell = curVNode.cell;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java,scan,280-280,[        if (!curVNode.cell.isPrefixOf(scanCell))],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.java,,273-299,[      return new DocIdSetIterator() {,         int idx = -1;,         @Override,         public int docID() {,           if (idx >= 0 && idx < size),             return docs[idx];,           else,             return -1;,         }, ,         @Override,         public int nextDoc() throws IOException {,           if (++idx < size),             return docs[idx];,           return NO_MORE_DOCS;,         }, ,         @Override,         public int advance(int target) throws IOException {,           //for this small set this is likely faster vs. a binary search,           // into the sorted array,           return slowAdvance(target);,         }, ,         @Override,         public long cost() {,           return size;],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter.java,equals,52-52,[    return super.equals(o) && hasIndexedLeaves == ((IntersectsPrefixTreeFilter)o).hasIndexedLeaves;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/spatial/prefix/NumberRangePrefixTreeFacets.java,visit,124-124,[                if (parentFacet.childCounts == null) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/spatial/prefix/NumberRangePrefixTreeFacets.java,visitLeaf,167-167,[              parentFacet.parentLeaves += count;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java,,97-97,[    this.defaultFieldValuesArrayLen = defaultFieldValuesArrayLen;],,,161-161,[          p = new PointPrefixTreeFieldCacheProvider(grid, getFieldName(), defaultFieldValuesArrayLen);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy.java,,51-51,[  protected boolean simplifyIndexedCells = false;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/spatial/prefix/WithinPrefixTreeFilter.java,finish,138-138,[        inside.andNot(outside);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree.java,toString,334-335,[        case Calendar.MILLISECOND: ptnLen += 4;,         case Calendar.SECOND: ptnLen += 3;],,toString,335-336,[        case Calendar.SECOND: ptnLen += 3;,         case Calendar.MINUTE: ptnLen += 3;],,toString,336-337,[        case Calendar.MINUTE: ptnLen += 3;,         case Calendar.HOUR_OF_DAY: ptnLen += 5;],,toString,337-338,[        case Calendar.HOUR_OF_DAY: ptnLen += 5;,         case Calendar.DAY_OF_MONTH: ptnLen += 3;],,toString,338-339,[        case Calendar.DAY_OF_MONTH: ptnLen += 3;,         case Calendar.MONTH: ptnLen += 3;],,toString,339-340,[        case Calendar.MONTH: ptnLen += 3;,         case Calendar.YEAR: ptnLen += 4;],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE,org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree.java,<init>,112-112,[    maxLV = toShape((Calendar)MAXCAL.clone());],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE,org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree.java,<init>,113-113,[    minLV = toShape((Calendar)MINCAL.clone());],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE,org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree.java,newCal,181-181,[    return (Calendar) CAL_TMP.clone();],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE,org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree.java,toCalendar,286-286,[      return (Calendar) MINCAL.clone();//full precision; truncation would cause underflow],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/spatial/prefix/tree/LegacyCell.java,compareToNoLeaf,207-207,[    LegacyCell b = (LegacyCell) fromCell;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/spatial/prefix/tree/LegacyCell.java,isPrefixOf,179-179,[    LegacyCell cell = (LegacyCell)c;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/spatial/prefix/tree/LegacyPrefixTree.java,readCell,55-55,[    LegacyCell cell = (LegacyCell) scratch;],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java,clone,889-891,[      NRCell cell = (NRCell) readCell(getTokenBytesNoLeaf(null), null);,       cell.ensureOwnTermBytes();,       return cell.getShape();],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java,relate,868-868,[      if ((startCmp < 0 || startCmp == 0 && nrMinLevel <= getLevel())],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java,relate,868-868,[      if ((startCmp < 0 || startCmp == 0 && nrMinLevel <= getLevel())],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java,clone,330-330,[      return new SpanUnitsNRShape(minLV.clone(), maxLV.clone());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/spatial/prefix/tree/TreeCellIterator.java,remove,82-82,[    assert thisCell() != null && nextCell == null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/spatial/serialized/SerializedDVStrategy.java,,86-92,[      byteStream.writeTo(new FilterOutputStream(null/*not used*/) {,         @Override,         public void write(byte[] b, int off, int len) throws IOException {,           bytesRef.bytes = b;,           bytesRef.offset = off;,           bytesRef.length = len;,         }],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/spatial/util/ShapeFieldCacheProvider.java,getCache,68-68,[      te = terms.iterator(te);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/spatial/vector/DistanceValueSource.java,equals,112-112,[    if (multiplier != that.multiplier) return false;],,
PERFORMANCE,DM_NEXTINT_VIA_NEXTDOUBLE,org/apache/lucene/store/BaseDirectoryTestCase.java,testLargeWrites,1021-1021,[      largeBuf[i] = (byte) (Math.random() * 256);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/store/BaseDirectoryTestCase.java,testRandomLong,786-786,[      assertEquals(longs[i], slice.readLong(i * 8));],,testRandomLong,791-791,[      long offset = i * 8;],,testRandomLong,794-794,[        assertEquals(longs[j], subslice.readLong((j - i) * 8));],,testRandomLong,811-811,[        assertEquals(longs[j], whole.readLong(j * 8));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/store/BaseDirectoryTestCase.java,,403-420,[      public TheThread(String name) {,         this.name = name;,       },       ,       @Override,       public void run() {,         for (int i = 0; i < 1000; i++) {,           String fileName = this.name + i;,           try {,             //System.out.println("create:" + fileName);,             IndexOutput output = dir.createOutput(fileName, newIOContext(random()));,             output.close();,             assertTrue(slowFileExists(dir, fileName));,           } catch (IOException e) {,             throw new RuntimeException(e);,           },         },       }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/store/BaseDirectoryTestCase.java,,423-458,[    class TheThread2 extends Thread {,       private String name;,       private volatile boolean stop;, ,       public TheThread2(String name) {,         this.name = name;,       },       ,       @Override,       public void run() {,         while (stop == false) {,           try {,             String[] files = dir.listAll();,             for (String file : files) {,               //System.out.println("file:" + file);,              try {,               IndexInput input = dir.openInput(file, newIOContext(random()));,               input.close();,               } catch (FileNotFoundException | NoSuchFileException e) {,                 // ignore,               } catch (IOException e) {,                 if (e.getMessage() != null && e.getMessage().contains("still open for writing")) {,                   // ignore,                 } else {,                   throw new RuntimeException(e);,                 },               },               if (random().nextBoolean()) {,                 break;,               },             },           } catch (IOException e) {,             throw new RuntimeException(e);,           },         },       }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/store/BaseDirectoryTestCase.java,,428-428,[        this.name = name;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/lucene/store/BufferedIndexInput.java,setBufferSize,75-75,[    assert buffer == null || bufferSize == buffer.length: "buffer=" + buffer + " bufferSize=" + bufferSize + " buffer.length=" + (buffer != null ? buffer.length : 0);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/store/BufferedIndexInput.java,setBufferSize,75-75,[    assert buffer == null || bufferSize == buffer.length: "buffer=" + buffer + " bufferSize=" + bufferSize + " buffer.length=" + (buffer != null ? buffer.length : 0);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/store/ByteArrayDataInput.java,reset,65-65,[    this.bytes = bytes;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/store/ByteArrayDataOutput.java,reset,51-51,[    this.bytes = bytes;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/lucene/store/FSDirectory.java,listAll,178-178,[        entries.add(path.getFileName().toString());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/lucene/store/FSDirectory.java,,264-277,[    public FSIndexOutput(String name) throws IOException {,       super("FSIndexOutput(path=\"" + directory.resolve(name) + "\")", new FilterOutputStream(Files.newOutputStream(directory.resolve(name))) {,         // This implementation ensures, that we never write more than CHUNK_SIZE bytes:,         @Override,         public void write(byte[] b, int offset, int length) throws IOException {,           while (length > 0) {,             final int chunk = Math.min(length, CHUNK_SIZE);,             out.write(b, offset, chunk);,             length -= chunk;,             offset += chunk;,           },         },       }, CHUNK_SIZE);,     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/store/IndexInput.java,,38-105,[public abstract class IndexInput extends DataInput implements Cloneable,Closeable {, ,   private final String resourceDescription;, ,   /** resourceDescription should be a non-null, opaque string,    *  describing this resource; it's returned from,    *  {@link #toString}. */,   protected IndexInput(String resourceDescription) {,     if (resourceDescription == null) {,       throw new IllegalArgumentException("resourceDescription must not be null");,     },     this.resourceDescription = resourceDescription;,   }, ,   /** Closes the stream to further operations. */,   @Override,   public abstract void close() throws IOException;, ,   /** Returns the current position in this file, where the next read will,    * occur.,    * @see #seek(long),    */,   public abstract long getFilePointer();, ,   /** Sets current position in this file, where the next read will occur.,    * @see #getFilePointer(),    */,   public abstract void seek(long pos) throws IOException;, ,   /** The number of bytes in the file. */,   public abstract long length();, ,   @Override,   public String toString() {,     return resourceDescription;,   },   ,   /** {@inheritDoc},    * <p><b>Warning:</b> Lucene never closes cloned,    * {@code IndexInput}s, it will only do this on the original one.,    * The original instance must take care that cloned instances throw,    * {@link AlreadyClosedException} when the original one is closed.,    */,   @Override,   public IndexInput clone() {,     return (IndexInput) super.clone();,   },   ,   /**,    * Creates a slice of this index input, with the given description, offset, and length. ,    * The slice is seeked to the beginning.,    */,   public abstract IndexInput slice(String sliceDescription, long offset, long length) throws IOException;,   ,   /**,    * Creates a random-access slice of this index input, with the given offset and length. ,    * <p>,    * The default implementation calls {@link #slice}, and it doesn't support random access,,    * it implements absolute reads as seek+read.,    */,   public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {,     final IndexInput slice = slice("randomaccess", offset, length);,     if (slice instanceof RandomAccessInput) {,       // slice() already supports random access,       return (RandomAccessInput) slice;,     } else {,       // return default impl,       return new RandomAccessInput() {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/store/IndexInput.java,,105-127,[      return new RandomAccessInput() {,         @Override,         public byte readByte(long pos) throws IOException {,           slice.seek(pos);,           return slice.readByte();,         },         ,         @Override,         public short readShort(long pos) throws IOException {,           slice.seek(pos);,           return slice.readShort();,         },         ,         @Override,         public int readInt(long pos) throws IOException {,           slice.seek(pos);,           return slice.readInt();,         },         ,         @Override,         public long readLong(long pos) throws IOException {,           slice.seek(pos);,           return slice.readLong();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/store/Lock.java,,42-42,[  public static long LOCK_POLL_INTERVAL = 1000;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/store/MMapDirectory.java,<clinit>,160-160,[    } catch (Exception e) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/store/MockDirectoryWrapper.java,crash,309-309,[      } catch (Exception ignored) {}],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,169-169,[    allowReadingFilesStillOpenForWrite = value;],,,660-660,[    if (!allowReadingFilesStillOpenForWrite && openFilesForWrite.contains(name) && !name.startsWith("segments")) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,421-421,[    return assertNoDeleteOpenFile;],,,417-417,[    this.assertNoDeleteOpenFile = value;],,,576-576,[    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {],,,577-577,[      if (!assertNoDeleteOpenFile) {],,,259-259,[      if (assertNoDeleteOpenFile) {],,,519-519,[    if (!forced && (noDeleteOpenFile || assertNoDeleteOpenFile)) {],,,523-523,[        if (!assertNoDeleteOpenFile) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,556-556,[    failOnCreateOutput = v;],,,564-564,[    if (failOnCreateOutput) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,643-643,[    failOnOpenInput = v;],,,651-651,[    if (failOnOpenInput) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,409-409,[    return noDeleteOpenFile;],,,405-405,[    this.noDeleteOpenFile = value;],,,576-576,[    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {],,,261-261,[      } else if (noDeleteOpenFile) {],,,519-519,[    if (!forced && (noDeleteOpenFile || assertNoDeleteOpenFile)) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,155-155,[    preventDoubleWrite = value;],,,572-572,[      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals("segments.gen")) {],,,596-596,[      if (existing!=null && !name.equals("segments.gen") && preventDoubleWrite) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,200-200,[    this.throttling = throttling;],,,613-613,[    if (throttling == Throttling.ALWAYS || ],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,209-209,[    useSlowOpenClosers = v;],,,668-668,[    if (useSlowOpenClosers && randomInt == 0) {],,,673-673,[    } else if (useSlowOpenClosers && randomInt  == 1) { ],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/lucene/store/MockDirectoryWrapper.java,,728-728,[    this.wrapLocking = v;],,,1012-1012,[    if (wrapLocking) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/lucene/store/MockDirectoryWrapper.java,,956-956,[      doFail = true;],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/lucene/store/MockIndexInputWrapper.java,clone,75-97,[    ensureOpen();,     if (dir.verboseClone) {,       new Exception("clone: " + this).printStackTrace(System.out);,     },     dir.inputCloneCount.incrementAndGet();,     IndexInput iiclone = delegate.clone();,     MockIndexInputWrapper clone = new MockIndexInputWrapper(dir, name, iiclone);,     clone.isClone = true;,     // Pending resolution on LUCENE-686 we may want to,     // uncomment this code so that we also track that all,     // clones get closed:,     /*,     synchronized(dir.openFiles) {,       if (dir.openFiles.containsKey(name)) {,         Integer v = (Integer) dir.openFiles.get(name);,         v = Integer.valueOf(v.intValue()+1);,         dir.openFiles.put(name, v);,       } else {,         throw new RuntimeException("BUG: cloned file was not open?");,       },     },     */,     return clone;],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/lucene/store/NRTCachingDirectory.java,toString,92-92,[    return "NRTCachingDirectory(" + in + "; maxCacheMB=" + (maxCachedBytes/1024/1024.) + " maxMergeSizeMB=" + (maxMergeSizeBytes/1024/1024.) + ")";],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/store/NativeUnixDirectory.java,close,322-322,[          if (!isClone) {],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/lucene/store/RAFDirectory.java,<init>,48-48,[    path.toFile(); // throw exception if we can't get a File],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/store/RAMInputStream.java,,40-132,[    this(name, f, f.length);,   }, ,   RAMInputStream(String name, RAMFile f, long length) throws IOException {,     super("RAMInputStream(name=" + name + ")");,     this.file = f;,     this.length = length;,     if (length/BUFFER_SIZE >= Integer.MAX_VALUE) {,       throw new IOException("RAMInputStream too large length=" + length + ": " + name); ,     }, ,     // make sure that we switch to the,     // first needed buffer lazily,     currentBufferIndex = -1;,     currentBuffer = null;,   }, ,   @Override,   public void close() {,     // nothing to do here,   }, ,   @Override,   public long length() {,     return length;,   }, ,   @Override,   public byte readByte() throws IOException {,     if (bufferPosition >= bufferLength) {,       currentBufferIndex++;,       switchCurrentBuffer(true);,     },     return currentBuffer[bufferPosition++];,   }, ,   @Override,   public void readBytes(byte[] b, int offset, int len) throws IOException {,     while (len > 0) {,       if (bufferPosition >= bufferLength) {,         currentBufferIndex++;,         switchCurrentBuffer(true);,       }, ,       int remainInBuffer = bufferLength - bufferPosition;,       int bytesToCopy = len < remainInBuffer ? len : remainInBuffer;,       System.arraycopy(currentBuffer, bufferPosition, b, offset, bytesToCopy);,       offset += bytesToCopy;,       len -= bytesToCopy;,       bufferPosition += bytesToCopy;,     },   }, ,   private final void switchCurrentBuffer(boolean enforceEOF) throws IOException {,     bufferStart = (long) BUFFER_SIZE * (long) currentBufferIndex;,     if (bufferStart > length || currentBufferIndex >= file.numBuffers()) {,       // end of file reached, no more buffers left,       if (enforceEOF) {,         throw new EOFException("read past EOF: " + this);,       } else {,         // Force EOF if a read takes place at this position,         currentBufferIndex--;,         bufferPosition = BUFFER_SIZE;,       },     } else {,       currentBuffer = file.getBuffer(currentBufferIndex);,       bufferPosition = 0;,       long buflen = length - bufferStart;,       bufferLength = buflen > BUFFER_SIZE ? BUFFER_SIZE : (int) buflen;,     },   }, ,   @Override,   public long getFilePointer() {,     return currentBufferIndex < 0 ? 0 : bufferStart + bufferPosition;,   }, ,   @Override,   public void seek(long pos) throws IOException {,     if (currentBuffer==null || pos < bufferStart || pos >= bufferStart + BUFFER_SIZE) {,       currentBufferIndex = (int) (pos / BUFFER_SIZE);,       switchCurrentBuffer(false);,     },     bufferPosition = (int) (pos % BUFFER_SIZE);,   }, ,   @Override,   public IndexInput slice(String sliceDescription, final long offset, final long length) throws IOException {,     if (offset < 0 || length < 0 || offset + length > this.length) {,       throw new IllegalArgumentException("slice() " + sliceDescription + " out of bounds: "  + this);,     },     final String newResourceDescription = (sliceDescription == null) ? toString() : (toString() + " [slice=" + sliceDescription + "]");,     return new RAMInputStream(newResourceDescription, file, offset + length) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/store/RAMInputStream.java,,132-157,[    return new RAMInputStream(newResourceDescription, file, offset + length) {,       {,         seek(0L);,       },       ,       @Override,       public void seek(long pos) throws IOException {,         if (pos < 0L) {,           throw new IllegalArgumentException("Seeking to negative position: " + this);,         },         super.seek(pos + offset);,       },       ,       @Override,       public long getFilePointer() {,         return super.getFilePointer() - offset;,       }, ,       @Override,       public long length() {,         return super.length() - offset;,       }, ,       @Override,       public IndexInput slice(String sliceDescription, long ofs, long len) throws IOException {,         return super.slice(sliceDescription, offset + ofs, len);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/uninverting/FieldCacheImpl.java,,865-873,[        wrapper.setDocsWithField(reader, key.field, new Bits() {,           @Override,           public boolean get(int index) {,             return offsetReader.get(index) != 0;,           }, ,           @Override,           public int length() {,             return maxDoc;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/uninverting/FieldCacheImpl.java,visitDoc,533-533,[            values.set(docID, currentValue - minValue);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/lucene/uninverting/FieldCacheSanityChecker.java,checkSubreaders,225-225,[      Set<ReaderField> kids = badChildren.get(parent);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/uninverting/FieldCacheSanityChecker.java,getCacheEntries,348-348,[    public CacheEntry[] getCacheEntries() { return entries; }],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/util/ArrayUtil.java,,615-619,[  private static class NaturalComparator<T extends Comparable<? super T>> implements Comparator<T> {,     NaturalComparator() {},     @Override,     public int compare(T o1, T o2) {,       return o1.compareTo(o2);],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/lucene/util/AttributeImpl.java,reflectWith,103-103,[        f.setAccessible(true);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/AttributeImpl.java,,51-61,[    reflectWith(new AttributeReflector() {,       @Override,       public void reflect(Class<? extends Attribute> attClass, String key, Object value) {,         if (buffer.length() > 0) {,           buffer.append(',');,         },         if (prependAttClass) {,           buffer.append(attClass.getName()).append('#');,         },         buffer.append(key).append('=').append((value == null) ? "null" : value);,       }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/AttributeSource.java,,123-142,[      return new Iterator<AttributeImpl>() {,         private State state = initState;,       ,         @Override,         public void remove() {,           throw new UnsupportedOperationException();,         },         ,         @Override,         public AttributeImpl next() {,           if (state == null),             throw new NoSuchElementException();,           final AttributeImpl att = state.attribute;,           state = state.next;,           return att;,         },         ,         @Override,         public boolean hasNext() {,           return state != null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/AttributeSource.java,,371-381,[    reflectWith(new AttributeReflector() {,       @Override,       public void reflect(Class<? extends Attribute> attClass, String key, Object value) {,         if (buffer.length() > 0) {,           buffer.append(',');,         },         if (prependAttClass) {,           buffer.append(attClass.getName()).append('#');,         },         buffer.append(key).append('=').append((value == null) ? "null" : value);,       }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/util/BaseDocIdSetTestCase.java,,176-176,[    dummy.o1 = copyOf(new BitSet(length), length);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/lucene/util/BaseDocIdSetTestCase.java,,177-177,[    dummy.o2 = set;],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/util/ByteBlockPool.java,,237-237,[  public final static int[] LEVEL_SIZE_ARRAY = {5, 14, 20, 30, 40, 40, 80, 80, 120, 200};],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/lucene/util/ByteBlockPool.java,,232-232,[  public final static int[] NEXT_LEVEL_ARRAY = {1, 2, 3, 4, 5, 6, 7, 8, 9, 9};],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/util/BytesRef.java,<init>,56-56,[    this.bytes = bytes;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/util/BytesRef.java,,219-268,[  @Deprecated,   private static class UTF8SortedAsUTF16Comparator implements Comparator<BytesRef> {,     // Only singleton,     private UTF8SortedAsUTF16Comparator() {};, ,     @Override,     public int compare(BytesRef a, BytesRef b) {, ,       final byte[] aBytes = a.bytes;,       int aUpto = a.offset;,       final byte[] bBytes = b.bytes;,       int bUpto = b.offset;,       ,       final int aStop;,       if (a.length < b.length) {,         aStop = aUpto + a.length;,       } else {,         aStop = aUpto + b.length;,       }, ,       while(aUpto < aStop) {,         int aByte = aBytes[aUpto++] & 0xff;,         int bByte = bBytes[bUpto++] & 0xff;, ,         if (aByte != bByte) {, ,           // See http://icu-project.org/docs/papers/utf16_code_point_order.html#utf-8-in-utf-16-order, ,           // We know the terms are not equal, but, we may,           // have to carefully fixup the bytes at the,           // difference to match UTF16's sort order:,           ,           // NOTE: instead of moving supplementary code points (0xee and 0xef) to the unused 0xfe and 0xff, ,           // we move them to the unused 0xfc and 0xfd [reserved for future 6-byte character sequences],           // this reserves 0xff for preflex's term reordering (surrogate dance), and if unicode grows such,           // that 6-byte sequences are needed we have much bigger problems anyway.,           if (aByte >= 0xee && bByte >= 0xee) {,             if ((aByte & 0xfe) == 0xee) {,               aByte += 0xe;,             },             if ((bByte&0xfe) == 0xee) {,               bByte += 0xe;,             },           },           return aByte - bByte;,         },       }, ,       // One is a prefix of the other, or, they are equal:,       return a.length - b.length;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/util/BytesRef.java,,181-204,[  private static class UTF8SortedAsUnicodeComparator implements Comparator<BytesRef> {,     // Only singleton,     private UTF8SortedAsUnicodeComparator() {};, ,     @Override,     public int compare(BytesRef a, BytesRef b) {,       final byte[] aBytes = a.bytes;,       int aUpto = a.offset;,       final byte[] bBytes = b.bytes;,       int bUpto = b.offset;,       ,       final int aStop = aUpto + Math.min(a.length, b.length);,       while(aUpto < aStop) {,         int aByte = aBytes[aUpto++] & 0xff;,         int bByte = bBytes[bUpto++] & 0xff;, ,         int diff = aByte - bByte;,         if (diff != 0) {,           return diff;,         },       }, ,       // One is a prefix of the other, or, they are equal:,       return a.length - b.length;],,
STYLE,EQ_UNUSUAL,org/apache/lucene/util/BytesRefBuilder.java,equals,178-178,[    throw new UnsupportedOperationException();],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/util/BytesRefHash.java,rehash,411-411,[    bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_INT * (newSize));],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/util/CharsRef.java,<init>,59-59,[    this.chars = chars;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/util/CharsRef.java,,191-235,[  @Deprecated,   private static class UTF16SortedAsUTF8Comparator implements Comparator<CharsRef> {,     // Only singleton,     private UTF16SortedAsUTF8Comparator() {};, ,     @Override,     public int compare(CharsRef a, CharsRef b) {,       if (a == b),         return 0;, ,       final char[] aChars = a.chars;,       int aUpto = a.offset;,       final char[] bChars = b.chars;,       int bUpto = b.offset;, ,       final int aStop = aUpto + Math.min(a.length, b.length);, ,       while (aUpto < aStop) {,         char aChar = aChars[aUpto++];,         char bChar = bChars[bUpto++];,         if (aChar != bChar) {,           // http://icu-project.org/docs/papers/utf16_code_point_order.html,           ,           /* aChar != bChar, fix up each one if they're both in or above the surrogate range, then compare them */,           if (aChar >= 0xd800 && bChar >= 0xd800) {,             if (aChar >= 0xe000) {,               aChar -= 0x800;,             } else {,               aChar += 0x2000;,             },             ,             if (bChar >= 0xe000) {,               bChar -= 0x800;,             } else {,               bChar += 0x2000;,             },           },           ,           /* now aChar and bChar are in code point order */,           return (int)aChar - (int)bChar; /* int must be 32 bits wide */,         },       }, ,       // One is a prefix of the other, or, they are equal:,       return a.length - b.length;],,
STYLE,EQ_UNUSUAL,org/apache/lucene/util/CharsRefBuilder.java,equals,167-167,[    throw new UnsupportedOperationException();],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/lucene/util/Constants.java,<clinit>,75-75,[      unsafeField.setAccessible(true);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/util/Constants.java,<clinit>,81-81,[    } catch (Exception e) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/util/English.java,longToEnglish,80-103,[      switch (((int) i) / 10) {,         case 9:,           result.append("ninety");,           break;,         case 8:,           result.append("eighty");,           break;,         case 7:,           result.append("seventy");,           break;,         case 6:,           result.append("sixty");,           break;,         case 5:,           result.append("fifty");,           break;,         case 4:,           result.append("forty");,           break;,         case 3:,           result.append("thirty");,           break;,         case 2:,           result.append("twenty");],,longToEnglish,112-171,[    switch ((int) i) {,       case 19:,         result.append("nineteen ");,         break;,       case 18:,         result.append("eighteen ");,         break;,       case 17:,         result.append("seventeen ");,         break;,       case 16:,         result.append("sixteen ");,         break;,       case 15:,         result.append("fifteen ");,         break;,       case 14:,         result.append("fourteen ");,         break;,       case 13:,         result.append("thirteen ");,         break;,       case 12:,         result.append("twelve ");,         break;,       case 11:,         result.append("eleven ");,         break;,       case 10:,         result.append("ten ");,         break;,       case 9:,         result.append("nine ");,         break;,       case 8:,         result.append("eight ");,         break;,       case 7:,         result.append("seven ");,         break;,       case 6:,         result.append("six ");,         break;,       case 5:,         result.append("five ");,         break;,       case 4:,         result.append("four ");,         break;,       case 3:,         result.append("three ");,         break;,       case 2:,         result.append("two ");,         break;,       case 1:,         result.append("one ");,         break;,       case 0:,         result.append("");],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/lucene/util/FixedBitSet.java,clone,450-452,[    long[] bits = new long[this.bits.length];,     System.arraycopy(this.bits, 0, bits, 0, bits.length);,     return new FixedBitSet(bits, numBits);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/util/FixedBitSet.java,getBits,135-135,[    return bits;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/util/FixedBitSet.java,<init>,120-120,[    this.bits = storedBits;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/util/FixedBitSet.java,,34-480,[public final class FixedBitSet extends BitSet implements MutableBits, Accountable {, ,   private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(FixedBitSet.class);, ,   /**,    * If the given {@link FixedBitSet} is large enough to hold {@code numBits},,    * returns the given bits, otherwise returns a new {@link FixedBitSet} which,    * can hold the requested number of bits.,    * ,    * <p>,    * <b>NOTE:</b> the returned bitset reuses the underlying {@code long[]} of,    * the given {@code bits} if possible. Also, calling {@link #length()} on the,    * returned bits may return a value greater than {@code numBits}.,    */,   public static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {,     if (numBits < bits.length()) {,       return bits;,     } else {,       int numWords = bits2words(numBits);,       long[] arr = bits.getBits();,       if (numWords >= arr.length) {,         arr = ArrayUtil.grow(arr, numWords + 1);,       },       return new FixedBitSet(arr, arr.length << 6);,     },   }, ,   /** returns the number of 64 bit words it would take to hold numBits */,   public static int bits2words(int numBits) {,     int numLong = numBits >>> 6;,     if ((numBits & 63) != 0) {,       numLong++;,     },     return numLong;,   }, ,   /**,    * Returns the popcount or cardinality of the intersection of the two sets.,    * Neither set is modified.,    */,   public static long intersectionCount(FixedBitSet a, FixedBitSet b) {,     return BitUtil.pop_intersect(a.bits, b.bits, 0, Math.min(a.numWords, b.numWords));,   }, ,   /**,    * Returns the popcount or cardinality of the union of the two sets. Neither,    * set is modified.,    */,   public static long unionCount(FixedBitSet a, FixedBitSet b) {,     long tot = BitUtil.pop_union(a.bits, b.bits, 0, Math.min(a.numWords, b.numWords));,     if (a.numWords < b.numWords) {,       tot += BitUtil.pop_array(b.bits, a.numWords, b.numWords - a.numWords);,     } else if (a.numWords > b.numWords) {,       tot += BitUtil.pop_array(a.bits, b.numWords, a.numWords - b.numWords);,     },     return tot;,   }, ,   /**,    * Returns the popcount or cardinality of "a and not b" or,    * "intersection(a, not(b))". Neither set is modified.,    */,   public static long andNotCount(FixedBitSet a, FixedBitSet b) {,     long tot = BitUtil.pop_andnot(a.bits, b.bits, 0, Math.min(a.numWords, b.numWords));,     if (a.numWords > b.numWords) {,       tot += BitUtil.pop_array(a.bits, b.numWords, a.numWords - b.numWords);,     },     return tot;,   }, ,   final long[] bits;,   final int numBits;,   final int numWords;, ,   public FixedBitSet(int numBits) {,     this.numBits = numBits;,     bits = new long[bits2words(numBits)];,     numWords = bits.length;,   }, ,   public FixedBitSet(long[] storedBits, int numBits) {,     this.numWords = bits2words(numBits);,     if (numWords > storedBits.length) {,       throw new IllegalArgumentException("The given long array is too small  to hold " + numBits + " bits");,     },     this.numBits = numBits;,     this.bits = storedBits;,   }, ,   @Override,   public int length() {,     return numBits;,   }, ,   @Override,   public long ramBytesUsed() {,     return BASE_RAM_BYTES_USED + RamUsageEstimator.sizeOf(bits);,   }, ,   /** Expert. */,   public long[] getBits() {,     return bits;,   }, ,   @Override,   public int cardinality() {,     return (int) BitUtil.pop_array(bits, 0, bits.length);,   }, ,   @Override,   public boolean get(int index) {,     assert index >= 0 && index < numBits: "index=" + index + ", numBits=" + numBits;,     int i = index >> 6;               // div 64,     // signed shift will keep a negative index and force an,     // array-index-out-of-bounds-exception, removing the need for an explicit check.,     long bitmask = 1L << index;,     return (bits[i] & bitmask) != 0;,   }, ,   public void set(int index) {,     assert index >= 0 && index < numBits: "index=" + index + ", numBits=" + numBits;,     int wordNum = index >> 6;      // div 64,     long bitmask = 1L << index;,     bits[wordNum] |= bitmask;,   }, ,   public boolean getAndSet(int index) {,     assert index >= 0 && index < numBits;,     int wordNum = index >> 6;      // div 64,     long bitmask = 1L << index;,     boolean val = (bits[wordNum] & bitmask) != 0;,     bits[wordNum] |= bitmask;,     return val;,   }, ,   @Override,   public void clear(int index) {,     assert index >= 0 && index < numBits;,     int wordNum = index >> 6;,     long bitmask = 1L << index;,     bits[wordNum] &= ~bitmask;,   }, ,   public boolean getAndClear(int index) {,     assert index >= 0 && index < numBits;,     int wordNum = index >> 6;      // div 64,     long bitmask = 1L << index;,     boolean val = (bits[wordNum] & bitmask) != 0;,     bits[wordNum] &= ~bitmask;,     return val;,   }, ,   @Override,   public int nextSetBit(int index) {,     assert index >= 0 && index < numBits : "index=" + index + ", numBits=" + numBits;,     int i = index >> 6;,     long word = bits[i] >> index;  // skip all the bits to the right of index, ,     if (word!=0) {,       return index + Long.numberOfTrailingZeros(word);,     }, ,     while(++i < numWords) {,       word = bits[i];,       if (word != 0) {,         return (i<<6) + Long.numberOfTrailingZeros(word);,       },     }, ,     return DocIdSetIterator.NO_MORE_DOCS;,   }, ,   @Override,   public int prevSetBit(int index) {,     assert index >= 0 && index < numBits: "index=" + index + " numBits=" + numBits;,     int i = index >> 6;,     final int subIndex = index & 0x3f;  // index within the word,     long word = (bits[i] << (63-subIndex));  // skip all the bits to the left of index, ,     if (word != 0) {,       return (i << 6) + subIndex - Long.numberOfLeadingZeros(word); // See LUCENE-3197,     }, ,     while (--i >= 0) {,       word = bits[i];,       if (word !=0 ) {,         return (i << 6) + 63 - Long.numberOfLeadingZeros(word);,       },     }, ,     return -1;,   }, ,   @Override,   public void or(DocIdSetIterator iter) throws IOException {,     if (BitSetIterator.getFixedBitSetOrNull(iter) != null) {,       assertUnpositioned(iter);,       final FixedBitSet bits = BitSetIterator.getFixedBitSetOrNull(iter); ,       or(bits);,     } else {,       super.or(iter);,     },   }, ,   /** this = this OR other */,   public void or(FixedBitSet other) {,     or(other.bits, other.numWords);,   },   ,   private void or(final long[] otherArr, final int otherNumWords) {,     assert otherNumWords <= numWords : "numWords=" + numWords + ", otherNumWords=" + otherNumWords;,     final long[] thisArr = this.bits;,     int pos = Math.min(numWords, otherNumWords);,     while (--pos >= 0) {,       thisArr[pos] |= otherArr[pos];,     },   },   ,   /** this = this XOR other */,   public void xor(FixedBitSet other) {,     xor(other.bits, other.numWords);,   },   ,   /** Does in-place XOR of the bits provided by the iterator. */,   public void xor(DocIdSetIterator iter) throws IOException {,     assertUnpositioned(iter);,     if (BitSetIterator.getFixedBitSetOrNull(iter) != null) {,       final FixedBitSet bits = BitSetIterator.getFixedBitSetOrNull(iter); ,       xor(bits);,     } else {,       int doc;,       while ((doc = iter.nextDoc()) < numBits) {,         flip(doc);,       },     },   }, ,   private void xor(long[] otherBits, int otherNumWords) {,     assert otherNumWords <= numWords : "numWords=" + numWords + ", other.numWords=" + otherNumWords;,     final long[] thisBits = this.bits;,     int pos = Math.min(numWords, otherNumWords);,     while (--pos >= 0) {,       thisBits[pos] ^= otherBits[pos];,     },   }, ,   @Override,   public void and(DocIdSetIterator iter) throws IOException {,     if (BitSetIterator.getFixedBitSetOrNull(iter) != null) {,       assertUnpositioned(iter);,       final FixedBitSet bits = BitSetIterator.getFixedBitSetOrNull(iter); ,       and(bits);,     } else {,       super.and(iter);,     },   }, ,   /** returns true if the sets have any elements in common */,   public boolean intersects(FixedBitSet other) {,     int pos = Math.min(numWords, other.numWords);,     while (--pos>=0) {,       if ((bits[pos] & other.bits[pos]) != 0) return true;,     },     return false;,   }, ,   /** this = this AND other */,   public void and(FixedBitSet other) {,     and(other.bits, other.numWords);,   },   ,   private void and(final long[] otherArr, final int otherNumWords) {,     final long[] thisArr = this.bits;,     int pos = Math.min(this.numWords, otherNumWords);,     while(--pos >= 0) {,       thisArr[pos] &= otherArr[pos];,     },     if (this.numWords > otherNumWords) {,       Arrays.fill(thisArr, otherNumWords, this.numWords, 0L);,     },   }, ,   @Override,   public void andNot(DocIdSetIterator iter) throws IOException {,     if (BitSetIterator.getFixedBitSetOrNull(iter) != null) {,       assertUnpositioned(iter);,       final FixedBitSet bits = BitSetIterator.getFixedBitSetOrNull(iter); ,       andNot(bits);,     } else {,       super.andNot(iter);,     },   }, ,   /** this = this AND NOT other */,   public void andNot(FixedBitSet other) {,     andNot(other.bits, other.bits.length);,   },   ,   private void andNot(final long[] otherArr, final int otherNumWords) {,     final long[] thisArr = this.bits;,     int pos = Math.min(this.numWords, otherNumWords);,     while(--pos >= 0) {,       thisArr[pos] &= ~otherArr[pos];,     },   }, ,   // NOTE: no .isEmpty() here because that's trappy (ie,,   // typically isEmpty is low cost, but this one wouldn't,   // be), ,   /** Flips a range of bits,    *,    * @param startIndex lower index,    * @param endIndex one-past the last bit to flip,    */,   public void flip(int startIndex, int endIndex) {,     assert startIndex >= 0 && startIndex < numBits;,     assert endIndex >= 0 && endIndex <= numBits;,     if (endIndex <= startIndex) {,       return;,     }, ,     int startWord = startIndex >> 6;,     int endWord = (endIndex-1) >> 6;, ,     /*** Grrr, java shifting wraps around so -1L>>>64 == -1,      * for that reason, make sure not to use endmask if the bits to flip will,      * be zero in the last word (redefine endWord to be the last changed...),     long startmask = -1L << (startIndex & 0x3f);     // example: 11111...111000,     long endmask = -1L >>> (64-(endIndex & 0x3f));   // example: 00111...111111,     ***/, ,     long startmask = -1L << startIndex;,     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap, ,     if (startWord == endWord) {,       bits[startWord] ^= (startmask & endmask);,       return;,     }, ,     bits[startWord] ^= startmask;, ,     for (int i=startWord+1; i<endWord; i++) {,       bits[i] = ~bits[i];,     }, ,     bits[endWord] ^= endmask;,   }, ,   /** Flip the bit at the provided index. */,   public void flip(int index) {,     assert index >= 0 && index < numBits: "index=" + index + " numBits=" + numBits;,     int wordNum = index >> 6;      // div 64,     int bit = index & 0x3f;     // mod 64,     long bitmask = 1L << bit;,     bits[wordNum] ^= bitmask;,   }, ,   /** Sets a range of bits,    *,    * @param startIndex lower index,    * @param endIndex one-past the last bit to set,    */,   public void set(int startIndex, int endIndex) {,     assert startIndex >= 0 && startIndex < numBits;,     assert endIndex >= 0 && endIndex <= numBits;,     if (endIndex <= startIndex) {,       return;,     }, ,     int startWord = startIndex >> 6;,     int endWord = (endIndex-1) >> 6;, ,     long startmask = -1L << startIndex;,     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap, ,     if (startWord == endWord) {,       bits[startWord] |= (startmask & endmask);,       return;,     }, ,     bits[startWord] |= startmask;,     Arrays.fill(bits, startWord+1, endWord, -1L);,     bits[endWord] |= endmask;,   }, ,   @Override,   public void clear(int startIndex, int endIndex) {,     assert startIndex >= 0 && startIndex < numBits : "startIndex=" + startIndex + ", numBits=" + numBits;,     assert endIndex >= 0 && endIndex <= numBits : "endIndex=" + endIndex + ", numBits=" + numBits;,     if (endIndex <= startIndex) {,       return;,     }, ,     int startWord = startIndex >> 6;,     int endWord = (endIndex-1) >> 6;, ,     long startmask = -1L << startIndex;,     long endmask = -1L >>> -endIndex;  // 64-(endIndex&0x3f) is the same as -endIndex due to wrap, ,     // invert masks since we are clearing,     startmask = ~startmask;,     endmask = ~endmask;, ,     if (startWord == endWord) {,       bits[startWord] &= (startmask | endmask);,       return;,     }, ,     bits[startWord] &= startmask;,     Arrays.fill(bits, startWord+1, endWord, 0L);,     bits[endWord] &= endmask;,   }, ,   @Override,   public FixedBitSet clone() {,     long[] bits = new long[this.bits.length];,     System.arraycopy(this.bits, 0, bits, 0, bits.length);,     return new FixedBitSet(bits, numBits);,   }, ,   /** returns true if both sets have the same bits set */,   @Override,   public boolean equals(Object o) {,     if (this == o) {,       return true;,     },     if (!(o instanceof FixedBitSet)) {,       return false;,     },     FixedBitSet other = (FixedBitSet) o;,     if (numBits != other.length()) {,       return false;,     },     return Arrays.equals(bits, other.bits);,   }, ,   @Override,   public int hashCode() {,     long h = 0;,     for (int i = numWords; --i>=0;) {,       h ^= bits[i];,       h = (h << 1) | (h >>> 63); // rotate left,     },     // fold leftmost bits into right and add a constant to prevent,     // empty sets from returning 0, which is too common.,     return (int) ((h>>32) ^ h) + 0x98761234;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/lucene/util/IOUtils.java,spinsLinux,492-492,[    devName = path.getRoot().resolve(devName).toRealPath().getFileName().toString();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/lucene/util/IOUtils.java,spinsLinux,495-495,[    Path sysinfo = path.getRoot().resolve("sys/block");],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/util/IntsRef.java,<init>,55-55,[    this.ints = ints;],,
STYLE,EQ_UNUSUAL,org/apache/lucene/util/IntsRefBuilder.java,equals,120-120,[    throw new UnsupportedOperationException();],,
STYLE,NP_DEREFERENCE_OF_READLINE_VALUE,org/apache/lucene/util/LineFileDocs.java,nextDoc,232-232,[    int spot = line.indexOf(SEP);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/lucene/util/LineFileDocs.java,open,89-89,[    InputStream is = getClass().getResourceAsStream(path);],,open,90-90,[    boolean needSkip = true;],,open,91-91,[    long size = 0L, seekTo = 0L;],,open,92-92,[    if (is == null) {],,open,112-112,[      size = is.available();],,
BAD_PRACTICE,SR_NOT_CHECKED,org/apache/lucene/util/LineFileDocs.java,open,128-128,[      is.skip(seekTo);],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/lucene/util/LineFileDocs.java,open,89-89,[    InputStream is = getClass().getResourceAsStream(path);],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/lucene/util/LongBitSet.java,clone,336-338,[    long[] bits = new long[this.bits.length];,     System.arraycopy(this.bits, 0, bits, 0, bits.length);,     return new LongBitSet(bits, numBits);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/util/LongBitSet.java,getBits,89-89,[    return bits;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/util/LongBitSet.java,<init>,79-79,[    this.bits = storedBits;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/util/LongsRef.java,<init>,54-54,[    this.longs = longs;],,
PERFORMANCE,DM_STRING_CTOR,org/apache/lucene/util/LuceneTestCase.java,newField,1428-1428,[    name = new String(name);],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/lucene/util/LuceneTestCase.java,setIndexWriterMaxDocs,691-691,[    m.setAccessible(true);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/util/LuceneTestCase.java,avoidPathologicalMerging,971-971,[      estFlushSizeBytes = Math.min(estFlushSizeBytes, iwc.getMaxBufferedDocs() * 1024);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/lucene/util/LuceneTestCase.java,,617-617,[    .around(classEnvRule = new TestRuleSetupAndRestoreClassEnv());],,
CORRECTNESS,NP_ALWAYS_NULL,org/apache/lucene/util/LuceneTestCase.java,newDirectoryImpl,1578-1578,[      throw null; // dummy to prevent compiler failure],,
CORRECTNESS,NP_ALWAYS_NULL,org/apache/lucene/util/LuceneTestCase.java,newFSDirectory,1328-1328,[      throw null; // dummy to prevent compiler failure],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/lucene/util/LuceneTestCase.java,assertTermsSeekingEquals,2183-2183,[    rightEnum = rightTerms.iterator(rightEnum);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/util/LuceneTestCase.java,newDirectoryImpl,1576-1576,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/util/LuceneTestCase.java,newFSDirectory,1326-1326,[    } catch (Exception e) {],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/lucene/util/LuceneTestCase.java,getDataPath,1798-1798,[      return Paths.get(this.getClass().getResource(name).toURI());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/LuceneTestCase.java,,2261-2264,[      Comparator<StorableField> comp = new Comparator<StorableField>() {,         @Override,         public int compare(StorableField arg0, StorableField arg1) {,           return arg0.name().compareTo(arg1.name());],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/util/NamedSPILoader.java,reload,76-76,[      } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/NotDocIdSet.java,,55-64,[    return new Bits() {, ,       @Override,       public boolean get(int index) {,         return !inBits.get(index);,       }, ,       @Override,       public int length() {,         return inBits.length();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/lucene/util/OfflineSorter.java,read,536-536,[        return null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/util/PagedBytes.java,copy,199-199,[      left = blockSize;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/util/RamUsageEstimator.java,<clinit>,160-160,[    } catch (Exception e) {],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/lucene/util/RamUsageEstimator.java,<clinit>,158-158,[      unsafeField.setAccessible(true);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/lucene/util/RamUsageEstimator.java,<clinit>,205-205,[      final Method arrayBaseOffsetM = unsafeClass.getMethod("arrayBaseOffset", Class.class);],,<clinit>,153-153,[    Class<?> unsafeClass = null;],,<clinit>,156-156,[      unsafeClass = Class.forName("sun.misc.Unsafe");],,
CORRECTNESS,RC_REF_COMPARISON,org/apache/lucene/util/RamUsageEstimator.java,<clinit>,244-244,[        && Long.valueOf(longCacheMinValue - 1) == Long.valueOf(longCacheMinValue - 1)) {],,<clinit>,249-249,[        && Long.valueOf(longCacheMaxValue + 1) == Long.valueOf(longCacheMaxValue + 1)) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/util/RamUsageEstimator.java,<clinit>,170-170,[    } catch (Exception e) {],,<clinit>,197-197,[    } catch (Exception e) {],,<clinit>,209-209,[    } catch (Exception e) {],,<clinit>,232-232,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/lucene/util/RamUsageEstimator.java,<clinit>,160-160,[    } catch (Exception e) {],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/util/RecyclingByteBlockAllocator.java,freeBlocks,153-153,[    bytesUsed.addAndGet(-count*blockSize);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/util/RecyclingByteBlockAllocator.java,recycleByteBlocks,107-107,[    bytesUsed.addAndGet(-(end - stop) * blockSize);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/util/RecyclingIntBlockAllocator.java,freeBlocks,153-153,[    bytesUsed.addAndGet(-count*blockSize* RamUsageEstimator.NUM_BYTES_INT);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/util/RecyclingIntBlockAllocator.java,getIntBlock,81-81,[      bytesUsed.addAndGet(blockSize*RamUsageEstimator.NUM_BYTES_INT);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/lucene/util/SPIClassIterator.java,loadNextProfile,95-95,[          final BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));],,
BAD_PRACTICE,CN_IDIOM,org/apache/lucene/util/SetOnce.java,,40-75,[  private volatile T obj = null;,   private final AtomicBoolean set;,   ,   /**,    * A default constructor which does not set the internal object, and allows,    * setting it by calling {@link #set(Object)}.,    */,   public SetOnce() {,     set = new AtomicBoolean(false);,   }, ,   /**,    * Creates a new instance with the internal object set to the given object.,    * Note that any calls to {@link #set(Object)} afterwards will result in,    * {@link AlreadySetException},    *,    * @throws AlreadySetException if called more than once,    * @see #set(Object),    */,   public SetOnce(T obj) {,     this.obj = obj;,     set = new AtomicBoolean(true);,   },   ,   /** Sets the given object. If the object has already been set, an exception is thrown. */,   public final void set(T obj) {,     if (set.compareAndSet(false, true)) {,       this.obj = obj;,     } else {,       throw new AlreadySetException();,     },   },   ,   /** Returns the object set by {@link #set(Object)}. */,   public final T get() {,     return obj;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/util/SloppyMath.java,<clinit>,247-247,[    final double a = 6_378_137; // [m]],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/lucene/util/Sorter.java,mergeInPlace,73-73,[      len11 = first_cut - from;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/util/SparseFixedBitSet.java,insertLong,187-187,[      ramBytesUsed += (newSize - bitArray.length) * RamUsageEstimator.NUM_BYTES_LONG;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/lucene/util/SparseFixedBitSet.java,,36-520,[public class SparseFixedBitSet extends BitSet implements Bits, Accountable {, ,   private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(SparseFixedBitSet.class);,   private static final long SINGLE_ELEMENT_ARRAY_BYTES_USED = RamUsageEstimator.sizeOf(new long[1]);,   private static final int MASK_4096 = (1 << 12) - 1;, ,   private static int blockCount(int length) {,     int blockCount = length >>> 12;,     if ((blockCount << 12) < length) {,       ++blockCount;,     },     assert (blockCount << 12) >= length;,     return blockCount;,   }, ,   final long[] indices;,   final long[][] bits;,   final int length;,   int nonZeroLongCount;,   long ramBytesUsed;, ,   /** Create a {@link SparseFixedBitSet} that can contain bits between,    *  <code>0</code> included and <code>length</code> excluded. */,   public SparseFixedBitSet(int length) {,     if (length < 1) {,       throw new IllegalArgumentException("length needs to be >= 1");,     },     this.length = length;,     final int blockCount = blockCount(length);,     indices = new long[blockCount];,     bits = new long[blockCount][];,     ramBytesUsed = BASE_RAM_BYTES_USED,         + RamUsageEstimator.shallowSizeOf(indices),         + RamUsageEstimator.shallowSizeOf(bits);,   }, ,   @Override,   public int length() {,     return length;,   }, ,   private boolean consistent(int index) {,     assert index >= 0 && index < length : "index=" + index + ",length=" + length;,     return true;,   }, ,   @Override,   public int cardinality() {,     int cardinality = 0;,     for (long[] bitArray : bits) {,       if (bitArray != null) {,         for (long bits : bitArray) {,           cardinality += Long.bitCount(bits);,         },       },     },     return cardinality;,   }, ,   @Override,   public int approximateCardinality() {,     // we are assuming that bits are uniformly set and use the linear counting,     // algorithm to estimate the number of bits that are set based on the number,     // of longs that are different from zero,     final int totalLongs = (length + 63) >>> 6; // total number of longs in the space,     assert totalLongs >= nonZeroLongCount;,     final int zeroLongs = totalLongs - nonZeroLongCount; // number of longs that are zeros,     // No need to guard against division by zero, it will return +Infinity and things will work as expected,     final long estimate = Math.round(totalLongs * Math.log((double) totalLongs / zeroLongs));,     return (int) Math.min(length, estimate);,   }, ,   @Override,   public boolean get(int i) {,     assert consistent(i);,     final int i4096 = i >>> 12;,     final long index = indices[i4096];,     final int i64 = i >>> 6;,     // first check the index, if the i64-th bit is not set, then i is not set,     // note: this relies on the fact that shifts are mod 64 in java,     if ((index & (1L << i64)) == 0) {,       return false;,     }, ,     // if it is set, then we count the number of bits that are set on the right,     // of i64, and that gives us the index of the long that stores the bits we,     // are interested in,     final long bits = this.bits[i4096][Long.bitCount(index & ((1L << i64) - 1))];,     return (bits & (1L << i)) != 0;,   }, ,   private static int oversize(int s) {,     int newSize = s + (s >>> 1);,     if (newSize > 50) {,       newSize = 64;,     },     return newSize;,   }, ,   /**,    * Set the bit at index <tt>i</tt>.,    */,   public void set(int i) {,     assert consistent(i);,     final int i4096 = i >>> 12;,     final long index = indices[i4096];,     final int i64 = i >>> 6;,     if ((index & (1L << i64)) != 0) {,       // in that case the sub 64-bits block we are interested in already exists,,       // we just need to set a bit in an existing long: the number of ones on,       // the right of i64 gives us the index of the long we need to update,       bits[i4096][Long.bitCount(index & ((1L << i64) - 1))] |= 1L << i; // shifts are mod 64 in java,     } else if (index == 0) {,       // if the index is 0, it means that we just found a block of 4096 bits,       // that has no bit that is set yet. So let's initialize a new block:,       insertBlock(i4096, i64, i);,     } else {,       // in that case we found a block of 4096 bits that has some values, but,       // the sub-block of 64 bits that we are interested in has no value yet,,       // so we need to insert a new long,       insertLong(i4096, i64, i, index);,     },   }, ,   private void insertBlock(int i4096, int i64, int i) {,     indices[i4096] = 1L << i64; // shifts are mod 64 in java,     assert bits[i4096] == null;,     bits[i4096] = new long[] { 1L << i }; // shifts are mod 64 in java,     ++nonZeroLongCount;,     ramBytesUsed += SINGLE_ELEMENT_ARRAY_BYTES_USED;,   }, ,   private void insertLong(int i4096, int i64, int i, long index) {,     indices[i4096] |= 1L << i64; // shifts are mod 64 in java,     // we count the number of bits that are set on the right of i64,     // this gives us the index at which to perform the insertion,     final int o = Long.bitCount(index & ((1L << i64) - 1));,     final long[] bitArray = bits[i4096];,     if (bitArray[bitArray.length - 1] == 0) {,       // since we only store non-zero longs, if the last value is 0, it means,       // that we alreay have extra space, make use of it,       System.arraycopy(bitArray, o, bitArray, o + 1, bitArray.length - o - 1);,       bitArray[o] = 1L << i;,     } else {,       // we don't have extra space so we need to resize to insert the new long,       final int newSize = oversize(bitArray.length + 1);,       final long[] newBitArray = new long[newSize];,       System.arraycopy(bitArray, 0, newBitArray, 0, o);,       newBitArray[o] = 1L << i;,       System.arraycopy(bitArray, o, newBitArray, o + 1, bitArray.length - o);,       bits[i4096] = newBitArray;,       ramBytesUsed += (newSize - bitArray.length) * RamUsageEstimator.NUM_BYTES_LONG;,     },     ++nonZeroLongCount;,   }, ,   /**,    * Clear the bit at index <tt>i</tt>.,    */,   public void clear(int i) {,     assert consistent(i);,     final int i4096 = i >>> 12;,     final int i64 = i >>> 6;,     and(i4096, i64, ~(1L << i));,   }, ,   private void and(int i4096, int i64, long mask) {,     final long index = indices[i4096];,     if ((index & (1L << i64)) != 0) {,       // offset of the long bits we are interested in in the array,       final int o = Long.bitCount(index & ((1L << i64) - 1));,       long bits = this.bits[i4096][o] & mask;,       if (bits == 0) {,         removeLong(i4096, i64, index, o);,       } else {,         this.bits[i4096][o] = bits;,       },     },   }, ,   private void removeLong(int i4096, int i64, long index, int o) {,     index &= ~(1L << i64);,     indices[i4096] = index;,     if (index == 0) {,       // release memory, there is nothing in this block anymore,       this.bits[i4096] = null;,     } else {,       final int length = Long.bitCount(index);,       final long[] bitArray = bits[i4096];,       System.arraycopy(bitArray, o + 1, bitArray, o, length - o);,       bitArray[length] = 0L;,     },     nonZeroLongCount -= 1;,   }, ,   @Override,   public void clear(int from, int to) {,     assert from >= 0;,     assert to <= length;,     if (from >= to) {,       return;,     },     final int firstBlock = from >>> 12;,     final int lastBlock = (to - 1) >>> 12;,     if (firstBlock == lastBlock) {,       clearWithinBlock(firstBlock, from & MASK_4096, (to - 1) & MASK_4096);,     } else {,       clearWithinBlock(firstBlock, from & MASK_4096, MASK_4096);,       for (int i = firstBlock + 1; i < lastBlock; ++i) {,         nonZeroLongCount -= Long.bitCount(indices[i]);,         indices[i] = 0;,         bits[i] = null;,       },       clearWithinBlock(lastBlock, 0, (to - 1) & MASK_4096);,     },   }, ,   // create a long that has bits set to one between from and to,   private static long mask(int from, int to) {,     return ((1L << (to - from) << 1) - 1) << from;,   }, ,   private void clearWithinBlock(int i4096, int from, int to) {,     int firstLong = from >>> 6;,     int lastLong = to >>> 6;, ,     if (firstLong == lastLong) {,       and(i4096, firstLong, ~mask(from, to));,     } else {,       assert firstLong < lastLong;,       and(i4096, lastLong, ~mask(0, to));,       for (int i = lastLong - 1; i >= firstLong + 1; --i) {,         and(i4096, i, 0L);,       },       and(i4096, firstLong, ~mask(from, 63));,     },   }, ,   /** Return the first document that occurs on or after the provided block index. */,   private int firstDoc(int i4096) {,     long index = 0;,     while (i4096 < indices.length) {,       index = indices[i4096];,       if (index != 0) {,         final int i64 = Long.numberOfTrailingZeros(index);,         return (i4096 << 12) | (i64 << 6) | Long.numberOfTrailingZeros(bits[i4096][0]);,       },       i4096 += 1;,     },     return DocIdSetIterator.NO_MORE_DOCS;,   }, ,   @Override,   public int nextSetBit(int i) {,     assert i < length;,     final int i4096 = i >>> 12;,     final long index = indices[i4096];,     final long[] bitArray = this.bits[i4096];,     int i64 = i >>> 6;,     int o = Long.bitCount(index & ((1L << i64) - 1));,     if ((index & (1L << i64)) != 0) {,       // There is at least one bit that is set in the current long, check if,       // one of them is after i,       final long bits = bitArray[o] >>> i; // shifts are mod 64,       if (bits != 0) {,         return i + Long.numberOfTrailingZeros(bits);,       },       o += 1;,     },     final long indexBits = index >>> i64 >>> 1;,     if (indexBits == 0) {,       // no more bits are set in the current block of 4096 bits, go to the next one,       return firstDoc(i4096 + 1);,     },     // there are still set bits,     i64 += 1 + Long.numberOfTrailingZeros(indexBits);,     final long bits = bitArray[o];,     return (i64 << 6) | Long.numberOfTrailingZeros(bits);,   }, ,   /** Return the last document that occurs on or before the provided block index. */,   private int lastDoc(int i4096) {,     long index;,     while (i4096 >= 0) {,       index = indices[i4096];,       if (index != 0) {,         final int i64 = 63 - Long.numberOfLeadingZeros(index);,         final long bits = this.bits[i4096][Long.bitCount(index) - 1];,         return (i4096 << 12) | (i64 << 6) | (63 - Long.numberOfLeadingZeros(bits));,       },       i4096 -= 1;,     },     return -1;,   }, ,   @Override,   public int prevSetBit(int i) {,     assert i >= 0;,     final int i4096 = i >>> 12;,     final long index = indices[i4096];,     final long[] bitArray = this.bits[i4096];,     int i64 = i >>> 6;,     final long indexBits = index & ((1L << i64) - 1);,     final int o = Long.bitCount(indexBits);,     if ((index & (1L << i64)) != 0) {,       // There is at least one bit that is set in the same long, check if there,       // is one bit that is set that is lower than i,       final long bits = bitArray[o] & ((1L << i << 1) - 1);,       if (bits != 0) {,         return (i64 << 6) | (63 - Long.numberOfLeadingZeros(bits));,       },     },     if (indexBits == 0) {,       // no more bits are set in this block, go find the last bit in the,       // previous block,       return lastDoc(i4096 - 1);,     },     // go to the previous long,     i64 = 63 - Long.numberOfLeadingZeros(indexBits);,     final long bits = bitArray[o - 1];,     return (i4096 << 12) | (i64 << 6) | (63 - Long.numberOfLeadingZeros(bits));,   }, ,   /** Return the long bits at the given <code>i64</code> index. */,   private long longBits(long index, long[] bits, int i64) {,     if ((index & (1L << i64)) == 0) {,       return 0L;,     } else {,       return bits[Long.bitCount(index & ((1L << i64) - 1))];,     },   }, ,   private void or(final int i4096, final long index, long[] bits, int nonZeroLongCount) {,     assert Long.bitCount(index) == nonZeroLongCount;,     final long currentIndex = indices[i4096];,     if (currentIndex == 0) {,       // fast path: if we currently have nothing in the block, just copy the data,       // this especially happens all the time if you call OR on an empty set,       indices[i4096] = index;,       this.bits[i4096] = Arrays.copyOf(bits, nonZeroLongCount);,       this.nonZeroLongCount += nonZeroLongCount;,       return;,     },     final long[] currentBits = this.bits[i4096];,     final long[] newBits;,     final long newIndex = currentIndex | index;,     final int requiredCapacity = Long.bitCount(newIndex);,     if (currentBits.length >= requiredCapacity) {,       newBits = currentBits;,     } else {,       newBits = new long[oversize(requiredCapacity)];,     },     // we iterate backwards in order to not override data we might need on the next iteration if the,     // array is reused,     for (int i = Long.numberOfLeadingZeros(newIndex), newO = Long.bitCount(newIndex) - 1;,         i < 64;,         i += 1 + Long.numberOfLeadingZeros(newIndex << (i + 1)), newO -= 1) {,       // bitIndex is the index of a bit which is set in newIndex and newO is the number of 1 bits on its right,       final int bitIndex = 63 - i;,       assert newO == Long.bitCount(newIndex & ((1L << bitIndex) - 1));,       newBits[newO] = longBits(currentIndex, currentBits, bitIndex) | longBits(index, bits, bitIndex);,     },     indices[i4096] = newIndex;,     this.bits[i4096] = newBits;,     this.nonZeroLongCount += nonZeroLongCount - Long.bitCount(currentIndex & index);,   }, ,   private void or(SparseFixedBitSet other) {,     for (int i = 0; i < other.indices.length; ++i) {,       final long index = other.indices[i];,       if (index != 0) {,         or(i, index, other.bits[i], Long.bitCount(index));,       },     },   }, ,   /**,    * {@link #or(DocIdSetIterator)} impl that works best when <code>it</code> is dense,    */,   private void orDense(DocIdSetIterator it) throws IOException {,     assertUnpositioned(it);,     // The goal here is to try to take advantage of the ordering of documents,     // to build the data-structure more efficiently,     // NOTE: this heavily relies on the fact that shifts are mod 64,     final int firstDoc = it.nextDoc();,     if (firstDoc == DocIdSetIterator.NO_MORE_DOCS) {,       return;,     },     int i4096 = firstDoc >>> 12;,     int i64 = firstDoc >>> 6;,     long index = 1L << i64;,     long currentLong = 1L << firstDoc;,     // we store at most 64 longs per block so preallocate in order never to have to resize,     long[] longs = new long[64];,     int numLongs = 0;, ,     for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {,       final int doc64 = doc >>> 6;,       if (doc64 == i64) {,         // still in the same long, just set the bit,         currentLong |= 1L << doc;,       } else {,         longs[numLongs++] = currentLong;, ,         final int doc4096 = doc >>> 12;,         if (doc4096 == i4096) {,           index |= 1L << doc64;,         } else {,           // we are on a new block, flush what we buffered,           or(i4096, index, longs, numLongs);,           // and reset state for the new block,           i4096 = doc4096;,           index = 1L << doc64;,           numLongs = 0;,         }, ,         // we are on a new long, reset state,         i64 = doc64;,         currentLong = 1L << doc;,       },     }, ,     // flush,     longs[numLongs++] = currentLong;,     or(i4096, index, longs, numLongs);,   }, ,   @Override,   public void or(DocIdSetIterator it) throws IOException {,     {,       // specialize union with another SparseFixedBitSet,       final SparseFixedBitSet other = BitSetIterator.getSparseFixedBitSetOrNull(it);,       if (other != null) {,         assertUnpositioned(it);,         or(other);,         return;,       },     }, ,     // We do not specialize the union with a FixedBitSet since FixedBitSets are,     // supposed to be used for dense data and sparse fixed bit sets for sparse,     // data, so a sparse set would likely get upgraded by DocIdSetBuilder before,     // being or'ed with a FixedBitSet, ,     if (it.cost() < indices.length) {,       // the default impl is good for sparse iterators,       super.or(it);,     } else {,       orDense(it);,     },   }, ,   // AND and AND_NOT do not need much specialization here since this sparse set,   // is supposed to be used on sparse data and the default AND/AND_NOT impl,   // (leap frog) is efficient when at least one of the sets contains sparse data, ,   @Override,   public void and(DocIdSetIterator it) throws IOException {,     final SparseFixedBitSet other = BitSetIterator.getSparseFixedBitSetOrNull(it);,     if (other != null) {,       // if we are merging with another SparseFixedBitSet, a quick win is,       // to clear up some blocks by only looking at their index. Then the set,       // is sparser and the leap-frog approach of the parent class is more,       // efficient. Since SparseFixedBitSet is supposed to be used for sparse,       // sets, the intersection of two SparseFixedBitSet is likely very sparse,       final int numCommonBlocks = Math.min(indices.length, other.indices.length);,       for (int i = 0; i < numCommonBlocks; ++i) {,         if ((indices[i] & other.indices[i]) == 0) {,           this.nonZeroLongCount -= Long.bitCount(this.indices[i]);,           this.indices[i] = 0;,           this.bits[i] = null;,         },       },     },     super.and(it);,   }, ,   @Override,   public long ramBytesUsed() {,     return ramBytesUsed;,   }, ,   @Override,   public String toString() {,     return "SparseFixedBitSet(size=" + length + ",cardinality=~" + approximateCardinality();],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/lucene/util/StringHelper.java,<clinit>,258-258,[      x1 = StringHelper.class.hashCode() << 32;],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/lucene/util/StringHelper.java,murmurhash3_x86_32,200-203,[        k1 = (data[roundedEnd + 2] & 0xff) << 16;,         // fallthrough,       case 2:,         k1 |= (data[roundedEnd + 1] & 0xff) << 8;],,murmurhash3_x86_32,203-206,[        k1 |= (data[roundedEnd + 1] & 0xff) << 8;,         // fallthrough,       case 1:,         k1 |= (data[roundedEnd] & 0xff);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/util/StringHelper.java,murmurhash3_x86_32,198-210,[    switch(len & 0x03) {,       case 3:,         k1 = (data[roundedEnd + 2] & 0xff) << 16;,         // fallthrough,       case 2:,         k1 |= (data[roundedEnd + 1] & 0xff) << 8;,         // fallthrough,       case 1:,         k1 |= (data[roundedEnd] & 0xff);,         k1 *= c1;,         k1 = Integer.rotateLeft(k1, 15);,         k1 *= c2;,         h1 ^= k1;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/TestRuleAssertionsRequired.java,,30-55,[    return new Statement() {,       @Override,       public void evaluate() throws Throwable {,         try {,           // Make sure -ea matches -Dtests.asserts, to catch accidental mis-use:,           if (LuceneTestCase.assertsAreEnabled != LuceneTestCase.TEST_ASSERTS_ENABLED) {,             String msg = "Assertions mismatch: ";,             if (LuceneTestCase.assertsAreEnabled) {,               msg += "-ea was specified";,             } else {,               msg += "-ea was not specified";,             },             if (LuceneTestCase.TEST_ASSERTS_ENABLED) {,               msg += " but -Dtests.asserts=true";,             } else  {,               msg += " but -Dtests.asserts=false";,             },             System.err.println(msg);,             throw new Exception(msg);,           },         } catch (AssertionError e) {,           // Ok, enabled.,         }, ,         base.evaluate();,       }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/TestRuleIgnoreTestSuites.java,,48-56,[    return new Statement() {,       @Override,       public void evaluate() throws Throwable {,         if (NestedTestSuite.class.isAssignableFrom(d.getTestClass())) {,           LuceneTestCase.assumeTrue("Nested suite class ignored (started as stand-alone).",,               isRunningNested());,         },         s.evaluate();,       }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java,,181-194,[      codec = new AssertingCodec() {       ,         @Override,         public PostingsFormat getPostingsFormatForField(String field) {,           return format;,         }, ,         @Override,         public DocValuesFormat getDocValuesFormatForField(String field) {,           return dvFormat;,         }, ,         @Override,         public String toString() {,           return super.toString() + ": " + format.toString() + ", " + dvFormat.toString();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java,createTempDir,241-241,[      } catch (IOException ignore) {}],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java,createTempFile,267-267,[      } catch (IOException ignore) {}],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java,getPerTestClassTempDir,213-213,[        } catch (IOException ignore) {}],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/lucene/util/TestSecurityManager.java,,51-82,[    AccessController.doPrivileged(new PrivilegedAction<Void>() {,       @Override,       public Void run() {,         final String systemClassName = System.class.getName(),,             runtimeClassName = Runtime.class.getName();,         String exitMethodHit = null;,         for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {,           final String className = se.getClassName(), methodName = se.getMethodName();,           if (,             ("exit".equals(methodName) || "halt".equals(methodName)) &&,             (systemClassName.equals(className) || runtimeClassName.equals(className)),           ) {,             exitMethodHit = className + '#' + methodName + '(' + status + ')';,             continue;,           },           ,           if (exitMethodHit != null) {,             if (className.startsWith(TEST_RUNNER_PACKAGE)) {,               // this exit point is allowed, we return normally from closure:,               return /*void*/ null;,             } else {,               // anything else in stack trace is not allowed, break and throw SecurityException below:,               break;,             },           },         },         ,         if (exitMethodHit == null) {,           // should never happen, only if JVM hides stack trace - replace by generic:,           exitMethodHit = "JVM exit method";,         },         throw new SecurityException(exitMethodHit + " calls are not allowed because they terminate the test runner's JVM.");],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/lucene/util/TestUtil.java,,1184-1184,[  public static final char[] WHITESPACE_CHARACTERS = new char[] {],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/lucene/util/TestUtil.java,unzip,128-128,[        Files.createDirectories(targetFile.getParent());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/util/TestUtil.java,checkIndex,234-234,[      if (indexStatus == null || indexStatus.clean == false) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/util/TestUtil.java,randomHtmlishString,523-525,[          switch(nextInt(random, 0, 2)) {,             case 0: sb.append(randomSimpleString(random)); break;,             case 1: sb.append(HTML_CHAR_ENTITIES[random.nextInt(HTML_CHAR_ENTITIES.length)]); break;],,randomHtmlishString,562-565,[          switch (nextInt(random, 0, 3)) {,             case 0: sb.append(randomlyRecaseCodePoints(random, "script")); break;,             case 1: sb.append(randomlyRecaseCodePoints(random, "style")); break;,             case 2: sb.append(randomlyRecaseCodePoints(random, "br")); break;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/lucene/util/TestUtil.java,randomlyRecaseCodePoints,586-589,[      switch (nextInt(random, 0, 2)) {,         case 0: builder.appendCodePoint(Character.toUpperCase(codePoint)); break;,         case 1: builder.appendCodePoint(Character.toLowerCase(codePoint)); break;,         case 2: builder.appendCodePoint(codePoint); // leave intact],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_COMPARE,org/apache/lucene/util/VirtualMethod.java,compareImplementationDistance,146-146,[    return Integer.valueOf(m1.getImplementationDistance(clazz)).compareTo(m2.getImplementationDistance(clazz));],,
STYLE,UC_USELESS_CONDITION,org/apache/lucene/util/automaton/AutomatonTestUtil.java,getRandomCodePoint,117-117,[        throw new IllegalArgumentException("transition accepts only surrogates: min=" + min + " max=" + max);],,getRandomCodePoint,113-113,[      if (min < UnicodeUtil.UNI_SUR_HIGH_START) {],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java,equals,87-87,[      final State other = (State) obj;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java,equals,87-90,[      final State other = (State) obj;,       return is_final == other.is_final,           && Arrays.equals(this.labels, other.labels),           && referenceEquals(this.states, other.states);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/util/automaton/LevenshteinAutomata.java,<init>,65-65,[    this.word = word;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/lucene/util/automaton/LevenshteinAutomata.java,toAutomaton,162-162,[    if (prefix != null) {],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/lucene/util/automaton/LevenshteinAutomata.java,unpack,305-305,[      final long bitLoc = bitsPerValue * index;],,
CORRECTNESS,GC_UNRELATED_TYPES,org/apache/lucene/util/automaton/Operations.java,determinize,739-739,[          Integer q = newstate.get(statesSet);],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/lucene/util/automaton/Operations.java,equals,561-561,[      return ((PointTransitions) other).point == point;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/util/automaton/Operations.java,equals,561-561,[      return ((PointTransitions) other).point == point;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/lucene/util/automaton/RegExp.java,toStringTree,786-789,[        b.append(indent);,         b.append(kind);,         b.append('\n');,         break;],,toStringTree,798-801,[        b.append(indent);,         b.append(kind);,         b.append('\n');,         break;],,toStringTree,803-806,[        b.append(indent);,         b.append(kind);,         b.append('\n');,         break;],,
BAD_PRACTICE,EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS,org/apache/lucene/util/automaton/SortedIntSet.java,equals,172-172,[    if (!(_other instanceof FrozenIntSet)) {],,equals,175-175,[    FrozenIntSet other = (FrozenIntSet) _other;],,
STYLE,EQ_UNUSUAL,org/apache/lucene/util/automaton/SortedIntSet.java,equals,169-188,[    if (_other == null) {,       return false;,     },     if (!(_other instanceof FrozenIntSet)) {,       return false;,     },     FrozenIntSet other = (FrozenIntSet) _other;,     if (hashCode != other.hashCode) {,       return false;,     },     if (other.values.length != upto) {,       return false;,     },     for(int i=0;i<upto;i++) {,       if (other.values[i] != values[i]) {,         return false;,       },     }, ,     return true;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/lucene/util/automaton/SortedIntSet.java,<init>,210-210,[      this.values = values;],,
BAD_PRACTICE,EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS,org/apache/lucene/util/automaton/SortedIntSet.java,equals,245-245,[      } else if (_other instanceof SortedIntSet) {],,equals,246-246,[        SortedIntSet other = (SortedIntSet) _other;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/lucene/util/automaton/Automaton.java,,50-635,[public class Automaton {,   /** Where we next write to the int[] states; this increments by 2 for,    *  each added state because we pack a pointer to the transitions,    *  array and a count of how many transitions leave the state.  */,   private int nextState;, ,   /** Where we next write to in int[] transitions; this,    *  increments by 3 for each added transition because we,    *  pack min, max, dest in sequence. */,   private int nextTransition;, ,   /** Current state we are adding transitions to; the caller,    *  must add all transitions for this state before moving,    *  onto another state. */,   private int curState = -1;, ,   /** Index in the transitions array, where this states,    *  leaving transitions are stored, or -1 if this state,    *  has not added any transitions yet, followed by number,    *  of transitions. */,   private int[] states;, ,   private final BitSet isAccept;,   ,   /** Holds toState, min, max for each transition. */,   private int[] transitions;, ,   /** True if no state has two transitions leaving with the same label. */,   private boolean deterministic = true;, ,   /** Sole constructor; creates an automaton with no states. */,   public Automaton() {,      this(2, 2);,   }, ,   /**,    * Constructor which creates an automaton with enough space for the given,    * number of states and transitions.,    * ,    * @param numStates,    *           Number of states.,    * @param numTransitions,    *           Number of transitions.,    */,   public Automaton(int numStates, int numTransitions) {,      states = new int[numStates * 2];,      isAccept = new BitSet(numStates);,      transitions = new int[numTransitions * 3];,   }, ,   /** Create a new state. */,   public int createState() {,     growStates();,     int state = nextState/2;,     states[nextState] = -1;,     nextState += 2;,     return state;,   }, ,   /** Set or clear this state as an accept state. */,   public void setAccept(int state, boolean accept) {,     if (state >= getNumStates()) {,       throw new IllegalArgumentException("state=" + state + " is out of bounds (numStates=" + getNumStates() + ")");,     },     if (accept) {,       isAccept.set(state);,     } else {,       isAccept.clear(state);,     },   }, ,   /** Sugar to get all transitions for all states.  This is,    *  object-heavy; it's better to iterate state by state instead. */,   public Transition[][] getSortedTransitions() {,     int numStates = getNumStates();,     Transition[][] transitions = new Transition[numStates][];,     for(int s=0;s<numStates;s++) {,       int numTransitions = getNumTransitions(s);,       transitions[s] = new Transition[numTransitions];,       for(int t=0;t<numTransitions;t++) {,         Transition transition = new Transition();,         getTransition(s, t, transition);,         transitions[s][t] = transition;,       },     }, ,     return transitions;,   }, ,   /** Returns accept states.  If the bit is set then that state is an accept state. */,   BitSet getAcceptStates() {,     return isAccept;,   }, ,   /** Returns true if this state is an accept state. */,   public boolean isAccept(int state) {,     return isAccept.get(state);,   }, ,   /** Add a new transition with min = max = label. */,   public void addTransition(int source, int dest, int label) {,     addTransition(source, dest, label, label);,   }, ,   /** Add a new transition with the specified source, dest, min, max. */,   public void addTransition(int source, int dest, int min, int max) {,     assert nextTransition%3 == 0;, ,     if (source >= nextState/2) {,       throw new IllegalArgumentException("source=" + source + " is out of bounds (maxState is " + (nextState/2-1) + ")");,     },     if (dest >= nextState/2) {,       throw new IllegalArgumentException("dest=" + dest + " is out of bounds (max state is " + (nextState/2-1) + ")");,     }, ,     growTransitions();,     if (curState != source) {,       if (curState != -1) {,         finishCurrentState();,       }, ,       // Move to next source:,       curState = source;,       if (states[2*curState] != -1) {,         throw new IllegalStateException("from state (" + source + ") already had transitions added");,       },       assert states[2*curState+1] == 0;,       states[2*curState] = nextTransition;,     }, ,     transitions[nextTransition++] = dest;,     transitions[nextTransition++] = min;,     transitions[nextTransition++] = max;, ,     // Increment transition count for this state,     states[2*curState+1]++;,   }, ,   /** Add a [virtual] epsilon transition between source and dest.,    *  Dest state must already have all transitions added because this,    *  method simply copies those same transitions over to source. */,   public void addEpsilon(int source, int dest) {,     Transition t = new Transition();,     int count = initTransition(dest, t);,     for(int i=0;i<count;i++) {,       getNextTransition(t);,       addTransition(source, t.dest, t.min, t.max);,     },     if (isAccept(dest)) {,       setAccept(source, true);,     },   }, ,   /** Copies over all states/transitions from other.  The states numbers,    *  are sequentially assigned (appended). */,   public void copy(Automaton other) {, ,     // Bulk copy and then fixup the state pointers:,     int stateOffset = getNumStates();,     states = ArrayUtil.grow(states, nextState + other.nextState);,     System.arraycopy(other.states, 0, states, nextState, other.nextState);,     for(int i=0;i<other.nextState;i += 2) {,       if (states[nextState+i] != -1) {,         states[nextState+i] += nextTransition;,       },     },     nextState += other.nextState;,     int otherNumStates = other.getNumStates();,     BitSet otherAcceptStates = other.getAcceptStates();,     int state = 0;,     while (state < otherNumStates && (state = otherAcceptStates.nextSetBit(state)) != -1) {,       setAccept(stateOffset + state, true);,       state++;,     }, ,     // Bulk copy and then fixup dest for each transition:,     transitions = ArrayUtil.grow(transitions, nextTransition + other.nextTransition);,     System.arraycopy(other.transitions, 0, transitions, nextTransition, other.nextTransition);,     for(int i=0;i<other.nextTransition;i += 3) {,       transitions[nextTransition+i] += stateOffset;,     },     nextTransition += other.nextTransition;, ,     if (other.deterministic == false) {,       deterministic = false;,     },   }, ,   /** Freezes the last state, sorting and reducing the transitions. */,   private void finishCurrentState() {,     int numTransitions = states[2*curState+1];,     assert numTransitions > 0;, ,     int offset = states[2*curState];,     int start = offset/3;,     destMinMaxSorter.sort(start, start+numTransitions);, ,     // Reduce any "adjacent" transitions:,     int upto = 0;,     int min = -1;,     int max = -1;,     int dest = -1;, ,     for(int i=0;i<numTransitions;i++) {,       int tDest = transitions[offset+3*i];,       int tMin = transitions[offset+3*i+1];,       int tMax = transitions[offset+3*i+2];, ,       if (dest == tDest) {,         if (tMin <= max+1) {,           if (tMax > max) {,             max = tMax;,           },         } else {,           if (dest != -1) {,             transitions[offset+3*upto] = dest;,             transitions[offset+3*upto+1] = min;,             transitions[offset+3*upto+2] = max;,             upto++;,           },           min = tMin;,           max = tMax;,         },       } else {,         if (dest != -1) {,           transitions[offset+3*upto] = dest;,           transitions[offset+3*upto+1] = min;,           transitions[offset+3*upto+2] = max;,           upto++;,         },         dest = tDest;,         min = tMin;,         max = tMax;,       },     }, ,     if (dest != -1) {,       // Last transition,       transitions[offset+3*upto] = dest;,       transitions[offset+3*upto+1] = min;,       transitions[offset+3*upto+2] = max;,       upto++;,     }, ,     nextTransition -= (numTransitions-upto)*3;,     states[2*curState+1] = upto;, ,     // Sort transitions by min/max/dest:,     minMaxDestSorter.sort(start, start+upto);, ,     if (deterministic && upto > 1) {,       int lastMax = transitions[offset+2];,       for(int i=1;i<upto;i++) {,         min = transitions[offset + 3*i + 1];,         if (min <= lastMax) {,           deterministic = false;,           break;,         },         lastMax = transitions[offset + 3*i + 2];,       },     },   }, ,   /** Returns true if this automaton is deterministic (for ever state,    *  there is only one transition for each label). */,   public boolean isDeterministic() {,     return deterministic;,   }, ,   /** Finishes the current state; call this once you are done adding,    *  transitions for a state.  This is automatically called if you,    *  start adding transitions to a new source state, but for the last,    *  state you add you need to this method yourself. */,   public void finishState() {,     if (curState != -1) {,       finishCurrentState();,       curState = -1;,     },   }, ,   // TODO: add finish() to shrink wrap the arrays?, ,   /** How many states this automaton has. */,   public int getNumStates() {,     return nextState/2;,   }, ,   /** How many transitions this automaton has. */,   public int getNumTransitions() {,     return nextTransition / 3;   ,   },   ,   /** How many transitions this state has. */,   public int getNumTransitions(int state) {,     int count = states[2*state+1];,     if (count == -1) {,       return 0;,     } else {,       return count;,     },   }, ,   private void growStates() {,     if (nextState+2 >= states.length) {,       states = ArrayUtil.grow(states, nextState+2);,     },   }, ,   private void growTransitions() {,     if (nextTransition+3 >= transitions.length) {,       transitions = ArrayUtil.grow(transitions, nextTransition+3);,     },   }, ,   /** Sorts transitions by dest, ascending, then min label ascending, then max label ascending */,   private final Sorter destMinMaxSorter = new InPlaceMergeSorter() {, ,       private void swapOne(int i, int j) {,         int x = transitions[i];,         transitions[i] = transitions[j];,         transitions[j] = x;,       }, ,       @Override,       protected void swap(int i, int j) {,         int iStart = 3*i;,         int jStart = 3*j;,         swapOne(iStart, jStart);,         swapOne(iStart+1, jStart+1);,         swapOne(iStart+2, jStart+2);,       };, ,       @Override,       protected int compare(int i, int j) {,         int iStart = 3*i;,         int jStart = 3*j;, ,         // First dest:,         int iDest = transitions[iStart];,         int jDest = transitions[jStart];,         if (iDest < jDest) {,           return -1;,         } else if (iDest > jDest) {,           return 1;,         }, ,         // Then min:,         int iMin = transitions[iStart+1];,         int jMin = transitions[jStart+1];,         if (iMin < jMin) {,           return -1;,         } else if (iMin > jMin) {,           return 1;,         }, ,         // Then max:,         int iMax = transitions[iStart+2];,         int jMax = transitions[jStart+2];,         if (iMax < jMax) {,           return -1;,         } else if (iMax > jMax) {,           return 1;,         }, ,         return 0;,       },     };, ,   /** Sorts transitions by min label, ascending, then max label ascending, then dest ascending */,   private final Sorter minMaxDestSorter = new InPlaceMergeSorter() {, ,       private void swapOne(int i, int j) {,         int x = transitions[i];,         transitions[i] = transitions[j];,         transitions[j] = x;,       }, ,       @Override,       protected void swap(int i, int j) {,         int iStart = 3*i;,         int jStart = 3*j;,         swapOne(iStart, jStart);,         swapOne(iStart+1, jStart+1);,         swapOne(iStart+2, jStart+2);,       };, ,       @Override,       protected int compare(int i, int j) {,         int iStart = 3*i;,         int jStart = 3*j;, ,         // First min:,         int iMin = transitions[iStart+1];,         int jMin = transitions[jStart+1];,         if (iMin < jMin) {,           return -1;,         } else if (iMin > jMin) {,           return 1;,         }, ,         // Then max:,         int iMax = transitions[iStart+2];,         int jMax = transitions[jStart+2];,         if (iMax < jMax) {,           return -1;,         } else if (iMax > jMax) {,           return 1;,         }, ,         // Then dest:,         int iDest = transitions[iStart];,         int jDest = transitions[jStart];,         if (iDest < jDest) {,           return -1;,         } else if (iDest > jDest) {,           return 1;,         }, ,         return 0;,       },     };, ,   /** Initialize the provided Transition to iterate through all transitions,    *  leaving the specified state.  You must call {@link #getNextTransition} to,    *  get each transition.  Returns the number of transitions,    *  leaving this state. */,   public int initTransition(int state, Transition t) {,     assert state < nextState/2: "state=" + state + " nextState=" + nextState;,     t.source = state;,     t.transitionUpto = states[2*state];,     return getNumTransitions(state);,   }, ,   /** Iterate to the next transition after the provided one */,   public void getNextTransition(Transition t) {,     // Make sure there is still a transition left:,     assert (t.transitionUpto+3 - states[2*t.source]) <= 3*states[2*t.source+1];,     t.dest = transitions[t.transitionUpto++];,     t.min = transitions[t.transitionUpto++];,     t.max = transitions[t.transitionUpto++];,   }, ,   /** Fill the provided {@link Transition} with the index'th,    *  transition leaving the specified state. */,   public void getTransition(int state, int index, Transition t) {,     int i = states[2*state] + 3*index;,     t.source = state;,     t.dest = transitions[i++];,     t.min = transitions[i++];,     t.max = transitions[i++];,   }, ,   static void appendCharString(int c, StringBuilder b) {,     if (c >= 0x21 && c <= 0x7e && c != '\\' && c != '"') b.appendCodePoint(c);,     else {,       b.append("\\\\U");,       String s = Integer.toHexString(c);,       if (c < 0x10) b.append("0000000").append(s);,       else if (c < 0x100) b.append("000000").append(s);,       else if (c < 0x1000) b.append("00000").append(s);,       else if (c < 0x10000) b.append("0000").append(s);,       else if (c < 0x100000) b.append("000").append(s);,       else if (c < 0x1000000) b.append("00").append(s);,       else if (c < 0x10000000) b.append("0").append(s);,       else b.append(s);,     },   }, ,   /*,   public void writeDot(String fileName) {,     if (fileName.indexOf('/') == -1) {,       fileName = "/l/la/lucene/core/" + fileName + ".dot";,     },     try {,       PrintWriter pw = new PrintWriter(fileName);,       pw.println(toDot());,       pw.close();,     } catch (IOException ioe) {,       throw new RuntimeException(ioe);,     },   },   */, ,   /** Returns the dot (graphviz) representation of this automaton.,    *  This is extremely useful for visualizing the automaton. */,   public String toDot() {,     // TODO: breadth first search so we can see get layered output..., ,     StringBuilder b = new StringBuilder();,     b.append("digraph Automaton {\n");,     b.append("  rankdir = LR\n");,     final int numStates = getNumStates();,     if (numStates > 0) {,       b.append("  initial [shape=plaintext,label=\"0\"]\n");,       b.append("  initial -> 0\n");,     }, ,     Transition t = new Transition();, ,     for(int state=0;state<numStates;state++) {,       b.append("  ");,       b.append(state);,       if (isAccept(state)) {,         b.append(" [shape=doublecircle,label=\"" + state + "\"]\n");,       } else {,         b.append(" [shape=circle,label=\"" + state + "\"]\n");,       },       int numTransitions = initTransition(state, t);,       //System.out.println("toDot: state " + state + " has " + numTransitions + " transitions; t.nextTrans=" + t.transitionUpto);,       for(int i=0;i<numTransitions;i++) {,         getNextTransition(t);,         //System.out.println("  t.nextTrans=" + t.transitionUpto);,         assert t.max >= t.min;,         b.append("  ");,         b.append(state);,         b.append(" -> ");,         b.append(t.dest);,         b.append(" [label=\"");,         appendCharString(t.min, b);,         if (t.max != t.min) {,           b.append('-');,           appendCharString(t.max, b);,         },         b.append("\"]\n");,         //System.out.println("  t=" + t);,       },     },     b.append('}');,     return b.toString();,   }, ,   /**,    * Returns sorted array of all interval start points.,    */,   int[] getStartPoints() {,     Set<Integer> pointset = new HashSet<>();,     pointset.add(Character.MIN_CODE_POINT);,     //System.out.println("getStartPoints");,     for (int s=0;s<nextState;s+=2) {,       int trans = states[s];,       int limit = trans+3*states[s+1];,       //System.out.println("  state=" + (s/2) + " trans=" + trans + " limit=" + limit);,       while (trans < limit) {,         int min = transitions[trans+1];,         int max = transitions[trans+2];,         //System.out.println("    min=" + min);,         pointset.add(min);,         if (max < Character.MAX_CODE_POINT) {,           pointset.add(max + 1);,         },         trans += 3;,       },     },     int[] points = new int[pointset.size()];,     int n = 0;,     for (Integer m : pointset) {,       points[n++] = m;,     },     Arrays.sort(points);,     return points;,   }, ,   /**,    * Performs lookup in transitions, assuming determinism.,    * ,    * @param state starting state,    * @param label codepoint to look up,    * @return destination state, -1 if no matching outgoing transition,    */,   public int step(int state, int label) {,     assert state >= 0;,     assert label >= 0;,     int trans = states[2*state];,     int limit = trans + 3*states[2*state+1];,     // TODO: we could do bin search; transitions are sorted,     while (trans < limit) {,       int dest = transitions[trans];,       int min = transitions[trans+1];,       int max = transitions[trans+2];,       if (min <= label && label <= max) {,         return dest;,       },       trans += 3;,     }, ,     return -1;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/lucene/util/automaton/RegExp.java,,375-1164,[  RegExp() {,     this.originalString = null;,   },   ,   /**,    * Constructs new <code>RegExp</code> from a string. Same as,    * <code>RegExp(s, ALL)</code>.,    * ,    * @param s regexp string,    * @exception IllegalArgumentException if an error occured while parsing the,    *              regular expression,    */,   public RegExp(String s) throws IllegalArgumentException {,     this(s, ALL);,   },   ,   /**,    * Constructs new <code>RegExp</code> from a string.,    * ,    * @param s regexp string,    * @param syntax_flags boolean 'or' of optional syntax constructs to be,    *          enabled,    * @exception IllegalArgumentException if an error occured while parsing the,    *              regular expression,    */,   public RegExp(String s, int syntax_flags) throws IllegalArgumentException {,     originalString = s;,     flags = syntax_flags;,     RegExp e;,     if (s.length() == 0) e = makeString("");,     else {,       e = parseUnionExp();,       if (pos < originalString.length()) throw new IllegalArgumentException(,           "end-of-string expected at position " + pos);,     },     kind = e.kind;,     exp1 = e.exp1;,     exp2 = e.exp2;,     this.s = e.s;,     c = e.c;,     min = e.min;,     max = e.max;,     digits = e.digits;,     from = e.from;,     to = e.to;,   }, ,   /**,    * Constructs new <code>Automaton</code> from this <code>RegExp</code>. Same,    * as <code>toAutomaton(null)</code> (empty automaton map).,    */,   public Automaton toAutomaton() {,     return toAutomaton(null, null, Operations.DEFAULT_MAX_DETERMINIZED_STATES);,   }, ,   /**,    * Constructs new <code>Automaton</code> from this <code>RegExp</code>. The,    * constructed automaton is minimal and deterministic and has no transitions,    * to dead states.,    * ,    * @param maxDeterminizedStates maximum number of states in the resulting,    *   automata.  If the automata would need more than this many states,    *   TooComplextToDeterminizeException is thrown.  Higher number require more,    *   space but can process more complex regexes.,    * @exception IllegalArgumentException if this regular expression uses a named,    *              identifier that is not available from the automaton provider,    * @exception TooComplexToDeterminizeException if determinizing this regexp,    *   requires more than maxDeterminizedStates states,    */,   public Automaton toAutomaton(int maxDeterminizedStates),       throws IllegalArgumentException, TooComplexToDeterminizeException {,     return toAutomaton(null, null, maxDeterminizedStates);,   }, ,   /**,    * Constructs new <code>Automaton</code> from this <code>RegExp</code>. The,    * constructed automaton is minimal and deterministic and has no transitions,    * to dead states.,    * ,    * @param automaton_provider provider of automata for named identifiers,    * @param maxDeterminizedStates maximum number of states in the resulting,    *   automata.  If the automata would need more than this many states,    *   TooComplextToDeterminizeException is thrown.  Higher number require more,    *   space but can process more complex regexes.,    * @exception IllegalArgumentException if this regular expression uses a named,    *   identifier that is not available from the automaton provider,    * @exception TooComplexToDeterminizeException if determinizing this regexp,    *   requires more than maxDeterminizedStates states,    */,   public Automaton toAutomaton(AutomatonProvider automaton_provider,,       int maxDeterminizedStates) throws IllegalArgumentException,,       TooComplexToDeterminizeException {,     return toAutomaton(null, automaton_provider, maxDeterminizedStates);,   },   ,   /**,    * Constructs new <code>Automaton</code> from this <code>RegExp</code>. The,    * constructed automaton is minimal and deterministic and has no transitions,    * to dead states.,    * ,    * @param automata a map from automaton identifiers to automata (of type,    *          <code>Automaton</code>).,    * @param maxDeterminizedStates maximum number of states in the resulting,    *   automata.  If the automata would need more than this many states,    *   TooComplexToDeterminizeException is thrown.  Higher number require more,    *   space but can process more complex regexes.,    * @exception IllegalArgumentException if this regular expression uses a named,    *   identifier that does not occur in the automaton map,    * @exception TooComplexToDeterminizeException if determinizing this regexp,    *   requires more than maxDeterminizedStates states,    */,   public Automaton toAutomaton(Map<String,Automaton> automata,,       int maxDeterminizedStates) throws IllegalArgumentException,,       TooComplexToDeterminizeException {,     return toAutomaton(automata, null, maxDeterminizedStates);,   }, ,   private Automaton toAutomaton(Map<String,Automaton> automata,,       AutomatonProvider automaton_provider, int maxDeterminizedStates),       throws IllegalArgumentException, TooComplexToDeterminizeException {,     try {,       return toAutomatonInternal(automata, automaton_provider,,         maxDeterminizedStates);,     } catch (TooComplexToDeterminizeException e) {,       throw new TooComplexToDeterminizeException(this, e);,     },   }, ,   private Automaton toAutomatonInternal(Map<String,Automaton> automata,,       AutomatonProvider automaton_provider, int maxDeterminizedStates),       throws IllegalArgumentException {,     List<Automaton> list;,     Automaton a = null;,     switch (kind) {,       case REGEXP_UNION:,         list = new ArrayList<>();,         findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,,           maxDeterminizedStates);,         findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,,           maxDeterminizedStates);,         a = Operations.union(list);,         a = MinimizationOperations.minimize(a, maxDeterminizedStates);,         break;,       case REGEXP_CONCATENATION:,         list = new ArrayList<>();,         findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,,             automaton_provider, maxDeterminizedStates);,         findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,,             automaton_provider, maxDeterminizedStates);,         a = Operations.concatenate(list);,         a = MinimizationOperations.minimize(a, maxDeterminizedStates);,         break;,       case REGEXP_INTERSECTION:,         a = Operations.intersection(,             exp1.toAutomatonInternal(,               automata, automaton_provider, maxDeterminizedStates),,             exp2.toAutomatonInternal(,               automata, automaton_provider, maxDeterminizedStates));,         a = MinimizationOperations.minimize(a, maxDeterminizedStates);,         break;,       case REGEXP_OPTIONAL:,         a = Operations.optional(exp1.toAutomatonInternal(automata,,           automaton_provider, maxDeterminizedStates));,         a = MinimizationOperations.minimize(a, maxDeterminizedStates);,         break;,       case REGEXP_REPEAT:,         a = Operations.repeat(exp1.toAutomatonInternal(,           automata, automaton_provider, maxDeterminizedStates));,         a = MinimizationOperations.minimize(a, maxDeterminizedStates);,         break;,       case REGEXP_REPEAT_MIN:,         a = Operations.repeat(,           exp1.toAutomatonInternal(automata, automaton_provider,,             maxDeterminizedStates),,           min);,         a = MinimizationOperations.minimize(a, maxDeterminizedStates);,         break;,       case REGEXP_REPEAT_MINMAX:,         a = Operations.repeat(,           exp1.toAutomatonInternal(automata, automaton_provider,,             maxDeterminizedStates),,           min,,           max);,         a = MinimizationOperations.minimize(a, maxDeterminizedStates);,         break;,       case REGEXP_COMPLEMENT:,         a = Operations.complement(,           exp1.toAutomatonInternal(automata, automaton_provider,,             maxDeterminizedStates),,           maxDeterminizedStates);,         a = MinimizationOperations.minimize(a, maxDeterminizedStates);,         break;,       case REGEXP_CHAR:,         a = Automata.makeChar(c);,         break;,       case REGEXP_CHAR_RANGE:,         a = Automata.makeCharRange(from, to);,         break;,       case REGEXP_ANYCHAR:,         a = Automata.makeAnyChar();,         break;,       case REGEXP_EMPTY:,         a = Automata.makeEmpty();,         break;,       case REGEXP_STRING:,         a = Automata.makeString(s);,         break;,       case REGEXP_ANYSTRING:,         a = Automata.makeAnyString();,         break;,       case REGEXP_AUTOMATON:,         Automaton aa = null;,         if (automata != null) {,           aa = automata.get(s);,         },         if (aa == null && automaton_provider != null) {,           try {,             aa = automaton_provider.getAutomaton(s);,           } catch (IOException e) {,             throw new IllegalArgumentException(e);,           },         },         if (aa == null) {,           throw new IllegalArgumentException("'" + s + "' not found");,         },         a = aa;,         break;,       case REGEXP_INTERVAL:,         a = Automata.makeInterval(min, max, digits);,         break;,     },     return a;,   },   ,   private void findLeaves(RegExp exp, Kind kind, List<Automaton> list,,       Map<String,Automaton> automata, AutomatonProvider automaton_provider,,       int maxDeterminizedStates) {,     if (exp.kind == kind) {,       findLeaves(exp.exp1, kind, list, automata, automaton_provider,,         maxDeterminizedStates);,       findLeaves(exp.exp2, kind, list, automata, automaton_provider,,         maxDeterminizedStates);,     } else {,       list.add(exp.toAutomatonInternal(automata, automaton_provider, ,         maxDeterminizedStates));,     },   }, ,   /**,    * The string that was used to construct the regex.  Compare to toString.,    */,   public String getOriginalString() {,     return originalString;,   }, ,   /**,    * Constructs string from parsed regular expression.,    */,   @Override,   public String toString() {,     StringBuilder b = new StringBuilder();,     toStringBuilder(b);,     return b.toString();,   },   ,   void toStringBuilder(StringBuilder b) {,     switch (kind) {,       case REGEXP_UNION:,         b.append("(");,         exp1.toStringBuilder(b);,         b.append("|");,         exp2.toStringBuilder(b);,         b.append(")");,         break;,       case REGEXP_CONCATENATION:,         exp1.toStringBuilder(b);,         exp2.toStringBuilder(b);,         break;,       case REGEXP_INTERSECTION:,         b.append("(");,         exp1.toStringBuilder(b);,         b.append("&");,         exp2.toStringBuilder(b);,         b.append(")");,         break;,       case REGEXP_OPTIONAL:,         b.append("(");,         exp1.toStringBuilder(b);,         b.append(")?");,         break;,       case REGEXP_REPEAT:,         b.append("(");,         exp1.toStringBuilder(b);,         b.append(")*");,         break;,       case REGEXP_REPEAT_MIN:,         b.append("(");,         exp1.toStringBuilder(b);,         b.append("){").append(min).append(",}");,         break;,       case REGEXP_REPEAT_MINMAX:,         b.append("(");,         exp1.toStringBuilder(b);,         b.append("){").append(min).append(",").append(max).append("}");,         break;,       case REGEXP_COMPLEMENT:,         b.append("~(");,         exp1.toStringBuilder(b);,         b.append(")");,         break;,       case REGEXP_CHAR:,         b.append("\\").appendCodePoint(c);,         break;,       case REGEXP_CHAR_RANGE:,         b.append("[\\").appendCodePoint(from).append("-\\").appendCodePoint(to).append("]");,         break;,       case REGEXP_ANYCHAR:,         b.append(".");,         break;,       case REGEXP_EMPTY:,         b.append("#");,         break;,       case REGEXP_STRING:,         b.append("\"").append(s).append("\"");,         break;,       case REGEXP_ANYSTRING:,         b.append("@");,         break;,       case REGEXP_AUTOMATON:,         b.append("<").append(s).append(">");,         break;,       case REGEXP_INTERVAL:,         String s1 = Integer.toString(min);,         String s2 = Integer.toString(max);,         b.append("<");,         if (digits > 0) for (int i = s1.length(); i < digits; i++),           b.append('0');,         b.append(s1).append("-");,         if (digits > 0) for (int i = s2.length(); i < digits; i++),           b.append('0');,         b.append(s2).append(">");,         break;,     },   }, ,   /**,    * Like to string, but more verbose (shows the higherchy more clearly).,    */,   public String toStringTree() {,     StringBuilder b = new StringBuilder();,     toStringTree(b, "");,     return b.toString();,   }, ,   void toStringTree(StringBuilder b, String indent) {,     switch (kind) {,       // binary,       case REGEXP_UNION:,       case REGEXP_CONCATENATION:,       case REGEXP_INTERSECTION:,         b.append(indent);,         b.append(kind);,         b.append('\n');,         exp1.toStringTree(b, indent + "  ");,         exp2.toStringTree(b, indent + "  ");,         break;,       // unary,       case REGEXP_OPTIONAL:,       case REGEXP_REPEAT:,       case REGEXP_COMPLEMENT:,         b.append(indent);,         b.append(kind);,         b.append('\n');,         exp1.toStringTree(b, indent + "  ");,         break;,       case REGEXP_REPEAT_MIN:,         b.append(indent);,         b.append(kind);,         b.append(" min=");,         b.append(min);,         b.append('\n');,         exp1.toStringTree(b, indent + "  ");,         break;,       case REGEXP_REPEAT_MINMAX:,         b.append(indent);,         b.append(kind);,         b.append(" min=");,         b.append(min);,         b.append(" max=");,         b.append(max);,         b.append('\n');,         exp1.toStringTree(b, indent + "  ");,         break;,       case REGEXP_CHAR:,         b.append(indent);,         b.append(kind);,         b.append(" char=");,         b.appendCodePoint(c);,         b.append('\n');,         break;,       case REGEXP_CHAR_RANGE:,         b.append(indent);,         b.append(kind);,         b.append(" from=");,         b.appendCodePoint(from);,         b.append(" to=");,         b.appendCodePoint(to);,         b.append('\n');,         break;,       case REGEXP_ANYCHAR:,       case REGEXP_EMPTY:,         b.append(indent);,         b.append(kind);,         b.append('\n');,         break;,       case REGEXP_STRING:,         b.append(indent);,         b.append(kind);,         b.append(" string=");,         b.append(s);,         b.append('\n');,         break;,       case REGEXP_ANYSTRING:,         b.append(indent);,         b.append(kind);,         b.append('\n');,         break;,       case REGEXP_AUTOMATON:,         b.append(indent);,         b.append(kind);,         b.append('\n');,         break;,       case REGEXP_INTERVAL:,         b.append(indent);,         b.append(kind);,         String s1 = Integer.toString(min);,         String s2 = Integer.toString(max);,         b.append("<");,         if (digits > 0) for (int i = s1.length(); i < digits; i++),           b.append('0');,         b.append(s1).append("-");,         if (digits > 0) for (int i = s2.length(); i < digits; i++),           b.append('0');,         b.append(s2).append(">");,         b.append('\n');,         break;,     },   }, ,   /**,    * Returns set of automaton identifiers that occur in this regular expression.,    */,   public Set<String> getIdentifiers() {,     HashSet<String> set = new HashSet<>();,     getIdentifiers(set);,     return set;,   },   ,   void getIdentifiers(Set<String> set) {,     switch (kind) {,       case REGEXP_UNION:,       case REGEXP_CONCATENATION:,       case REGEXP_INTERSECTION:,         exp1.getIdentifiers(set);,         exp2.getIdentifiers(set);,         break;,       case REGEXP_OPTIONAL:,       case REGEXP_REPEAT:,       case REGEXP_REPEAT_MIN:,       case REGEXP_REPEAT_MINMAX:,       case REGEXP_COMPLEMENT:,         exp1.getIdentifiers(set);,         break;,       case REGEXP_AUTOMATON:,         set.add(s);,         break;,       default:,     },   },   ,   static RegExp makeUnion(RegExp exp1, RegExp exp2) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_UNION;,     r.exp1 = exp1;,     r.exp2 = exp2;,     return r;,   },   ,   static RegExp makeConcatenation(RegExp exp1, RegExp exp2) {,     if ((exp1.kind == Kind.REGEXP_CHAR || exp1.kind == Kind.REGEXP_STRING),         && (exp2.kind == Kind.REGEXP_CHAR || exp2.kind == Kind.REGEXP_STRING)) return makeString(,         exp1, exp2);,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_CONCATENATION;,     if (exp1.kind == Kind.REGEXP_CONCATENATION,         && (exp1.exp2.kind == Kind.REGEXP_CHAR || exp1.exp2.kind == Kind.REGEXP_STRING),         && (exp2.kind == Kind.REGEXP_CHAR || exp2.kind == Kind.REGEXP_STRING)) {,       r.exp1 = exp1.exp1;,       r.exp2 = makeString(exp1.exp2, exp2);,     } else if ((exp1.kind == Kind.REGEXP_CHAR || exp1.kind == Kind.REGEXP_STRING),         && exp2.kind == Kind.REGEXP_CONCATENATION,         && (exp2.exp1.kind == Kind.REGEXP_CHAR || exp2.exp1.kind == Kind.REGEXP_STRING)) {,       r.exp1 = makeString(exp1, exp2.exp1);,       r.exp2 = exp2.exp2;,     } else {,       r.exp1 = exp1;,       r.exp2 = exp2;,     },     return r;,   },   ,   static private RegExp makeString(RegExp exp1, RegExp exp2) {,     StringBuilder b = new StringBuilder();,     if (exp1.kind == Kind.REGEXP_STRING) b.append(exp1.s);,     else b.appendCodePoint(exp1.c);,     if (exp2.kind == Kind.REGEXP_STRING) b.append(exp2.s);,     else b.appendCodePoint(exp2.c);,     return makeString(b.toString());,   },   ,   static RegExp makeIntersection(RegExp exp1, RegExp exp2) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_INTERSECTION;,     r.exp1 = exp1;,     r.exp2 = exp2;,     return r;,   },   ,   static RegExp makeOptional(RegExp exp) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_OPTIONAL;,     r.exp1 = exp;,     return r;,   },   ,   static RegExp makeRepeat(RegExp exp) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_REPEAT;,     r.exp1 = exp;,     return r;,   },   ,   static RegExp makeRepeat(RegExp exp, int min) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_REPEAT_MIN;,     r.exp1 = exp;,     r.min = min;,     return r;,   },   ,   static RegExp makeRepeat(RegExp exp, int min, int max) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_REPEAT_MINMAX;,     r.exp1 = exp;,     r.min = min;,     r.max = max;,     return r;,   },   ,   static RegExp makeComplement(RegExp exp) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_COMPLEMENT;,     r.exp1 = exp;,     return r;,   },   ,   static RegExp makeChar(int c) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_CHAR;,     r.c = c;,     return r;,   },   ,   static RegExp makeCharRange(int from, int to) {,     if (from > to) ,       throw new IllegalArgumentException("invalid range: from (" + from + ") cannot be > to (" + to + ")");,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_CHAR_RANGE;,     r.from = from;,     r.to = to;,     return r;,   },   ,   static RegExp makeAnyChar() {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_ANYCHAR;,     return r;,   },   ,   static RegExp makeEmpty() {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_EMPTY;,     return r;,   },   ,   static RegExp makeString(String s) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_STRING;,     r.s = s;,     return r;,   },   ,   static RegExp makeAnyString() {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_ANYSTRING;,     return r;,   },   ,   static RegExp makeAutomaton(String s) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_AUTOMATON;,     r.s = s;,     return r;,   },   ,   static RegExp makeInterval(int min, int max, int digits) {,     RegExp r = new RegExp();,     r.kind = Kind.REGEXP_INTERVAL;,     r.min = min;,     r.max = max;,     r.digits = digits;,     return r;,   },   ,   private boolean peek(String s) {,     return more() && s.indexOf(originalString.codePointAt(pos)) != -1;,   },   ,   private boolean match(int c) {,     if (pos >= originalString.length()) return false;,     if (originalString.codePointAt(pos) == c) {,       pos += Character.charCount(c);,       return true;,     },     return false;,   },   ,   private boolean more() {,     return pos < originalString.length();,   },   ,   private int next() throws IllegalArgumentException {,     if (!more()) throw new IllegalArgumentException("unexpected end-of-string");,     int ch = originalString.codePointAt(pos);,     pos += Character.charCount(ch);,     return ch;,   },   ,   private boolean check(int flag) {,     return (flags & flag) != 0;,   },   ,   final RegExp parseUnionExp() throws IllegalArgumentException {,     RegExp e = parseInterExp();,     if (match('|')) e = makeUnion(e, parseUnionExp());,     return e;,   },   ,   final RegExp parseInterExp() throws IllegalArgumentException {,     RegExp e = parseConcatExp();,     if (check(INTERSECTION) && match('&')) e = makeIntersection(e,,         parseInterExp());,     return e;,   },   ,   final RegExp parseConcatExp() throws IllegalArgumentException {,     RegExp e = parseRepeatExp();,     if (more() && !peek(")|") && (!check(INTERSECTION) || !peek("&"))) e = makeConcatenation(,         e, parseConcatExp());,     return e;,   },   ,   final RegExp parseRepeatExp() throws IllegalArgumentException {,     RegExp e = parseComplExp();,     while (peek("?*+{")) {,       if (match('?')) e = makeOptional(e);,       else if (match('*')) e = makeRepeat(e);,       else if (match('+')) e = makeRepeat(e, 1);,       else if (match('{')) {,         int start = pos;,         while (peek("0123456789")),           next();,         if (start == pos) throw new IllegalArgumentException(,             "integer expected at position " + pos);,         int n = Integer.parseInt(originalString.substring(start, pos));,         int m = -1;,         if (match(',')) {,           start = pos;,           while (peek("0123456789")),             next();,           if (start != pos) m = Integer.parseInt(,             originalString.substring(start, pos));,         } else m = n;,         if (!match('}')) throw new IllegalArgumentException(,             "expected '}' at position " + pos);,         if (m == -1) e = makeRepeat(e, n);,         else e = makeRepeat(e, n, m);,       },     },     return e;,   },   ,   final RegExp parseComplExp() throws IllegalArgumentException {,     if (check(COMPLEMENT) && match('~')) return makeComplement(parseComplExp());,     else return parseCharClassExp();,   },   ,   final RegExp parseCharClassExp() throws IllegalArgumentException {,     if (match('[')) {,       boolean negate = false;,       if (match('^')) negate = true;,       RegExp e = parseCharClasses();,       if (negate) e = makeIntersection(makeAnyChar(), makeComplement(e));,       if (!match(']')) throw new IllegalArgumentException(,           "expected ']' at position " + pos);,       return e;,     } else return parseSimpleExp();,   },   ,   final RegExp parseCharClasses() throws IllegalArgumentException {,     RegExp e = parseCharClass();,     while (more() && !peek("]")),       e = makeUnion(e, parseCharClass());,     return e;,   },   ,   final RegExp parseCharClass() throws IllegalArgumentException {,     int c = parseCharExp();,     if (match('-')) return makeCharRange(c, parseCharExp());,     else return makeChar(c);,   },   ,   final RegExp parseSimpleExp() throws IllegalArgumentException {,     if (match('.')) return makeAnyChar();,     else if (check(EMPTY) && match('#')) return makeEmpty();,     else if (check(ANYSTRING) && match('@')) return makeAnyString();,     else if (match('"')) {,       int start = pos;,       while (more() && !peek("\"")),         next();,       if (!match('"')) throw new IllegalArgumentException(,           "expected '\"' at position " + pos);,       return makeString(originalString.substring(start, pos - 1));,     } else if (match('(')) {,       if (match(')')) return makeString("");,       RegExp e = parseUnionExp();,       if (!match(')')) throw new IllegalArgumentException(,           "expected ')' at position " + pos);,       return e;,     } else if ((check(AUTOMATON) || check(INTERVAL)) && match('<')) {,       int start = pos;,       while (more() && !peek(">")),         next();,       if (!match('>')) throw new IllegalArgumentException(,           "expected '>' at position " + pos);,       String s = originalString.substring(start, pos - 1);,       int i = s.indexOf('-');,       if (i == -1) {,         if (!check(AUTOMATON)) throw new IllegalArgumentException(,             "interval syntax error at position " + (pos - 1));,         return makeAutomaton(s);,       } else {,         if (!check(INTERVAL)) throw new IllegalArgumentException(,             "illegal identifier at position " + (pos - 1));,         try {,           if (i == 0 || i == s.length() - 1 || i != s.lastIndexOf('-')) throw new NumberFormatException();,           String smin = s.substring(0, i);,           String smax = s.substring(i + 1, s.length());,           int imin = Integer.parseInt(smin);,           int imax = Integer.parseInt(smax);,           int digits;,           if (smin.length() == smax.length()) digits = smin.length();,           else digits = 0;,           if (imin > imax) {,             int t = imin;,             imin = imax;,             imax = t;,           },           return makeInterval(imin, imax, digits);,         } catch (NumberFormatException e) {,           throw new IllegalArgumentException(,               "interval syntax error at position " + (pos - 1));,         },       },     } else return makeChar(parseCharExp());,   },   ,   final int parseCharExp() throws IllegalArgumentException {,     match('\\');,     return next();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/util/fst/NodeHash.java,hash,84-84,[      h = PRIME * h + arc.nextFinalOutput.hashCode();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/util/fst/NodeHash.java,nodesEqual,52-52,[          !arc.nextFinalOutput.equals(scratchArc.nextFinalOutput) ||],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/util/fst/NodeHash.java,hash,83-83,[      h = PRIME * h + arc.output.hashCode();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/lucene/util/fst/NodeHash.java,nodesEqual,50-50,[          !arc.output.equals(scratchArc.output) ||],,
CORRECTNESS,GC_UNRELATED_TYPES,org/apache/lucene/util/fst/FST.java,pack,1706-1706,[              final Integer ptr = topNodeMap.get(arc.target);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/util/fst/FST.java,compareTo,1879-1885,[      if (count > other.count) {,         return 1;,       } else if (count < other.count) {,         return -1;,       } else {,         // Tie-break: smaller node compares as greater than,         return other.node - node;],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/lucene/util/fst/FSTTester.java,compareTo,175-175,[      if (other instanceof InputOutput) {],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/lucene/util/fst/FSTTester.java,compareTo,175-178,[      if (other instanceof InputOutput) {,         return input.compareTo((other).input);,       } else {,         throw new IllegalArgumentException();],,
CORRECTNESS,SIO_SUPERFLUOUS_INSTANCEOF,org/apache/lucene/util/fst/FSTTester.java,compareTo,175-175,[      if (other instanceof InputOutput) {],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/lucene/util/fst/PositiveIntOutputs.java,<clinit>,35-35,[  private final static Long NO_OUTPUT = new Long(0);],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE,org/apache/lucene/util/fst/PositiveIntOutputs.java,add,78-78,[    if (prefix == NO_OUTPUT) {],,add,80-80,[    } else if (output == NO_OUTPUT) {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE,org/apache/lucene/util/fst/PositiveIntOutputs.java,common,50-50,[    if (output1 == NO_OUTPUT || output2 == NO_OUTPUT) {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE,org/apache/lucene/util/fst/PositiveIntOutputs.java,valid,105-105,[    assert o == NO_OUTPUT || o > 0: "o=" + o;],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE,org/apache/lucene/util/fst/PositiveIntOutputs.java,subtract,65-65,[    if (inc == NO_OUTPUT) {],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/lucene/util/fst/UpToTwoPositiveIntOutputs.java,valid,203-203,[    assert o instanceof Long;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/lucene/util/fst/UpToTwoPositiveIntOutputs.java,<clinit>,85-85,[  private final static Long NO_OUTPUT = new Long(0);],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE,org/apache/lucene/util/fst/UpToTwoPositiveIntOutputs.java,add,155-155,[      if (prefix == NO_OUTPUT) {],,add,157-157,[      } else if (output == NO_OUTPUT) {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE,org/apache/lucene/util/fst/UpToTwoPositiveIntOutputs.java,valid,204-204,[    assert o == NO_OUTPUT || o > 0;],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE,org/apache/lucene/util/fst/UpToTwoPositiveIntOutputs.java,common,118-118,[    if (output1 == NO_OUTPUT || output2 == NO_OUTPUT) {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE,org/apache/lucene/util/fst/UpToTwoPositiveIntOutputs.java,subtract,139-139,[    if (inc == NO_OUTPUT) {],,
CORRECTNESS,SIO_SUPERFLUOUS_INSTANCEOF,org/apache/lucene/util/fst/UpToTwoPositiveIntOutputs.java,valid,203-203,[    assert o instanceof Long;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/lucene/util/fst/Util.java,,270-282,[  private static class TieBreakByInputComparator<T> implements Comparator<FSTPath<T>> {,     private final Comparator<T> comparator;,     public TieBreakByInputComparator(Comparator<T> comparator) {,       this.comparator = comparator;,     }, ,     @Override,     public int compare(FSTPath<T> a, FSTPath<T> b) {,       int cmp = comparator.compare(a.cost, b.cost);,       if (cmp == 0) {,         return a.input.get().compareTo(b.input.get());,       } else {,         return cmp;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/lucene/util/mutable/MutableValue.java,equals,53-53,[    return (getClass() == other.getClass()) && this.equalsSameType(other);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/util/mutable/MutableValueBool.java,copy,36-36,[    MutableValueBool s = (MutableValueBool) source;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/lucene/util/mutable/MutableValueBool.java,hashCode,67-68,[    assert exists || (false == value);,     return value ? 2 : (exists ? 1 : 0);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/util/mutable/MutableValueDouble.java,copy,36-36,[    MutableValueDouble s = (MutableValueDouble) source;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/util/mutable/MutableValueDouble.java,equalsSameType,53-53,[    return value == b.value && exists == b.exists;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/lucene/util/mutable/MutableValueDouble.java,hashCode,68-70,[    assert exists || 0.0D == value;,     long x = Double.doubleToLongBits(value);,     return (int)x + (int)(x>>>32);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/util/mutable/MutableValueFloat.java,copy,36-36,[    MutableValueFloat s = (MutableValueFloat) source;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/lucene/util/mutable/MutableValueFloat.java,equalsSameType,53-53,[    return value == b.value && exists == b.exists;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/lucene/util/mutable/MutableValueFloat.java,hashCode,68-69,[    assert exists || 0.0F == value;,     return Float.floatToIntBits(value);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/util/mutable/MutableValueInt.java,copy,36-36,[    MutableValueInt s = (MutableValueInt) source;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/lucene/util/mutable/MutableValueInt.java,hashCode,72-74,[    assert exists || 0 == value;,     // TODO: if used in HashMap, it already mixes the value... maybe use a straight value?,     return (value>>8) + (value>>16);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/util/mutable/MutableValueLong.java,copy,36-36,[    MutableValueLong s = (MutableValueLong) source;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/lucene/util/mutable/MutableValueLong.java,hashCode,70-71,[    assert exists || 0L == value;,     return (int)value + (int)(value>>32);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/lucene/util/mutable/MutableValueStr.java,copy,39-39,[    MutableValueStr s = (MutableValueStr) source;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/lucene/util/mutable/MutableValueStr.java,hashCode,72-73,[    assert exists || 0 == value.length();,     return value.get().hashCode();],,
STYLE,ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT,org/apache/lucene/util/packed/BulkOperationPacked.java,encode,263-263,[          blocks[blocksOffset++] = (byte) (v >>> bits);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/util/packed/EliasFanoEncoder.java,getIndexBits,307-307,[    return upperZeroBitPositionIndex;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/util/packed/EliasFanoEncoder.java,getLowerBits,297-297,[    return lowerLongs;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/lucene/util/packed/EliasFanoEncoder.java,getUpperBits,302-302,[    return upperLongs;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/BaseDistributedSearchTestCase.java,compare,634-634,[        Object prev = mapB.put(b.getName(i), b.getVal(i));],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/solr/BaseDistributedSearchTestCase.java,eq,612-612,[    return a == b || (a != null && a.equals(b));],,
MALICIOUS_CODE,MS_FINAL_PKGPROTECT,org/apache/solr/BaseDistributedSearchTestCase.java,,254-254,[  public static RandVal[] randVals = new RandVal[]{rint, rfloat, rfloat, rdouble, rdouble, rlong, rlong, rdate, rdate};],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/solr/BaseDistributedSearchTestCase.java,,253-253,[  public static String[] fieldNames = new String[]{"n_ti1", "n_f1", "n_tf1", "n_d1", "n_td1", "n_l1", "n_tl1", "n_dt1", "n_tdt1"};],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,206-206,[  public static int SKIP = 2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,207-207,[  public static int SKIPVAL = 4;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,208-208,[  public static int UNORDERED = 8;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,214-214,[  public static Logger log = LoggerFactory.getLogger(BaseDistributedSearchTestCase.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,244-244,[  public static RandVal rdate = new RandDate();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,237-237,[  public static RandVal rdouble = new RandVal() {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,230-230,[  public static RandVal rfloat = new RandVal() {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,216-216,[  public static RandVal rint = new RandVal() {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,223-223,[  public static RandVal rlong = new RandVal() {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,205-205,[  public static int ORDERED = 1;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/BaseDistributedSearchTestCase.java,testDistribSearch,867-867,[      RandVal.uniqueValues = new HashSet(); //reset random values],,testDistribSearch,873-873,[        RandVal.uniqueValues = new HashSet(); //reset random values],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/BaseDistributedSearchTestCase.java,compare1,701-701,[      Object vala = a.get(keya);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/BaseDistributedSearchTestCase.java,,914-914,[    public static TrieDateField df = new TrieDateField();],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/solr/BaseDistributedSearchTestCase.java,,901-901,[    public static Set uniqueValues = new HashSet();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/JSONTestUtil.java,matchMap,289-289,[    Set<String> visited = new HashSet<>();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/JSONTestUtil.java,,161-161,[    this.expectedRoot = expected;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/JSONTestUtil.java,,119-119,[    this.valRoot = val;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/JSONTestUtil.java,matchMap,307-307,[      expected = expectedMap.get(expectedKey);],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/solr/JSONTestUtil.java,match,71-71,[    return match(path, input, expected, delta);],,match,69-69,[    String path = pos>=0 ? pathAndExpected.substring(0,pos) : null;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/SolrJettyTestBase.java,legacyExampleCollection1SolrHome,170-170,[          } catch (Exception ignore){}],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/solr/SolrJettyTestBase.java,afterSolrJettyTestBase,84-86,[    if (jetty != null) {,       jetty.stop();,       jetty = null;],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/solr/SolrJettyTestBase.java,getSolrClient,95-96,[      if (client == null) {,         client = createNewSolrClient();],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/solr/SolrJettyTestBase.java,,51-51,[  public static SolrClient client = null;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/SolrJettyTestBase.java,legacyExampleCollection1SolrHome,174-174,[    } catch (Exception exc) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/SolrJettyTestBase.java,getSolrClient,96-96,[        client = createNewSolrClient();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/SolrLogFormatter.java,_format,163-163,[    long timeSinceLast = now - lastTime;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/SolrLogFormatter.java,_format,194-194,[      if (zkController == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/SolrLogFormatter.java,_format,194-194,[      if (zkController == null) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/SolrLogFormatter.java,_format,185-185,[        info.shortId = "C"+Integer.toString(CoreInfo.maxCoreNum++);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/SolrTestCaseJ4.java,assertQ,703-703,[      String m = (null == message) ? "" : message + " ";],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/solr/SolrTestCaseJ4.java,deleteCore,641-648,[    if (h != null) { h.close(); }, ,     if (factoryProp == null) {,       System.clearProperty("solr.directoryFactory");,     },     ,     solrConfig = null;,     h = null;],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/solr/SolrTestCaseJ4.java,ignoreException,468-469,[    if (SolrException.ignorePatterns == null),       SolrException.ignorePatterns = new HashSet<>();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/SolrTestCaseJ4.java,,127-127,[  public static int DEFAULT_CONNECTION_TIMEOUT = 60000;  // default socket connection timeout in ms],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/SolrTestCaseJ4.java,,552-552,[  public static Logger log = LoggerFactory.getLogger(SolrTestCaseJ4.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/SolrTestCaseJ4.java,,148-148,[             .around(new RevertDefaultThreadHandlerRule());],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/solr/SolrTestCaseJ4.java,initCore,385-385,[    assertNotNull(solrHome);],,initCore,389-389,[    if (solrHome != null) {],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/solr/SolrTestCaseJ4.java,afterClass,185-209,[      deleteCore();,       resetExceptionIgnores();,       endTrackingSearchers();,       endTrackingZkClients();,       resetFactory();,       coreName = ConfigSolrXmlOld.DEFAULT_DEFAULT_CORE_NAME;,     } finally {,       initCoreDataDir = null;,       System.clearProperty("zookeeper.forceSync");,       System.clearProperty("jetty.testMode");,       System.clearProperty("tests.shardhandler.randomSeed");,       System.clearProperty("enable.update.log");,       System.clearProperty("useCompoundFile");,       System.clearProperty("urlScheme");,       ,       if (isSSLMode()) {,         HttpClientUtil.setConfigurer(new HttpClientConfigurer());,       }, ,       // clean up static,       sslConfig = null;,     },     ,     IpTables.unblockAllPorts();,   }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/solr/SolrTestCaseJ4.java,beforeClass,157-179,[    initCoreDataDir = createTempDir("init-core-data").toFile();, ,     System.err.println("Creating dataDir: " + initCoreDataDir.getAbsolutePath());, ,     System.setProperty("zookeeper.forceSync", "no");,     System.setProperty("jetty.testMode", "true");,     System.setProperty("enable.update.log", usually() ? "true" : "false");,     System.setProperty("tests.shardhandler.randomSeed", Long.toString(random().nextLong()));,     System.setProperty("solr.clustering.enabled", "false");,     setupLogging();,     startTrackingSearchers();,     startTrackingZkClients();,     ignoreException("ignore_exception");,     newRandomConfig();,     ,     sslConfig = buildSSLConfig();,     //will use ssl specific or default depending on sslConfig,     HttpClientUtil.setConfigurer(sslConfig.getHttpClientConfigurer());,     if(isSSLMode()) {,       // SolrCloud tests should usually clear this,       System.setProperty("urlScheme", "https");,     },   }],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/SolrTestCaseJ4.java,invertField,1709-1709,[      Doc doc = model.get(key);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/SolrTestCaseJ4.java,compareTo,1410-1410,[      return this.id.compareTo(other.id);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/SolrTestCaseJ4.java,hashCode,1396-1396,[      return id.hashCode();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/SolrTestCaseJ4.java,,1455-1484,[      this(fname, ZERO_ONE, vals);,     }, ,     public FldType(String fname, IVals numValues, Vals vals) {,       this.fname = fname;,       this.numValues = numValues;,       this.vals = vals;      ,     }, ,     public Comparable createValue() {,       return vals.get();,     }, ,     public List<Comparable> createValues() {,       int nVals = numValues.getInt();,       if (nVals <= 0) return null;,       List<Comparable> vals = new ArrayList<>(nVals);,       for (int i=0; i<nVals; i++),         vals.add(createValue());,       return vals;,     }, ,     public Fld createField() {,       List<Comparable> vals = createValues();,       if (vals == null) return null;, ,       Fld fld = new Fld();,       fld.ftype = this;,       fld.vals = vals;,       return fld;          ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/analysis/LegacyHTMLStripCharFilter.java,readScriptString,544-544,[        ch=next();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analysis/LegacyHTMLStripCharFilter.java,<clinit>,784-784,[      entityTable.put(entityName[i], new Character(entityVal[i]));],,<clinit>,787-787,[    entityTable.put("nbsp",new Character(' '));],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/analysis/TokenizerChain.java,getCharFilterFactories,46-46,[  public CharFilterFactory[] getCharFilterFactories() { return charFilters; }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/analysis/TokenizerChain.java,getTokenFilterFactories,48-48,[  public TokenFilterFactory[] getTokenFilterFactories() { return filters; }],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analysis/TokenizerChain.java,<init>,41-41,[    this.charFilters = charFilters;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analysis/TokenizerChain.java,<init>,43-43,[    this.filters = filters;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/analytics/accumulator/FacetingAccumulator.java,,95-95,[    this.analyticsRequest = request;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/solr/analytics/accumulator/FacetingAccumulator.java,,292-303,[  public static class EntryComparator implements Comparator<Entry<String,Expression[]>> {,     private final Comparator<Expression> comp;,     private final int comparatorExpressionPlace;,    ,     public EntryComparator(Comparator<Expression> comp, int comparatorExpressionPlace) {,       this.comp = comp;,       this.comparatorExpressionPlace = comparatorExpressionPlace;,     }, ,     @Override,     public int compare(Entry<String,Expression[]> o1, Entry<String,Expression[]> o2) {,       return comp.compare(o1.getValue()[comparatorExpressionPlace], o2.getValue()[comparatorExpressionPlace]);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/analytics/accumulator/facet/FieldFacetAccumulator.java,,70-70,[    this.dateField = schemaField.getType().getClass().equals(TrieDateField.class);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/analytics/accumulator/facet/FieldFacetAccumulator.java,,63-63,[    this.schemaField = schemaField;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/analytics/accumulator/facet/FieldFacetAccumulator.java,,62-62,[    this.searcher = searcher;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/expression/SingleDelegateExpression.java,getValue,67-67,[      return new Double(d*-1);],,getValue,69-69,[      return new Double(d);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/expression/MultiDelegateExpression.java,getValue,55-55,[    return new Double(sum);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analytics/expression/MultiDelegateExpression.java,getValue,51-51,[        dComp = new Long(((Date)dComp).getTime());],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/expression/BaseExpression.java,<init>,51-51,[    constant = new Double(d);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/expression/DualDelegateExpression.java,getValue,53-53,[    return new Double(div);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/analytics/expression/Expression.java,,32-39,[    return new Comparator<Expression>(){,       @SuppressWarnings("unchecked"),       @Override,       public int compare(Expression a, Expression b) {,         if( direction == FacetSortDirection.ASCENDING ){,           return a.getValue().compareTo(b.getValue());,         } else {,           return b.getValue().compareTo(a.getValue());],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/solr/analytics/expression/ExpressionFactory.java,getArguments,172-172,[      } else if (c == '\\') {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/expression/MultiDelegateExpression.java,<init>,32-32,[    this.delegates = delegates;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/expression/MultiDelegateExpression.java,getValue,76-76,[    return new Double(prod);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/expression/SingleDelegateExpression.java,getValue,48-48,[    return new Double(((Number)nComp).doubleValue()*-1);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analytics/expression/SingleDelegateExpression.java,getValue,46-46,[      nComp = new Long(((Date)nComp).getTime());],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/expression/DualDelegateExpression.java,getValue,76-76,[    return new Double(Math.pow(((Number)aComp).doubleValue(),((Number)bComp).doubleValue()));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/analytics/plugin/AnalyticsStatisticsCollector.java,endRequest,87-87,[    currentTimer.stop();],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,41-41,[  public final String ANALYTICS_REQUEST="analyticsRequest";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,39-39,[  public final String ANALYTICS_REQUEST_ENVELOPE="analyticsRequestEnvelope";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,55-55,[  public final String DIRECTION="direction";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,59-59,[  public final String END="end";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,45-45,[  public final String EXPRESSION="expression";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,48-48,[  public final String FIELD="field";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,47-47,[  public final String FIELD_FACET="fieldFacet";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,60-60,[  public final String GAP="gap";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,63-63,[  public final String HARD_END="hardend";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,61-61,[  public final String INCLUDE_BOUNDARY="includeBoundary";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,50-50,[  public final String LIMIT="limit";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,51-51,[  public final String MIN_COUNT="minCount";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,42-42,[  public final String NAME="name";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,62-62,[  public final String OTHER_RANGE="otherRange";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,66-66,[  public final String QUERY="query";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,65-65,[  public final String QUERY_FACET="queryFacet";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,57-57,[  public final String RANGE_FACET="rangeFacet";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,49-49,[  public final String SHOW_MISSING="showMissing";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,53-53,[  public final String SORT_SPECIFICATION="sortSpecification";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,58-58,[  public final String START="start";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,44-44,[  public final String STATISTIC="statistic";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,54-54,[  public final String STAT_NAME="statName";],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/analytics/request/AnalyticsContentHandler.java,,157-157,[            minCount = Integer.parseInt(att);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/analytics/request/AnalyticsRequestFactory.java,parse,117-117,[      AnalyticsRequest ar = requestMap.get(reqName);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/analytics/request/AnalyticsStats.java,execute,71-71,[    if(requests == null || requests.size()==0){],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/analytics/request/ExpressionRequest.java,compareTo,65-65,[    return name.compareTo(o.getName());],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/analytics/request/RangeFacetRequest.java,getGaps,89-89,[    return gaps;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/request/RangeFacetRequest.java,<init>,51-51,[    this.gaps = gaps;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/request/RangeFacetRequest.java,setGaps,93-93,[    this.gaps = gaps;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/analytics/statistics/MedianStatsCollector.java,collect,59-59,[      values.add(function.doubleVal(doc));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/analytics/statistics/MedianStatsCollector.java,collect,58-58,[    if (value.exists) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/analytics/statistics/PercentileStatsCollector.java,collect,75-75,[    if (value.exists) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/analytics/statistics/UniqueStatsCollector.java,collect,36-36,[    if (value.exists) {],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/statistics/MedianStatsCollector.java,getMedian,39-39,[    return new Double(MedianCalculator.getMedian(values));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/statistics/MedianStatsCollector.java,getStat,45-45,[      return new Double(median);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analytics/statistics/MinMaxStatsCollector.java,getStat,81-81,[      return new Long(valueCount);],,getStat,84-84,[      return new Long(missingCount);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/analytics/statistics/NumericStatsCollector.java,collect,39-39,[    double value = function.doubleVal(doc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/analytics/statistics/MinMaxStatsCollector.java,collect,57-57,[    if( value.exists ){],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/analytics/statistics/MinMaxStatsCollector.java,collect,56-56,[    valueFiller.fillValue(doc);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/statistics/NumericStatsCollector.java,getStat,47-47,[      return new Double(sum);],,getStat,50-50,[      return new Double(sumOfSquares);],,getStat,53-53,[      return new Double(mean);],,getStat,56-56,[      return new Double(stddev);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/statistics/PercentileStatsCollector.java,<init>,42-42,[    this.percentileNames = percentileNames;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/statistics/PercentileStatsCollector.java,<init>,41-41,[    this.percentiles = percentiles;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory.java,buildFilterSource,465-465,[        defaultObject = new Double(arguments[1]);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory.java,buildFilterSource,458-458,[        defaultObject = new Float(arguments[1]);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory.java,buildFilterSource,440-440,[        defaultObject = new Integer(arguments[1]);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory.java,buildFilterSource,452-452,[        defaultObject = new Long(arguments[1]);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analytics/statistics/UniqueStatsCollector.java,getStat,44-44,[      return new Long(uniqueValues.size());],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/solr/analytics/util/MedianCalculator.java,getMedian,39-39,[    int secondIdx = (firstIdx <= size && size % 2 == 1) ? firstIdx + 1 : firstIdx;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/util/RangeEndpointCalculator.java,<init>,327-327,[      this.now = now;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/util/RangeEndpointCalculator.java,parseAndAddGap,286-286,[      return new Double(value.doubleValue() + Double.valueOf(gap).doubleValue());],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/analytics/util/RangeEndpointCalculator.java,,127-127,[      this.name = name;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/util/RangeEndpointCalculator.java,parseAndAddGap,270-270,[      return new Float(value.floatValue() + Float.valueOf(gap).floatValue());],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/analytics/util/RangeEndpointCalculator.java,parseAndAddGap,302-302,[      return new Integer(value.intValue() + Integer.valueOf(gap).intValue());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analytics/util/RangeEndpointCalculator.java,parseAndAddGap,302-302,[      return new Integer(value.intValue() + Integer.valueOf(gap).intValue());],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/analytics/util/RangeEndpointCalculator.java,parseAndAddGap,318-318,[      return new Long(value.longValue() + Long.valueOf(gap).longValue());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/analytics/util/RangeEndpointCalculator.java,parseAndAddGap,318-318,[      return new Long(value.longValue() + Long.valueOf(gap).longValue());],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/solr/analytics/util/valuesource/AbsoluteValueDoubleFunction.java,equals,54-56,[    if (getClass() != o.getClass()) return false;,     AbsoluteValueDoubleFunction other = (AbsoluteValueDoubleFunction)o;,     return this.source.equals(other.source);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/AbsoluteValueDoubleFunction.java,equals,54-56,[    if (getClass() != o.getClass()) return false;,     AbsoluteValueDoubleFunction other = (AbsoluteValueDoubleFunction)o;,     return this.source.equals(other.source);],,
CORRECTNESS,BC_IMPOSSIBLE_CAST,org/apache/solr/analytics/util/valuesource/ConstDoubleSource.java,equals,72-72,[    ConstDoubleSource other = (ConstDoubleSource)o;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/analytics/util/valuesource/ConstDoubleSource.java,getNumber,98-98,[    return new Double(constant);],,
BAD_PRACTICE,EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS,org/apache/solr/analytics/util/valuesource/ConstDoubleSource.java,equals,71-71,[    if (!(o instanceof ConstValueSource)) return false;],,
CORRECTNESS,EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC,org/apache/solr/analytics/util/valuesource/ConstStringSource.java,equals,44-48,[    if (this == o) return true;,     if (!(o instanceof ConstStringSource)) return false;,     ConstStringSource that = (ConstStringSource) o;, ,     return getValue().equals(that.getValue());],,equals,77-82,[    if (this == o) return true;,     if (!(o instanceof LiteralValueSource)) return false;, ,     LiteralValueSource that = (LiteralValueSource) o;, ,     return string.equals(that.string);],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/solr/analytics/util/valuesource/ConstStringSource.java,equals,44-48,[    if (this == o) return true;,     if (!(o instanceof ConstStringSource)) return false;,     ConstStringSource that = (ConstStringSource) o;, ,     return getValue().equals(that.getValue());],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/DateFieldSource.java,equals,108-110,[    if (o.getClass() != this.getClass()) return false;,     DateFieldSource other = (DateFieldSource) o;,     return field.equals(other.field);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/DualDoubleFunction.java,equals,80-83,[    if (getClass() != o.getClass()) return false;,     DualDoubleFunction other = (DualDoubleFunction)o;,     return this.a.equals(other.a),         && this.b.equals(other.b);],,
STYLE,NS_DANGEROUS_NON_SHORT_CIRCUIT,org/apache/solr/analytics/util/valuesource/DualDoubleFunction.java,exists,62-62,[        return aVals.exists(doc) & bVals.exists(doc);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/FilterFieldSource.java,equals,146-148,[    if (getClass() != o.getClass()) return false;,     FilterFieldSource other = (FilterFieldSource)o;,     return this.source.equals(other.source) && this.missValue.equals(other.missValue);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/util/valuesource/MultiDateFunction.java,<init>,39-39,[    this.sources = sources;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/MultiDateFunction.java,equals,123-126,[    if (getClass() != o.getClass()) return false;,     MultiDateFunction other = (MultiDateFunction)o;,     return this.name().equals(other.name()),             && Arrays.equals(this.sources, other.sources);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/util/valuesource/MultiDoubleFunction.java,<init>,38-38,[    this.sources = sources;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/MultiDoubleFunction.java,equals,110-113,[    if (getClass() != o.getClass()) return false;,     MultiDoubleFunction other = (MultiDoubleFunction)o;,     return this.name().equals(other.name()),             && Arrays.equals(this.sources, other.sources);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/analytics/util/valuesource/MultiStringFunction.java,<init>,40-40,[    this.sources = sources;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/MultiStringFunction.java,equals,136-139,[    if (getClass() != o.getClass()) return false;,     MultiStringFunction other = (MultiStringFunction)o;,     return this.name().equals(other.name()),             && Arrays.equals(this.sources, other.sources);],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/solr/analytics/util/valuesource/NegateDoubleFunction.java,equals,49-51,[    if (getClass() != o.getClass()) return false;,     NegateDoubleFunction other = (NegateDoubleFunction)o;,     return this.source.equals(other.source);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/NegateDoubleFunction.java,equals,49-51,[    if (getClass() != o.getClass()) return false;,     NegateDoubleFunction other = (NegateDoubleFunction)o;,     return this.source.equals(other.source);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/SingleDoubleFunction.java,equals,70-72,[    if (getClass() != o.getClass()) return false;,     SingleDoubleFunction other = (SingleDoubleFunction)o;,     return this.source.equals(other.source);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/analytics/util/valuesource/SingleStringFunction.java,equals,108-110,[    if (getClass() != o.getClass()) return false;,     SingleStringFunction other = (SingleStringFunction)o;,     return this.source.equals(other.source);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/client/solrj/SolrQuery.java,getSortFields,621-621,[    if (s==null) return null;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/SolrQuery.java,,57-1086,[    super();,   }, ,   /** Create a new SolrQuery,    * ,    * @param q query string,    */,   public SolrQuery(String q) {,     this();,     this.set(CommonParams.Q, q);,   }, ,   /** enable/disable terms.  ,    * ,    * @param b flag to indicate terms should be enabled. <br /> if b==false, removes all other terms parameters,    * @return Current reference (<i>this</i>),    */,   public SolrQuery setTerms(boolean b) {,     if (b) {,       this.set(TermsParams.TERMS, true);,     } else {,       this.remove(TermsParams.TERMS);,       this.remove(TermsParams.TERMS_FIELD);,       this.remove(TermsParams.TERMS_LOWER);,       this.remove(TermsParams.TERMS_UPPER);,       this.remove(TermsParams.TERMS_UPPER_INCLUSIVE);,       this.remove(TermsParams.TERMS_LOWER_INCLUSIVE);,       this.remove(TermsParams.TERMS_LIMIT);,       this.remove(TermsParams.TERMS_PREFIX_STR);,       this.remove(TermsParams.TERMS_MINCOUNT);,       this.remove(TermsParams.TERMS_MAXCOUNT);,       this.remove(TermsParams.TERMS_RAW);,       this.remove(TermsParams.TERMS_SORT);,       this.remove(TermsParams.TERMS_REGEXP_STR);,       this.remove(TermsParams.TERMS_REGEXP_FLAG);,     },     return this;,   },   ,   public boolean getTerms() {,     return this.getBool(TermsParams.TERMS, false);,   },   ,   public SolrQuery addTermsField(String field) {,     this.add(TermsParams.TERMS_FIELD, field);,     return this;,   },   ,   public String[] getTermsFields() {,     return this.getParams(TermsParams.TERMS_FIELD);,   },   ,   public SolrQuery setTermsLower(String lower) {,     this.set(TermsParams.TERMS_LOWER, lower);,     return this;,   },   ,   public String getTermsLower() {,     return this.get(TermsParams.TERMS_LOWER, "");,   },   ,   public SolrQuery setTermsUpper(String upper) {,     this.set(TermsParams.TERMS_UPPER, upper);,     return this;,   },   ,   public String getTermsUpper() {,     return this.get(TermsParams.TERMS_UPPER, "");,   },   ,   public SolrQuery setTermsUpperInclusive(boolean b) {,     this.set(TermsParams.TERMS_UPPER_INCLUSIVE, b);,     return this;,   },   ,   public boolean getTermsUpperInclusive() {,     return this.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);,   },   ,   public SolrQuery setTermsLowerInclusive(boolean b) {,     this.set(TermsParams.TERMS_LOWER_INCLUSIVE, b);,     return this;,   },   ,   public boolean getTermsLowerInclusive() {,     return this.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);,   },  ,   public SolrQuery setTermsLimit(int limit) {,     this.set(TermsParams.TERMS_LIMIT, limit);,     return this;,   },   ,   public int getTermsLimit() {,     return this.getInt(TermsParams.TERMS_LIMIT, 10);,   },  ,   public SolrQuery setTermsMinCount(int cnt) {,     this.set(TermsParams.TERMS_MINCOUNT, cnt);,     return this;,   },   ,   public int getTermsMinCount() {,     return this.getInt(TermsParams.TERMS_MINCOUNT, 1);,   }, ,   public SolrQuery setTermsMaxCount(int cnt) {,     this.set(TermsParams.TERMS_MAXCOUNT, cnt);,     return this;,   },   ,   public int getTermsMaxCount() {,     return this.getInt(TermsParams.TERMS_MAXCOUNT, -1);,   },   ,   public SolrQuery setTermsPrefix(String prefix) {,     this.set(TermsParams.TERMS_PREFIX_STR, prefix);,     return this;,   },   ,   public String getTermsPrefix() {,     return this.get(TermsParams.TERMS_PREFIX_STR, "");,   },   ,   public SolrQuery setTermsRaw(boolean b) {,     this.set(TermsParams.TERMS_RAW, b);,     return this;,   },   ,   public boolean getTermsRaw() {,     return this.getBool(TermsParams.TERMS_RAW, false);,   },  ,   public SolrQuery setTermsSortString(String type) {,     this.set(TermsParams.TERMS_SORT, type);,     return this;,   },   ,   public String getTermsSortString() {,     return this.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT);,   }, ,   public SolrQuery setTermsRegex(String regex)  {,     this.set(TermsParams.TERMS_REGEXP_STR, regex);,     return this;,   }, ,   public String getTermsRegex() {,     return this.get(TermsParams.TERMS_REGEXP_STR);,   }, ,   public SolrQuery setTermsRegexFlag(String flag) {,     this.add(TermsParams.TERMS_REGEXP_FLAG, flag);,     return this;,   }, ,   public String[] getTermsRegexFlags()  {,     return this.getParams(TermsParams.TERMS_REGEXP_FLAG);,   },      ,   /** Add field(s) for facet computation.,    * ,    * @param fields Array of field names from the IndexSchema,    * @return this,    */,   public SolrQuery addFacetField(String ... fields) {,     add(FacetParams.FACET_FIELD, fields);,     this.set(FacetParams.FACET, true);,     return this;,   }, ,   /** Add field(s) for pivot computation.,    * ,    * pivot fields are comma separated,    * ,    * @param fields Array of field names from the IndexSchema,    * @return this,    */,   public SolrQuery addFacetPivotField(String ... fields) {,     add(FacetParams.FACET_PIVOT, fields);,     this.set(FacetParams.FACET, true);,     return this;,   }, ,   /**,    * Add a numeric range facet.,    *,    * @param field The field,    * @param start The start of range,    * @param end The end of the range,    * @param gap The gap between each count,    * @return this,    */,   public SolrQuery addNumericRangeFacet(String field, Number start, Number end, Number gap) {,     add(FacetParams.FACET_RANGE, field);,     add(String.format(Locale.ROOT, "f.%s.%s", field, FacetParams.FACET_RANGE_START), start.toString());,     add(String.format(Locale.ROOT, "f.%s.%s", field, FacetParams.FACET_RANGE_END), end.toString());,     add(String.format(Locale.ROOT, "f.%s.%s", field, FacetParams.FACET_RANGE_GAP), gap.toString());,     this.set(FacetParams.FACET, true);,     return this;,   }, ,   /**,    * Add a numeric range facet.,    *,    * @param field The field,    * @param start The start of range,    * @param end The end of the range,    * @param gap The gap between each count,    * @return this,    */,   public SolrQuery addDateRangeFacet(String field, Date start, Date end, String gap) {,     add(FacetParams.FACET_RANGE, field);,     add(String.format(Locale.ROOT, "f.%s.%s", field, FacetParams.FACET_RANGE_START), DateUtil.getThreadLocalDateFormat().format(start));,     add(String.format(Locale.ROOT, "f.%s.%s", field, FacetParams.FACET_RANGE_END), DateUtil.getThreadLocalDateFormat().format(end));,     add(String.format(Locale.ROOT, "f.%s.%s", field, FacetParams.FACET_RANGE_GAP), gap);,     this.set(FacetParams.FACET, true);,     return this;,   },   ,   /**,    * Add Interval Faceting on a field. All intervals for the same field should be included,    * in the same call to this method.,    * For syntax documentation see <a href="https://wiki.apache.org/solr/SimpleFacetParameters#Interval_Faceting">Solr wiki</a>,    * ,    * @param field the field to add facet intervals,    * @param intervals Intervals to be used for faceting. It can be an empty array, but it can't ,    * be <code>null</code>,    * @return this,    */,   public SolrQuery addIntervalFacets(String field, String[] intervals) {,     if (intervals == null) {,       throw new IllegalArgumentException("Can't add null intervals");,     },     set(FacetParams.FACET, true);,     add(FacetParams.FACET_INTERVAL, field);,     for (String interval:intervals) {,       add(String.format(Locale.ROOT, "f.%s.facet.interval.set", field), interval);,     },     return this;,   },   ,   /**,    * Remove all Interval Facets on a field,    * ,    * @param field the field to remove from facet intervals,    * @return Array of current intervals for <code>field</code>,    */,   public String[] removeIntervalFacets(String field) {,     while(remove(FacetParams.FACET_INTERVAL, field)){};,     return remove(String.format(Locale.ROOT, "f.%s.facet.interval.set", field));,   },   ,   /** get the facet fields,    * ,    * @return string array of facet fields or null if not set/empty,    */,   public String[] getFacetFields() {,     return this.getParams(FacetParams.FACET_FIELD);,   }, ,   /** remove a facet field,    * ,    * @param name Name of the facet field to be removed.,    * ,    * @return true, if the item was removed. <br />,    *           false, if the facet field was null or did not exist.,    */,   public boolean removeFacetField(String name) {,     boolean b = this.remove(FacetParams.FACET_FIELD, name);,     if (this.get(FacetParams.FACET_FIELD) == null && this.get(FacetParams.FACET_QUERY) == null) {,       this.setFacet(false);,     },     return b;,   },   ,   /** enable/disable faceting.  ,    * ,    * @param b flag to indicate faceting should be enabled. <br /> if b==false, removes all other faceting parameters,    * @return Current reference (<i>this</i>),    */,   public SolrQuery setFacet(boolean b) {,     if (b) {,       this.set(FacetParams.FACET, true);,     } else {,       this.remove(FacetParams.FACET);,       this.remove(FacetParams.FACET_MINCOUNT);,       this.remove(FacetParams.FACET_FIELD);,       this.remove(FacetParams.FACET_LIMIT);,       this.remove(FacetParams.FACET_MISSING);,       this.remove(FacetParams.FACET_OFFSET);,       this.remove(FacetParams.FACET_PREFIX);,       this.remove(FacetParams.FACET_QUERY);,       this.remove(FacetParams.FACET_SORT);,       this.remove(FacetParams.FACET_ZEROS);,       this.remove(FacetParams.FACET_PREFIX); // does not include the individual fields...,       this.remove(FacetParams.FACET_INTERVAL); // does not remove interval parameters,     },     return this;,   },   ,   public SolrQuery setFacetPrefix( String prefix ),   {,     this.set( FacetParams.FACET_PREFIX, prefix );,     return this;,   }, ,   public SolrQuery setFacetPrefix( String field, String prefix ),   {,     this.set( "f."+field+"."+FacetParams.FACET_PREFIX, prefix );,     return this;,   }, ,   /** add a faceting query,    * ,    * @param f facet query,    */,   public SolrQuery addFacetQuery(String f) {,     this.add(FacetParams.FACET_QUERY, f);,     this.set(FacetParams.FACET, true);,     return this;,   }, ,   /** get facet queries,    * ,    * @return all facet queries or null if not set/empty,    */,   public String[] getFacetQuery() {,     return this.getParams(FacetParams.FACET_QUERY);,   }, ,   /** remove a facet query,    * ,    * @param q the facet query to remove,    * @return true if the facet query was removed false otherwise,    */,   public boolean removeFacetQuery(String q) {,     boolean b = this.remove(FacetParams.FACET_QUERY, q);,     if (this.get(FacetParams.FACET_FIELD) == null && this.get(FacetParams.FACET_QUERY) == null) {,       this.setFacet(false);,     },     return b;,   }, ,   /** set the facet limit,    * ,    * @param lim number facet items to return,    */,   public SolrQuery setFacetLimit(int lim) {,     this.set(FacetParams.FACET_LIMIT, lim);,     return this;,   }, ,   /** get current facet limit,    * ,    * @return facet limit or default of 25,    */,   public int getFacetLimit() {,     return this.getInt(FacetParams.FACET_LIMIT, 25);,   }, ,   /** set facet minimum count,    * ,    * @param cnt facets having less that cnt hits will be excluded from teh facet list,    */,   public SolrQuery setFacetMinCount(int cnt) {,     this.set(FacetParams.FACET_MINCOUNT, cnt);,     return this;,   }, ,   /** get facet minimum count,    * ,    * @return facet minimum count or default of 1,    */,   public int getFacetMinCount() {,     return this.getInt(FacetParams.FACET_MINCOUNT, 1);,   }, ,   /**,    * Sets facet missing boolean flag ,    * ,    * @param v flag to indicate the field of  {@link FacetParams#FACET_MISSING} .,    * @return this,    */,   public SolrQuery setFacetMissing(Boolean v) {,     this.set(FacetParams.FACET_MISSING, v);,     return this;,   }, ,   /**,    * @deprecated use {@link #setFacetMissing(Boolean)},    */,   @Deprecated,   public SolrQuery setMissing(String fld) {,     return setFacetMissing(Boolean.valueOf(fld));,   }, ,   /** get facet sort,    * ,    * @return facet sort or default of {@link FacetParams#FACET_SORT_COUNT},    */,   public String getFacetSortString() {,     return this.get(FacetParams.FACET_SORT, FacetParams.FACET_SORT_COUNT);,   }, ,   /** get facet sort,    * ,    * @return facet sort or default of true. <br />,    * true corresponds to,    * {@link FacetParams#FACET_SORT_COUNT} and <br />false to {@link FacetParams#FACET_SORT_INDEX},    * ,    * @deprecated Use {@link #getFacetSortString()} instead.,    */,   @Deprecated,   public boolean getFacetSort() {,     return this.get(FacetParams.FACET_SORT, FacetParams.FACET_SORT_COUNT).equals(FacetParams.FACET_SORT_COUNT);,   }, ,   /** set facet sort,    * ,    * @param sort sort facets,    * @return this,    */,   public SolrQuery setFacetSort(String sort) {,     this.set(FacetParams.FACET_SORT, sort);,     return this;,   }, ,   /** set facet sort,    * ,    * @param sort sort facets,    * @return this,    * @deprecated Use {@link #setFacetSort(String)} instead, true corresponds to,    * {@link FacetParams#FACET_SORT_COUNT} and false to {@link FacetParams#FACET_SORT_INDEX}.,    */,   @Deprecated,   public SolrQuery setFacetSort(boolean sort) { ,     this.set(FacetParams.FACET_SORT, sort == true ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);,     return this;,   }, ,   /** add highlight field,    * ,    * @param f field to enable for highlighting,    */,   public SolrQuery addHighlightField(String f) {,     this.add(HighlightParams.FIELDS, f);,     this.set(HighlightParams.HIGHLIGHT, true);,     return this;,   }, ,   /** remove a field for highlighting,    * ,    * @param f field name to not highlight,    * @return <i>true</i>, if removed, <br /> <i>false</i>, otherwise,    */,   public boolean removeHighlightField(String f) {,     boolean b = this.remove(HighlightParams.FIELDS, f);,     if (this.get(HighlightParams.FIELDS) == null) {,       this.setHighlight(false);,     },     return b;,   }, ,   /** get list of highlighted fields,    * ,    * @return Array of highlight fields or null if not set/empty,    */,   public String[] getHighlightFields() {,     return this.getParams(HighlightParams.FIELDS);,   }, ,   public SolrQuery setHighlightSnippets(int num) {,     this.set(HighlightParams.SNIPPETS, num);,     return this;,   }, ,   public int getHighlightSnippets() {,     return this.getInt(HighlightParams.SNIPPETS, 1);,   }, ,   public SolrQuery setHighlightFragsize(int num) {,     this.set(HighlightParams.FRAGSIZE, num);,     return this;,   }, ,   public int getHighlightFragsize() {,     return this.getInt(HighlightParams.FRAGSIZE, 100);,   }, ,   public SolrQuery setHighlightRequireFieldMatch(boolean flag) {,     this.set(HighlightParams.FIELD_MATCH, flag);,     return this;,   }, ,   public boolean getHighlightRequireFieldMatch() {,     return this.getBool(HighlightParams.FIELD_MATCH, false);,   }, ,   public SolrQuery setHighlightSimplePre(String f) {,     this.set(HighlightParams.SIMPLE_PRE, f);,     return this;,   }, ,   public String getHighlightSimplePre() {,     return this.get(HighlightParams.SIMPLE_PRE, "");,   }, ,   public SolrQuery setHighlightSimplePost(String f) {,     this.set(HighlightParams.SIMPLE_POST, f);,     return this;,   }, ,   public String getHighlightSimplePost() {,     return this.get(HighlightParams.SIMPLE_POST, "");,   }, ,   /**,    * Replaces the sort string with a single sort field.,    * @deprecated Use {@link #setSort(SortClause)} instead, which is part,    * of an api handling a wider range of sort specifications.,    */,   @Deprecated,   public SolrQuery setSortField(String field, ORDER order) {,     this.remove(CommonParams.SORT);,     addValueToParam(CommonParams.SORT, toSortString(field, order));,     return this;,   },   ,   /**,    * Adds a sort field to the end of the sort string.,    * @deprecated Use {@link #addSort(SortClause)} instead, which is part,    * of an api handling a wider range of sort specifications.,    */,   @Deprecated,   public SolrQuery addSortField(String field, ORDER order) {,     return addValueToParam(CommonParams.SORT, toSortString(field, order));,   }, ,   /**,    * Removes a sort field to the end of the sort string.,    * @deprecated Use {@link #removeSort(SortClause)} instead, which is part,    * of an api handling a wider range of sort specifications.,    */,   @Deprecated,   public SolrQuery removeSortField(String field, ORDER order) {,     String[] sorts = getSortFields();,     if (sorts != null) {,       String removeSort = toSortString(field, order);,       String s = join(sorts, ",", removeSort);,       if (s.length()==0) s=null;,       this.set(CommonParams.SORT, s);,     },     return this;,   },   ,   /**,    * Gets an array of sort specifications.,    * @deprecated Use {@link #getSorts()} instead, which is part,    * of an api handling a wider range of sort specifications.,    */,   @Deprecated,   public String[] getSortFields() {,     String s = getSortField();,     if (s==null) return null;,     return s.trim().split(", *");,   }, ,   /**,    * Gets the raw sort field, as it will be sent to Solr.,    * <p>,    * The returned sort field will always contain a serialized version,    * of the sort string built using {@link #setSort(SortClause)},,    * {@link #addSort(SortClause)}, {@link #addOrUpdateSort(SortClause)},,    * {@link #removeSort(SortClause)}, {@link #clearSorts()} and ,    * {@link #setSorts(List)}.,    */,   public String getSortField() {,     return this.get(CommonParams.SORT);,   },   ,   /**,    * Clears current sort information.,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery clearSorts() {,     sortClauses = null;,     serializeSorts();,     return this;,   }, ,   /**,    * Replaces the current sort information.,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery setSorts(List<SortClause> value) {,     sortClauses = new ArrayList<>(value);,     serializeSorts();,     return this;,   }, ,   /**,    * Gets an a list of current sort clauses.,    *,    * @return an immutable list of current sort clauses,    * @since 4.2,    */,   public List<SortClause> getSorts() {,     if (sortClauses == null) return Collections.emptyList();,     else return Collections.unmodifiableList(sortClauses);,   }, ,   /**,    * Replaces the current sort information with a single sort clause,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery setSort(String field, ORDER order) {,     return setSort(new SortClause(field, order));,   }, ,   /**,    * Replaces the current sort information with a single sort clause,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery setSort(SortClause sortClause) {,     clearSorts();,     return addSort(sortClause);,   }, ,   /**,    * Adds a single sort clause to the end of the current sort information.,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery addSort(String field, ORDER order) {,     return addSort(new SortClause(field, order));,   }, ,   /**,    * Adds a single sort clause to the end of the query.,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery addSort(SortClause sortClause) {,     if (sortClauses == null) sortClauses = new ArrayList<>();,     sortClauses.add(sortClause);,     serializeSorts();,     return this;,   }, ,   /**,    * Updates or adds a single sort clause to the query.,    * If the field is already used for sorting, the order,    * of the existing field is modified; otherwise, it is,    * added to the end.,    * <p>,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery addOrUpdateSort(String field, ORDER order) {,     return addOrUpdateSort(new SortClause(field, order));,   }, ,   /**,    * Updates or adds a single sort field specification to the current sort,    * information. If the sort field already exist in the sort information map,,    * its position is unchanged and the sort order is set; if it does not exist,,    * it is appended at the end with the specified order..,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery addOrUpdateSort(SortClause sortClause) {,     if (sortClauses != null) {,       for (int index=0 ; index<sortClauses.size() ; index++) {,         SortClause existing = sortClauses.get(index);,         if (existing.getItem().equals(sortClause.getItem())) {,           sortClauses.set(index, sortClause);,           serializeSorts();,           return this;,         },       },     },     return addSort(sortClause);,   }, ,   /**,    * Removes a single sort field from the current sort information.,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery removeSort(SortClause sortClause) {,     return removeSort(sortClause.getItem());,   }, ,   /**,    * Removes a single sort field from the current sort information.,    *,    * @return the modified SolrQuery object, for easy chaining,    * @since 4.2,    */,   public SolrQuery removeSort(String itemName) {,     if (sortClauses != null) {,       for (SortClause existing : sortClauses) {,         if (existing.getItem().equals(itemName)) {,           sortClauses.remove(existing);,           if (sortClauses.isEmpty()) sortClauses = null;,           serializeSorts();,           break;,         },       },     },     return this;,   }, ,   private void serializeSorts() {,     if (sortClauses == null || sortClauses.isEmpty()) {,       remove(CommonParams.SORT);,     } else {,       StringBuilder sb = new StringBuilder();,       for (SortClause sortClause : sortClauses) {,         if (sb.length() > 0) sb.append(",");,         sb.append(sortClause.getItem());,         sb.append(" ");,         sb.append(sortClause.getOrder());,       },       set(CommonParams.SORT, sb.toString());,     },   }, ,   public void setGetFieldStatistics( boolean v ),   {,     this.set( StatsParams.STATS, v );,   },   ,   public void setGetFieldStatistics( String field ),   {,     this.set( StatsParams.STATS, true );,     this.add( StatsParams.STATS_FIELD, field );,   },   , ,   public void addGetFieldStatistics( String ... field ),     {,       this.set( StatsParams.STATS, true );,       this.add( StatsParams.STATS_FIELD, field );,     },   ,   public void addStatsFieldFacets( String field, String ... facets ),   {,     if( field == null ) {,       this.add( StatsParams.STATS_FACET, facets );,     },     else {,       for( String f : facets ) {,         this.add( "f."+field+"."+StatsParams.STATS_FACET, f );,       },     },   }, ,   public void addStatsFieldCalcDistinct(String field, boolean calcDistinct) {,     if (field == null) {,       this.add(StatsParams.STATS_CALC_DISTINCT, Boolean.toString(calcDistinct));,     } else {,       this.add("f." + field + "." + StatsParams.STATS_CALC_DISTINCT, Boolean.toString(calcDistinct));,     },   }, ,   public SolrQuery setFilterQueries(String ... fq) {,     this.set(CommonParams.FQ, fq);,     return this;,   }, ,   public SolrQuery addFilterQuery(String ... fq) {,     this.add(CommonParams.FQ, fq);,     return this;,   }, ,   public boolean removeFilterQuery(String fq) {,     return this.remove(CommonParams.FQ, fq);,   }, ,   public String[] getFilterQueries() {,     return this.getParams(CommonParams.FQ);,   },   ,   public boolean getHighlight() {,     return this.getBool(HighlightParams.HIGHLIGHT, false);,   },   ,   public SolrQuery setHighlight(boolean b) {,     if (b) {,       this.set(HighlightParams.HIGHLIGHT, true);,     } else {,       this.remove(HighlightParams.HIGHLIGHT);,       this.remove(HighlightParams.FIELD_MATCH);,       this.remove(HighlightParams.FIELDS);,       this.remove(HighlightParams.FORMATTER);,       this.remove(HighlightParams.FRAGSIZE);,       this.remove(HighlightParams.SIMPLE_POST);,       this.remove(HighlightParams.SIMPLE_PRE);,       this.remove(HighlightParams.SNIPPETS);,     },     return this;,   }, ,   public SolrQuery setFields(String ... fields) {,     if( fields == null || fields.length == 0 ) {,       this.remove( CommonParams.FL );,       return this;,     },     StringBuilder sb = new StringBuilder();,     sb.append( fields[0] );,     for( int i=1; i<fields.length; i++ ) {,       sb.append( ',' );,       sb.append( fields[i] );,     },     this.set(CommonParams.FL, sb.toString() );,     return this;,   },     ,   public SolrQuery addField(String field) {,     return addValueToParam(CommonParams.FL, field);,   }, ,   public String getFields() {,     String fields = this.get(CommonParams.FL);,     if (fields!=null && fields.equals("score")) {,       fields = "*, score";,     },     return fields;,   }, ,   private static Pattern scorePattern = Pattern.compile("(^|[, ])score");, ,   public SolrQuery setIncludeScore(boolean includeScore) {,     String fields = get(CommonParams.FL,"*");,     if (includeScore) {,       if (!scorePattern.matcher(fields).find()) {   ,         this.set(CommonParams.FL, fields+",score");,       },     } else {,       this.set(CommonParams.FL, scorePattern.matcher(fields).replaceAll(""));,     },     return this;,   }, ,   public SolrQuery setQuery(String query) {,     this.set(CommonParams.Q, query);,     return this;,   }, ,   public String getQuery() {,     return this.get(CommonParams.Q);,   }, ,   public SolrQuery setRows(Integer rows) {,     if( rows == null ) {,       this.remove( CommonParams.ROWS );,     },     else {,       this.set(CommonParams.ROWS, rows);,     },     return this;,   }, ,   public Integer getRows(),   {,     return this.getInt(CommonParams.ROWS);,   }, ,   public void setShowDebugInfo(boolean showDebugInfo) {,     this.set(CommonParams.DEBUG_QUERY, String.valueOf(showDebugInfo));,   }, ,   public void setDistrib(boolean val) {,     this.set(CommonParams.DISTRIB, String.valueOf(val));,   }, , ,   public SolrQuery setStart(Integer start) {,     if( start == null ) {,       this.remove( CommonParams.START );,     },     else {,       this.set(CommonParams.START, start);,     },     return this;,   },   ,   public Integer getStart(),   {,     return this.getInt(CommonParams.START);,   }, ,   /**,    * The Request Handler to use (see the solrconfig.xml), which is stored in the "qt" parameter.,    * Normally it starts with a '/' and if so it will be used by,    * {@link org.apache.solr.client.solrj.request.QueryRequest#getPath()} in the URL instead of the "qt" parameter.,    * If this is left blank, then the default of "/select" is assumed.,    *,    * @param qt The Request Handler name corresponding to one in solrconfig.xml on the server.,    * @return this,    */,   public SolrQuery setRequestHandler(String qt) {,     this.set(CommonParams.QT, qt);,     return this;,   }, ,   public String getRequestHandler() {,     return this.get(CommonParams.QT);,   }, ,   /**,    * @deprecated See {@link #setRequestHandler(String)}.,    */,   @Deprecated,   public SolrQuery setQueryType(String qt) {,     return setRequestHandler(qt);,   }, ,   /**,    * @deprecated See {@link #getRequestHandler()}.,    */,   @Deprecated,   public String getQueryType() {,     return getRequestHandler();,   }, ,   /**,    * @return this,    * @see ModifiableSolrParams#set(String,String[]),    */,   public SolrQuery setParam(String name, String ... values) {,     this.set(name, values);,     return this;,   }, ,   /**,    * @return this,    * @see org.apache.solr.common.params.ModifiableSolrParams#set(String, boolean),    */,   public SolrQuery setParam(String name, boolean value) {,     this.set(name, value);,     return this;,   }, ,   /** get a deep copy of this object **/,   public SolrQuery getCopy() {,     SolrQuery q = new SolrQuery();,     for (String name : this.getParameterNames()) {,       q.setParam(name, this.getParams(name));,     },     return q;,   },   ,   /**,   * Set the maximum time allowed for this query. If the query takes more time,   * than the specified milliseconds, a timeout occurs and partial (or no),   * results may be returned.,   * ,   * If given Integer is null, then this parameter is removed from the request,   * ,   *@param milliseconds the time in milliseconds allowed for this query,   */,   public SolrQuery setTimeAllowed(Integer milliseconds) {,     if (milliseconds == null) {,       this.remove(CommonParams.TIME_ALLOWED);,     } else {,       this.set(CommonParams.TIME_ALLOWED, milliseconds);,     },     return this;,   },   ,   /**,   * Get the maximum time allowed for this query.,   */,   public Integer getTimeAllowed() {,     return this.getInt(CommonParams.TIME_ALLOWED);,   }, ,   ///////////////////////,   //  Utility functions,   ///////////////////////,   ,   private String toSortString(String field, ORDER order) {,     return field.trim() + ' ' + String.valueOf(order).trim();,   },   ,   private String join(String a, String b, String sep) {,     StringBuilder sb = new StringBuilder();,     if (a!=null && a.length()>0) {,       sb.append(a);,       sb.append(sep);,     } ,     if (b!=null && b.length()>0) {,       sb.append(b);,     },     return sb.toString().trim();,   },   ,   private SolrQuery addValueToParam(String name, String value) {,     String tmp = this.get(name);,     tmp = join(tmp, value, ",");,     this.set(name, tmp);,     return this;,   },    ,   private String join(String[] vals, String sep, String removeVal) {,     StringBuilder sb = new StringBuilder();,     for (int i=0; i<vals.length; i++) {,       if (!vals[i].equals(removeVal)) {,         if (sb.length() > 0) {,           sb.append(sep);,         },         sb.append(vals[i]);,       },     },     return sb.toString().trim();],,
MT_CORRECTNESS,JLM_JSR166_UTILCONCURRENT_MONITORENTER,org/apache/solr/client/solrj/beans/DocumentObjectBinder.java,getDocFields,98-98,[      synchronized(infocache) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/client/solrj/beans/DocumentObjectBinder.java,getBean,67-67,[    } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/client/solrj/beans/DocumentObjectBinder.java,<init>,146-146,[        setter = (Method) member;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/client/solrj/beans/DocumentObjectBinder.java,<init>,165-165,[              } catch(Exception ex2) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/client/solrj/beans/DocumentObjectBinder.java,<init>,159-159,[          } catch (Exception ex) {],,<init>,165-165,[              } catch(Exception ex2) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/client/solrj/beans/DocumentObjectBinder.java,set,369-369,[      catch (Exception e) {],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java,request,110-110,[    SolrCore core =  coreContainer.getCore( coreName );],,request,132-132,[      if( handler == null &&],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/servlet/SolrRequestParsers.java,,65-418,[public class SolrRequestParsers , {,   final Logger log = LoggerFactory.getLogger(SolrRequestParsers.class);,   ,   // Should these constants be in a more public place?,   public static final String MULTIPART = "multipart";,   public static final String FORMDATA = "formdata";,   public static final String RAW = "raw";,   public static final String SIMPLE = "simple";,   public static final String STANDARD = "standard";,   ,   private static final Charset CHARSET_US_ASCII = Charset.forName("US-ASCII");,   ,   public static final String INPUT_ENCODING_KEY = "ie";,   private static final byte[] INPUT_ENCODING_BYTES = INPUT_ENCODING_KEY.getBytes(CHARSET_US_ASCII);, ,   private final HashMap<String, SolrRequestParser> parsers =,       new HashMap<>();,   private final boolean enableRemoteStreams;,   private StandardRequestParser standard;,   private boolean handleSelect = true;,   private boolean addHttpRequestToContext;, ,   /** Default instance for e.g. admin requests. Limits to 2 MB uploads and does not allow remote streams. */,   public static final SolrRequestParsers DEFAULT = new SolrRequestParsers();,   ,   /**,    * Pass in an xml configuration.  A null configuration will enable,    * everything with maximum values.,    */,   public SolrRequestParsers( SolrConfig globalConfig ) {,     final int multipartUploadLimitKB, formUploadLimitKB;,     if( globalConfig == null ) {,       multipartUploadLimitKB = formUploadLimitKB = Integer.MAX_VALUE; ,       enableRemoteStreams = true;,       handleSelect = true;,       addHttpRequestToContext = false;,     } else {,       multipartUploadLimitKB = globalConfig.getMultipartUploadLimitKB();,       ,       formUploadLimitKB = globalConfig.getFormUploadLimitKB();,       ,       enableRemoteStreams = globalConfig.isEnableRemoteStreams();,   ,       // Let this filter take care of /select?xxx format,       handleSelect = globalConfig.isHandleSelect();,       ,       addHttpRequestToContext = globalConfig.isAddHttpRequestToContext();,     },     init(multipartUploadLimitKB, formUploadLimitKB);,   },   ,   private SolrRequestParsers() {,     enableRemoteStreams = false;,     handleSelect = false;,     addHttpRequestToContext = false;,     init(2048, 2048);,   }, ,   private void init( int multipartUploadLimitKB, int formUploadLimitKB) {       ,     MultipartRequestParser multi = new MultipartRequestParser( multipartUploadLimitKB );,     RawRequestParser raw = new RawRequestParser();,     FormDataRequestParser formdata = new FormDataRequestParser( formUploadLimitKB );,     standard = new StandardRequestParser( multi, raw, formdata );,     ,     // I don't see a need to have this publicly configured just yet,     // adding it is trivial,     parsers.put( MULTIPART, multi );,     parsers.put( FORMDATA, formdata );,     parsers.put( RAW, raw );,     parsers.put( SIMPLE, new SimpleRequestParser() );,     parsers.put( STANDARD, standard );,     parsers.put( "", standard );,   }, ,   public SolrQueryRequest parse( SolrCore core, String path, HttpServletRequest req ) throws Exception,   {,     SolrRequestParser parser = standard;,     ,     // TODO -- in the future, we could pick a different parser based on the request,     ,     // Pick the parser from the request...,     ArrayList<ContentStream> streams = new ArrayList<>(1);,     SolrParams params = parser.parseParamsAndFillStreams( req, streams );,     SolrQueryRequest sreq = buildRequestFrom( core, params, streams );, ,     // Handlers and login will want to know the path. If it contains a ':',     // the handler could use it for RESTful URLs,     sreq.getContext().put( "path", RequestHandlers.normalize(path) );,     sreq.getContext().put("httpMethod", req.getMethod());, ,     if(addHttpRequestToContext) {,       sreq.getContext().put("httpRequest", req);,     },     return sreq;,   },   ,   public SolrQueryRequest buildRequestFrom( SolrCore core, SolrParams params, Collection<ContentStream> streams ) throws Exception,   {,     // The content type will be applied to all streaming content,     String contentType = params.get( CommonParams.STREAM_CONTENTTYPE );,       ,     // Handle anything with a remoteURL,     String[] strs = params.getParams( CommonParams.STREAM_URL );,     if( strs != null ) {,       if( !enableRemoteStreams ) {,         throw new SolrException( ErrorCode.BAD_REQUEST, "Remote Streaming is disabled." );,       },       for( final String url : strs ) {,         ContentStreamBase stream = new ContentStreamBase.URLStream( new URL(url) );,         if( contentType != null ) {,           stream.setContentType( contentType );,         },         streams.add( stream );,       },     },     ,     // Handle streaming files,     strs = params.getParams( CommonParams.STREAM_FILE );,     if( strs != null ) {,       if( !enableRemoteStreams ) {,         throw new SolrException( ErrorCode.BAD_REQUEST, "Remote Streaming is disabled." );,       },       for( final String file : strs ) {,         ContentStreamBase stream = new ContentStreamBase.FileStream( new File(file) );,         if( contentType != null ) {,           stream.setContentType( contentType );,         },         streams.add( stream );,       },     },     ,     // Check for streams in the request parameters,     strs = params.getParams( CommonParams.STREAM_BODY );,     if( strs != null ) {,       for( final String body : strs ) {,         ContentStreamBase stream = new ContentStreamBase.StringStream( body );,         if( contentType != null ) {,           stream.setContentType( contentType );,         },         streams.add( stream );,       },     },     ,     SolrQueryRequestBase q = new SolrQueryRequestBase( core, params ) { };,     if( streams != null && streams.size() > 0 ) {,       q.setContentStreams( streams );,     },     return q;,   },   ,   /**,    * Given a url-encoded query string (UTF-8), map it into solr params,    */,   public static MultiMapSolrParams parseQueryString(String queryString) {,     Map<String,String[]> map = new HashMap<>();,     parseQueryString(queryString, map);,     return new MultiMapSolrParams(map);,   }, ,   /**,    * Given a url-encoded query string (UTF-8), map it into the given map,    * @param queryString as given from URL,    * @param map place all parameters in this map,    */,   static void parseQueryString(final String queryString, final Map<String,String[]> map) {,     if (queryString != null && queryString.length() > 0) {,       try {,         final int len = queryString.length();,         // this input stream emulates to get the raw bytes from the URL as passed to servlet container, it disallows any byte > 127 and enforces to %-escape them:,         final InputStream in = new InputStream() {,           int pos = 0;,           @Override,           public int read() {,             if (pos < len) {,               final char ch = queryString.charAt(pos);,               if (ch > 127) {,                 throw new SolrException(ErrorCode.BAD_REQUEST, "URLDecoder: The query string contains a not-%-escaped byte > 127 at position " + pos);,               },               pos++;,               return ch;,             } else {,               return -1;,             },           },         };,         parseFormDataContent(in, Long.MAX_VALUE, StandardCharsets.UTF_8, map, true);,       } catch (IOException ioe) {,         throw new SolrException(ErrorCode.BAD_REQUEST, ioe);,       },     },   },   ,   /**,    * Given a url-encoded form from POST content (as InputStream), map it into the given map.,    * The given InputStream should be buffered!,    * @param postContent to be parsed,    * @param charset to be used to decode resulting bytes after %-decoding,    * @param map place all parameters in this map,    */,   @SuppressWarnings({"fallthrough", "resource"}),   static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {,     CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);,     final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<>() : null;,     long len = 0L, keyPos = 0L, valuePos = 0L;,     final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),,       valueStream = new ByteArrayOutputStream();,     ByteArrayOutputStream currentStream = keyStream;,     for(;;) {,       int b = postContent.read();,       switch (b) {,         case -1: // end of stream,         case '&': // separator,           if (keyStream.size() > 0) {,             final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();,             if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {,               // we found a charset declaration in the raw bytes,               if (charsetDecoder != null) {,                 throw new SolrException(ErrorCode.BAD_REQUEST,,                   supportCharsetParam ? (,                     "Query string invalid: duplicate '"+,                     INPUT_ENCODING_KEY + "' (input encoding) key.",                   ) : (,                     "Key '" + INPUT_ENCODING_KEY + "' (input encoding) cannot "+,                     "be used in POSTed application/x-www-form-urlencoded form data. "+,                     "To set the input encoding of POSTed form data, use the "+,                     "'Content-Type' header and provide a charset!",                   ),                 );,               },               // decode the charset from raw bytes,               charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));,               charsetDecoder = getCharsetDecoder(charset);,               // finally decode all buffered tokens,               decodeBuffer(buffer, map, charsetDecoder);,             } else if (charsetDecoder == null) {,               // we have no charset decoder until now, buffer the keys / values for later processing:,               buffer.add(keyBytes);,               buffer.add(Long.valueOf(keyPos));,               buffer.add(valueBytes);,               buffer.add(Long.valueOf(valuePos));,             } else {,               // we already have a charsetDecoder, so we can directly decode without buffering:,               final String key = decodeChars(keyBytes, keyPos, charsetDecoder),,                   value = decodeChars(valueBytes, valuePos, charsetDecoder);,               MultiMapSolrParams.addParam(key, value, map);,             },           } else if (valueStream.size() > 0) {,             throw new SolrException(ErrorCode.BAD_REQUEST, "application/x-www-form-urlencoded invalid: missing key");,           },           keyStream.reset();,           valueStream.reset();,           keyPos = valuePos = len + 1;,           currentStream = keyStream;,           break;,         case '+': // space replacement,           currentStream.write(' ');,           break;,         case '%': // escape,           final int upper = digit16(b = postContent.read());,           len++;,           final int lower = digit16(b = postContent.read());,           len++;,           currentStream.write(((upper << 4) + lower));,           break;,         case '=': // kv separator,           if (currentStream == keyStream) {,             valuePos = len + 1;,             currentStream = valueStream;,             break;,           },           // fall-through,         default:,           currentStream.write(b);,       },       if (b == -1) {,         break;,       },       len++;,       if (len > maxLen) {,         throw new SolrException(ErrorCode.BAD_REQUEST, "application/x-www-form-urlencoded content exceeds upload limit of " + (maxLen/1024L) + " KB");,       },     },     // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):,     if (buffer != null && !buffer.isEmpty()) {,       assert charsetDecoder == null;,       decodeBuffer(buffer, map, getCharsetDecoder(charset));,     },     return len;,   },   ,   private static CharsetDecoder getCharsetDecoder(Charset charset) {,     return charset.newDecoder(),       .onMalformedInput(CodingErrorAction.REPORT),       .onUnmappableCharacter(CodingErrorAction.REPORT);,   },   ,   private static String decodeChars(byte[] bytes, long position, CharsetDecoder charsetDecoder) {,     try {,       return charsetDecoder.decode(ByteBuffer.wrap(bytes)).toString();,     } catch (CharacterCodingException cce) {,       throw new SolrException(ErrorCode.BAD_REQUEST,,         "URLDecoder: Invalid character encoding detected after position " + position +,         " of query string / form data (while parsing as " + charsetDecoder.charset().name() + ")",       );,     },   },   ,   private static void decodeBuffer(final LinkedList<Object> input, final Map<String,String[]> map, CharsetDecoder charsetDecoder) {,     for (final Iterator<Object> it = input.iterator(); it.hasNext(); ) {,       final byte[] keyBytes = (byte[]) it.next();,       it.remove();,       final Long keyPos = (Long) it.next();,       it.remove();,       final byte[] valueBytes = (byte[]) it.next();,       it.remove();,       final Long valuePos = (Long) it.next();,       it.remove();,       MultiMapSolrParams.addParam(decodeChars(keyBytes, keyPos.longValue(), charsetDecoder),,           decodeChars(valueBytes, valuePos.longValue(), charsetDecoder), map);,     },   },   ,   private static int digit16(int b) {,     if (b == -1) {,       throw new SolrException(ErrorCode.BAD_REQUEST, "URLDecoder: Incomplete trailing escape (%) pattern");,     },     if (b >= '0' && b <= '9') {,       return b - '0';,     },     if (b >= 'A' && b <= 'F') {,       return b - ('A' - 10);,     },     if (b >= 'a' && b <= 'f') {,       return b - ('a' - 10);,     },     throw new SolrException(ErrorCode.BAD_REQUEST, "URLDecoder: Invalid digit (" + ((char) b) + ") in escape (%) pattern");,   },   ,   public boolean isHandleSelect() {,     return handleSelect;,   }, ,   public void setHandleSelect(boolean handleSelect) {,     this.handleSelect = handleSelect;,   },   ,   public boolean isAddRequestHeadersToContext() {,     return addHttpRequestToContext;,   }, ,   public void setAddRequestHeadersToContext(boolean addRequestHeadersToContext) {,     this.addHttpRequestToContext = addRequestHeadersToContext;,   }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/core/CoreContainer.java,,64-904,[  protected static final Logger log = LoggerFactory.getLogger(CoreContainer.class);, ,   final SolrCores solrCores = new SolrCores(this);, ,   public static class CoreLoadFailure {, ,     public final CoreDescriptor cd;,     public final Exception exception;, ,     public CoreLoadFailure(CoreDescriptor cd, Exception loadFailure) {,       this.cd = cd;,       this.exception = loadFailure;,     },   }, ,   protected final Map<String, CoreLoadFailure> coreInitFailures = new ConcurrentHashMap<>();, ,   protected CoreAdminHandler coreAdminHandler = null;,   protected CollectionsHandler collectionsHandler = null;,   private InfoHandler infoHandler;, ,   protected Properties containerProperties;, ,   private ConfigSetService coreConfigService;,   ,   protected ZkContainer zkSys = new ZkContainer();,   protected ShardHandlerFactory shardHandlerFactory;,   ,   private UpdateShardHandler updateShardHandler;, ,   protected LogWatcher logging = null;, ,   private CloserThread backgroundCloser = null;,   protected final ConfigSolr cfg;,   protected final SolrResourceLoader loader;, ,   protected final String solrHome;, ,   protected final CoresLocator coresLocator;,   ,   private String hostName;,   private final JarRepository jarRepository = new JarRepository(this);,   ,   private Map<String ,SolrRequestHandler> containerHandlers = new HashMap<>();, ,   public SolrRequestHandler getRequestHandler(String path) {,     return RequestHandlerBase.getRequestHandler(path, containerHandlers);,   }, ,   public Map<String, SolrRequestHandler> getRequestHandlers(){,     return this.containerHandlers;, ,   }, ,  // private ClientConnectionManager clientConnectionManager = new PoolingClientConnectionManager();, ,   {,     log.info("New CoreContainer " + System.identityHashCode(this));,   }, ,   /**,    * Create a new CoreContainer using system properties to detect the solr home,    * directory.  The container's cores are not loaded.,    * @see #load(),    */,   public CoreContainer() {,     this(new SolrResourceLoader(SolrResourceLoader.locateSolrHome()));,   }, ,   /**,    * Create a new CoreContainer using the given SolrResourceLoader.  The container's,    * cores are not loaded.,    * @param loader the SolrResourceLoader,    * @see #load(),    */,   public CoreContainer(SolrResourceLoader loader) {,     this(loader, ConfigSolr.fromSolrHome(loader, loader.getInstanceDir()));,   }, ,   /**,    * Create a new CoreContainer using the given solr home directory.  The container's,    * cores are not loaded.,    * @param solrHome a String containing the path to the solr home directory,    * @see #load(),    */,   public CoreContainer(String solrHome) {,     this(new SolrResourceLoader(solrHome));,   }, ,   /**,    * Create a new CoreContainer using the given SolrResourceLoader,,    * configuration and CoresLocator.  The container's cores are,    * not loaded.,    * @param loader the SolrResourceLoader,    * @param config a ConfigSolr representation of this container's configuration,    * @see #load(),    */,   public CoreContainer(SolrResourceLoader loader, ConfigSolr config) {,     this.loader = checkNotNull(loader);,     this.solrHome = loader.getInstanceDir();,     this.cfg = checkNotNull(config);,     this.coresLocator = config.getCoresLocator();,   }, ,   public CoreContainer(SolrResourceLoader loader, ConfigSolr config, CoresLocator locator) {,     this.loader = checkNotNull(loader);,     this.solrHome = loader.getInstanceDir();,     this.cfg = checkNotNull(config);,     this.coresLocator = locator;,   }, ,   /**,    * This method allows subclasses to construct a CoreContainer,    * without any default init behavior.,    * ,    * @param testConstructor pass (Object)null.,    * @lucene.experimental,    */,   protected CoreContainer(Object testConstructor) {,     solrHome = null;,     loader = null;,     coresLocator = null;,     cfg = null;,   },   ,   /**,    * Create a new CoreContainer and load its cores,    * @param solrHome the solr home directory,    * @param configFile the file containing this container's configuration,    * @return a loaded CoreContainer,    */,   public static CoreContainer createAndLoad(String solrHome, File configFile) {,     SolrResourceLoader loader = new SolrResourceLoader(solrHome);,     CoreContainer cc = new CoreContainer(loader, ConfigSolr.fromFile(loader, configFile));,     cc.load();,     return cc;,   },   ,   public Properties getContainerProperties() {,     return containerProperties;,   }, ,   //-------------------------------------------------------------------,   // Initialization / Cleanup,   //-------------------------------------------------------------------, ,   /**,    * Load the cores defined for this CoreContainer,    */,   public void load()  {, ,     log.info("Loading cores into CoreContainer [instanceDir={}]", loader.getInstanceDir());, ,     // add the sharedLib to the shared resource loader before initializing cfg based plugins,     String libDir = cfg.getSharedLibDirectory();,     if (libDir != null) {,       File f = FileUtils.resolvePath(new File(solrHome), libDir);,       log.info("loading shared library: " + f.getAbsolutePath());,       loader.addToClassLoader(libDir, null, false);,       loader.reloadLuceneSPI();,     }, , ,     shardHandlerFactory = ShardHandlerFactory.newInstance(cfg.getShardHandlerFactoryPluginInfo(), loader);, ,     updateShardHandler = new UpdateShardHandler(cfg);, ,     solrCores.allocateLazyCores(cfg.getTransientCacheSize(), loader);, ,     logging = LogWatcher.newRegisteredLogWatcher(cfg.getLogWatcherConfig(), loader);, ,     hostName = cfg.getHost();,     log.info("Host Name: " + hostName);, ,     zkSys.initZooKeeper(this, solrHome, cfg);, ,     collectionsHandler = createHandler(cfg.getCollectionsHandlerClass(), CollectionsHandler.class);,     containerHandlers.put("/admin/collections" , collectionsHandler);,     infoHandler        = createHandler(cfg.getInfoHandlerClass(), InfoHandler.class);,     containerHandlers.put("/admin/info" , infoHandler);,     coreAdminHandler   = createHandler(cfg.getCoreAdminHandlerClass(), CoreAdminHandler.class);,     containerHandlers.put(cfg.getAdminPath() , coreAdminHandler);, ,     coreConfigService = cfg.createCoreConfigService(loader, zkSys.getZkController());, ,     containerProperties = cfg.getSolrProperties("solr");, ,     // setup executor to load cores in parallel,     // do not limit the size of the executor in zk mode since cores may try and wait for each other.,     ExecutorService coreLoadExecutor = Executors.newFixedThreadPool(,         ( zkSys.getZkController() == null ? cfg.getCoreLoadThreadCount() : Integer.MAX_VALUE ),,         new DefaultSolrThreadFactory("coreLoadExecutor") );, ,     try {, ,       List<CoreDescriptor> cds = coresLocator.discover(this);,       checkForDuplicateCoreNames(cds);, ,       List<Callable<SolrCore>> creators = new ArrayList<>();,       for (final CoreDescriptor cd : cds) {,         if (cd.isTransient() || !cd.isLoadOnStartup()) {,           solrCores.putDynamicDescriptor(cd.getName(), cd);,         },         if (cd.isLoadOnStartup()) {,           creators.add(new Callable<SolrCore>() {,             @Override,             public SolrCore call() throws Exception {,               if (zkSys.getZkController() != null) {,                 zkSys.getZkController().throwErrorIfReplicaReplaced(cd);,               },               return create(cd, false);   ,             },           });,         },       }, ,       try {,         coreLoadExecutor.invokeAll(creators);,       },       catch (InterruptedException e) {,         throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, "Interrupted while loading cores");,       }, ,       // Start the background thread,       backgroundCloser = new CloserThread(this, solrCores, cfg);,       backgroundCloser.start();, ,     } finally {,       ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);,     },     ,     if (isZooKeeperAware()) {,       // register in zk in background threads,       Collection<SolrCore> cores = getCores();,       if (cores != null) {,         for (SolrCore core : cores) {,           try {,             zkSys.registerInZk(core, true);,           } catch (Throwable t) {,             SolrException.log(log, "Error registering SolrCore", t);,           },         },       },       zkSys.getZkController().checkOverseerDesignate();,     },   }, ,   private static void checkForDuplicateCoreNames(List<CoreDescriptor> cds) {,     Map<String, String> addedCores = Maps.newHashMap();,     for (CoreDescriptor cd : cds) {,       final String name = cd.getName();,       if (addedCores.containsKey(name)),         throw new SolrException(ErrorCode.SERVER_ERROR,,             String.format(Locale.ROOT, "Found multiple cores with the name [%s], with instancedirs [%s] and [%s]",,                 name, addedCores.get(name), cd.getInstanceDir()));,       addedCores.put(name, cd.getInstanceDir());,     },   }, ,   private volatile boolean isShutDown = false;,   ,   public boolean isShutDown() {,     return isShutDown;,   }, ,   /**,    * Stops all cores.,    */,   public void shutdown() {,     log.info("Shutting down CoreContainer instance=",         + System.identityHashCode(this));,     ,     isShutDown = true;,     ,     if (isZooKeeperAware()) {,       cancelCoreRecoveries();,       zkSys.publishCoresAsDown(solrCores.getCores());,     }, ,     try {,       coreAdminHandler.shutdown();,     } catch (Exception e) {,       log.warn("Error shutting down CoreAdminHandler. Continuing to close CoreContainer.");,       e.printStackTrace();,     }, ,     try {,       // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.,       synchronized (solrCores.getModifyLock()) {,         solrCores.getModifyLock().notifyAll(); // wake up anyone waiting,       },       if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.,         try {,           backgroundCloser.join();,         } catch (InterruptedException e) {,           Thread.currentThread().interrupt();,           if (log.isDebugEnabled()) {,             log.debug("backgroundCloser thread was interrupted before finishing");,           },         },       },       // Now clear all the cores that are being operated upon.,       solrCores.close();, ,       // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.,       // Since all the pending operations queues have been drained, there should be nothing to do.,       synchronized (solrCores.getModifyLock()) {,         solrCores.getModifyLock().notifyAll(); // wake up the thread,       }, ,     } finally {,       try {,         if (shardHandlerFactory != null) {,           shardHandlerFactory.close();,         },       } finally {,         try {,           if (updateShardHandler != null) {,             updateShardHandler.close();,           },         } finally {,           // we want to close zk stuff last,           zkSys.close();,         },       },     },     org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort,   }, ,   public void cancelCoreRecoveries() {, ,     List<SolrCore> cores = solrCores.getCores();, ,     // we must cancel without holding the cores sync,     // make sure we wait for any recoveries to stop,     for (SolrCore core : cores) {,       try {,         core.getSolrCoreState().cancelRecovery();,       } catch (Exception e) {,         SolrException.log(log, "Error canceling recovery for core", e);,       },     },   },   ,   @Override,   protected void finalize() throws Throwable {,     try {,       if(!isShutDown){,         log.error("CoreContainer was not close prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEAK!!!  instance=" + System.identityHashCode(this));,       },     } finally {,       super.finalize();,     },   }, ,   public CoresLocator getCoresLocator() {,     return coresLocator;,   },   ,   protected SolrCore registerCore(String name, SolrCore core, boolean registerInZk) {,     if( core == null ) {,       throw new RuntimeException( "Can not register a null core." );,     },     if( name == null ||,         name.indexOf( '/'  ) >= 0 ||,         name.indexOf( '\\' ) >= 0 ){,       throw new RuntimeException( "Invalid core name: "+name );,     },     // We can register a core when creating them via the admin UI, so we need to insure that the dynamic descriptors,     // are up to date,     CoreDescriptor cd = core.getCoreDescriptor();,     if ((cd.isTransient() || ! cd.isLoadOnStartup()),         && solrCores.getDynamicDescriptor(name) == null) {,       // Store it away for later use. includes non-transient but not,       // loaded at startup cores.,       solrCores.putDynamicDescriptor(name, cd);,     }, ,     SolrCore old = null;, ,     if (isShutDown) {,       core.close();,       throw new IllegalStateException("This CoreContainer has been close");,     },     if (cd.isTransient()) {,       old = solrCores.putTransientCore(cfg, name, core, loader);,     } else {,       old = solrCores.putCore(name, core);,     },       /*,       * set both the name of the descriptor and the name of the,       * core, since the descriptors name is used for persisting.,       */, ,     core.setName(name);, ,     coreInitFailures.remove(name);, ,     if( old == null || old == core) {,       log.info( "registering core: "+name );,       if (registerInZk) {,         zkSys.registerInZk(core, false);,       },       return null;,     },     else {,       log.info( "replacing core: "+name );,       old.close();,       if (registerInZk) {,         zkSys.registerInZk(core, false);,       },       return old;,     },   }, ,   /**,    * Creates a new core based on a CoreDescriptor, publishing the core state to the cluster,    * @param cd the CoreDescriptor,    * @return the newly created core,    */,   public SolrCore create(CoreDescriptor cd) {,     return create(cd, true);,   }, ,   /**,    * Creates a new core based on a CoreDescriptor.,    *,    * @param dcore        a core descriptor,    * @param publishState publish core state to the cluster if true,    *,    * @return the newly created core,    */,   public SolrCore create(CoreDescriptor dcore, boolean publishState) {, ,     if (isShutDown) {,       throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, "Solr has close.");,     }, ,     try {, ,       if (zkSys.getZkController() != null) {,         zkSys.getZkController().preRegister(dcore);,       }, ,       ConfigSet coreConfig = coreConfigService.getConfig(dcore);,       log.info("Creating SolrCore '{}' using configuration from {}", dcore.getName(), coreConfig.getName());,       SolrCore core = new SolrCore(dcore, coreConfig);,       solrCores.addCreated(core);, ,       // always kick off recovery if we are in non-Cloud mode,       if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {,         core.getUpdateHandler().getUpdateLog().recoverFromLog();,       }, ,       registerCore(dcore.getName(), core, publishState);, ,       return core;, ,     },     catch (Exception e) {,       coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));,       log.error("Error creating core [{}]: {}", dcore.getName(), e.getMessage(), e);,       throw new SolrException(ErrorCode.SERVER_ERROR, "Unable to create core [" + dcore.getName() + "]", e);,     }, ,   }, ,   /**,    * @return a Collection of registered SolrCores,    */,   public Collection<SolrCore> getCores() {,     return solrCores.getCores();,   }, ,   /**,    * @return a Collection of the names that cores are mapped to,    */,   public Collection<String> getCoreNames() {,     return solrCores.getCoreNames();,   }, ,   /** This method is currently experimental.,    * @return a Collection of the names that a specific core is mapped to.,    */,   public Collection<String> getCoreNames(SolrCore core) {,     return solrCores.getCoreNames(core);,   }, ,   /**,    * get a list of all the cores that are currently loaded,    * @return a list of al lthe available core names in either permanent or transient core lists.,    */,   public Collection<String> getAllCoreNames() {,     return solrCores.getAllCoreNames();, ,   }, ,   /**,    * Returns an immutable Map of Exceptions that occured when initializing ,    * SolrCores (either at startup, or do to runtime requests to create cores) ,    * keyed off of the name (String) of the SolrCore that had the Exception ,    * during initialization.,    * <p>,    * While the Map returned by this method is immutable and will not change ,    * once returned to the client, the source data used to generate this Map ,    * can be changed as various SolrCore operations are performed:,    * </p>,    * <ul>,    *  <li>Failed attempts to create new SolrCores will add new Exceptions.</li>,    *  <li>Failed attempts to re-create a SolrCore using a name already contained in this Map will replace the Exception.</li>,    *  <li>Failed attempts to reload a SolrCore will cause an Exception to be added to this list -- even though the existing SolrCore with that name will continue to be available.</li>,    *  <li>Successful attempts to re-created a SolrCore using a name already contained in this Map will remove the Exception.</li>,    *  <li>Registering an existing SolrCore with a name already contained in this Map (ie: ALIAS or SWAP) will remove the Exception.</li>,    * </ul>,    */,   public Map<String, CoreLoadFailure> getCoreInitFailures() {,     return ImmutableMap.copyOf(coreInitFailures);,   }, , ,   // ---------------- Core name related methods --------------- ,   /**,    * Recreates a SolrCore.,    * While the new core is loading, requests will continue to be dispatched to,    * and processed by the old core,    * ,    * @param name the name of the SolrCore to reload,    */,   public void reload(String name) {, ,     name = checkDefault(name);, ,     SolrCore core = solrCores.getCoreFromAnyList(name, false);,     if (core == null),       throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "No such core: " + name );, ,     CoreDescriptor cd = core.getCoreDescriptor();,     try {,       solrCores.waitAddPendingCoreOps(name);,       ConfigSet coreConfig = coreConfigService.getConfig(cd);,       log.info("Reloading SolrCore '{}' using configuration from {}", cd.getName(), coreConfig.getName());,       SolrCore newCore = core.reload(coreConfig);,       registerCore(name, newCore, false);,     },     catch (Exception e) {,       coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));,       throw new SolrException(ErrorCode.SERVER_ERROR, "Unable to reload core [" + cd.getName() + "]", e);,     },     finally {,       solrCores.removeFromPendingOps(name);,     }, ,   }, ,   //5.0 remove all checkDefaults?,   private String checkDefault(String name) {,     return (null == name || name.isEmpty()) ? getDefaultCoreName() : name;,   } , ,   /**,    * Swaps two SolrCore descriptors.,    */,   public void swap(String n0, String n1) {,     if( n0 == null || n1 == null ) {,       throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Can not swap unnamed cores." );,     },     n0 = checkDefault(n0);,     n1 = checkDefault(n1);,     solrCores.swap(n0, n1);, ,     coresLocator.swap(this, solrCores.getCoreDescriptor(n0), solrCores.getCoreDescriptor(n1));, ,     log.info("swapped: "+n0 + " with " + n1);,   }, ,   /**,    * Unload a core from this container, leaving all files on disk,    * @param name the name of the core to unload,    */,   public void unload(String name) {,     unload(name, false, false, false);,   }, ,   /**,    * Unload a core from this container, optionally removing the core's data and configuration,    *,    * @param name the name of the core to unload,    * @param deleteIndexDir if true, delete the core's index on close,    * @param deleteDataDir if true, delete the core's data directory on close,    * @param deleteInstanceDir if true, delete the core's instance directory on close,    */,   public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {, ,     name = checkDefault(name);, ,     // check for core-init errors first,     CoreLoadFailure loadFailure = coreInitFailures.remove(name);,     if (loadFailure != null) {,       // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,,       // which we may not be able to do because of the init error.  So we just go with what we,       // can glean from the CoreDescriptor - datadir and instancedir,       SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);,       return;,     }, ,     CoreDescriptor cd = solrCores.getCoreDescriptor(name);,     if (cd == null),       throw new SolrException(ErrorCode.BAD_REQUEST, "Cannot unload non-existent core [" + name + "]");, ,     boolean close = solrCores.isLoadedNotPendingClose(name);,     SolrCore core = solrCores.remove(name);,     coresLocator.delete(this, cd);, ,     if (core == null) {,       // transient core,       SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);,       return;,     }, ,     if (zkSys.getZkController() != null) {,       // cancel recovery in cloud mode,       core.getSolrCoreState().cancelRecovery();,     },     String configSetZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getConfigSetZkPath() : null;, ,     core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);,     if (close),       core.close();, ,     if (zkSys.getZkController() != null) {,       try {,         zkSys.getZkController().unregister(name, cd, configSetZkPath);,       } catch (InterruptedException e) {,         Thread.currentThread().interrupt();,         throw new SolrException(ErrorCode.SERVER_ERROR, "Interrupted while unregistering core [" + name + "] from cloud state");,       } catch (KeeperException e) {,         throw new SolrException(ErrorCode.SERVER_ERROR, "Error unregistering core [" + name + "] from cloud state", e);,       },     }, ,   }, ,   public void rename(String name, String toName) {,     try (SolrCore core = getCore(name)) {,       if (core != null) {,         registerCore(toName, core, true);,         name = checkDefault(name);,         SolrCore old = solrCores.remove(name);,         coresLocator.rename(this, old.getCoreDescriptor(), core.getCoreDescriptor());,       },     },   }, ,   /**,    * Get the CoreDescriptors for all cores managed by this container,    * @return a List of CoreDescriptors,    */,   public List<CoreDescriptor> getCoreDescriptors() {,     return solrCores.getCoreDescriptors();,   }, ,   public CoreDescriptor getCoreDescriptor(String coreName) {,     // TODO make this less hideous!,     for (CoreDescriptor cd : getCoreDescriptors()) {,       if (cd.getName().equals(coreName)),         return cd;,     },     return null;,   }, ,   public String getCoreRootDirectory() {,     return cfg.getCoreRootDirectory();,   }, ,   /**,    * Gets a core by name and increase its refcount.,    *,    * @see SolrCore#close(),    * @param name the core name,    * @return the core if found, null if a SolrCore by this name does not exist,    * @exception SolrException if a SolrCore with this name failed to be initialized,    */,   public SolrCore getCore(String name) {, ,     name = checkDefault(name);, ,     // Do this in two phases since we don't want to lock access to the cores over a load.,     SolrCore core = solrCores.getCoreFromAnyList(name, true);, ,     if (core != null) {,       return core;,     }, ,     // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.,     CoreDescriptor desc = solrCores.getDynamicDescriptor(name);,     if (desc == null) { //Nope, no transient core with this name, ,       // if there was an error initalizing this core, throw a 500,       // error with the details for clients attempting to access it.,       CoreLoadFailure loadFailure = getCoreInitFailures().get(name);,       if (null != loadFailure) {,         throw new SolrException(ErrorCode.SERVER_ERROR, "SolrCore '" + name +,                                 "' is not available due to init failure: " +,                                 loadFailure.exception.getMessage(), loadFailure.exception);,       },       // otherwise the user is simply asking for something that doesn't exist.,       return null;,     }, ,     // This will put an entry in pending core ops if the core isn't loaded,     core = solrCores.waitAddPendingCoreOps(name);, ,     if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off,                                  // the wait as a consequence of shutting down.,     try {,       if (core == null) {,         if (zkSys.getZkController() != null) {,           zkSys.getZkController().throwErrorIfReplicaReplaced(desc);,         },         core = create(desc); // This should throw an error if it fails.,       },       core.open();,     },     finally {,       solrCores.removeFromPendingOps(name);,     }, ,     return core;,   }, ,   public JarRepository getJarRepository(){,     return jarRepository;,   }, ,   // ---------------- CoreContainer request handlers --------------, ,   protected <T> T createHandler(String handlerClass, Class<T> clazz) {,     return loader.newInstance(handlerClass, clazz, null, new Class[] { CoreContainer.class }, new Object[] { this });,   }, ,   public CoreAdminHandler getMultiCoreHandler() {,     return coreAdminHandler;,   }, ,   public CollectionsHandler getCollectionsHandler() {,     return collectionsHandler;,   }, ,   public InfoHandler getInfoHandler() {,     return infoHandler;,   }, ,   // ---------------- Multicore self related methods ---------------, ,   /**,    * the default core name, or null if there is no default core name,    */,   public String getDefaultCoreName() {,     return cfg.getDefaultCoreName();,   }, ,   // all of the following properties aren't synchronized,   // but this should be OK since they normally won't be changed rapidly,   @Deprecated,   public boolean isPersistent() {,     return cfg.isPersistent();,   },   ,   public String getAdminPath() {,     return cfg.getAdminPath();,   },   ,   public String getHostName() {,     return this.hostName;,   }, ,   /**,    * Gets the alternate path for multicore handling:,    * This is used in case there is a registered unnamed core (aka name is "") to,    * declare an alternate way of accessing named cores.,    * This can also be used in a pseudo single-core environment so admins can prepare,    * a new version before swapping.,    */,   public String getManagementPath() {,     return cfg.getManagementPath();,   }, ,   public LogWatcher getLogging() {,     return logging;,   }, ,   /**,    * Determines whether the core is already loaded or not but does NOT load the core,    *,    */,   public boolean isLoaded(String name) {,     return solrCores.isLoaded(name);,   }, ,   public boolean isLoadedNotPendingClose(String name) {,     return solrCores.isLoadedNotPendingClose(name);,   }, ,   /**,    * Gets a solr core descriptor for a core that is not loaded. Note that if the caller calls this on a,    * loaded core, the unloaded descriptor will be returned.,    *,    * @param cname - name of the unloaded core descriptor to load. NOTE:,    * @return a coreDescriptor. May return null,    */,   public CoreDescriptor getUnloadedCoreDescriptor(String cname) {,     return solrCores.getUnloadedCoreDescriptor(cname);,   }, ,   public String getSolrHome() {,     return solrHome;,   }, ,   public boolean isZooKeeperAware() {,     return zkSys.getZkController() != null;,   },   ,   public ZkController getZkController() {,     return zkSys.getZkController();,   },   ,   public ConfigSolr getConfig() {,     return cfg;,   }, ,   /** The default ShardHandlerFactory used to communicate with other solr instances */,   public ShardHandlerFactory getShardHandlerFactory() {,     return shardHandlerFactory;,   },   ,   public UpdateShardHandler getUpdateShardHandler() {,     return updateShardHandler;,   }, ,   public SolrResourceLoader getResourceLoader() {,     return loader;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java,,69-257,[  {,     if ( core == null ) {,       throw new NullPointerException("SolrCore instance required");,     },     CoreDescriptor dcore = core.getCoreDescriptor();,     if (dcore == null),       throw new NullPointerException("CoreDescriptor required");,     ,     CoreContainer cores = dcore.getCoreContainer();,     if (cores == null),       throw new NullPointerException("CoreContainer required");,     ,     coreName = dcore.getName();,     coreContainer = cores;,     _parser = new SolrRequestParsers( null );,   },     ,   /**,    * Creates a SolrServer.,    * @param coreContainer the core container,    * @param coreName the core name,    */,   public EmbeddedSolrServer(CoreContainer coreContainer, String coreName),   {,     if ( coreContainer == null ) {,       throw new NullPointerException("CoreContainer instance required");,     },     this.coreContainer = coreContainer;,     this.coreName = coreName == null? "" : coreName;,     _parser = new SolrRequestParsers( null );,   },   ,   @Override,   public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException ,   {,     String path = request.getPath();,     if( path == null || !path.startsWith( "/" ) ) {,       path = "/select";,     }, ,     // Check for cores action,     SolrCore core =  coreContainer.getCore( coreName );,     if( core == null ) {,       throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, ,                                "No such core: " + coreName );,     },     ,     SolrParams params = request.getParams();,     if( params == null ) {,       params = new ModifiableSolrParams();,     },     ,     // Extract the handler from the path or params,     SolrRequestHandler handler = core.getRequestHandler( path );,     if( handler == null ) {,       if( "/select".equals( path ) || "/select/".equalsIgnoreCase( path) ) {,         String qt = params.get( CommonParams.QT );,         handler = core.getRequestHandler( qt );,         if( handler == null ) {,           throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+qt);,         },       },       // Perhaps the path is to manage the cores,       if( handler == null &&,           coreContainer != null &&,           path.equals( coreContainer.getAdminPath() ) ) {,         handler = coreContainer.getMultiCoreHandler();,       },     },     if( handler == null ) {,       core.close();,       throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+path );,     }, ,     SolrQueryRequest req = null;,     try {,       req = _parser.buildRequestFrom( core, params, request.getContentStreams() );,       req.getContext().put( "path", path );,       SolrQueryResponse rsp = new SolrQueryResponse();,       SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));,       ,       core.execute( handler, req, rsp );,       if( rsp.getException() != null ) {,         if(rsp.getException() instanceof SolrException) {,           throw rsp.getException();,         },         throw new SolrServerException( rsp.getException() );,       },       ,       // Check if this should stream results,       if( request.getStreamingResponseCallback() != null ) {,         try {,           final StreamingResponseCallback callback = request.getStreamingResponseCallback();,           BinaryResponseWriter.Resolver resolver = ,             new BinaryResponseWriter.Resolver( req, rsp.getReturnFields()) ,           {,             @Override,             public void writeResults(ResultContext ctx, JavaBinCodec codec) throws IOException {,               // write an empty list...,               SolrDocumentList docs = new SolrDocumentList();,               docs.setNumFound( ctx.docs.matches() );,               docs.setStart( ctx.docs.offset() );,               docs.setMaxScore( ctx.docs.maxScore() );,               codec.writeSolrDocumentList( docs );,               ,               // This will transform,               writeResultsBody( ctx, codec );,             },           };,           , ,           ByteArrayOutputStream out = new ByteArrayOutputStream();,           new JavaBinCodec(resolver) {, ,             @Override,             public void writeSolrDocument(SolrDocument doc) {,               callback.streamSolrDocument( doc );,               //super.writeSolrDocument( doc, fields );,             }, ,             @Override,             public void writeSolrDocumentList(SolrDocumentList docs) throws IOException {,               if( docs.size() > 0 ) {,                 SolrDocumentList tmp = new SolrDocumentList();,                 tmp.setMaxScore( docs.getMaxScore() );,                 tmp.setNumFound( docs.getNumFound() );,                 tmp.setStart( docs.getStart() );,                 docs = tmp;,               },               callback.streamDocListInfo( docs.getNumFound(), docs.getStart(), docs.getMaxScore() );,               super.writeSolrDocumentList(docs);,             },             ,           }.marshal(rsp.getValues(), out);, ,           InputStream in = new ByteArrayInputStream(out.toByteArray());,           return (NamedList<Object>) new JavaBinCodec(resolver).unmarshal(in);,         },         catch (Exception ex) {,           throw new RuntimeException(ex);,         },       },       ,       // Now write it out,       NamedList<Object> normalized = getParsedResponse(req, rsp);,       return normalized;,     },     catch( IOException iox ) {,       throw iox;,     },     catch( SolrException sx ) {,       throw sx;,     },     catch( Exception ex ) {,       throw new SolrServerException( ex );,     },     finally {,       if (req != null) req.close();,       core.close();,       SolrRequestInfo.clearRequestInfo();,     },   },   ,   /**,    * Returns a response object equivalent to what you get from the XML/JSON/javabin parser. Documents,    * become SolrDocuments, DocList becomes SolrDocumentList etc.,    * ,    * @deprecated use {@link BinaryResponseWriter#getParsedResponse(SolrQueryRequest, SolrQueryResponse)},    */,   @Deprecated,   public NamedList<Object> getParsedResponse( SolrQueryRequest req, SolrQueryResponse rsp ),   {,     return BinaryResponseWriter.getParsedResponse(req, rsp);,   },   ,   /**,    * Shutdown all cores within the EmbeddedSolrServer instance,    */,   @Override,   public void shutdown() {,     coreContainer.shutdown();,   },   ,   /**,    * Getter method for the CoreContainer,    * @return the core container,    */,   public CoreContainer getCoreContainer() {,     return coreContainer;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java,,181-200,[          new JavaBinCodec(resolver) {, ,             @Override,             public void writeSolrDocument(SolrDocument doc) {,               callback.streamSolrDocument( doc );,               //super.writeSolrDocument( doc, fields );,             }, ,             @Override,             public void writeSolrDocumentList(SolrDocumentList docs) throws IOException {,               if( docs.size() > 0 ) {,                 SolrDocumentList tmp = new SolrDocumentList();,                 tmp.setMaxScore( docs.getMaxScore() );,                 tmp.setNumFound( docs.getNumFound() );,                 tmp.setStart( docs.getStart() );,                 docs = tmp;,               },               callback.streamDocListInfo( docs.getNumFound(), docs.getStart(), docs.getMaxScore() );,               super.writeSolrDocumentList(docs);,             }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/client/solrj/embedded/JettySolrRunner.java,,396-396,[      waitOnSolr = false;],,,289-289,[          waitOnSolr = true;],,,421-421,[        while (!waitOnSolr) {],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/solr/client/solrj/embedded/JettySolrRunner.java,lifeCycleStarting,290-290,[          JettySolrRunner.this.notify();],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/client/solrj/embedded/JettySolrRunner.java,setDebugEnabled,587-587,[    debug = enabled;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/client/solrj/impl/BinaryRequestWriter.java,getSize,88-88,[        return new Long(baos.size());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/client/solrj/impl/BinaryRequestWriter.java,,69-98,[    return new ContentStream() {,       @Override,       public String getName() {,         return null;,       }, ,       @Override,       public String getSourceInfo() {,         return "javabin";,       }, ,       @Override,       public String getContentType() {,         return "application/javabin";,       }, ,       @Override,       public Long getSize() // size if we know it, otherwise null,       {,         return new Long(baos.size());,       }, ,       @Override,       public InputStream getStream() {,         return new ByteArrayInputStream(baos.getbuf(), 0, baos.size());,       }, ,       @Override,       public Reader getReader() {,         throw new RuntimeException("No reader available . this is a binarystream");],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/client/solrj/impl/BinaryRequestWriter.java,,115-117,[  class BAOS extends ByteArrayOutputStream {,     byte[] getbuf() {,       return super.buf;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/client/solrj/impl/CloudSolrClient.java,,438-438,[    this.zkClientTimeout = zkClientTimeout;],,,452-452,[            zk = new ZkStateReader(zkHost, zkClientTimeout,],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/client/solrj/impl/CloudSolrClient.java,,433-433,[    this.zkConnectTimeout = zkConnectTimeout;],,,452-452,[            zk = new ZkStateReader(zkHost, zkClientTimeout,],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/client/solrj/impl/CloudSolrClient.java,directUpdate,611-611,[      } catch (Exception e) {],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/solr/client/solrj/impl/CloudSolrClient.java,sendRequest,960-960,[            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/impl/CloudSolrClient.java,,149-155,[    ExpiringCachedDocCollection(DocCollection cached) {,       this.cached = cached;,       this.cachedAt = System.currentTimeMillis();,     }, ,     boolean isExpired(long timeToLive) {,       return (System.currentTimeMillis() - cachedAt) > timeToLive;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/common/cloud/ZkStateReader.java,,55-906,[public class ZkStateReader implements Closeable {,   private static Logger log = LoggerFactory.getLogger(ZkStateReader.class);,   ,   public static final String BASE_URL_PROP = "base_url";,   public static final String NODE_NAME_PROP = "node_name";,   public static final String CORE_NODE_NAME_PROP = "core_node_name";,   public static final String ROLES_PROP = "roles";,   public static final String STATE_PROP = "state";,   public static final String CORE_NAME_PROP = "core";,   public static final String COLLECTION_PROP = "collection";,   public static final String ELECTION_NODE_PROP = "election_node";,   public static final String SHARD_ID_PROP = "shard";,   public static final String REPLICA_PROP = "replica";,   public static final String SHARD_RANGE_PROP = "shard_range";,   public static final String SHARD_STATE_PROP = "shard_state";,   public static final String SHARD_PARENT_PROP = "shard_parent";,   public static final String NUM_SHARDS_PROP = "numShards";,   public static final String LEADER_PROP = "leader";,   public static final String PROPERTY_PROP = "property";,   public static final String PROPERTY_VALUE_PROP = "property.value";,   public static final String MAX_AT_ONCE_PROP = "maxAtOnce";,   public static final String MAX_WAIT_SECONDS_PROP = "maxWaitSeconds";,   public static final String COLLECTIONS_ZKNODE = "/collections";,   public static final String LIVE_NODES_ZKNODE = "/live_nodes";,   public static final String ALIASES = "/aliases.json";,   public static final String CLUSTER_STATE = "/clusterstate.json";,   public static final String CLUSTER_PROPS = "/clusterprops.json";,   public static final String REJOIN_AT_HEAD_PROP = "rejoinAtHead";, ,   public static final String REPLICATION_FACTOR = "replicationFactor";,   public static final String MAX_SHARDS_PER_NODE = "maxShardsPerNode";,   public static final String AUTO_ADD_REPLICAS = "autoAddReplicas";, ,   public static final String ROLES = "/roles.json";, ,   public static final String RECOVERING = "recovering";,   public static final String RECOVERY_FAILED = "recovery_failed";,   public static final String ACTIVE = "active";,   public static final String DOWN = "down";,   public static final String SYNC = "sync";, ,   public static final String CONFIGS_ZKNODE = "/configs";,   public final static String CONFIGNAME_PROP="configName";, ,   public static final String LEGACY_CLOUD = "legacyCloud";, ,   public static final String URL_SCHEME = "urlScheme";,   ,   protected volatile ClusterState clusterState;, ,   private static final long SOLRCLOUD_UPDATE_DELAY = Long.parseLong(System.getProperty("solrcloud.update.delay", "5000"));, ,   public static final String LEADER_ELECT_ZKNODE = "leader_elect";, ,   public static final String SHARD_LEADERS_ZKNODE = "leaders";,   public static final String ELECTION_NODE = "election";, ,   private final Set<String> watchedCollections = new HashSet<String>();, ,   /**These are collections which are actively watched by this  instance .,    *,    */,   private Map<String , DocCollection> watchedCollectionStates = new ConcurrentHashMap<String, DocCollection>();, , ,   //,   // convenience methods... should these go somewhere else?,   //,   public static byte[] toJSON(Object o) {,     CharArr out = new CharArr();,     new JSONWriter(out, 2).write(o); // indentation by default,     return toUTF8(out);,   }, ,   public static byte[] toUTF8(CharArr out) {,     byte[] arr = new byte[out.size() << 2]; // is 4x the real worst-case upper-bound?,     int nBytes = ByteUtils.UTF16toUTF8(out, 0, out.size(), arr, 0);,     return Arrays.copyOf(arr, nBytes);,   }, ,   public static Object fromJSON(byte[] utf8) {,     // convert directly from bytes to chars,     // and parse directly from that instead of going through,     // intermediate strings or readers,     CharArr chars = new CharArr();,     ByteUtils.UTF8toUTF16(utf8, 0, utf8.length, chars);,     JSONParser parser = new JSONParser(chars.getArray(), chars.getStart(), chars.length());,     try {,       return ObjectBuilder.getVal(parser);,     } catch (IOException e) {,       throw new RuntimeException(e); // should never happen w/o using real IO,     },   },   ,   /**,    * Returns config set name for collection.,    *,    * @param collection to return config set name for,    */,   public String readConfigName(String collection) {, ,     String configName = null;, ,     String path = COLLECTIONS_ZKNODE + "/" + collection;,     if (log.isInfoEnabled()) {,       log.info("Load collection config from:" + path);,     }, ,     try {,       byte[] data = zkClient.getData(path, null, null, true);, ,       if(data != null) {,         ZkNodeProps props = ZkNodeProps.load(data);,         configName = props.getStr(CONFIGNAME_PROP);,       }, ,       if (configName != null) {,         if (!zkClient.exists(CONFIGS_ZKNODE + "/" + configName, true)) {,           log.error("Specified config does not exist in ZooKeeper:" + configName);,           throw new ZooKeeperException(ErrorCode.SERVER_ERROR,,               "Specified config does not exist in ZooKeeper:" + configName);,         } else if (log.isInfoEnabled()) {,           log.info("path={} {}={} specified config exists in ZooKeeper",,               new Object[] {path, CONFIGNAME_PROP, configName});,         },       } else {,         throw new ZooKeeperException(ErrorCode.INVALID_STATE, "No config data found at path: " + path);,       },     },     catch (KeeperException e) {,       throw new SolrException(ErrorCode.SERVER_ERROR, "Error loading config name for collection " + collection, e);,     },     catch (InterruptedException e) {,       Thread.interrupted();,       throw new SolrException(ErrorCode.SERVER_ERROR, "Error loading config name for collection " + collection, e);,     }, ,     return configName;,   }, , ,   private static class ZKTF implements ThreadFactory {,     private static ThreadGroup tg = new ThreadGroup("ZkStateReader");,     @Override,     public Thread newThread(Runnable r) {,       Thread td = new Thread(tg, r);,       td.setDaemon(true);,       return td;,     },   },   private ScheduledExecutorService updateCloudExecutor = Executors.newScheduledThreadPool(1, new ZKTF());, ,   private boolean clusterStateUpdateScheduled;, ,   private SolrZkClient zkClient;,   ,   private boolean closeClient = false;, ,   private ZkCmdExecutor cmdExecutor;, ,   private volatile Aliases aliases = new Aliases();, ,   private volatile boolean closed = false;, ,   public ZkStateReader(SolrZkClient zkClient) {,     this.zkClient = zkClient;,     initZkCmdExecutor(zkClient.getZkClientTimeout());,   }, ,   public ZkStateReader(String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout) throws InterruptedException, TimeoutException, IOException {,     closeClient = true;,     initZkCmdExecutor(zkClientTimeout);,     zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,,         // on reconnect, reload cloud info,         new OnReconnect() {, ,           @Override,           public void command() {,             try {,               ZkStateReader.this.createClusterStateWatchersAndUpdate();,             } catch (KeeperException e) {,               log.error("", e);,               throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,,                   "", e);,             } catch (InterruptedException e) {,               // Restore the interrupted status,               Thread.currentThread().interrupt();,               log.error("", e);,               throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,,                   "", e);,             } , ,           },         });,   },   ,   private void initZkCmdExecutor(int zkClientTimeout) {,     // we must retry at least as long as the session timeout,     cmdExecutor = new ZkCmdExecutor(zkClientTimeout);,   },   ,   // load and publish a new CollectionInfo,   public void updateClusterState(boolean immediate) throws KeeperException, InterruptedException {,     updateClusterState(immediate, false);,   },   ,   // load and publish a new CollectionInfo,   public void updateLiveNodes() throws KeeperException, InterruptedException {,     updateClusterState(true, true);,   },   ,   public Aliases getAliases() {,     return aliases;,   }, ,   public Boolean checkValid(String coll, int version) {,     DocCollection collection = clusterState.getCollectionOrNull(coll);,     if (collection == null) return null;,     if (collection.getZNodeVersion() < version) {,       log.debug("server older than client {}<{}", collection.getZNodeVersion(), version);,       DocCollection nu = getCollectionLive(this, coll);,       if (nu.getZNodeVersion() > collection.getZNodeVersion()) {,         updateWatchedCollection(nu);,         collection = nu;,       },     },     ,     if (collection.getZNodeVersion() == version) {,       return Boolean.TRUE;,     },     ,     log.debug("wrong version from client {}!={} ", version, collection.getZNodeVersion());,     ,     return Boolean.FALSE;,   },   ,   public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,,       InterruptedException {,     // We need to fetch the current cluster state and the set of live nodes,     ,     synchronized (getUpdateLock()) {,       cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);,       cmdExecutor.ensureExists(ALIASES, zkClient);,       ,       log.info("Updating cluster state from ZooKeeper... ");,       ,       zkClient.exists(CLUSTER_STATE, new Watcher() {,         ,         @Override,         public void process(WatchedEvent event) {,           // session events are not change events,,           // and do not remove the watcher,           if (EventType.None.equals(event.getType())) {,             return;,           },           log.info("A cluster state change: {}, has occurred - updating... (live nodes size: {})", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());,           try {,             ,             // delayed approach,             // ZkStateReader.this.updateClusterState(false, false);,             synchronized (ZkStateReader.this.getUpdateLock()) {,               // remake watch,               final Watcher thisWatch = this;,               Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();,               // update volatile,               ZkStateReader.this.clusterState = constructState(ln, thisWatch);,             },           } catch (KeeperException e) {,             if (e.code() == KeeperException.Code.SESSIONEXPIRED,                 || e.code() == KeeperException.Code.CONNECTIONLOSS) {,               log.warn("ZooKeeper watch triggered, but Solr cannot talk to ZK");,               return;,             },             log.error("", e);,             throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,,                 "", e);,           } catch (InterruptedException e) {,             // Restore the interrupted status,             Thread.currentThread().interrupt();,             log.warn("", e);,             return;,           },         },         ,       }, true);,     },    ,     ,     synchronized (ZkStateReader.this.getUpdateLock()) {,       List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,,           new Watcher() {,             ,             @Override,             public void process(WatchedEvent event) {,               // session events are not change events,,               // and do not remove the watcher,               if (EventType.None.equals(event.getType())) {,                 return;,               },               try {,                 // delayed approach,                 // ZkStateReader.this.updateClusterState(false, true);,                 synchronized (ZkStateReader.this.getUpdateLock()) {,                   List<String> liveNodes = zkClient.getChildren(,                       LIVE_NODES_ZKNODE, this, true);,                   log.debug("Updating live nodes... ({})", liveNodes.size());,                   Set<String> liveNodesSet = new HashSet<>();,                   liveNodesSet.addAll(liveNodes);, ,                   ClusterState clusterState =  ZkStateReader.this.clusterState;, ,                   clusterState.setLiveNodes(liveNodesSet);,                 },               } catch (KeeperException e) {,                 if (e.code() == KeeperException.Code.SESSIONEXPIRED,                     || e.code() == KeeperException.Code.CONNECTIONLOSS) {,                   log.warn("ZooKeeper watch triggered, but Solr cannot talk to ZK");,                   return;,                 },                 log.error("", e);,                 throw new ZooKeeperException(,                     SolrException.ErrorCode.SERVER_ERROR, "", e);,               } catch (InterruptedException e) {,                 // Restore the interrupted status,                 Thread.currentThread().interrupt();,                 log.warn("", e);,                 return;,               },             },             ,           }, true);,     ,       Set<String> liveNodeSet = new HashSet<>();,       liveNodeSet.addAll(liveNodes);,       this.clusterState = constructState(liveNodeSet, null);, ,       zkClient.exists(ALIASES,,           new Watcher() {,             ,             @Override,             public void process(WatchedEvent event) {,               // session events are not change events,,               // and do not remove the watcher,               if (EventType.None.equals(event.getType())) {,                 return;,               },               try {,                 synchronized (ZkStateReader.this.getUpdateLock()) {,                   log.info("Updating aliases... ");, ,                   // remake watch,                   final Watcher thisWatch = this;,                   Stat stat = new Stat();,                   byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,,                       true);, ,                   Aliases aliases = ClusterState.load(data);, ,                   ZkStateReader.this.aliases = aliases;,                 },               } catch (KeeperException e) {,                 if (e.code() == KeeperException.Code.SESSIONEXPIRED,                     || e.code() == KeeperException.Code.CONNECTIONLOSS) {,                   log.warn("ZooKeeper watch triggered, but Solr cannot talk to ZK");,                   return;,                 },                 log.error("", e);,                 throw new ZooKeeperException(,                     SolrException.ErrorCode.SERVER_ERROR, "", e);,               } catch (InterruptedException e) {,                 // Restore the interrupted status,                 Thread.currentThread().interrupt();,                 log.warn("", e);,                 return;,               },             },             ,           }, true);,     },     updateAliases();,     //on reconnect of SolrZkClient re-add watchers for the watched external collections,     synchronized (this) {,       for (String watchedCollection : watchedCollections) {,         addZkWatch(watchedCollection);,       },     },   }, ,   private ClusterState constructState(Set<String> ln, Watcher watcher),       throws KeeperException, InterruptedException {,     Stat stat = new Stat();,     byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);,     ClusterState loadedData = ClusterState.load(stat.getVersion(), data, ln,,         CLUSTER_STATE);,     Map<String,ClusterState.CollectionRef> result = new LinkedHashMap<>();,     result.putAll(loadedData.getCollectionStates());// first load all,                                                     // collections in,                                                     // clusterstate.json,     for (String s : getIndividualColls()) {,       synchronized (this) {,         if (watchedCollections.contains(s)) {,           DocCollection live = getCollectionLive(this, s);,           watchedCollectionStates.put(s, live);,           // if it is a watched collection, add too,           result.put(s, new ClusterState.CollectionRef(live));,         } else {,           // if it is not collection, then just create a reference which can fetch,           // the collection object just in time from ZK,           // this is also cheap (lazy loaded) so we put it inside the synchronized,           // block although it is not required,           final String collName = s;,           result.put(s, new ClusterState.CollectionRef(null) {,             @Override,             public DocCollection get() {,               return getCollectionLive(ZkStateReader.this, collName);,             },           });,         },       },     },     return new ClusterState(ln, result, stat.getVersion());,   }, , ,   private Set<String> getIndividualColls() throws KeeperException, InterruptedException {,     List<String> children = null;,     try {,       children = zkClient.getChildren(COLLECTIONS_ZKNODE, null, true);,     } catch (KeeperException.NoNodeException e) {,       log.warn("Error fetching collection names");,       ,       return new HashSet<>();,     },     if (children == null || children.isEmpty()) return new HashSet<>();,     HashSet<String> result = new HashSet<>(children.size());,     ,     for (String c : children) {,       try {,         if (zkClient.exists(getCollectionPath(c), true)) {,           result.add(c);,         },       } catch (Exception e) {,         log.warn("Error reading collections nodes", e);,       },     },     return result;,   }, ,   // load and publish a new CollectionInfo,   private synchronized void updateClusterState(boolean immediate,,       final boolean onlyLiveNodes) throws KeeperException,,       InterruptedException {,     // build immutable CloudInfo,     ,     if (immediate) {,       ClusterState clusterState;,       synchronized (getUpdateLock()) {,         List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,,             true);,         Set<String> liveNodesSet = new HashSet<>();,         liveNodesSet.addAll(liveNodes);,         ,         if (!onlyLiveNodes) {,           log.debug("Updating cloud state from ZooKeeper... ");,           ,           clusterState = constructState(liveNodesSet,null);,         } else {,           log.debug("Updating live nodes from ZooKeeper... ({})", liveNodesSet.size());,           clusterState = this.clusterState;,           clusterState.setLiveNodes(liveNodesSet);,         },         this.clusterState = clusterState;,       },       synchronized (ZkStateReader.this) {,         for (String watchedCollection : watchedCollections) {,           updateWatchedCollection(getCollectionLive(this, watchedCollection));,         },       }, ,     } else {,       if (clusterStateUpdateScheduled) {,         log.debug("Cloud state update for ZooKeeper already scheduled");,         return;,       },       log.debug("Scheduling cloud state update from ZooKeeper...");,       clusterStateUpdateScheduled = true;,       updateCloudExecutor.schedule(new Runnable() {,         ,         @Override,         public void run() {,           log.debug("Updating cluster state from ZooKeeper...");,           synchronized (getUpdateLock()) {,             clusterStateUpdateScheduled = false;,             ClusterState clusterState;,             try {,               List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,,                   null, true);,               Set<String> liveNodesSet = new HashSet<>();,               liveNodesSet.addAll(liveNodes);,               ,               if (!onlyLiveNodes) {,                 log.debug("Updating cloud state from ZooKeeper... ");, ,                 clusterState = constructState(liveNodesSet,null);,               } else {,                 log.debug("Updating live nodes from ZooKeeper... ");,                 clusterState = ZkStateReader.this.clusterState;,                 clusterState.setLiveNodes(liveNodesSet);,               },               ,               ZkStateReader.this.clusterState = clusterState;,               ,             } catch (KeeperException e) {,               if (e.code() == KeeperException.Code.SESSIONEXPIRED,                   || e.code() == KeeperException.Code.CONNECTIONLOSS) {,                 log.warn("ZooKeeper watch triggered, but Solr cannot talk to ZK");,                 return;,               },               log.error("", e);,               throw new ZooKeeperException(,                   SolrException.ErrorCode.SERVER_ERROR, "", e);,             } catch (InterruptedException e) {,               // Restore the interrupted status,               Thread.currentThread().interrupt();,               log.error("", e);,               throw new ZooKeeperException(,                   SolrException.ErrorCode.SERVER_ERROR, "", e);,             } ,             // update volatile,             ZkStateReader.this.clusterState = clusterState;, ,             synchronized (ZkStateReader.this) {,               for (String watchedCollection : watchedCollections) {,                 updateWatchedCollection(getCollectionLive(ZkStateReader.this, watchedCollection));,               },             },           },         },       }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);,     },   }, ,   /**,    * @return information about the cluster from ZooKeeper,    */,   public ClusterState getClusterState() {,     return clusterState;,   },   ,   public Object getUpdateLock() {,     return this;,   }, ,   public void close() {,     this.closed  = true;,     if (closeClient) {,       zkClient.close();,     },   },   ,   abstract class RunnableWatcher implements Runnable {,     Watcher watcher;,     public RunnableWatcher(Watcher watcher){,       this.watcher = watcher;,     }, ,   },   ,   public String getLeaderUrl(String collection, String shard, int timeout),       throws InterruptedException, KeeperException {,     ZkCoreNodeProps props = new ZkCoreNodeProps(getLeaderRetry(collection,,         shard, timeout));,     return props.getCoreUrl();,   },   ,   /**,    * Get shard leader properties, with retry if none exist.,    */,   public Replica getLeaderRetry(String collection, String shard) throws InterruptedException {,     return getLeaderRetry(collection, shard, 4000);,   }, ,   /**,    * Get shard leader properties, with retry if none exist.,    */,   public Replica getLeaderRetry(String collection, String shard, int timeout) throws InterruptedException {,     long timeoutAt = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeout, TimeUnit.MILLISECONDS);,     while (System.nanoTime() < timeoutAt && !closed) {,       if (clusterState != null) {    ,         Replica replica = clusterState.getLeader(collection, shard);,         if (replica != null && getClusterState().liveNodesContain(replica.getNodeName())) {,           return replica;,         },       },       Thread.sleep(50);,     },     throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, "No registered leader was found after waiting for ",         + timeout + "ms " + ", collection: " + collection + " slice: " + shard);,   }, ,   /**,    * Get path where shard leader properties live in zookeeper.,    */,   public static String getShardLeadersPath(String collection, String shardId) {,     return COLLECTIONS_ZKNODE + "/" + collection + "/",         + SHARD_LEADERS_ZKNODE + (shardId != null ? ("/" + shardId),         : "");,   }, ,   /**,    * Get path where shard leader elections ephemeral nodes are.,    */,   public static String getShardLeadersElectPath(String collection, String shardId) {,     return COLLECTIONS_ZKNODE + "/" + collection + "/",         + LEADER_ELECT_ZKNODE  + (shardId != null ? ("/" + shardId + "/" + ELECTION_NODE),         : "");,   }, , ,   public List<ZkCoreNodeProps> getReplicaProps(String collection,,       String shardId, String thisCoreNodeName) {,     return getReplicaProps(collection, shardId, thisCoreNodeName, null);,   },   ,   public List<ZkCoreNodeProps> getReplicaProps(String collection,,       String shardId, String thisCoreNodeName, String mustMatchStateFilter) {,     return getReplicaProps(collection, shardId, thisCoreNodeName, mustMatchStateFilter, null);,   },   ,   public List<ZkCoreNodeProps> getReplicaProps(String collection,,       String shardId, String thisCoreNodeName, String mustMatchStateFilter, String mustNotMatchStateFilter) {,     assert thisCoreNodeName != null;,     ClusterState clusterState = this.clusterState;,     if (clusterState == null) {,       return null;,     },     Map<String,Slice> slices = clusterState.getSlicesMap(collection);,     if (slices == null) {,       throw new ZooKeeperException(ErrorCode.BAD_REQUEST,,           "Could not find collection in zk: " + collection + " ",               + clusterState.getCollections());,     },     ,     Slice replicas = slices.get(shardId);,     if (replicas == null) {,       throw new ZooKeeperException(ErrorCode.BAD_REQUEST, "Could not find shardId in zk: " + shardId);,     },     ,     Map<String,Replica> shardMap = replicas.getReplicasMap();,     List<ZkCoreNodeProps> nodes = new ArrayList<>(shardMap.size());,     for (Entry<String,Replica> entry : shardMap.entrySet()) {,       ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(entry.getValue());,       ,       String coreNodeName = entry.getValue().getName();,       ,       if (clusterState.liveNodesContain(nodeProps.getNodeName()) && !coreNodeName.equals(thisCoreNodeName)) {,         if (mustMatchStateFilter == null || mustMatchStateFilter.equals(nodeProps.getState())) {,           if (mustNotMatchStateFilter == null || !mustNotMatchStateFilter.equals(nodeProps.getState())) {,             nodes.add(nodeProps);,           },         },       },     },     if (nodes.size() == 0) {,       // no replicas,       return null;,     }, ,     return nodes;,   }, ,   public SolrZkClient getZkClient() {,     return zkClient;,   }, ,   public void updateAliases() throws KeeperException, InterruptedException {,     byte[] data = zkClient.getData(ALIASES, null, null, true);, ,     Aliases aliases = ClusterState.load(data);, ,     ZkStateReader.this.aliases = aliases;,   },   public Map getClusterProps(){,     Map result = null;,     try {,       if(getZkClient().exists(ZkStateReader.CLUSTER_PROPS, true)){,         result = (Map) ZkStateReader.fromJSON(getZkClient().getData(ZkStateReader.CLUSTER_PROPS, null, new Stat(), true)) ;,       } else {,         result= new LinkedHashMap();,       },       return result;,     } catch (Exception e) {,       throw new SolrException(ErrorCode.SERVER_ERROR,"Error reading cluster properties",e) ;,     },   },   ,   /**,    * Returns the baseURL corresponding to a given node's nodeName --,    * NOTE: does not (currently) imply that the nodeName (or resulting ,    * baseURL) exists in the cluster.,    * @lucene.experimental,    */,   public String getBaseUrlForNodeName(final String nodeName) {,     final int _offset = nodeName.indexOf("_");,     if (_offset < 0) {,       throw new IllegalArgumentException("nodeName does not contain expected '_' seperator: " + nodeName);,     },     final String hostAndPort = nodeName.substring(0,_offset);,     try {,       final String path = URLDecoder.decode(nodeName.substring(1+_offset), "UTF-8");,       String urlScheme = (String) getClusterProps().get(URL_SCHEME);,       if(urlScheme == null) {,         urlScheme = "http";,       },       return urlScheme + "://" + hostAndPort + (path.isEmpty() ? "" : ("/" + path));,     } catch (UnsupportedEncodingException e) {,       throw new IllegalStateException("JVM Does not seem to support UTF-8", e);,     },   }, ,   public static DocCollection getCollectionLive(ZkStateReader zkStateReader,,       String coll) {,     String collectionPath = getCollectionPath(coll);,     try {,       if (!zkStateReader.getZkClient().exists(collectionPath, true)) return null;,       Stat stat = new Stat();,       byte[] data = zkStateReader.getZkClient().getData(collectionPath, null, stat, true);,       ClusterState state = ClusterState.load(stat.getVersion(), data,,           Collections.<String> emptySet(), collectionPath);,       ClusterState.CollectionRef collectionRef = state.getCollectionStates().get(coll);,       return collectionRef == null ? null : collectionRef.get();,     } catch (KeeperException.NoNodeException e) {,       log.warn("No node available : " + collectionPath, e);,       return null;,     } catch (KeeperException e) {,       throw new SolrException(ErrorCode.BAD_REQUEST,,           "Could not load collection from ZK:" + coll, e);,     } catch (InterruptedException e) {,       Thread.currentThread().interrupt();,       throw new SolrException(ErrorCode.BAD_REQUEST,,           "Could not load collection from ZK:" + coll, e);,     },   }, ,   public static String getCollectionPath(String coll) {,     return COLLECTIONS_ZKNODE+"/"+coll + "/state.json";,   }, ,   public void addCollectionWatch(String coll) throws KeeperException, InterruptedException {,     synchronized (this) {,       if (watchedCollections.contains(coll)) return;,       else {,         watchedCollections.add(coll);,       },       addZkWatch(coll);,     },   }, ,   private void addZkWatch(final String coll) throws KeeperException,,       InterruptedException {,     log.info("addZkWatch {}", coll);,     final String fullpath = getCollectionPath(coll);,     synchronized (getUpdateLock()) {,       ,       cmdExecutor.ensureExists(fullpath, zkClient);,       log.info("Updating collection state at {} from ZooKeeper... ", fullpath);,       ,       Watcher watcher = new Watcher() {,         ,         @Override,         public void process(WatchedEvent event) {,           // session events are not change events,,           // and do not remove the watcher,           if (EventType.None.equals(event.getType())) {,             return;,           },           log.info("A cluster state change: {}, has occurred - updating... ",,               (event), ZkStateReader.this.clusterState == null ? 0,                   : ZkStateReader.this.clusterState.getLiveNodes().size());,           try {,             ,             // delayed approach,             // ZkStateReader.this.updateClusterState(false, false);,             synchronized (ZkStateReader.this.getUpdateLock()) {,               if (!watchedCollections.contains(coll)) {,                 log.info("Unwatched collection {}", coll);,                 return;,               },               // remake watch,               final Watcher thisWatch = this;,               Stat stat = new Stat();,               byte[] data = zkClient.getData(fullpath, thisWatch, stat, true);,               ,               if (data == null || data.length == 0) {,                 log.warn("No value set for collection state : {}", coll);,                 return;,                 ,               },               ClusterState clusterState = ClusterState.load(stat.getVersion(),,                   data, Collections.<String> emptySet(), fullpath);,               // update volatile,               ,               DocCollection newState = clusterState.getCollectionStates(),                   .get(coll).get();,               updateWatchedCollection(newState);,               ,             },           } catch (KeeperException e) {,             if (e.code() == KeeperException.Code.SESSIONEXPIRED,                 || e.code() == KeeperException.Code.CONNECTIONLOSS) {,               log.warn("ZooKeeper watch triggered, but Solr cannot talk to ZK");,               return;,             },             log.error("Unwatched collection :" + coll, e);,             throw new ZooKeeperException(ErrorCode.SERVER_ERROR, "", e);,             ,           } catch (InterruptedException e) {,             Thread.currentThread().interrupt();,             log.error("Unwatched collection :" + coll, e);,             return;,           },         },         ,       };,       zkClient.exists(fullpath, watcher, true);,     },     updateWatchedCollection(getCollectionLive(this, coll));,   },   ,   private void updateWatchedCollection(DocCollection newState) {,     watchedCollectionStates.put(newState.getName(), newState);,     log.info("Updating data for {} to ver {} ", newState.getName(),,         newState.getZNodeVersion());,     ,     this.clusterState = clusterState.copyWith(newState.getName(), newState);,   },   ,   /** This is not a public API. Only used by ZkController */,   public void removeZKWatch(final String coll) {,     synchronized (this) {,       watchedCollections.remove(coll);,       watchedCollectionStates.remove(coll);,       try {,         updateClusterState(true);,       } catch (KeeperException e) {,         log.error("Error updating state",e);,       } catch (InterruptedException e) {,         log.error("Error updating state",e);,         Thread.currentThread().interrupt();,       },     },   }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/impl/CloudSolrClient.java,,87-1154,[@SuppressWarnings("serial"), public class CloudSolrClient extends SolrClient {,   protected static final Logger log = LoggerFactory.getLogger(CloudSolrClient.class);, ,   private volatile ZkStateReader zkStateReader;,   private String zkHost; // the zk server connect string,   private int zkConnectTimeout = 10000;,   private int zkClientTimeout = 10000;,   private volatile String defaultCollection;,   private final LBHttpSolrClient lbClient;,   private final boolean shutdownLBHttpSolrServer;,   private HttpClient myClient;,   private final boolean clientIsInternal;,   //no of times collection state to be reloaded if stale state error is received,   private static final int MAX_STALE_RETRIES = 5;,   Random rand = new Random();,   ,   private final boolean updatesToLeaders;,   private boolean parallelUpdates = true;,   private ExecutorService threadPool = Executors,       .newCachedThreadPool(new SolrjNamedThreadFactory(,           "CloudSolrServer ThreadPool"));,   private String idField = "id";,   public static final String STATE_VERSION = "_stateVer_";,   private final Set<String> NON_ROUTABLE_PARAMS;,   {,     NON_ROUTABLE_PARAMS = new HashSet<>();,     NON_ROUTABLE_PARAMS.add(UpdateParams.EXPUNGE_DELETES);,     NON_ROUTABLE_PARAMS.add(UpdateParams.MAX_OPTIMIZE_SEGMENTS);,     NON_ROUTABLE_PARAMS.add(UpdateParams.COMMIT);,     NON_ROUTABLE_PARAMS.add(UpdateParams.WAIT_SEARCHER);,     NON_ROUTABLE_PARAMS.add(UpdateParams.OPEN_SEARCHER);,     ,     NON_ROUTABLE_PARAMS.add(UpdateParams.SOFT_COMMIT);,     NON_ROUTABLE_PARAMS.add(UpdateParams.PREPARE_COMMIT);,     NON_ROUTABLE_PARAMS.add(UpdateParams.OPTIMIZE);,     ,     // Not supported via SolrCloud,     // NON_ROUTABLE_PARAMS.add(UpdateParams.ROLLBACK);, ,   },   private volatile long timeToLive = 60* 1000L;, , ,   protected Map<String, ExpiringCachedDocCollection> collectionStateCache = new ConcurrentHashMap<String, ExpiringCachedDocCollection>(){,     @Override,     public ExpiringCachedDocCollection get(Object key) {,       ExpiringCachedDocCollection val = super.get(key);,       if(val == null) return null;,       if(val.isExpired(timeToLive)) {,         super.remove(key);,         return null;,       },       return val;,     }, ,   };, ,   class ExpiringCachedDocCollection {,     DocCollection cached;,     long cachedAt;, ,     ExpiringCachedDocCollection(DocCollection cached) {,       this.cached = cached;,       this.cachedAt = System.currentTimeMillis();,     }, ,     boolean isExpired(long timeToLive) {,       return (System.currentTimeMillis() - cachedAt) > timeToLive;,     },   }, ,   /**,    * Create a new client object that connects to Zookeeper and is always aware,    * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and,    * SolrCloud has enough replicas for every shard in a collection, there is no,    * single point of failure. Updates will be sent to shard leaders by default.,    * ,    * @param zkHost,    *          The client endpoint of the zookeeper quorum containing the cloud,    *          state. The full specification for this string is one or more comma,    *          separated HOST:PORT values, followed by an optional chroot value,    *          that starts with a forward slash. Using a chroot allows multiple,    *          applications to coexist in one ensemble. For full details, see the,    *          Zookeeper documentation. Some examples:,    *          <p/>,    *          "host1:2181",    *          <p/>,    *          "host1:2181,host2:2181,host3:2181/mysolrchroot",    *          <p/>,    *          "zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181",    */,   public CloudSolrClient(String zkHost) {,       this.zkHost = zkHost;,       this.clientIsInternal = true;,       this.myClient = HttpClientUtil.createClient(null);,       this.lbClient = new LBHttpSolrClient(myClient);,       this.lbClient.setRequestWriter(new BinaryRequestWriter());,       this.lbClient.setParser(new BinaryResponseParser());,       this.updatesToLeaders = true;,       shutdownLBHttpSolrServer = true;,       lbClient.addQueryParams(STATE_VERSION);,   }, ,   /**,    * Create a new client object that connects to Zookeeper and is always aware,    * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and,    * SolrCloud has enough replicas for every shard in a collection, there is no,    * single point of failure. Updates will be sent to shard leaders by default.,    *,    * @param zkHost,    *          The client endpoint of the zookeeper quorum containing the cloud,    *          state. The full specification for this string is one or more comma,    *          separated HOST:PORT values, followed by an optional chroot value,    *          that starts with a forward slash. Using a chroot allows multiple,    *          applications to coexist in one ensemble. For full details, see the,    *          Zookeeper documentation. Some examples:,    *          <p/>,    *          "host1:2181",    *          <p/>,    *          "host1:2181,host2:2181,host3:2181/mysolrchroot",    *          <p/>,    *          "zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181",    * @param httpClient,    *          the {@link HttpClient} instance to be used for all requests. The,    *          provided httpClient should use a multi-threaded connection manager.,    */,   public CloudSolrClient(String zkHost, HttpClient httpClient)  {,     this.zkHost = zkHost;,     this.clientIsInternal = httpClient == null;,     this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;,     this.lbClient = new LBHttpSolrClient(myClient);,     this.lbClient.setRequestWriter(new BinaryRequestWriter());,     this.lbClient.setParser(new BinaryResponseParser());,     this.updatesToLeaders = true;,     shutdownLBHttpSolrServer = true;,     lbClient.addQueryParams(STATE_VERSION);,   },   ,   /**,    * Create a new client object using multiple string values in a Collection,    * instead of a standard zkHost connection string. Note that this method will,    * not be used if there is only one String argument - that will use,    * {@link #CloudSolrClient(String)} instead.,    * ,    * @param zkHosts,    *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for,    *          each host in the zookeeper ensemble. Note that with certain,    *          Collection types like HashSet, the order of hosts in the final,    *          connect string may not be in the same order you added them.,    * @param chroot,    *          A chroot value for zookeeper, starting with a forward slash. If no,    *          chroot is required, use null.,    * @throws IllegalArgumentException,    *           if the chroot value does not start with a forward slash.,    * @see #CloudSolrClient(String),    */,   public CloudSolrClient(Collection<String> zkHosts, String chroot) {,     this(zkHosts, chroot, null);,   }, ,   /**,    * Create a new client object using multiple string values in a Collection,    * instead of a standard zkHost connection string. Note that this method will,    * not be used if there is only one String argument - that will use,    * {@link #CloudSolrClient(String)} instead.,    *,    * @param zkHosts,    *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for,    *          each host in the zookeeper ensemble. Note that with certain,    *          Collection types like HashSet, the order of hosts in the final,    *          connect string may not be in the same order you added them.,    * @param chroot,    *          A chroot value for zookeeper, starting with a forward slash. If no,    *          chroot is required, use null.,    * @param httpClient,    *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a,    *          multi-threaded connection manager.,    * @throws IllegalArgumentException,    *           if the chroot value does not start with a forward slash.,    * @see #CloudSolrClient(String),    */,   public CloudSolrClient(Collection<String> zkHosts, String chroot, HttpClient httpClient) {,     StringBuilder zkBuilder = new StringBuilder();,     int lastIndexValue = zkHosts.size() - 1;,     int i = 0;,     for (String zkHost : zkHosts) {,       zkBuilder.append(zkHost);,       if (i < lastIndexValue) {,         zkBuilder.append(",");,       },       i++;,     },     if (chroot != null) {,       if (chroot.startsWith("/")) {,         zkBuilder.append(chroot);,       } else {,         throw new IllegalArgumentException(,             "The chroot must start with a forward slash.");,       },     }, ,     /* Log the constructed connection string and then initialize. */,     log.info("Final constructed zkHost string: " + zkBuilder.toString());, ,     this.zkHost = zkBuilder.toString();,     this.clientIsInternal = httpClient == null;,     this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;,     this.lbClient = new LBHttpSolrClient(myClient);,     this.lbClient.setRequestWriter(new BinaryRequestWriter());,     this.lbClient.setParser(new BinaryResponseParser());,     this.updatesToLeaders = true;,     shutdownLBHttpSolrServer = true;,   },   ,   /**,    * @param zkHost,    *          A zookeeper client endpoint.,    * @param updatesToLeaders,    *          If true, sends updates only to shard leaders.,    * @see #CloudSolrClient(String) for full description and details on zkHost,    */,   public CloudSolrClient(String zkHost, boolean updatesToLeaders) {,     this(zkHost, updatesToLeaders, null);,   }, ,   /**,    * @param zkHost,    *          A zookeeper client endpoint.,    * @param updatesToLeaders,    *          If true, sends updates only to shard leaders.,    * @param httpClient,    *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a,    *          multi-threaded connection manager.,    * @see #CloudSolrClient(String) for full description and details on zkHost,    */,   public CloudSolrClient(String zkHost, boolean updatesToLeaders, HttpClient httpClient) {,     this.zkHost = zkHost;,     this.clientIsInternal = httpClient == null;,     this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;,     this.lbClient = new LBHttpSolrClient(myClient);,     this.lbClient.setRequestWriter(new BinaryRequestWriter());,     this.lbClient.setParser(new BinaryResponseParser());,     this.updatesToLeaders = updatesToLeaders;,     shutdownLBHttpSolrServer = true;,     lbClient.addQueryParams(STATE_VERSION);,   }, ,   /**Sets the cache ttl for DocCollection Objects cached  . This is only applicable for collections which are persisted outside of clusterstate.json,    * @param seconds ttl value in seconds,    */,   public void setCollectionCacheTTl(int seconds){,     assert seconds > 0;,     timeToLive = seconds*1000L;,   }, ,   /**,    * @param zkHost,    *          A zookeeper client endpoint.,    * @param lbClient,    *          LBHttpSolrServer instance for requests.,    * @see #CloudSolrClient(String) for full description and details on zkHost,    */,   public CloudSolrClient(String zkHost, LBHttpSolrClient lbClient) {,     this(zkHost, lbClient, true);,   },   ,   /**,    * @param zkHost,    *          A zookeeper client endpoint.,    * @param lbClient,    *          LBHttpSolrServer instance for requests.,    * @param updatesToLeaders,    *          If true, sends updates only to shard leaders.,    * @see #CloudSolrClient(String) for full description and details on zkHost,    */,   public CloudSolrClient(String zkHost, LBHttpSolrClient lbClient, boolean updatesToLeaders) {,     this.zkHost = zkHost;,     this.lbClient = lbClient;,     this.updatesToLeaders = updatesToLeaders;,     shutdownLBHttpSolrServer = false;,     this.clientIsInternal = false;,     lbClient.addQueryParams(STATE_VERSION);,   },   ,   public ResponseParser getParser() {,     return lbClient.getParser();,   },   ,   /**,    * Note: This setter method is <b>not thread-safe</b>.,    * ,    * @param processor,    *          Default Response Parser chosen to parse the response if the parser,    *          were not specified as part of the request.,    * @see org.apache.solr.client.solrj.SolrRequest#getResponseParser(),    */,   public void setParser(ResponseParser processor) {,     lbClient.setParser(processor);,   },   ,   public RequestWriter getRequestWriter() {,     return lbClient.getRequestWriter();,   },   ,   public void setRequestWriter(RequestWriter requestWriter) {,     lbClient.setRequestWriter(requestWriter);,   }, ,   /**,    * @return the zkHost value used to connect to zookeeper.,    */,   public String getZkHost() {,     return zkHost;,   }, ,   public ZkStateReader getZkStateReader() {,     return zkStateReader;,   }, ,   /**,    * @param idField the field to route documents on.,    */,   public void setIdField(String idField) {,     this.idField = idField;,   }, ,   /**,    * @return the field that updates are routed on.,    */,   public String getIdField() {,     return idField;,   },   ,   /** Sets the default collection for request */,   public void setDefaultCollection(String collection) {,     this.defaultCollection = collection;,   }, ,   /** Gets the default collection for request */,   public String getDefaultCollection() {,     return defaultCollection;,   }, ,   /** Set the connect timeout to the zookeeper ensemble in ms */,   public void setZkConnectTimeout(int zkConnectTimeout) {,     this.zkConnectTimeout = zkConnectTimeout;,   }, ,   /** Set the timeout to the zookeeper ensemble in ms */,   public void setZkClientTimeout(int zkClientTimeout) {,     this.zkClientTimeout = zkClientTimeout;,   }, ,   /**,    * Connect to the zookeeper ensemble.,    * This is an optional method that may be used to force a connect before any other requests are sent.,    *,    */,   public void connect() {,     if (zkStateReader == null) {,       synchronized (this) {,         if (zkStateReader == null) {,           ZkStateReader zk = null;,           try {,             zk = new ZkStateReader(zkHost, zkClientTimeout,,                 zkConnectTimeout);,             zk.createClusterStateWatchersAndUpdate();,             zkStateReader = zk;,           } catch (InterruptedException e) {,             if (zk != null) zk.close();,             Thread.currentThread().interrupt();,             throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,,                 "", e);,           } catch (KeeperException e) {,             if (zk != null) zk.close();,             throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,,                 "", e);,           } catch (IOException e) {,             if (zk != null) zk.close();,             throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,,                 "", e);,           } catch (TimeoutException e) {,             if (zk != null) zk.close();,             throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,,                 "", e);,           } catch (Exception e) {,             if (zk != null) zk.close();,             // do not wrap because clients may be relying on the underlying exception being thrown,             throw e;,           },         },       },     },   }, ,   public void setParallelUpdates(boolean parallelUpdates) {,     this.parallelUpdates = parallelUpdates;,   }, ,   private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {,     UpdateRequest updateRequest = (UpdateRequest) request;,     ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();,     ModifiableSolrParams routableParams = new ModifiableSolrParams();,     ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();, ,     if(params != null) {,       nonRoutableParams.add(params);,       routableParams.add(params);,       for(String param : NON_ROUTABLE_PARAMS) {,         routableParams.remove(param);,       },     }, ,     String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);,     if (collection == null) {,       throw new SolrServerException("No collection param specified on request and no default collection has been set.");,     }, , ,     //Check to see if the collection is an alias.,     Aliases aliases = zkStateReader.getAliases();,     if(aliases != null) {,       Map<String, String> collectionAliases = aliases.getCollectionAliasMap();,       if(collectionAliases != null && collectionAliases.containsKey(collection)) {,         collection = collectionAliases.get(collection);,       },     }, ,     DocCollection col = getDocCollection(clusterState, collection);, ,     DocRouter router = col.getRouter();,     ,     if (router instanceof ImplicitDocRouter) {,       // short circuit as optimization,       return null;,     }, ,     //Create the URL map, which is keyed on slice name.,     //The value is a list of URLs for each replica in the slice.,     //The first value in the list is the leader for the slice.,     Map<String,List<String>> urlMap = buildUrlMap(col);,     if (urlMap == null) {,       // we could not find a leader yet - use unoptimized general path,       return null;,     }, ,     NamedList<Throwable> exceptions = new NamedList<>();,     NamedList<NamedList> shardResponses = new NamedList<>();, ,     Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);,     if (routes == null) {,       return null;,     }, ,     long start = System.nanoTime();, ,     if (parallelUpdates) {,       final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());,       for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {,         final String url = entry.getKey();,         final LBHttpSolrClient.Req lbRequest = entry.getValue();,         responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {,           @Override,           public NamedList<?> call() throws Exception {,             return lbClient.request(lbRequest).getResponse();,           },         }));,       }, ,       for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {,         final String url = entry.getKey();,         final Future<NamedList<?>> responseFuture = entry.getValue();,         try {,           shardResponses.add(url, responseFuture.get());,         } catch (InterruptedException e) {,           Thread.currentThread().interrupt();,           throw new RuntimeException(e);,         } catch (ExecutionException e) {,           exceptions.add(url, e.getCause());,         },       }, ,       if (exceptions.size() > 0) {,         throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);,       },     } else {,       for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {,         String url = entry.getKey();,         LBHttpSolrClient.Req lbRequest = entry.getValue();,         try {,           NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();,           shardResponses.add(url, rsp);,         } catch (Exception e) {,           throw new SolrServerException(e);,         },       },     }, ,     UpdateRequest nonRoutableRequest = null;,     List<String> deleteQuery = updateRequest.getDeleteQuery();,     if (deleteQuery != null && deleteQuery.size() > 0) {,       UpdateRequest deleteQueryRequest = new UpdateRequest();,       deleteQueryRequest.setDeleteQuery(deleteQuery);,       nonRoutableRequest = deleteQueryRequest;,     },     ,     Set<String> paramNames = nonRoutableParams.getParameterNames();,     ,     Set<String> intersection = new HashSet<>(paramNames);,     intersection.retainAll(NON_ROUTABLE_PARAMS);,     ,     if (nonRoutableRequest != null || intersection.size() > 0) {,       if (nonRoutableRequest == null) {,         nonRoutableRequest = new UpdateRequest();,       },       nonRoutableRequest.setParams(nonRoutableParams);,       List<String> urlList = new ArrayList<>();,       urlList.addAll(routes.keySet());,       Collections.shuffle(urlList, rand);,       LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);,       try {,         LBHttpSolrClient.Rsp rsp = lbClient.request(req);,         shardResponses.add(urlList.get(0), rsp.getResponse());,       } catch (Exception e) {,         throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);,       },     }, ,     long end = System.nanoTime();, ,     RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));,     rr.setRouteResponses(shardResponses);,     rr.setRoutes(routes);,     return rr;,   }, ,   private Map<String,List<String>> buildUrlMap(DocCollection col) {,     Map<String, List<String>> urlMap = new HashMap<>();,     Collection<Slice> slices = col.getActiveSlices();,     Iterator<Slice> sliceIterator = slices.iterator();,     while (sliceIterator.hasNext()) {,       Slice slice = sliceIterator.next();,       String name = slice.getName();,       List<String> urls = new ArrayList<>();,       Replica leader = slice.getLeader();,       if (leader == null) {,         // take unoptimized general path - we cannot find a leader yet,         return null;,       },       ZkCoreNodeProps zkProps = new ZkCoreNodeProps(leader);,       String url = zkProps.getCoreUrl();,       urls.add(url);,       Collection<Replica> replicas = slice.getReplicas();,       Iterator<Replica> replicaIterator = replicas.iterator();,       while (replicaIterator.hasNext()) {,         Replica replica = replicaIterator.next();,         if (!replica.getNodeName().equals(leader.getNodeName()) &&,             !replica.getName().equals(leader.getName())) {,           ZkCoreNodeProps zkProps1 = new ZkCoreNodeProps(replica);,           String url1 = zkProps1.getCoreUrl();,           urls.add(url1);,         },       },       urlMap.put(name, urls);,     },     return urlMap;,   }, ,   public RouteResponse condenseResponse(NamedList response, long timeMillis) {,     RouteResponse condensed = new RouteResponse();,     int status = 0;,     Integer rf = null;,     Integer minRf = null;,     for(int i=0; i<response.size(); i++) {,       NamedList shardResponse = (NamedList)response.getVal(i);,       NamedList header = (NamedList)shardResponse.get("responseHeader");      ,       Integer shardStatus = (Integer)header.get("status");,       int s = shardStatus.intValue();,       if(s > 0) {,           status = s;,       },       Object rfObj = header.get(UpdateRequest.REPFACT);,       if (rfObj != null && rfObj instanceof Integer) {,         Integer routeRf = (Integer)rfObj;,         if (rf == null || routeRf < rf),           rf = routeRf;,       },       minRf = (Integer)header.get(UpdateRequest.MIN_REPFACT);,     }, ,     NamedList cheader = new NamedList();,     cheader.add("status", status);,     cheader.add("QTime", timeMillis);,     if (rf != null),       cheader.add(UpdateRequest.REPFACT, rf);,     if (minRf != null),       cheader.add(UpdateRequest.MIN_REPFACT, minRf);,     ,     condensed.add("responseHeader", cheader);,     return condensed;,   }, ,   public static class RouteResponse extends NamedList {,     private NamedList routeResponses;,     private Map<String, LBHttpSolrClient.Req> routes;, ,     public void setRouteResponses(NamedList routeResponses) {,       this.routeResponses = routeResponses;,     }, ,     public NamedList getRouteResponses() {,       return routeResponses;,     }, ,     public void setRoutes(Map<String, LBHttpSolrClient.Req> routes) {,       this.routes = routes;,     }, ,     public Map<String, LBHttpSolrClient.Req> getRoutes() {,       return routes;,     }, ,   }, ,   public static class RouteException extends SolrException {, ,     private NamedList<Throwable> throwables;,     private Map<String, LBHttpSolrClient.Req> routes;, ,     public RouteException(ErrorCode errorCode, NamedList<Throwable> throwables, Map<String, LBHttpSolrClient.Req> routes){,       super(errorCode, throwables.getVal(0).getMessage(), throwables.getVal(0));,       this.throwables = throwables;,       this.routes = routes;,     }, ,     public NamedList<Throwable> getThrowables() {,       return throwables;,     }, ,     public Map<String, LBHttpSolrClient.Req> getRoutes() {,       return this.routes;,     },   }, ,   @Override,   public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {,     SolrParams reqParams = request.getParams();,     String collection = (reqParams != null) ? reqParams.get("collection", getDefaultCollection()) : getDefaultCollection();,     return requestWithRetryOnStaleState(request, 0, collection);,   }, ,   /**,    * As this class doesn't watch external collections on the client side,,    * there's a chance that the request will fail due to cached stale state,,    * which means the state must be refreshed from ZK and retried.,    */,   protected NamedList<Object> requestWithRetryOnStaleState(SolrRequest request, int retryCount, String collection),       throws SolrServerException, IOException {, ,     connect(); // important to call this before you start working with the ZkStateReader, ,     // build up a _stateVer_ param to pass to the server containing all of the,     // external collection state versions involved in this request, which allows,     // the server to notify us that our cached state for one or more of the external,     // collections is stale and needs to be refreshed ... this code has no impact on internal collections,     String stateVerParam = null;,     List<DocCollection> requestedCollections = null;,     if (collection != null && !request.getPath().startsWith("/admin")) { // don't do _stateVer_ checking for admin requests,       Set<String> requestedCollectionNames = getCollectionList(getZkStateReader().getClusterState(), collection);, ,       StringBuilder stateVerParamBuilder = null;,       for (String requestedCollection : requestedCollectionNames) {,         // track the version of state we're using on the client side using the _stateVer_ param,         DocCollection coll = getDocCollection(getZkStateReader().getClusterState(), requestedCollection);,         int collVer = coll.getZNodeVersion();,         if (coll.getStateFormat()>1) {,           if(requestedCollections == null) requestedCollections = new ArrayList<>(requestedCollectionNames.size());,           requestedCollections.add(coll);, ,           if (stateVerParamBuilder == null) {,             stateVerParamBuilder = new StringBuilder();,           } else {,             stateVerParamBuilder.append("|"); // hopefully pipe is not an allowed char in a collection name,           }, ,           stateVerParamBuilder.append(coll.getName()).append(":").append(collVer);,         },       }, ,       if (stateVerParamBuilder != null) {,         stateVerParam = stateVerParamBuilder.toString();,       },     }, ,     if (request.getParams() instanceof ModifiableSolrParams) {,       ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();,       if (stateVerParam != null) {,         params.set(STATE_VERSION, stateVerParam);,       } else {,         params.remove(STATE_VERSION);,       },     } // else: ??? how to set this ???, ,     NamedList<Object> resp = null;,     try {,       resp = sendRequest(request);,     } catch (Exception exc) {, ,       Throwable rootCause = SolrException.getRootCause(exc);,       // don't do retry support for admin requests or if the request doesn't have a collection specified,       if (collection == null || request.getPath().startsWith("/admin")) {,         if (exc instanceof SolrServerException) {,           throw (SolrServerException)exc;,         } else if (exc instanceof IOException) {,           throw (IOException)exc;,         }else if (exc instanceof RuntimeException) {,           throw (RuntimeException) exc;,         },         else {,           throw new SolrServerException(rootCause);,         },       }, ,       int errorCode = (rootCause instanceof SolrException) ?,           ((SolrException)rootCause).code() : SolrException.ErrorCode.UNKNOWN.code;, ,       log.error("Request to collection {} failed due to ("+errorCode+,           ") {}, retry? "+retryCount, collection, rootCause.toString());, ,       boolean wasCommError =,           (rootCause instanceof ConnectException ||,               rootCause instanceof ConnectTimeoutException ||,               rootCause instanceof NoHttpResponseException ||,               rootCause instanceof SocketException);, ,       boolean stateWasStale = false;,       if (retryCount < MAX_STALE_RETRIES  &&,           requestedCollections != null    &&,           !requestedCollections.isEmpty() &&,           SolrException.ErrorCode.getErrorCode(errorCode) == SolrException.ErrorCode.INVALID_STATE),       {,         // cached state for one or more external collections was stale,         // re-issue request using updated state,         stateWasStale = true;, ,         // just re-read state for all of them, which is a little heavy handed but hopefully a rare occurrence,         for (DocCollection ext : requestedCollections) {,           collectionStateCache.remove(ext.getName());,         },       }, ,       // if we experienced a communication error, it's worth checking the state,       // with ZK just to make sure the node we're trying to hit is still part of the collection,       if (retryCount < MAX_STALE_RETRIES &&,           !stateWasStale &&,           requestedCollections != null &&,           !requestedCollections.isEmpty() &&,           wasCommError) {,         for (DocCollection ext : requestedCollections) {,           DocCollection latestStateFromZk = getDocCollection(zkStateReader.getClusterState(), ext.getName());,           if (latestStateFromZk.getZNodeVersion() != ext.getZNodeVersion()) {,             // looks like we couldn't reach the server because the state was stale == retry,             stateWasStale = true;,             // we just pulled state from ZK, so update the cache so that the retry uses it,             collectionStateCache.put(ext.getName(), new ExpiringCachedDocCollection(latestStateFromZk));,           },         },       }, ,       if (requestedCollections != null) {,         requestedCollections.clear(); // done with this,       }, ,       // if the state was stale, then we retry the request once with new state pulled from Zk,       if (stateWasStale) {,         log.warn("Re-trying request to  collection(s) "+collection+" after stale state error from server.");,         resp = requestWithRetryOnStaleState(request, retryCount+1, collection);,       } else {,         if (exc instanceof SolrServerException) {,           throw (SolrServerException)exc;,         } else if (exc instanceof IOException) {,           throw (IOException)exc;,         } else {,           throw new SolrServerException(rootCause);,         },       },     }, ,     return resp;,   }, ,   protected NamedList<Object> sendRequest(SolrRequest request),       throws SolrServerException, IOException {,     connect();,     ,     ClusterState clusterState = zkStateReader.getClusterState();,     ,     boolean sendToLeaders = false;,     List<String> replicas = null;,     ,     if (request instanceof IsUpdateRequest) {,       if (request instanceof UpdateRequest) {,         NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,,             clusterState);,         if (response != null) {,           return response;,         },       },       sendToLeaders = true;,       replicas = new ArrayList<>();,     },     ,     SolrParams reqParams = request.getParams();,     if (reqParams == null) {,       reqParams = new ModifiableSolrParams();,     },     List<String> theUrlList = new ArrayList<>();,     if (request.getPath().equals("/admin/collections"),         || request.getPath().equals("/admin/cores")) {,       Set<String> liveNodes = clusterState.getLiveNodes();,       for (String liveNode : liveNodes) {,         theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));,       },     } else {,       String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);,       ,       if (collection == null) {,         throw new SolrServerException(,             "No collection param specified on request and no default collection has been set.");,       },       ,       Set<String> collectionsList = getCollectionList(clusterState, collection);,       if (collectionsList.size() == 0) {,         throw new SolrException(ErrorCode.BAD_REQUEST,,             "Could not find collection: " + collection);,       }, ,       String shardKeys =  reqParams.get(ShardParams._ROUTE_);,       if(shardKeys == null) {,         shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated,       }, ,       // TODO: not a big deal because of the caching, but we could avoid looking,       // at every shard,       // when getting leaders if we tweaked some things,       ,       // Retrieve slices from the cloud state and, for each collection,       // specified,,       // add it to the Map of slices.,       Map<String,Slice> slices = new HashMap<>();,       for (String collectionName : collectionsList) {,         DocCollection col = getDocCollection(clusterState, collectionName);,         Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);,         ClientUtils.addSlices(slices, collectionName, routeSlices, true);,       },       Set<String> liveNodes = clusterState.getLiveNodes();, ,       List<String> leaderUrlList = null;,       List<String> urlList = null;,       List<String> replicasList = null;,       ,       // build a map of unique nodes,       // TODO: allow filtering by group, role, etc,       Map<String,ZkNodeProps> nodes = new HashMap<>();,       List<String> urlList2 = new ArrayList<>();,       for (Slice slice : slices.values()) {,         for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {,           ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);,           String node = coreNodeProps.getNodeName();,           if (!liveNodes.contains(coreNodeProps.getNodeName()),               || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;,           if (nodes.put(node, nodeProps) == null) {,             if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {,               String url;,               if (reqParams.get(UpdateParams.COLLECTION) == null) {,                 url = ZkCoreNodeProps.getCoreUrl(,                     nodeProps.getStr(ZkStateReader.BASE_URL_PROP),,                     defaultCollection);,               } else {,                 url = coreNodeProps.getCoreUrl();,               },               urlList2.add(url);,             } else if (sendToLeaders) {,               String url;,               if (reqParams.get(UpdateParams.COLLECTION) == null) {,                 url = ZkCoreNodeProps.getCoreUrl(,                     nodeProps.getStr(ZkStateReader.BASE_URL_PROP),,                     defaultCollection);,               } else {,                 url = coreNodeProps.getCoreUrl();,               },               replicas.add(url);,             },           },         },       },       ,       if (sendToLeaders) {,         leaderUrlList = urlList2;,         replicasList = replicas;,       } else {,         urlList = urlList2;,       },       ,       if (sendToLeaders) {,         theUrlList = new ArrayList<>(leaderUrlList.size());,         theUrlList.addAll(leaderUrlList);,       } else {,         theUrlList = new ArrayList<>(urlList.size());,         theUrlList.addAll(urlList);,       },       if(theUrlList.isEmpty()) {,         throw new SolrException(SolrException.ErrorCode.INVALID_STATE, "Not enough nodes to handle the request");,       }, ,       Collections.shuffle(theUrlList, rand);,       if (sendToLeaders) {,         ArrayList<String> theReplicas = new ArrayList<>(,             replicasList.size());,         theReplicas.addAll(replicasList);,         Collections.shuffle(theReplicas, rand);,         theUrlList.addAll(theReplicas);,       },       ,     },     ,     LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);,     LBHttpSolrClient.Rsp rsp = lbClient.request(req);,     return rsp.getResponse();,   }, ,   private Set<String> getCollectionList(ClusterState clusterState,,       String collection) {,     // Extract each comma separated collection name and store in a List.,     List<String> rawCollectionsList = StrUtils.splitSmart(collection, ",", true);,     Set<String> collectionsList = new HashSet<>();,     // validate collections,     for (String collectionName : rawCollectionsList) {,       if (!clusterState.getCollections().contains(collectionName)) {,         Aliases aliases = zkStateReader.getAliases();,         String alias = aliases.getCollectionAlias(collectionName);,         if (alias != null) {,           List<String> aliasList = StrUtils.splitSmart(alias, ",", true);,           collectionsList.addAll(aliasList);,           continue;,         }, ,           throw new SolrException(ErrorCode.BAD_REQUEST, "Collection not found: " + collectionName);,         }, ,       collectionsList.add(collectionName);,     },     return collectionsList;,   }, ,   @Override,   public void shutdown() {,     if (zkStateReader != null) {,       synchronized(this) {,         if (zkStateReader!= null),           zkStateReader.close();,         zkStateReader = null;,       },     },     ,     if (shutdownLBHttpSolrServer) {,       lbClient.shutdown();,     },     ,     if (clientIsInternal && myClient!=null) {,       myClient.getConnectionManager().shutdown();,     }, ,     if(this.threadPool != null && !this.threadPool.isShutdown()) {,       this.threadPool.shutdown();,     },   }, ,   public LBHttpSolrClient getLbClient() {,     return lbClient;,   },   ,   public boolean isUpdatesToLeaders() {,     return updatesToLeaders;,   }, ,   protected DocCollection getDocCollection(ClusterState clusterState, String collection) throws SolrException {,     ExpiringCachedDocCollection cachedState = collectionStateCache != null ? collectionStateCache.get(collection) : null;,     if (cachedState != null && cachedState.cached != null) {,       return cachedState.cached;,     }, ,     DocCollection col = clusterState.getCollectionOrNull(collection);,     if(col == null ) return  null;,     if(col.getStateFormat() >1) collectionStateCache.put(collection, new ExpiringCachedDocCollection(col));,     return col;,   }, , ,   /**,    * Useful for determining the minimum achieved replication factor across,    * all shards involved in processing an update request, typically useful,    * for gauging the replication factor of a batch. ,    */,   @SuppressWarnings("rawtypes"),   public int getMinAchievedReplicationFactor(String collection, NamedList resp) {,     // it's probably already on the top-level header set by condense,     NamedList header = (NamedList)resp.get("responseHeader");,     Integer achRf = (Integer)header.get(UpdateRequest.REPFACT);,     if (achRf != null),       return achRf.intValue();, ,     // not on the top-level header, walk the shard route tree,     Map<String,Integer> shardRf = getShardReplicationFactor(collection, resp);,     for (Integer rf : shardRf.values()) {,       if (achRf == null || rf < achRf) {,         achRf = rf;,       },     }    ,     return (achRf != null) ? achRf.intValue() : -1;,   },   ,   /**,    * Walks the NamedList response after performing an update request looking for,    * the replication factor that was achieved in each shard involved in the request.,    * For single doc updates, there will be only one shard in the return value. ,    */,   @SuppressWarnings("rawtypes"),   public Map<String,Integer> getShardReplicationFactor(String collection, NamedList resp) {,     connect();,     ,     Map<String,Integer> results = new HashMap<String,Integer>();,     if (resp instanceof CloudSolrClient.RouteResponse) {,       NamedList routes = ((CloudSolrClient.RouteResponse)resp).getRouteResponses();,       ClusterState clusterState = zkStateReader.getClusterState();     ,       Map<String,String> leaders = new HashMap<String,String>();,       for (Slice slice : clusterState.getActiveSlices(collection)) {,         Replica leader = slice.getLeader();,         if (leader != null) {,           ZkCoreNodeProps zkProps = new ZkCoreNodeProps(leader);,           String leaderUrl = zkProps.getBaseUrl() + "/" + zkProps.getCoreName();,           leaders.put(leaderUrl, slice.getName());,           String altLeaderUrl = zkProps.getBaseUrl() + "/" + collection;,           leaders.put(altLeaderUrl, slice.getName());,         },       },       ,       Iterator<Map.Entry<String,Object>> routeIter = routes.iterator();,       while (routeIter.hasNext()) {,         Map.Entry<String,Object> next = routeIter.next();,         String host = next.getKey();,         NamedList hostResp = (NamedList)next.getValue();,         Integer rf = (Integer)((NamedList)hostResp.get("responseHeader")).get(UpdateRequest.REPFACT);,         if (rf != null) {,           String shard = leaders.get(host);,           if (shard == null) {,             if (host.endsWith("/")),               shard = leaders.get(host.substring(0,host.length()-1));,             if (shard == null) {,               shard = host;,             },           },           results.put(shard, rf);,         },       },     }    ,     return results;],,
STYLE,UC_USELESS_CONDITION,org/apache/solr/client/solrj/impl/CloudSolrClient.java,sendRequest,960-960,[            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {],,sendRequest,970-970,[            } else if (sendToLeaders) {],,
BAD_PRACTICE,SE_INNER_CLASS,org/apache/solr/client/solrj/impl/CloudSolrClient.java,,131-140,[  protected Map<String, ExpiringCachedDocCollection> collectionStateCache = new ConcurrentHashMap<String, ExpiringCachedDocCollection>(){,     @Override,     public ExpiringCachedDocCollection get(Object key) {,       ExpiringCachedDocCollection val = super.get(key);,       if(val == null) return null;,       if(val.isExpired(timeToLive)) {,         super.remove(key);,         return null;,       },       return val;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/client/solrj/impl/CloudSolrClient.java,,149-155,[    ExpiringCachedDocCollection(DocCollection cached) {,       this.cached = cached;,       this.cachedAt = System.currentTimeMillis();,     }, ,     boolean isExpired(long timeToLive) {,       return (System.currentTimeMillis() - cachedAt) > timeToLive;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,169-191,[    public Req(SolrRequest request, List<String> servers) {,       this.request = request;,       this.servers = servers;,       this.numDeadServersToTry = servers.size();,     }, ,     public SolrRequest getRequest() {,       return request;,     },     public List<String> getServers() {,       return servers;,     }, ,     /** @return the number of dead servers to try if there are no live servers left */,     public int getNumDeadServersToTry() {,       return numDeadServersToTry;,     }, ,     /** @param numDeadServersToTry The number of dead servers to try if there are no live servers left.,      * Defaults to the number of servers in this request. */,     public void setNumDeadServersToTry(int numDeadServersToTry) {,       this.numDeadServersToTry = numDeadServersToTry;,     }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/solr/common/util/NamedList.java,equals,704-706,[    if (!(obj instanceof NamedList)) return false;,     NamedList<?> nl = (NamedList<?>) obj;,     return this.nvPairs.equals(nl.nvPairs);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,169-191,[    public Req(SolrRequest request, List<String> servers) {,       this.request = request;,       this.servers = servers;,       this.numDeadServersToTry = servers.size();,     }, ,     public SolrRequest getRequest() {,       return request;,     },     public List<String> getServers() {,       return servers;,     }, ,     /** @return the number of dead servers to try if there are no live servers left */,     public int getNumDeadServersToTry() {,       return numDeadServersToTry;,     }, ,     /** @param numDeadServersToTry The number of dead servers to try if there are no live servers left.,      * Defaults to the number of servers in this request. */,     public void setNumDeadServersToTry(int numDeadServersToTry) {,       this.numDeadServersToTry = numDeadServersToTry;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/impl/CloudSolrClient.java,,690-707,[  public static class RouteResponse extends NamedList {,     private NamedList routeResponses;,     private Map<String, LBHttpSolrClient.Req> routes;, ,     public void setRouteResponses(NamedList routeResponses) {,       this.routeResponses = routeResponses;,     }, ,     public NamedList getRouteResponses() {,       return routeResponses;,     }, ,     public void setRoutes(Map<String, LBHttpSolrClient.Req> routes) {,       this.routes = routes;,     }, ,     public Map<String, LBHttpSolrClient.Req> getRoutes() {,       return routes;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java,,147-289,[  class Runner implements Runnable {,     final Lock runnerLock = new ReentrantLock();, ,     @Override,     public void run() {,       runnerLock.lock();, ,       log.debug("starting runner: {}", this);,       HttpPost method = null;,       HttpResponse response = null;            ,       try {,         while (!queue.isEmpty()) {,           try {,             final UpdateRequest updateRequest = ,                 queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);,             if (updateRequest == null),               break;,                        ,             String contentType = client.requestWriter.getUpdateContentType();,             final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);, ,             final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());, ,             EntityTemplate template = new EntityTemplate(new ContentProducer() {, ,               @Override,               public void writeTo(OutputStream out) throws IOException {,                 try {,                   if (isXml) {,                     out.write("<stream>".getBytes(StandardCharsets.UTF_8)); // can be anything,                   }                                    ,                   UpdateRequest req = updateRequest;,                   while (req != null) {                                        ,                     SolrParams currentParams = new ModifiableSolrParams(req.getParams());,                     if (!origParams.toNamedList().equals(currentParams.toNamedList())) {,                       queue.add(req); // params are different, push back to queue,                       break;,                     },                     ,                     client.requestWriter.write(req, out);,                     if (isXml) {,                       // check for commit or optimize,                       SolrParams params = req.getParams();,                       if (params != null) {,                         String fmt = null;,                         if (params.getBool(UpdateParams.OPTIMIZE, false)) {,                           fmt = "<optimize waitSearcher=\"%s\" />";,                         } else if (params.getBool(UpdateParams.COMMIT, false)) {,                           fmt = "<commit waitSearcher=\"%s\" />";,                         },                         if (fmt != null) {,                           byte[] content = String.format(Locale.ROOT,,                               fmt,,                               params.getBool(UpdateParams.WAIT_SEARCHER, false),                                   + "").getBytes(StandardCharsets.UTF_8);,                           out.write(content);,                         },                       },                     },                     out.flush();,                     req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);,                   },                   ,                   if (isXml) {,                     out.write("</stream>".getBytes(StandardCharsets.UTF_8));,                   }, ,                 } catch (InterruptedException e) {,                   Thread.currentThread().interrupt();,                   log.warn("", e);,                 },               },             });,             ,             // The parser 'wt=' and 'version=' params are used instead of the,             // original params,             ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);,             requestParams.set(CommonParams.WT, client.parser.getWriterType());,             requestParams.set(CommonParams.VERSION, client.parser.getVersion());, ,             method = new HttpPost(client.getBaseURL() + "/update",                 + ClientUtils.toQueryString(requestParams, false));,             method.setEntity(template);,             method.addHeader("User-Agent", HttpSolrClient.AGENT);,             method.addHeader("Content-Type", contentType);,                         ,             response = client.getHttpClient().execute(method);,             int statusCode = response.getStatusLine().getStatusCode();,             if (statusCode != HttpStatus.SC_OK) {,               StringBuilder msg = new StringBuilder();,               msg.append(response.getStatusLine().getReasonPhrase());,               msg.append("\n\n\n\n");,               msg.append("request: ").append(method.getURI());, ,               SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());,               // parse out the metadata from the SolrException,               try {,                 NamedList<Object> resp =,                     client.parser.processResponse(response.getEntity().getContent(),,                         response.getEntity().getContentType().getValue());,                 NamedList<Object> error = (NamedList<Object>) resp.get("error");,                 if (error != null),                   solrExc.setMetadata((NamedList<String>) error.get("metadata"));,               } catch (Exception exc) {,                 // don't want to fail to report error if parsing the response fails,                 log.warn("Failed to parse error response from "+ client.getBaseURL()+" due to: "+exc);,               }, ,               handleError(solrExc);,             } else {,               onSuccess(response);,             },           } finally {,             try {,               if (response != null) {,                 response.getEntity().getContent().close();,               },             } catch (Exception ex) {,               log.warn("", ex);,             },           },         },       } catch (Throwable e) {,         if (e instanceof OutOfMemoryError) {,           throw (OutOfMemoryError) e;,         },         handleError(e);,       } finally {,         synchronized (runners) {,           if (runners.size() == 1 && !queue.isEmpty()) {,             // keep this runner alive,             scheduler.execute(this);,           } else {,             runners.remove(this);,             if (runners.isEmpty()),               runners.notifyAll();,           },         }, ,         log.debug("finished: {}", this);,         runnerLock.unlock();,       },     }],,
MT_CORRECTNESS,UL_UNRELEASED_LOCK_EXCEPTION_PATH,org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java,run,152-152,[      runnerLock.lock();],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/solr/client/solrj/impl/HttpClientConfigurer.java,toBooleanObject,96-96,[    return null;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/client/solrj/impl/HttpSolrClient.java,executeMethod,550-550,[        } catch (Exception ex) {}],,
BAD_PRACTICE,NM_CONFUSING,org/apache/solr/client/solrj/impl/HttpSolrClient.java,getBaseURL,603-603,[    return baseUrl;],,getBaseUrl,1084-1084,[    return baseURL;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/client/solrj/impl/HttpSolrClient.java,createMethod,440-440,[          if(is != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/client/solrj/impl/HttpSolrClient.java,createMethod,440-440,[          if(is != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/client/solrj/impl/HttpSolrClient.java,executeMethod,550-550,[        } catch (Exception ex) {}],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/ResponseParser.java,,29-51,[public abstract class ResponseParser, {,   public abstract String getWriterType(); // for example: wt=XML, JSON, etc, ,   public abstract NamedList<Object> processResponse(InputStream body, String encoding);, ,   public abstract NamedList<Object> processResponse(Reader reader);,   ,   /**,    * A well behaved ResponseParser will return its content-type.,    * ,    * @return the content-type this parser expects to parse,    */,   public String getContentType() {,     return null;,   },   ,   /**,    * @return the version param passed to solr,    */,   public String getVersion(),   {,     return "2.2";],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/request/RequestWriter.java,,41-144,[public class RequestWriter {,   public static final Charset UTF_8 = StandardCharsets.UTF_8;, ,   public Collection<ContentStream> getContentStreams(SolrRequest req) throws IOException {,     if (req instanceof UpdateRequest) {,       UpdateRequest updateRequest = (UpdateRequest) req;,       if (isEmpty(updateRequest)) return null;,       List<ContentStream> l = new ArrayList<>();,       l.add(new LazyContentStream(updateRequest));,       return l;,     },     return req.getContentStreams();,   }, ,   private boolean isEmpty(UpdateRequest updateRequest) {,     return isNull(updateRequest.getDocuments()) &&,             isNull(updateRequest.getDeleteByIdMap()) &&,             isNull(updateRequest.getDeleteQuery()) &&,             updateRequest.getDocIterator() == null;,   }, ,   public String getPath(SolrRequest req) {,     return req.getPath();,   }, ,   public ContentStream getContentStream(UpdateRequest req) throws IOException {,     return new ContentStreamBase.StringStream(req.getXML());,   }, ,   public void write(SolrRequest request, OutputStream os) throws IOException {,     if (request instanceof UpdateRequest) {,       UpdateRequest updateRequest = (UpdateRequest) request;,       BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, UTF_8));,       updateRequest.writeXML(writer);,       writer.flush();,     },   }, ,   public String getUpdateContentType() {,     return ClientUtils.TEXT_XML;, ,   }, ,   public class LazyContentStream implements ContentStream {,     ContentStream contentStream = null;,     UpdateRequest req = null;, ,     public LazyContentStream(UpdateRequest req) {,       this.req = req;,     }, ,     private ContentStream getDelegate() {,       if (contentStream == null) {,         try {,           contentStream = getContentStream(req);,         } catch (IOException e) {,           throw new RuntimeException("Unable to write xml into a stream", e);,         },       },       return contentStream;,     }, ,     @Override,     public String getName() {,       return getDelegate().getName();,     }, ,     @Override,     public String getSourceInfo() {,       return getDelegate().getSourceInfo();,     }, ,     @Override,     public String getContentType() {,       return getUpdateContentType();,     }, ,     @Override,     public Long getSize() {,       return getDelegate().getSize();,     }, ,     @Override,     public InputStream getStream() throws IOException {,       return getDelegate().getStream();,     }, ,     @Override,     public Reader getReader() throws IOException {,       return getDelegate().getReader();,     }, ,     public void writeTo(OutputStream os) throws IOException {,       write(req, os);, ,     },   }, ,   protected boolean isNull(List l) {,     return l == null || l.isEmpty();,   },   ,   protected boolean isNull(Map l) {,     return l == null || l.isEmpty();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/client/solrj/impl/HttpSolrClient.java,,406-414,[                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {,                   @Override,                   public Header getContentType() {,                     return new BasicHeader("Content-Type", contentStream[0].getContentType());,                   },                   ,                   @Override,                   public boolean isRepeatable() {,                     return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/client/solrj/impl/HttpSolrClient.java,,419-427,[                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {,                   @Override,                   public Header getContentType() {,                     return new BasicHeader("Content-Type", contentStream[0].getContentType());,                   },                   ,                   @Override,                   public boolean isRepeatable() {,                     return false;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/cloud/RecoveryStrategy.java,sendPrepRecoveryCmd,615-615,[      mrr.future.get();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/schema/ManagedIndexSchema.java,call,341-341,[            NamedList<Object> zkversionResp = mrr.future.get();],,
MT_CORRECTNESS,DC_DOUBLECHECK,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,startAliveCheckExecutor,607-609,[    if (aliveCheckExecutor == null) {,       synchronized (this) {,         if (aliveCheckExecutor == null) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,addToAlive,414-414,[      ServerWrapper prev = aliveServers.put(wrapper.getKey(), wrapper);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,456-456,[    if (aliveCheckExecutor != null) {],,,457-457,[      aliveCheckExecutor.shutdownNow();],,,607-607,[    if (aliveCheckExecutor == null) {],,,609-609,[        if (aliveCheckExecutor == null) {],,,610-610,[          aliveCheckExecutor = Executors.newSingleThreadScheduledExecutor(],,,612-612,[          aliveCheckExecutor.scheduleAtFixedRate(],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,601-601,[    this.interval = interval;],,,613-613,[                  getAliveCheckRunner(new WeakReference<>(this)),],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,checkAZombieServer,568-568,[    } catch (Exception e) {],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,134-160,[    boolean standard = true;, ,     int failedPings = 0;, ,     public ServerWrapper(HttpSolrClient client) {,       this.client = client;,     }, ,     @Override,     public String toString() {,       return client.getBaseURL();,     }, ,     public String getKey() {,       return client.getBaseURL();,     }, ,     @Override,     public int hashCode() {,       return this.getKey().hashCode();,     }, ,     @Override,     public boolean equals(Object obj) {,       if (this == obj) return true;,       if (!(obj instanceof ServerWrapper)) return false;,       return this.getKey().equals(((ServerWrapper)obj).getKey());],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,134-160,[    boolean standard = true;, ,     int failedPings = 0;, ,     public ServerWrapper(HttpSolrClient client) {,       this.client = client;,     }, ,     @Override,     public String toString() {,       return client.getBaseURL();,     }, ,     public String getKey() {,       return client.getBaseURL();,     }, ,     @Override,     public int hashCode() {,       return this.getKey().hashCode();,     }, ,     @Override,     public boolean equals(Object obj) {,       if (this == obj) return true;,       if (!(obj instanceof ServerWrapper)) return false;,       return this.getKey().equals(((ServerWrapper)obj).getKey());],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/request/RequestWriter.java,,41-144,[public class RequestWriter {,   public static final Charset UTF_8 = StandardCharsets.UTF_8;, ,   public Collection<ContentStream> getContentStreams(SolrRequest req) throws IOException {,     if (req instanceof UpdateRequest) {,       UpdateRequest updateRequest = (UpdateRequest) req;,       if (isEmpty(updateRequest)) return null;,       List<ContentStream> l = new ArrayList<>();,       l.add(new LazyContentStream(updateRequest));,       return l;,     },     return req.getContentStreams();,   }, ,   private boolean isEmpty(UpdateRequest updateRequest) {,     return isNull(updateRequest.getDocuments()) &&,             isNull(updateRequest.getDeleteByIdMap()) &&,             isNull(updateRequest.getDeleteQuery()) &&,             updateRequest.getDocIterator() == null;,   }, ,   public String getPath(SolrRequest req) {,     return req.getPath();,   }, ,   public ContentStream getContentStream(UpdateRequest req) throws IOException {,     return new ContentStreamBase.StringStream(req.getXML());,   }, ,   public void write(SolrRequest request, OutputStream os) throws IOException {,     if (request instanceof UpdateRequest) {,       UpdateRequest updateRequest = (UpdateRequest) request;,       BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, UTF_8));,       updateRequest.writeXML(writer);,       writer.flush();,     },   }, ,   public String getUpdateContentType() {,     return ClientUtils.TEXT_XML;, ,   }, ,   public class LazyContentStream implements ContentStream {,     ContentStream contentStream = null;,     UpdateRequest req = null;, ,     public LazyContentStream(UpdateRequest req) {,       this.req = req;,     }, ,     private ContentStream getDelegate() {,       if (contentStream == null) {,         try {,           contentStream = getContentStream(req);,         } catch (IOException e) {,           throw new RuntimeException("Unable to write xml into a stream", e);,         },       },       return contentStream;,     }, ,     @Override,     public String getName() {,       return getDelegate().getName();,     }, ,     @Override,     public String getSourceInfo() {,       return getDelegate().getSourceInfo();,     }, ,     @Override,     public String getContentType() {,       return getUpdateContentType();,     }, ,     @Override,     public Long getSize() {,       return getDelegate().getSize();,     }, ,     @Override,     public InputStream getStream() throws IOException {,       return getDelegate().getStream();,     }, ,     @Override,     public Reader getReader() throws IOException {,       return getDelegate().getReader();,     }, ,     public void writeTo(OutputStream os) throws IOException {,       write(req, os);, ,     },   }, ,   protected boolean isNull(List l) {,     return l == null || l.isEmpty();,   },   ,   protected boolean isNull(Map l) {,     return l == null || l.isEmpty();],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,134-160,[    boolean standard = true;, ,     int failedPings = 0;, ,     public ServerWrapper(HttpSolrClient client) {,       this.client = client;,     }, ,     @Override,     public String toString() {,       return client.getBaseURL();,     }, ,     public String getKey() {,       return client.getBaseURL();,     }, ,     @Override,     public int hashCode() {,       return this.getKey().hashCode();,     }, ,     @Override,     public boolean equals(Object obj) {,       if (this == obj) return true;,       if (!(obj instanceof ServerWrapper)) return false;,       return this.getKey().equals(((ServerWrapper)obj).getKey());],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/ResponseParser.java,,29-51,[public abstract class ResponseParser, {,   public abstract String getWriterType(); // for example: wt=XML, JSON, etc, ,   public abstract NamedList<Object> processResponse(InputStream body, String encoding);, ,   public abstract NamedList<Object> processResponse(Reader reader);,   ,   /**,    * A well behaved ResponseParser will return its content-type.,    * ,    * @return the content-type this parser expects to parse,    */,   public String getContentType() {,     return null;,   },   ,   /**,    * @return the version param passed to solr,    */,   public String getVersion(),   {,     return "2.2";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,77-679,[public class LBHttpSolrClient extends SolrClient {,   private static Set<Integer> RETRY_CODES = new HashSet<>(4);, ,   static {,     RETRY_CODES.add(404);,     RETRY_CODES.add(403);,     RETRY_CODES.add(503);,     RETRY_CODES.add(500);,   }, ,   // keys to the maps are currently of the form "http://localhost:8983/solr",   // which should be equivalent to HttpSolrServer.getBaseURL(),   private final Map<String, ServerWrapper> aliveServers = new LinkedHashMap<>();,   // access to aliveServers should be synchronized on itself,   ,   protected final Map<String, ServerWrapper> zombieServers = new ConcurrentHashMap<>();, ,   // changes to aliveServers are reflected in this array, no need to synchronize,   private volatile ServerWrapper[] aliveServerList = new ServerWrapper[0];, , ,   private ScheduledExecutorService aliveCheckExecutor;, ,   private final HttpClient httpClient;,   private final boolean clientIsInternal;,   private final AtomicInteger counter = new AtomicInteger(-1);, ,   private static final SolrQuery solrQuery = new SolrQuery("*:*");,   private volatile ResponseParser parser;,   private volatile RequestWriter requestWriter;, ,   private Set<String> queryParams = new HashSet<>();, ,   static {,     solrQuery.setRows(0);,     /**,      * Default sort (if we don't supply a sort) is by score and since,      * we request 0 rows any sorting and scoring is not necessary.,      * SolrQuery.DOCID schema-independently specifies a non-scoring sort.,      * <code>_docid_ asc</code> sort is efficient,,      * <code>_docid_ desc</code> sort is not, so choose ascending DOCID sort.,      */,     solrQuery.setSort(SolrQuery.DOCID, SolrQuery.ORDER.asc);,     // not a top-level request, we are interested only in the server being sent to i.e. it need not distribute our request to further servers    ,     solrQuery.setDistrib(false);,   }, ,   protected static class ServerWrapper {, ,     final HttpSolrClient client;, ,     long lastUsed;     // last time used for a real request,     long lastChecked;  // last time checked for liveness, ,     // "standard" servers are used by default.  They normally live in the alive list,     // and move to the zombie list when unavailable.  When they become available again,,     // they move back to the alive list.,     boolean standard = true;, ,     int failedPings = 0;, ,     public ServerWrapper(HttpSolrClient client) {,       this.client = client;,     }, ,     @Override,     public String toString() {,       return client.getBaseURL();,     }, ,     public String getKey() {,       return client.getBaseURL();,     }, ,     @Override,     public int hashCode() {,       return this.getKey().hashCode();,     }, ,     @Override,     public boolean equals(Object obj) {,       if (this == obj) return true;,       if (!(obj instanceof ServerWrapper)) return false;,       return this.getKey().equals(((ServerWrapper)obj).getKey());,     },   }, ,   public static class Req {,     protected SolrRequest request;,     protected List<String> servers;,     protected int numDeadServersToTry;, ,     public Req(SolrRequest request, List<String> servers) {,       this.request = request;,       this.servers = servers;,       this.numDeadServersToTry = servers.size();,     }, ,     public SolrRequest getRequest() {,       return request;,     },     public List<String> getServers() {,       return servers;,     }, ,     /** @return the number of dead servers to try if there are no live servers left */,     public int getNumDeadServersToTry() {,       return numDeadServersToTry;,     }, ,     /** @param numDeadServersToTry The number of dead servers to try if there are no live servers left.,      * Defaults to the number of servers in this request. */,     public void setNumDeadServersToTry(int numDeadServersToTry) {,       this.numDeadServersToTry = numDeadServersToTry;,     },   }, ,   public static class Rsp {,     protected String server;,     protected NamedList<Object> rsp;, ,     /** The response from the server */,     public NamedList<Object> getResponse() {,       return rsp;,     }, ,     /** The server that returned the response */,     public String getServer() {,       return server;,     },   }, ,   public LBHttpSolrClient(String... solrServerUrls) throws MalformedURLException {,     this(null, solrServerUrls);,   },   ,   /** The provided httpClient should use a multi-threaded connection manager */ ,   public LBHttpSolrClient(HttpClient httpClient, String... solrServerUrl) {,     this(httpClient, new BinaryResponseParser(), solrServerUrl);,   }, ,   /** The provided httpClient should use a multi-threaded connection manager */  ,   public LBHttpSolrClient(HttpClient httpClient, ResponseParser parser, String... solrServerUrl) {,     clientIsInternal = (httpClient == null);,     this.parser = parser;,     if (httpClient == null) {,       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set(HttpClientUtil.PROP_USE_RETRY, false);,       this.httpClient = HttpClientUtil.createClient(params);,     } else {,       this.httpClient = httpClient;,     },     for (String s : solrServerUrl) {,       ServerWrapper wrapper = new ServerWrapper(makeSolrClient(s));,       aliveServers.put(wrapper.getKey(), wrapper);,     },     updateAliveList();,   },   ,   public Set<String> getQueryParams() {,     return queryParams;,   }, ,   /**,    * Expert Method.,    * @param queryParams set of param keys to only send via the query string,    */,   public void setQueryParams(Set<String> queryParams) {,     this.queryParams = queryParams;,   },   public void addQueryParams(String queryOnlyParam) {,     this.queryParams.add(queryOnlyParam) ;,   }, ,   public static String normalize(String server) {,     if (server.endsWith("/")),       server = server.substring(0, server.length() - 1);,     return server;,   }, ,   protected HttpSolrClient makeSolrClient(String server) {,     HttpSolrClient client = new HttpSolrClient(server, httpClient, parser);,     if (requestWriter != null) {,       client.setRequestWriter(requestWriter);,     },     if (queryParams != null) {,       client.setQueryParams(queryParams);,     },     return client;,   }, ,   /**,    * Tries to query a live server from the list provided in Req. Servers in the dead pool are skipped.,    * If a request fails due to an IOException, the server is moved to the dead pool for a certain period of,    * time, or until a test request on that server succeeds.,    *,    * Servers are queried in the exact order given (except servers currently in the dead pool are skipped).,    * If no live servers from the provided list remain to be tried, a number of previously skipped dead servers will be tried.,    * Req.getNumDeadServersToTry() controls how many dead servers will be tried.,    *,    * If no live servers are found a SolrServerException is thrown.,    *,    * @param req contains both the request as well as the list of servers to query,    *,    * @return the result of the request,    *,    * @throws IOException If there is a low-level I/O error.,    */,   public Rsp request(Req req) throws SolrServerException, IOException {,     Rsp rsp = new Rsp();,     Exception ex = null;,     boolean isUpdate = req.request instanceof IsUpdateRequest;,     List<ServerWrapper> skipped = null;, ,     for (String serverStr : req.getServers()) {,       serverStr = normalize(serverStr);,       // if the server is currently a zombie, just skip to the next one,       ServerWrapper wrapper = zombieServers.get(serverStr);,       if (wrapper != null) {,         // System.out.println("ZOMBIE SERVER QUERIED: " + serverStr);,         final int numDeadServersToTry = req.getNumDeadServersToTry();,         if (numDeadServersToTry > 0) {,           if (skipped == null) {,             skipped = new ArrayList<>(numDeadServersToTry);,             skipped.add(wrapper);,           },           else if (skipped.size() < numDeadServersToTry) {,             skipped.add(wrapper);,           },         },         continue;,       },       rsp.server = serverStr;,       HttpSolrClient client = makeSolrClient(serverStr);, ,       ex = doRequest(client, req, rsp, isUpdate, false, null);,       if (ex == null) {,         return rsp; // SUCCESS,       },     }, ,     // try the servers we previously skipped,     if (skipped != null) {,       for (ServerWrapper wrapper : skipped) {,         ex = doRequest(wrapper.client, req, rsp, isUpdate, true, wrapper.getKey());,         if (ex == null) {,           return rsp; // SUCCESS,         },       },     }, , ,     if (ex == null) {,       throw new SolrServerException("No live SolrServers available to handle this request");,     } else {,       throw new SolrServerException("No live SolrServers available to handle this request:" + zombieServers.keySet(), ex);,     }, ,   }, ,   protected Exception addZombie(HttpSolrClient server, Exception e) {, ,     ServerWrapper wrapper;, ,     wrapper = new ServerWrapper(server);,     wrapper.lastUsed = System.currentTimeMillis();,     wrapper.standard = false;,     zombieServers.put(wrapper.getKey(), wrapper);,     startAliveCheckExecutor();,     return e;,   }  , ,   protected Exception doRequest(HttpSolrClient client, Req req, Rsp rsp, boolean isUpdate,,       boolean isZombie, String zombieKey) throws SolrServerException, IOException {,     Exception ex = null;,     try {,       rsp.rsp = client.request(req.getRequest());,       if (isZombie) {,         zombieServers.remove(zombieKey);,       },     } catch (SolrException e) {,       // we retry on 404 or 403 or 503 or 500,       // unless it's an update - then we only retry on connect exception,       if (!isUpdate && RETRY_CODES.contains(e.code())) {,         ex = (!isZombie) ? addZombie(client, e) : e;,       } else {,         // Server is alive but the request was likely malformed or invalid,         if (isZombie) {,           zombieServers.remove(zombieKey);,         },         throw e;,       },     } catch (SocketException e) {,       if (!isUpdate || e instanceof ConnectException) {,         ex = (!isZombie) ? addZombie(client, e) : e;,       } else {,         throw e;,       },     } catch (SocketTimeoutException e) {,       if (!isUpdate) {,         ex = (!isZombie) ? addZombie(client, e) : e;,       } else {,         throw e;,       },     } catch (SolrServerException e) {,       Throwable rootCause = e.getRootCause();,       if (!isUpdate && rootCause instanceof IOException) {,         ex = (!isZombie) ? addZombie(client, e) : e;,       } else if (isUpdate && rootCause instanceof ConnectException) {,         ex = (!isZombie) ? addZombie(client, e) : e;,       } else {,         throw e;,       },     } catch (Exception e) {,       throw new SolrServerException(e);,     }, ,     return ex;,   }, ,   private void updateAliveList() {,     synchronized (aliveServers) {,       aliveServerList = aliveServers.values().toArray(new ServerWrapper[aliveServers.size()]);,     },   }, ,   private ServerWrapper removeFromAlive(String key) {,     synchronized (aliveServers) {,       ServerWrapper wrapper = aliveServers.remove(key);,       if (wrapper != null),         updateAliveList();,       return wrapper;,     },   }, ,   private void addToAlive(ServerWrapper wrapper) {,     synchronized (aliveServers) {,       ServerWrapper prev = aliveServers.put(wrapper.getKey(), wrapper);,       // TODO: warn if there was a previous entry?,       updateAliveList();,     },   }, ,   public void addSolrServer(String server) throws MalformedURLException {,     HttpSolrClient client = makeSolrClient(server);,     addToAlive(new ServerWrapper(client));,   }, ,   public String removeSolrServer(String server) {,     try {,       server = new URL(server).toExternalForm();,     } catch (MalformedURLException e) {,       throw new RuntimeException(e);,     },     if (server.endsWith("/")) {,       server = server.substring(0, server.length() - 1);,     }, ,     // there is a small race condition here - if the server is in the process of being moved between,     // lists, we could fail to remove it.,     removeFromAlive(server);,     zombieServers.remove(server);,     return null;,   }, ,   public void setConnectionTimeout(int timeout) {,     HttpClientUtil.setConnectionTimeout(httpClient, timeout);,   }, ,   /**,    * set soTimeout (read timeout) on the underlying HttpConnectionManager. This is desirable for queries, but probably,    * not for indexing.,    */,   public void setSoTimeout(int timeout) {,     HttpClientUtil.setSoTimeout(httpClient, timeout);,   }, ,   @Override,   public void shutdown() {,     if (aliveCheckExecutor != null) {,       aliveCheckExecutor.shutdownNow();,     },     if(clientIsInternal) {,       httpClient.getConnectionManager().shutdown();,     },   }, ,   /**,    * Tries to query a live server. A SolrServerException is thrown if all servers are dead.,    * If the request failed due to IOException then the live server is moved to dead pool and the request is,    * retried on another live server.  After live servers are exhausted, any servers previously marked as dead,    * will be tried before failing the request.,    *,    * @param request the SolrRequest.,    *,    * @return response,    *,    * @throws IOException If there is a low-level I/O error.,    */,   @Override,   public NamedList<Object> request(final SolrRequest request),           throws SolrServerException, IOException {,     Exception ex = null;,     ServerWrapper[] serverList = aliveServerList;,     ,     int maxTries = serverList.length;,     Map<String,ServerWrapper> justFailed = null;, ,     for (int attempts=0; attempts<maxTries; attempts++) {,       int count = counter.incrementAndGet() & Integer.MAX_VALUE;,       ServerWrapper wrapper = serverList[count % serverList.length];,       wrapper.lastUsed = System.currentTimeMillis();, ,       try {,         return wrapper.client.request(request);,       } catch (SolrException e) {,         // Server is alive but the request was malformed or invalid,         throw e;,       } catch (SolrServerException e) {,         if (e.getRootCause() instanceof IOException) {,           ex = e;,           moveAliveToDead(wrapper);,           if (justFailed == null) justFailed = new HashMap<>();,           justFailed.put(wrapper.getKey(), wrapper);,         } else {,           throw e;,         },       } catch (Exception e) {,         throw new SolrServerException(e);,       },     }, , ,     // try other standard servers that we didn't try just now,     for (ServerWrapper wrapper : zombieServers.values()) {,       if (wrapper.standard==false || justFailed!=null && justFailed.containsKey(wrapper.getKey())) continue;,       try {,         NamedList<Object> rsp = wrapper.client.request(request);,         // remove from zombie list *before* adding to alive to avoid a race that could lose a server,         zombieServers.remove(wrapper.getKey());,         addToAlive(wrapper);,         return rsp;,       } catch (SolrException e) {,         // Server is alive but the request was malformed or invalid,         throw e;,       } catch (SolrServerException e) {,         if (e.getRootCause() instanceof IOException) {,           ex = e;,           // still dead,         } else {,           throw e;,         },       } catch (Exception e) {,         throw new SolrServerException(e);,       },     }, , ,     if (ex == null) {,       throw new SolrServerException("No live SolrServers available to handle this request");,     } else {,       throw new SolrServerException("No live SolrServers available to handle this request", ex);,     },   },   ,   /**,    * Takes up one dead server and check for aliveness. The check is done in a roundrobin. Each server is checked for,    * aliveness once in 'x' millis where x is decided by the setAliveCheckinterval() or it is defaulted to 1 minute,    *,    * @param zombieServer a server in the dead pool,    */,   private void checkAZombieServer(ServerWrapper zombieServer) {,     long currTime = System.currentTimeMillis();,     try {,       zombieServer.lastChecked = currTime;,       QueryResponse resp = zombieServer.client.query(solrQuery);,       if (resp.getStatus() == 0) {,         // server has come back up.,         // make sure to remove from zombies before adding to alive to avoid a race condition,         // where another thread could mark it down, move it back to zombie, and then we delete,         // from zombie and lose it forever.,         ServerWrapper wrapper = zombieServers.remove(zombieServer.getKey());,         if (wrapper != null) {,           wrapper.failedPings = 0;,           if (wrapper.standard) {,             addToAlive(wrapper);,           },         } else {,           // something else already moved the server from zombie to alive,         },       },     } catch (Exception e) {,       //Expected. The server is still down.,       zombieServer.failedPings++;, ,       // If the server doesn't belong in the standard set belonging to this load balancer,       // then simply drop it after a certain number of failed pings.,       if (!zombieServer.standard && zombieServer.failedPings >= NONSTANDARD_PING_LIMIT) {,         zombieServers.remove(zombieServer.getKey());,       },     },   }, ,   private void moveAliveToDead(ServerWrapper wrapper) {,     wrapper = removeFromAlive(wrapper.getKey());,     if (wrapper == null),       return;  // another thread already detected the failure and removed it,     zombieServers.put(wrapper.getKey(), wrapper);,     startAliveCheckExecutor();,   }, ,   private int interval = CHECK_INTERVAL;, ,   /**,    * LBHttpSolrServer keeps pinging the dead servers at fixed interval to find if it is alive. Use this to set that,    * interval,    *,    * @param interval time in milliseconds,    */,   public void setAliveCheckInterval(int interval) {,     if (interval <= 0) {,       throw new IllegalArgumentException("Alive check interval must be " +,               "positive, specified value = " + interval);,     },     this.interval = interval;,   }, ,   private void startAliveCheckExecutor() {,     // double-checked locking, but it's OK because we don't *do* anything with aliveCheckExecutor,     // if it's not null.,     if (aliveCheckExecutor == null) {,       synchronized (this) {,         if (aliveCheckExecutor == null) {,           aliveCheckExecutor = Executors.newSingleThreadScheduledExecutor(,               new SolrjNamedThreadFactory("aliveCheckExecutor"));,           aliveCheckExecutor.scheduleAtFixedRate(,                   getAliveCheckRunner(new WeakReference<>(this)),,                   this.interval, this.interval, TimeUnit.MILLISECONDS);,         },       },     },   }, ,   private static Runnable getAliveCheckRunner(final WeakReference<LBHttpSolrClient> lbRef) {,     return new Runnable() {,       @Override,       public void run() {,         LBHttpSolrClient lb = lbRef.get();,         if (lb != null && lb.zombieServers != null) {,           for (ServerWrapper zombieServer : lb.zombieServers.values()) {,             lb.checkAZombieServer(zombieServer);,           },         },       },     };,   }, ,   /**,    * Return the HttpClient this instance uses.,    */,   public HttpClient getHttpClient() {,     return httpClient;,   }, ,   public ResponseParser getParser() {,     return parser;,   }, ,   /**,    * Changes the {@link ResponseParser} that will be used for the internal,    * SolrServer objects.,    *,    * @param parser Default Response Parser chosen to parse the response if the parser,    *               were not specified as part of the request.,    * @see org.apache.solr.client.solrj.SolrRequest#getResponseParser(),    */,   public void setParser(ResponseParser parser) {,     this.parser = parser;,   }, ,   /**,    * Changes the {@link RequestWriter} that will be used for the internal,    * SolrServer objects.,    *,    * @param requestWriter Default RequestWriter, used to encode requests sent to the server.,    */,   public void setRequestWriter(RequestWriter requestWriter) {,     this.requestWriter = requestWriter;,   },   ,   public RequestWriter getRequestWriter() {,     return requestWriter;,   },   ,   @Override,   protected void finalize() throws Throwable {,     try {,       if(this.aliveCheckExecutor!=null),         this.aliveCheckExecutor.shutdownNow();,     } finally {,       super.finalize();,     },   }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,551-551,[      zombieServer.lastChecked = currTime;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/client/solrj/impl/LBHttpSolrClient.java,,342-342,[    wrapper.lastUsed = System.currentTimeMillis();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/client/solrj/impl/XMLResponseParser.java,processResponse,156-156,[      catch( Exception ex ){}],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/client/solrj/impl/XMLResponseParser.java,readArray,300-300,[          type = t;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/client/solrj/impl/XMLResponseParser.java,,51-51,[  public static Logger log = LoggerFactory.getLogger(XMLResponseParser.class);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/client/solrj/impl/XMLResponseParser.java,readArray,292-337,[      switch (parser.next()) {,       case XMLStreamConstants.START_ELEMENT:,         depth++;,         KnownType t = KnownType.get( parser.getLocalName() );,         if( t == null ) {,           throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );,         },         if( type == null ) {,           type = t;,         },         /*** actually, there is no rule that arrays need the same type,         else if( type != t && !(t == KnownType.NULL || type == KnownType.NULL)) {,           throw new RuntimeException( "arrays must have the same type! ("+type+"!="+t+") "+parser.getLocalName() );,         },         ***/,         type = t;, ,         builder.setLength( 0 ); // reset the text,         ,         if( !type.isLeaf ) {,           switch( type ) {,           case LST:    vals.add( readNamedList( parser ) ); depth--; continue;,           case ARR:    vals.add( readArray( parser ) ); depth--; continue;,           case RESULT: vals.add( readDocuments( parser ) ); depth--; continue;,           case DOC:    vals.add( readDocument( parser ) ); depth--; continue;,           },           throw new XMLStreamException( "branch element not handled!", parser.getLocation() );,         },         break;,         ,       case XMLStreamConstants.END_ELEMENT:,         if( --depth < 0 ) {,           return vals; // the last element is itself,         },         //System.out.println( "ARR:"+type+"::"+builder );,         Object val = type.read( builder.toString().trim() );,         if( val == null && type != KnownType.NULL) {,           throw new XMLStreamException( "error reading value:"+type, parser.getLocation() );,         },         vals.add( val );,         break;, ,       case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?,       case XMLStreamConstants.CDATA:,       case XMLStreamConstants.CHARACTERS:,         builder.append( parser.getText() );],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/client/solrj/impl/XMLResponseParser.java,readDocument,396-458,[      switch (parser.next()) {,       case XMLStreamConstants.START_ELEMENT:,         depth++;,         builder.setLength( 0 ); // reset the text,         type = KnownType.get( parser.getLocalName() );,         if( type == null ) {,           throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );,         },         ,         name = null;,         int cnt = parser.getAttributeCount();,         for( int i=0; i<cnt; i++ ) {,           if( "name".equals( parser.getAttributeLocalName( i ) ) ) {,             name = parser.getAttributeValue( i );,             break;,           },         }, ,         //Nested documents,         while( type == KnownType.DOC) {,           doc.addChildDocument(readDocument(parser));,           int event = parser.next();,           if (event == XMLStreamConstants.END_ELEMENT) { //Doc ends,             return doc;,           },         },         ,         if( name == null ) {,           throw new XMLStreamException( "requires 'name' attribute: "+parser.getLocalName(), parser.getLocation() );,         },         ,         // Handle multi-valued fields,         if( type == KnownType.ARR ) {,           for( Object val : readArray( parser ) ) {,             doc.addField( name, val );,           },           depth--; // the array reading clears out the 'endElement',         } else if( type == KnownType.LST ) {,             doc.addField( name, readNamedList( parser ) );,           depth--; ,         } else if( !type.isLeaf ) {,           System.out.println("nbot leaf!:" + type);,           ,           throw new XMLStreamException( "must be value or array", parser.getLocation() );,         },         break;,         ,       case XMLStreamConstants.END_ELEMENT:,         if( --depth < 0 ) {,           return doc;,         },         //System.out.println( "FIELD:"+type+"::"+name+"::"+builder );,         Object val = type.read( builder.toString().trim() );,         if( val == null ) {,           throw new XMLStreamException( "error reading value:"+type, parser.getLocation() );,         },         doc.addField( name, val );,         break;, ,       case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?,       case XMLStreamConstants.CDATA:,       case XMLStreamConstants.CHARACTERS:,         builder.append( parser.getText() );],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/client/solrj/impl/XMLResponseParser.java,readNamedList,223-269,[      switch (parser.next()) {,       case XMLStreamConstants.START_ELEMENT:,         depth++;,         builder.setLength( 0 ); // reset the text,         type = KnownType.get( parser.getLocalName() );,         if( type == null ) {,           throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );,         },         ,         name = null;,         int cnt = parser.getAttributeCount();,         for( int i=0; i<cnt; i++ ) {,           if( "name".equals( parser.getAttributeLocalName( i ) ) ) {,             name = parser.getAttributeValue( i );,             break;,           },         }, ,         /** The name in a NamedList can actually be null,         if( name == null ) {,           throw new XMLStreamException( "requires 'name' attribute: "+parser.getLocalName(), parser.getLocation() );,         },         **/,         ,         if( !type.isLeaf ) {,           switch( type ) {,           case LST:    nl.add( name, readNamedList( parser ) ); depth--; continue;,           case ARR:    nl.add( name, readArray(     parser ) ); depth--; continue;,           case RESULT: nl.add( name, readDocuments( parser ) ); depth--; continue;,           case DOC:    nl.add( name, readDocument(  parser ) ); depth--; continue;,           },           throw new XMLStreamException( "branch element not handled!", parser.getLocation() );,         },         break;,         ,       case XMLStreamConstants.END_ELEMENT:,         if( --depth < 0 ) {,           return nl;,         },         //System.out.println( "NL:ELEM:"+type+"::"+name+"::"+builder );,         nl.add( name, type.read( builder.toString().trim() ) );,         break;, ,       case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?,       case XMLStreamConstants.CDATA:,       case XMLStreamConstants.CHARACTERS:,         builder.append( parser.getText() );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/client/solrj/request/AbstractUpdateRequest.java,setAction,78-78,[    params.set(UpdateParams.EXPUNGE_DELETES, String.valueOf(expungeDeletes));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/client/solrj/request/AbstractUpdateRequest.java,setAction,88-88,[    params.set(UpdateParams.OPEN_SEARCHER, String.valueOf(openSearcher));],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,46-99,[public class CollectionAdminRequest extends SolrRequest {,   protected CollectionAction action = null;, ,   private static String PROPERTY_PREFIX = "property.";, ,   protected void setAction( CollectionAction action ) {,     this.action = action;,   }, ,   public CollectionAdminRequest(),   {,     super( METHOD.GET, "/admin/collections" );,   }, ,   public CollectionAdminRequest( String path ),   {,     super( METHOD.GET, path );,   }, ,   @Override,   public SolrParams getParams() {,     if( action == null ) {,       throw new RuntimeException( "no action specified!" );,     },     ModifiableSolrParams params = new ModifiableSolrParams();,     params.set( CoreAdminParams.ACTION, action.toString() );,     return params;,   }, ,   @Override,   public Collection<ContentStream> getContentStreams() throws IOException {,     return null;,   }, ,   @Override,   public CollectionAdminResponse process(SolrClient server) throws SolrServerException, IOException,   {,     long startTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     CollectionAdminResponse res = new CollectionAdminResponse();,     res.setResponse( server.request( this ) );,     long endTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     res.setElapsedTime(endTime - startTime);,     return res;,   },   ,   protected void addProperties(ModifiableSolrParams params, Properties props) {,     Iterator<Map.Entry<Object, Object>> iter = props.entrySet().iterator();,     while(iter.hasNext()) {,       Map.Entry<Object, Object> prop = iter.next();,       String key = (String) prop.getKey();,       String value = (String) prop.getValue();,       params.set(PROPERTY_PREFIX + key, value);,     },   }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,452-535,[  public static class AddReplica extends CollectionShardAdminRequest {,     private String node;,     private String routeKey;,     private String instanceDir;,     private String dataDir;,     private Properties properties;,     private String asyncId;, ,     public AddReplica() {,       action = CollectionAction.ADDREPLICA;,     }, ,     public Properties getProperties() {,       return properties;,     }, ,     public void setProperties(Properties properties) {,       this.properties = properties;,     }, ,     public String getNode() {,       return node;,     }, ,     public void setNode(String node) {,       this.node = node;,     }, ,     public String getRouteKey() {,       return routeKey;,     }, ,     public void setRouteKey(String routeKey) {,       this.routeKey = routeKey;,     }, ,     public String getInstanceDir() {,       return instanceDir;,     }, ,     public void setInstanceDir(String instanceDir) {,       this.instanceDir = instanceDir;,     }, ,     public String getDataDir() {,       return dataDir;,     }, ,     public void setDataDir(String dataDir) {,       this.dataDir = dataDir;,     }, ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       if (shardName == null || shardName.isEmpty()) {,         params.remove("shard");,         if (routeKey == null) {,           throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Either shard or routeKey must be provided");,         },         params.add(ShardParams._ROUTE_, routeKey);,       },       params.set("async", asyncId);,       if (node != null) {,         params.add("node", node);,       },       if (instanceDir != null)  {,         params.add("instanceDir", instanceDir);,       },       if (dataDir != null)  {,         params.add("dataDir", dataDir);,       },       if (properties != null) {,         addProperties(params, properties);,       },       return params;,     }, ,     public void setAsyncId(String asyncId) {,       this.asyncId = asyncId;,     },     ,     public String getAsyncId() {,       return asyncId;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,720-772,[  public static class AddReplicaProp extends CollectionShardAdminRequest {,     private String replica;,     private String propertyName;,     private String propertyValue;,     private Boolean shardUnique;,     ,     public AddReplicaProp() {,       action = CollectionAction.ADDREPLICAPROP;,     }, ,     public String getReplica() {,       return replica;,     }, ,     public void setReplica(String replica) {,       this.replica = replica;,     }, ,     public String getPropertyName() {,       return propertyName;,     }, ,     public void setPropertyName(String propertyName) {,       this.propertyName = propertyName;,     }, ,     public String getPropertyValue() {,       return propertyValue;,     }, ,     public void setPropertyValue(String propertyValue) {,       this.propertyValue = propertyValue;,     }, ,     public Boolean getShardUnique() {,       return shardUnique;,     }, ,     public void setShardUnique(Boolean shardUnique) {,       this.shardUnique = shardUnique;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.set("replica", replica);,       params.set("property", propertyName);,       params.set("property.value", propertyValue);,       ,       if(shardUnique != null),         params.set("shardUnique", shardUnique);,       ,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,683-686,[  public static class AddRole extends CollectionAdminRoleRequest {,     public AddRole() {,       action = CollectionAction.ADDROLE;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,812-859,[  public static class BalanceShardUnique extends CollectionAdminRequest {,     private String collection;,     private String propertyName;,     private Boolean onlyActiveNodes;,     private Boolean shardUnique;,     ,     public String getPropertyName() {,       return propertyName;,     }, ,     public void setPropertyName(String propertyName) {,       this.propertyName = propertyName;,     }, ,     public Boolean getOnlyActiveNodes() {,       return onlyActiveNodes;,     }, ,     public void setOnlyActiveNodes(Boolean onlyActiveNodes) {,       this.onlyActiveNodes = onlyActiveNodes;,     }, ,     public Boolean getShardUnique() {,       return shardUnique;,     }, ,     public void setShardUnique(Boolean shardUnique) {,       this.shardUnique = shardUnique;,     }, ,     public void setCollection(String collection) {,       this.collection = collection;,     },     ,     public String getCollection() {,       return collection;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.set("collection", collection);,       params.set("property", propertyName);,       if(onlyActiveNodes != null),         params.set("onlyactivenodes", onlyActiveNodes);,       if(shardUnique != null),         params.set("shardUnique", shardUnique);,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,577-606,[  public static class ClusterProp extends CollectionAdminRequest {,     private String propertyName;,     private String propertyValue;,     ,     public ClusterProp() {,       this.action = CollectionAction.CLUSTERPROP;,     },     ,     public void setPropertyName(String propertyName) {,       this.propertyName = propertyName;,     }, ,     public String getPropertyName() {,       return this.propertyName;,     }, ,     public void setPropertyValue(String propertyValue) {,       this.propertyValue = propertyValue;,     },     ,     public String getPropertyValue() {,       return this.propertyValue;,     },     ,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.add("name", propertyName);,       params.add("val", propertyValue);,       ,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,704-708,[  public static class ClusterStatus extends CollectionShardAdminRequest {,     ,     public ClusterStatus () {,       action = CollectionAction.CLUSTERSTATUS;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,142-167,[  protected static class CollectionAdminRoleRequest extends CollectionAdminRequest {,     private String node;,     private String role;, ,     public void setNode(String node) {,       this.node = node;,     }, ,     public String getNode() {,       return this.node;,     }, ,     public void setRole(String role) {,       this.role = role;,     }, ,     public String getRole() {,       return this.role;,     }, ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.set("role", this.role);,       params.set("node", this.node);,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,123-138,[  protected static class CollectionShardAdminRequest extends CollectionSpecificAdminRequest {,     protected String shardName = null;, ,     public void setShardName(String shard) { this.shardName = shard; },     public String getShardName() { return this.shardName; }, ,     public ModifiableSolrParams getCommonParams() {,       ModifiableSolrParams params = (ModifiableSolrParams) super.getParams();,       params.set( "collection", collection );,       params.set( "shard", shardName);,       return params;,     }, ,     @Override,     public SolrParams getParams() {,       return getCommonParams();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,105-117,[  protected static class CollectionSpecificAdminRequest extends CollectionAdminRequest {,     protected String collection = null;, ,     public final void setCollectionName( String collectionName ),     {,       this.collection = collectionName;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.set( CoreAdminParams.NAME, collection );,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,176-260,[    protected String configName = null;,     protected String createNodeSet = null;,     protected String routerName;,     protected String shards;,     protected String routerField;,     protected Integer numShards;,     protected Integer maxShardsPerNode;,     protected Integer replicationFactor;, ,     private Properties properties;,     protected Boolean autoAddReplicas;,     protected Integer stateFormat;,     protected String asyncId;, , ,     public Create() {,       action = CollectionAction.CREATE;,     }, ,     public void setConfigName(String config) { this.configName = config; },     public void setCreateNodeSet(String nodeSet) { this.createNodeSet = nodeSet; },     public void setRouterName(String routerName) { this.routerName = routerName; },     public void setShards(String shards) { this.shards = shards; },     public void setRouterField(String routerField) { this.routerField = routerField; },     public void setNumShards(Integer numShards) {this.numShards = numShards;},     public void setMaxShardsPerNode(Integer numShards) { this.maxShardsPerNode = numShards; },     public void setAutoAddReplicas(boolean autoAddReplicas) { this.autoAddReplicas = autoAddReplicas; },     public void setReplicationFactor(Integer repl) { this.replicationFactor = repl; },     public void setStateFormat(Integer stateFormat) { this.stateFormat = stateFormat; },     public void setAsyncId(String asyncId) {,       this.asyncId = asyncId;,     }, ,     public String getConfigName()  { return configName; },     public String getCreateNodeSet() { return createNodeSet; },     public String getRouterName() { return  routerName; },     public String getShards() { return  shards; },     public Integer getNumShards() { return numShards; },     public Integer getMaxShardsPerNode() { return maxShardsPerNode; },     public Integer getReplicationFactor() { return replicationFactor; },     public Boolean getAutoAddReplicas() { return autoAddReplicas; },     public Integer getStateFormat() { return stateFormat; },     public String getAsyncId() {,       return asyncId;,     }, ,     public Properties getProperties() {,       return properties;,     }, ,     public void setProperties(Properties properties) {,       this.properties = properties;,     }, ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = (ModifiableSolrParams) super.getParams();, ,       params.set( "collection.configName", configName);,       params.set( "createNodeSet", createNodeSet);,       if (numShards != null) {,         params.set( ZkStateReader.NUM_SHARDS_PROP, numShards);,       },       if (maxShardsPerNode != null) {,         params.set( "maxShardsPerNode", maxShardsPerNode);,       },       params.set( "router.name", routerName);,       params.set("shards", shards);,       if (routerField != null) {,         params.set("router.field", routerField);,       },       if (replicationFactor != null) {,         params.set( "replicationFactor", replicationFactor);,       },       params.set("async", asyncId);,       if (autoAddReplicas != null) {,         params.set(ZkStateReader.AUTO_ADD_REPLICAS, autoAddReplicas);,       },       if(properties != null) {,         addProperties(params, properties);,       },       if (stateFormat != null) {,         params.set(DocCollection.STATE_FORMAT, stateFormat);,       },       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,398-427,[  public static class CreateAlias extends CollectionAdminRequest {,     protected String aliasName;,     protected String aliasedCollections;, ,     public CreateAlias() {,       action = CollectionAction.CREATEALIAS;,     }, ,     public void setAliasName(String aliasName) {,       this.aliasName = aliasName;,     }, ,     public String getAliasName() {,       return aliasName;,     },     ,     public void setAliasedCollections(String alias) { this.aliasedCollections = alias; },     public String getAliasedCollections() { return this.aliasedCollections; },     ,     @Deprecated,     public void setCollectionName(String aliasName) {,       this.aliasName = aliasName;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = (ModifiableSolrParams) super.getParams();,       params.set("name", aliasName);,       params.set( "collections", aliasedCollections );,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,280-311,[  public static class CreateShard extends CollectionShardAdminRequest {,     protected String nodeSet;,     private Properties properties;, ,     public void setNodeSet(String nodeSet) {,       this.nodeSet = nodeSet;,     }, ,     public String getNodeSet() {,       return nodeSet;,     }, ,     public Properties getProperties() {,       return properties;,     }, ,     public void setProperties(Properties properties) {,       this.properties = properties;,     }, ,     public CreateShard() {,       action = CollectionAction.CREATESHARD;,     }, ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = getCommonParams();,       params.set( "createNodeSet", nodeSet);,       if(properties != null) {,         addProperties(params, properties);,       },       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,273-276,[  public static class Delete extends CollectionSpecificAdminRequest {,     public Delete() {,       action = CollectionAction.DELETE;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,432-447,[  public static class DeleteAlias extends CollectionAdminRequest {,     protected String aliasName;,     ,     public DeleteAlias() {,       action = CollectionAction.DELETEALIAS;,     },     ,     public void setAliasName(String aliasName) {,       this.aliasName = aliasName;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.set("name", aliasName);,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,540-572,[  public static class DeleteReplica extends CollectionShardAdminRequest {,     private String replica;,     private Boolean onlyIfDown;,     ,     public DeleteReplica() {,       action = CollectionAction.DELETEREPLICA;,     }, ,     public void setReplica(String replica) {,       this.replica = replica;,     }, ,     public String getReplica() {,       return this.replica;,     },     ,     public void setOnlyIfDown(boolean onlyIfDown) {,       this.onlyIfDown = onlyIfDown;,     },     ,     public Boolean getOnlyIfDown() {,       return this.onlyIfDown;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.set(ZkStateReader.REPLICA_PROP, this.replica);,       ,       if(onlyIfDown != null) {,         params.set("onlyIfDown", this.onlyIfDown);,       },       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,778-807,[  public static class DeleteReplicaProp extends CollectionShardAdminRequest {,     private String replica;,     private String propertyName;, ,     public DeleteReplicaProp() {,       this.action = CollectionAction.DELETEREPLICAPROP;,     },     ,     public String getReplica() {,       return replica;,     }, ,     public void setReplica(String replica) {,       this.replica = replica;,     }, ,     public String getPropertyName() {,       return propertyName;,     }, ,     public void setPropertyName(String propertyName) {,       this.propertyName = propertyName;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.set("replica", replica);,       params.set("property", propertyName);,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,372-375,[  public static class DeleteShard extends CollectionShardAdminRequest {,     public DeleteShard() {,       action = CollectionAction.DELETESHARD;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,713-716,[  public static class List extends CollectionAdminRequest {,     public List () {,       action = CollectionAction.LIST;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,619-678,[    public Migrate() {,       action = CollectionAction.MIGRATE;,     },     ,     public void setTargetCollection(String targetCollection) {,       this.targetCollection = targetCollection;,     },     ,     public String getTargetCollection() {,       return this.targetCollection;,     },     ,     public void setSplitKey(String splitKey) {,       this.splitKey = splitKey;,     },     ,     public String getSplitKey() {,       return this.splitKey;,     },     ,     public void setForwardTimeout(int forwardTimeout) {,       this.forwardTimeout = forwardTimeout;,     },     ,     public Integer getForwardTimeout() {,       return this.forwardTimeout;,     },     ,     public void setProperties(Properties properties) {,       this.properties = properties;,     },     ,     public Properties getProperties() {,       return this.properties;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());,       params.set( "collection", collection );,       params.set("target.collection", targetCollection);,       params.set("split.key", splitKey);,       if(forwardTimeout != null) {,         params.set("forward.timeout", forwardTimeout);,       },       params.set("async", asyncId);,       ,       if(properties != null) {,         addProperties(params, properties);,       },       ,       return params;,     }, ,     public void setAsyncId(String asyncId) {,       this.asyncId = asyncId;,     },     ,     public String getAsyncId() {,       return asyncId;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,697-700,[  public static class OverseerStatus extends CollectionAdminRequest {,     public OverseerStatus () {,       action = CollectionAction.OVERSEERSTATUS;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,266-269,[  public static class Reload extends CollectionSpecificAdminRequest {,     public Reload() {,       action = CollectionAction.RELOAD;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,690-693,[  public static class RemoveRole extends CollectionAdminRoleRequest {,     public RemoveRole() {,       action = CollectionAction.REMOVEROLE;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,379-393,[  public static class RequestStatus extends CollectionAdminRequest {,     protected  String requestId = null;, ,     public RequestStatus() {,       action = CollectionAction.REQUESTSTATUS;,     }, ,     public void setRequestId(String requestId) {this.requestId = requestId; },     public String getRequestId() { return this.requestId; }, ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = (ModifiableSolrParams) super.getParams();,       params.set("requestid", requestId);,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CollectionAdminRequest.java,,316-367,[  public static class SplitShard extends CollectionShardAdminRequest {,     protected String ranges;,     protected String splitKey;,     protected String asyncId;,     ,     private Properties properties;, ,     public SplitShard() {,       action = CollectionAction.SPLITSHARD;,     }, ,     public void setRanges(String ranges) { this.ranges = ranges; },     public String getRanges() { return ranges; }, ,     public void setSplitKey(String splitKey) {,       this.splitKey = splitKey;,     },     ,     public String getSplitKey() {,       return this.splitKey;,     },     ,     public Properties getProperties() {,       return properties;,     }, ,     public void setProperties(Properties properties) {,       this.properties = properties;,     }, ,     public void setAsyncId(String asyncId) {,       this.asyncId = asyncId;,     }, ,     public String getAsyncId() {,       return asyncId;,     },     ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = getCommonParams();,       params.set( "ranges", ranges);, ,       if(splitKey != null),         params.set("split.key", this.splitKey);,       ,       if(properties != null) {,         addProperties(params, properties);,       },       ,       params.set("async", asyncId);,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/ContentStreamUpdateRequest.java,,47-76,[    super(METHOD.POST, url);,     contentStreams = new ArrayList<>();,   }, ,   @Override,   public Collection<ContentStream> getContentStreams() throws IOException {,     return contentStreams;,   }, ,   /**,    * Add a File to the {@link org.apache.solr.common.util.ContentStream}s.,    * @param file The File to add.,    * @throws IOException if there was an error with the file.,    *,    * @see #getContentStreams(),    * @see org.apache.solr.common.util.ContentStreamBase.FileStream,    */,   public void addFile(File file, String contentType) throws IOException {,     ContentStreamBase cs = new ContentStreamBase.FileStream(file);,     cs.setContentType(contentType);,     addContentStream(cs);,   }, ,   /**,    * Add a {@link org.apache.solr.common.util.ContentStream} to {@link #getContentStreams()},    * @param contentStream The {@link org.apache.solr.common.util.ContentStream},    */,   public void addContentStream(ContentStream contentStream){,     contentStreams.add(contentStream);,   }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CoreAdminRequest.java,,42-605,[public class CoreAdminRequest extends SolrRequest, {,   protected String core = null;,   protected String other = null;,   protected boolean isIndexInfoNeeded = true;,   protected CoreAdminParams.CoreAdminAction action = null;,   ,   //a create core request,   public static class Create extends CoreAdminRequest {,     protected String instanceDir;,     protected String configName = null;,     protected String schemaName = null;,     protected String dataDir = null;,     protected String ulogDir = null;,     protected String configSet = null;,     protected String collection;,     private Integer numShards;,     private String shardId;,     private String roles;,     private String coreNodeName;,     private Boolean loadOnStartup;,     private Boolean isTransient;,     private String collectionConfigName;, ,     public Create() {,       action = CoreAdminAction.CREATE;,     },     ,     public void setInstanceDir(String instanceDir) { this.instanceDir = instanceDir; },     public void setSchemaName(String schema) { this.schemaName = schema; },     public void setConfigName(String config) { this.configName = config; },     public void setDataDir(String dataDir) { this.dataDir = dataDir; },     public void setUlogDir(String ulogDir) { this.ulogDir = ulogDir; },     public void setConfigSet(String configSet) {,       this.configSet = configSet;,     },     public void setCollection(String collection) { this.collection = collection; },     public void setNumShards(int numShards) {this.numShards = numShards;},     public void setShardId(String shardId) {this.shardId = shardId;},     public void setRoles(String roles) {this.roles = roles;},     public void setCoreNodeName(String coreNodeName) {this.coreNodeName = coreNodeName;},     public void setIsTransient(Boolean isTransient) { this.isTransient = isTransient; },     public void setIsLoadOnStartup(Boolean loadOnStartup) { this.loadOnStartup = loadOnStartup;},     public void setCollectionConfigName(String name) { this.collectionConfigName = name;}, ,     public String getInstanceDir() { return instanceDir; },     public String getSchemaName()  { return schemaName; },     public String getConfigName()  { return configName; },     public String getDataDir() { return dataDir; },     public String getUlogDir() { return ulogDir; },     public String getConfigSet() {,       return configSet;,     },     public String getCollection() { return collection; },     public String getShardId() { return shardId; },     public String getRoles() { return roles; },     public String getCoreNodeName() { return coreNodeName; },     public Boolean getIsLoadOnStartup() { return loadOnStartup; },     public Boolean getIsTransient() { return isTransient; },     public String getCollectionConfigName() { return collectionConfigName;},     ,     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set( CoreAdminParams.ACTION, action.toString() );,       if( action.equals(CoreAdminAction.CREATE) ) {,         params.set( CoreAdminParams.NAME, core );,       } else {,         params.set( CoreAdminParams.CORE, core );,       },       params.set( CoreAdminParams.INSTANCE_DIR, instanceDir);,       if (configName != null) {,         params.set( CoreAdminParams.CONFIG, configName);,       },       if (schemaName != null) {,         params.set( CoreAdminParams.SCHEMA, schemaName);,       },       if (dataDir != null) {,         params.set( CoreAdminParams.DATA_DIR, dataDir);,       },       if (ulogDir != null) {,         params.set( CoreAdminParams.ULOG_DIR, ulogDir);,       },       if (configSet != null) {,         params.set( CoreAdminParams.CONFIGSET, configSet);,       },       if (collection != null) {,         params.set( CoreAdminParams.COLLECTION, collection);,       },       if (numShards != null) {,         params.set( ZkStateReader.NUM_SHARDS_PROP, numShards);,       },       if (shardId != null) {,         params.set( CoreAdminParams.SHARD, shardId);,       },       if (roles != null) {,         params.set( CoreAdminParams.ROLES, roles);,       },       if (coreNodeName != null) {,         params.set( CoreAdminParams.CORE_NODE_NAME, coreNodeName);,       }, ,       if (isTransient != null) {,         params.set(CoreAdminParams.TRANSIENT, isTransient);,       }, ,       if (loadOnStartup != null) {,         params.set(CoreAdminParams.LOAD_ON_STARTUP, loadOnStartup);,       },       ,       if (collectionConfigName != null) {,         params.set("collection.configName", collectionConfigName);,       },       ,       return params;,     }, ,   },   ,   public static class WaitForState extends CoreAdminRequest {,     protected String nodeName;,     protected String coreNodeName;,     protected String state;,     protected Boolean checkLive;,     protected Boolean onlyIfLeader;,     protected Boolean onlyIfLeaderActive;, ,     public WaitForState() {,       action = CoreAdminAction.PREPRECOVERY;,     },     ,     public void setNodeName(String nodeName) {,       this.nodeName = nodeName;,     },     ,     public String getNodeName() {,       return nodeName;,     },     ,     public String getCoreNodeName() {,       return coreNodeName;,     }, ,     public void setCoreNodeName(String coreNodeName) {,       this.coreNodeName = coreNodeName;,     }, ,     public String getState() {,       return state;,     }, ,     public void setState(String state) {,       this.state = state;,     }, ,     public Boolean getCheckLive() {,       return checkLive;,     }, ,     public void setCheckLive(Boolean checkLive) {,       this.checkLive = checkLive;,     },     ,     public boolean isOnlyIfLeader() {,       return onlyIfLeader;,     }, ,     public void setOnlyIfLeader(boolean onlyIfLeader) {,       this.onlyIfLeader = onlyIfLeader;,     },     ,     public void setOnlyIfLeaderActive(boolean onlyIfLeaderActive) {,       this.onlyIfLeaderActive = onlyIfLeaderActive;,     },     ,     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set( CoreAdminParams.ACTION, action.toString() );,  ,       params.set( CoreAdminParams.CORE, core );,       ,       if (nodeName != null) {,         params.set( "nodeName", nodeName);,       },       ,       if (coreNodeName != null) {,         params.set( "coreNodeName", coreNodeName);,       },       ,       if (state != null) {,         params.set( "state", state);,       },       ,       if (checkLive != null) {,         params.set( "checkLive", checkLive);,       },       ,       if (onlyIfLeader != null) {,         params.set( "onlyIfLeader", onlyIfLeader);,       },       ,       if (onlyIfLeaderActive != null) {,         params.set( "onlyIfLeaderActive", onlyIfLeaderActive);,       }, ,       return params;,     },     ,     public String toString() {,       if (action != null) {,         return "WaitForState: "+getParams();,       } else {,         return super.toString();,       },     },   },   ,   public static class RequestRecovery extends CoreAdminRequest {, ,     public RequestRecovery() {,       action = CoreAdminAction.REQUESTRECOVERY;,     }, ,     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set( CoreAdminParams.ACTION, action.toString() );,  ,       params.set( CoreAdminParams.CORE, core );, ,       return params;,     },   },   ,   public static class RequestSyncShard extends CoreAdminRequest {,     private String shard;,     private String collection;,     ,     public RequestSyncShard() {,       action = CoreAdminAction.REQUESTSYNCSHARD;,     }, ,     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set(CoreAdminParams.ACTION, action.toString());,       params.set("shard", shard);,       params.set("collection", collection);,       params.set(CoreAdminParams.CORE, core);,       return params;,     }, ,     public String getShard() {,       return shard;,     }, ,     public void setShard(String shard) {,       this.shard = shard;,     }, ,     public String getCollection() {,       return collection;,     }, ,     public void setCollection(String collection) {,       this.collection = collection;,     },   },   ,     //a persist core request,   public static class Persist extends CoreAdminRequest {,     protected String fileName = null;,     ,     public Persist() {,       action = CoreAdminAction.PERSIST;,     },     ,     public void setFileName(String name) {,       fileName = name;,     },     public String getFileName() {,       return fileName;,     },     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set( CoreAdminParams.ACTION, action.toString() );,       if (fileName != null) {,         params.set( CoreAdminParams.FILE, fileName);,       },       return params;,     },   },   ,   public static class MergeIndexes extends CoreAdminRequest {,     protected List<String> indexDirs;,     protected List<String> srcCores;, ,     public MergeIndexes() {,       action = CoreAdminAction.MERGEINDEXES;,     }, ,     public void setIndexDirs(List<String> indexDirs) {,       this.indexDirs = indexDirs;,     }, ,     public List<String> getIndexDirs() {,       return indexDirs;,     }, ,     public List<String> getSrcCores() {,       return srcCores;,     }, ,     public void setSrcCores(List<String> srcCores) {,       this.srcCores = srcCores;,     }, ,     @Override,     public SolrParams getParams() {,       if (action == null) {,         throw new RuntimeException("no action specified!");,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set(CoreAdminParams.ACTION, action.toString());,       params.set(CoreAdminParams.CORE, core);,       if (indexDirs != null)  {,         for (String indexDir : indexDirs) {,           params.add(CoreAdminParams.INDEX_DIR, indexDir);,         },       },       if (srcCores != null) {,         for (String srcCore : srcCores) {,           params.add(CoreAdminParams.SRC_CORE, srcCore);,         },       },       return params;,     },   }, ,   public static class Unload extends CoreAdminRequest {,     protected boolean deleteIndex;,     protected boolean deleteDataDir;,     protected boolean deleteInstanceDir;, ,     public Unload(boolean deleteIndex) {,       action = CoreAdminAction.UNLOAD;,       this.deleteIndex = deleteIndex;,     }, ,     public boolean isDeleteIndex() {,       return deleteIndex;,     }, ,     public void setDeleteIndex(boolean deleteIndex) {,       this.deleteIndex = deleteIndex;,     }, ,     public void setDeleteDataDir(boolean deleteDataDir) {,      this.deleteDataDir = deleteDataDir; ,     }, ,     public void setDeleteInstanceDir(boolean deleteInstanceDir){,         this.deleteInstanceDir = deleteInstanceDir;,     }, ,     public boolean isDeleteDataDir() {,       return deleteDataDir;,     }, ,     public boolean isDeleteInstanceDir() {,       return deleteInstanceDir;,     }, ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = (ModifiableSolrParams) super.getParams();,       params.set(CoreAdminParams.DELETE_INDEX, deleteIndex);,       params.set(CoreAdminParams.DELETE_DATA_DIR, deleteDataDir);,       params.set(CoreAdminParams.DELETE_INSTANCE_DIR, deleteInstanceDir);,       return params;,     }, ,   }, ,   public CoreAdminRequest(),   {,     super( METHOD.GET, "/admin/cores" );,   }, ,   public CoreAdminRequest( String path ),   {,     super( METHOD.GET, path );,   }, ,   public final void setCoreName( String coreName ),   {,     this.core = coreName;,   }, ,   public final void setOtherCoreName( String otherCoreName ),   {,     this.other = otherCoreName;,   }, ,   public final void setIndexInfoNeeded(boolean isIndexInfoNeeded) {,     this.isIndexInfoNeeded = isIndexInfoNeeded;,   },   ,   //---------------------------------------------------------------------------------------,   //,   //---------------------------------------------------------------------------------------, ,   public void setAction( CoreAdminAction action ),   {,     this.action = action;,   }, ,   //---------------------------------------------------------------------------------------,   //,   //---------------------------------------------------------------------------------------, ,   @Override,   public SolrParams getParams() ,   {,     if( action == null ) {,       throw new RuntimeException( "no action specified!" );,     },     ModifiableSolrParams params = new ModifiableSolrParams();,     params.set( CoreAdminParams.ACTION, action.toString() );,     params.set( CoreAdminParams.CORE, core );,     params.set(CoreAdminParams.INDEX_INFO, (isIndexInfoNeeded ? "true" : "false"));,     if (other != null) {,       params.set(CoreAdminParams.OTHER, other);,     },     return params;,   }, ,   //---------------------------------------------------------------------------------------,   //,   //---------------------------------------------------------------------------------------, ,   @Override,   public Collection<ContentStream> getContentStreams() throws IOException {,     return null;,   }, ,   @Override,   public CoreAdminResponse process(SolrClient client) throws SolrServerException, IOException,   {,     long startTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     CoreAdminResponse res = new CoreAdminResponse();,     res.setResponse(client.request(this));,     long endTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     res.setElapsedTime(endTime - startTime);,     return res;,   }, ,   //---------------------------------------------------------------------------------------,   //,   //---------------------------------------------------------------------------------------, ,   public static CoreAdminResponse reloadCore(String name, SolrClient client) throws SolrServerException, IOException,   {,     CoreAdminRequest req = new CoreAdminRequest();,     req.setCoreName(name);,     req.setAction(CoreAdminAction.RELOAD);,     return req.process(client);,   }, ,   public static CoreAdminResponse unloadCore(String name, SolrClient client) throws SolrServerException, IOException,   {,     return unloadCore(name, false, client);,   }, ,   public static CoreAdminResponse unloadCore(String name, boolean deleteIndex, SolrClient client) throws SolrServerException, IOException {,     return unloadCore(name, deleteIndex, false, client);,   }, ,   public static CoreAdminResponse unloadCore(String name, boolean deleteIndex, boolean deleteInstanceDir, SolrClient client) throws SolrServerException, IOException {,     Unload req = new Unload(deleteIndex);,     req.setCoreName(name);,     req.setDeleteInstanceDir(deleteInstanceDir);,     return req.process(client);,   }, ,   public static CoreAdminResponse renameCore(String coreName, String newName, SolrClient client ) throws SolrServerException, IOException,   {,     CoreAdminRequest req = new CoreAdminRequest();,     req.setCoreName(coreName);,     req.setOtherCoreName(newName);,     req.setAction( CoreAdminAction.RENAME );,     return req.process( client );,   }, ,   public static CoreAdminResponse getStatus( String name, SolrClient client ) throws SolrServerException, IOException,   {,     CoreAdminRequest req = new CoreAdminRequest();,     req.setCoreName( name );,     req.setAction( CoreAdminAction.STATUS );,     return req.process( client );,   },   ,   public static CoreAdminResponse createCore( String name, String instanceDir, SolrClient client ) throws SolrServerException, IOException,   {,     return CoreAdminRequest.createCore(name, instanceDir, client, null, null);,   },   ,   public static CoreAdminResponse createCore( String name, String instanceDir, SolrClient client, String configFile, String schemaFile ) throws SolrServerException, IOException {,     return createCore(name, instanceDir, client, configFile, schemaFile, null, null);,   },   ,   public static CoreAdminResponse createCore( String name, String instanceDir, SolrClient client, String configFile, String schemaFile, String dataDir, String tlogDir ) throws SolrServerException, IOException,   {,     CoreAdminRequest.Create req = new CoreAdminRequest.Create();,     req.setCoreName( name );,     req.setInstanceDir(instanceDir);,     if (dataDir != null) {,       req.setDataDir(dataDir);,     },     if (tlogDir != null) {,       req.setUlogDir(tlogDir);,     },     if(configFile != null){,       req.setConfigName(configFile);,     },     if(schemaFile != null){,       req.setSchemaName(schemaFile);,     },     return req.process( client );,   }, ,   @Deprecated,   public static CoreAdminResponse persist(String fileName, SolrClient client) throws SolrServerException, IOException,   {,     CoreAdminRequest.Persist req = new CoreAdminRequest.Persist();,     req.setFileName(fileName);,     return req.process(client);,   }, ,   public static CoreAdminResponse mergeIndexes(String name,,       String[] indexDirs, String[] srcCores, SolrClient client) throws SolrServerException,,       IOException {,     CoreAdminRequest.MergeIndexes req = new CoreAdminRequest.MergeIndexes();,     req.setCoreName(name);,     req.setIndexDirs(Arrays.asList(indexDirs));,     req.setSrcCores(Arrays.asList(srcCores));,     return req.process(client);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CoreAdminRequest.java,,50-159,[  public static class Create extends CoreAdminRequest {,     protected String instanceDir;,     protected String configName = null;,     protected String schemaName = null;,     protected String dataDir = null;,     protected String ulogDir = null;,     protected String configSet = null;,     protected String collection;,     private Integer numShards;,     private String shardId;,     private String roles;,     private String coreNodeName;,     private Boolean loadOnStartup;,     private Boolean isTransient;,     private String collectionConfigName;, ,     public Create() {,       action = CoreAdminAction.CREATE;,     },     ,     public void setInstanceDir(String instanceDir) { this.instanceDir = instanceDir; },     public void setSchemaName(String schema) { this.schemaName = schema; },     public void setConfigName(String config) { this.configName = config; },     public void setDataDir(String dataDir) { this.dataDir = dataDir; },     public void setUlogDir(String ulogDir) { this.ulogDir = ulogDir; },     public void setConfigSet(String configSet) {,       this.configSet = configSet;,     },     public void setCollection(String collection) { this.collection = collection; },     public void setNumShards(int numShards) {this.numShards = numShards;},     public void setShardId(String shardId) {this.shardId = shardId;},     public void setRoles(String roles) {this.roles = roles;},     public void setCoreNodeName(String coreNodeName) {this.coreNodeName = coreNodeName;},     public void setIsTransient(Boolean isTransient) { this.isTransient = isTransient; },     public void setIsLoadOnStartup(Boolean loadOnStartup) { this.loadOnStartup = loadOnStartup;},     public void setCollectionConfigName(String name) { this.collectionConfigName = name;}, ,     public String getInstanceDir() { return instanceDir; },     public String getSchemaName()  { return schemaName; },     public String getConfigName()  { return configName; },     public String getDataDir() { return dataDir; },     public String getUlogDir() { return ulogDir; },     public String getConfigSet() {,       return configSet;,     },     public String getCollection() { return collection; },     public String getShardId() { return shardId; },     public String getRoles() { return roles; },     public String getCoreNodeName() { return coreNodeName; },     public Boolean getIsLoadOnStartup() { return loadOnStartup; },     public Boolean getIsTransient() { return isTransient; },     public String getCollectionConfigName() { return collectionConfigName;},     ,     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set( CoreAdminParams.ACTION, action.toString() );,       if( action.equals(CoreAdminAction.CREATE) ) {,         params.set( CoreAdminParams.NAME, core );,       } else {,         params.set( CoreAdminParams.CORE, core );,       },       params.set( CoreAdminParams.INSTANCE_DIR, instanceDir);,       if (configName != null) {,         params.set( CoreAdminParams.CONFIG, configName);,       },       if (schemaName != null) {,         params.set( CoreAdminParams.SCHEMA, schemaName);,       },       if (dataDir != null) {,         params.set( CoreAdminParams.DATA_DIR, dataDir);,       },       if (ulogDir != null) {,         params.set( CoreAdminParams.ULOG_DIR, ulogDir);,       },       if (configSet != null) {,         params.set( CoreAdminParams.CONFIGSET, configSet);,       },       if (collection != null) {,         params.set( CoreAdminParams.COLLECTION, collection);,       },       if (numShards != null) {,         params.set( ZkStateReader.NUM_SHARDS_PROP, numShards);,       },       if (shardId != null) {,         params.set( CoreAdminParams.SHARD, shardId);,       },       if (roles != null) {,         params.set( CoreAdminParams.ROLES, roles);,       },       if (coreNodeName != null) {,         params.set( CoreAdminParams.CORE_NODE_NAME, coreNodeName);,       }, ,       if (isTransient != null) {,         params.set(CoreAdminParams.TRANSIENT, isTransient);,       }, ,       if (loadOnStartup != null) {,         params.set(CoreAdminParams.LOAD_ON_STARTUP, loadOnStartup);,       },       ,       if (collectionConfigName != null) {,         params.set("collection.configName", collectionConfigName);,       },       ,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CoreAdminRequest.java,,352-394,[  public static class MergeIndexes extends CoreAdminRequest {,     protected List<String> indexDirs;,     protected List<String> srcCores;, ,     public MergeIndexes() {,       action = CoreAdminAction.MERGEINDEXES;,     }, ,     public void setIndexDirs(List<String> indexDirs) {,       this.indexDirs = indexDirs;,     }, ,     public List<String> getIndexDirs() {,       return indexDirs;,     }, ,     public List<String> getSrcCores() {,       return srcCores;,     }, ,     public void setSrcCores(List<String> srcCores) {,       this.srcCores = srcCores;,     }, ,     @Override,     public SolrParams getParams() {,       if (action == null) {,         throw new RuntimeException("no action specified!");,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set(CoreAdminParams.ACTION, action.toString());,       params.set(CoreAdminParams.CORE, core);,       if (indexDirs != null)  {,         for (String indexDir : indexDirs) {,           params.add(CoreAdminParams.INDEX_DIR, indexDir);,         },       },       if (srcCores != null) {,         for (String srcCore : srcCores) {,           params.add(CoreAdminParams.SRC_CORE, srcCore);,         },       },       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CoreAdminRequest.java,,325-348,[  public static class Persist extends CoreAdminRequest {,     protected String fileName = null;,     ,     public Persist() {,       action = CoreAdminAction.PERSIST;,     },     ,     public void setFileName(String name) {,       fileName = name;,     },     public String getFileName() {,       return fileName;,     },     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set( CoreAdminParams.ACTION, action.toString() );,       if (fileName != null) {,         params.set( CoreAdminParams.FILE, fileName);,       },       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CoreAdminRequest.java,,266-282,[  public static class RequestRecovery extends CoreAdminRequest {, ,     public RequestRecovery() {,       action = CoreAdminAction.REQUESTRECOVERY;,     }, ,     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set( CoreAdminParams.ACTION, action.toString() );,  ,       params.set( CoreAdminParams.CORE, core );, ,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CoreAdminRequest.java,,286-321,[  public static class RequestSyncShard extends CoreAdminRequest {,     private String shard;,     private String collection;,     ,     public RequestSyncShard() {,       action = CoreAdminAction.REQUESTSYNCSHARD;,     }, ,     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set(CoreAdminParams.ACTION, action.toString());,       params.set("shard", shard);,       params.set("collection", collection);,       params.set(CoreAdminParams.CORE, core);,       return params;,     }, ,     public String getShard() {,       return shard;,     }, ,     public void setShard(String shard) {,       this.shard = shard;,     }, ,     public String getCollection() {,       return collection;,     }, ,     public void setCollection(String collection) {,       this.collection = collection;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CoreAdminRequest.java,,398-438,[  public static class Unload extends CoreAdminRequest {,     protected boolean deleteIndex;,     protected boolean deleteDataDir;,     protected boolean deleteInstanceDir;, ,     public Unload(boolean deleteIndex) {,       action = CoreAdminAction.UNLOAD;,       this.deleteIndex = deleteIndex;,     }, ,     public boolean isDeleteIndex() {,       return deleteIndex;,     }, ,     public void setDeleteIndex(boolean deleteIndex) {,       this.deleteIndex = deleteIndex;,     }, ,     public void setDeleteDataDir(boolean deleteDataDir) {,      this.deleteDataDir = deleteDataDir; ,     }, ,     public void setDeleteInstanceDir(boolean deleteInstanceDir){,         this.deleteInstanceDir = deleteInstanceDir;,     }, ,     public boolean isDeleteDataDir() {,       return deleteDataDir;,     }, ,     public boolean isDeleteInstanceDir() {,       return deleteInstanceDir;,     }, ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams params = (ModifiableSolrParams) super.getParams();,       params.set(CoreAdminParams.DELETE_INDEX, deleteIndex);,       params.set(CoreAdminParams.DELETE_DATA_DIR, deleteDataDir);,       params.set(CoreAdminParams.DELETE_INSTANCE_DIR, deleteInstanceDir);,       return params;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/CoreAdminRequest.java,,164-261,[  public static class WaitForState extends CoreAdminRequest {,     protected String nodeName;,     protected String coreNodeName;,     protected String state;,     protected Boolean checkLive;,     protected Boolean onlyIfLeader;,     protected Boolean onlyIfLeaderActive;, ,     public WaitForState() {,       action = CoreAdminAction.PREPRECOVERY;,     },     ,     public void setNodeName(String nodeName) {,       this.nodeName = nodeName;,     },     ,     public String getNodeName() {,       return nodeName;,     },     ,     public String getCoreNodeName() {,       return coreNodeName;,     }, ,     public void setCoreNodeName(String coreNodeName) {,       this.coreNodeName = coreNodeName;,     }, ,     public String getState() {,       return state;,     }, ,     public void setState(String state) {,       this.state = state;,     }, ,     public Boolean getCheckLive() {,       return checkLive;,     }, ,     public void setCheckLive(Boolean checkLive) {,       this.checkLive = checkLive;,     },     ,     public boolean isOnlyIfLeader() {,       return onlyIfLeader;,     }, ,     public void setOnlyIfLeader(boolean onlyIfLeader) {,       this.onlyIfLeader = onlyIfLeader;,     },     ,     public void setOnlyIfLeaderActive(boolean onlyIfLeaderActive) {,       this.onlyIfLeaderActive = onlyIfLeaderActive;,     },     ,     @Override,     public SolrParams getParams() {,       if( action == null ) {,         throw new RuntimeException( "no action specified!" );,       },       ModifiableSolrParams params = new ModifiableSolrParams();,       params.set( CoreAdminParams.ACTION, action.toString() );,  ,       params.set( CoreAdminParams.CORE, core );,       ,       if (nodeName != null) {,         params.set( "nodeName", nodeName);,       },       ,       if (coreNodeName != null) {,         params.set( "coreNodeName", coreNodeName);,       },       ,       if (state != null) {,         params.set( "state", state);,       },       ,       if (checkLive != null) {,         params.set( "checkLive", checkLive);,       },       ,       if (onlyIfLeader != null) {,         params.set( "onlyIfLeader", onlyIfLeader);,       },       ,       if (onlyIfLeaderActive != null) {,         params.set( "onlyIfLeaderActive", onlyIfLeaderActive);,       }, ,       return params;,     },     ,     public String toString() {,       if (action != null) {,         return "WaitForState: "+getParams();,       } else {,         return super.toString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/client/solrj/request/CoreAdminRequest.java,isOnlyIfLeader,209-209,[      return onlyIfLeader;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/DirectXmlRequest.java,,38-71,[public class DirectXmlRequest extends SolrRequest implements IsUpdateRequest, {,   final String xml;,   private SolrParams params;,   ,   public DirectXmlRequest( String path, String body ),   {,     super( METHOD.POST, path );,     xml = body;,   }, ,   @Override,   public Collection<ContentStream> getContentStreams() {,     return ClientUtils.toContentStreams( xml, ClientUtils.TEXT_XML );,   }, ,   @Override,   public SolrParams getParams() {,     return params;,   }, , ,   public void setParams(SolrParams params) {,     this.params = params;,   }, ,   @Override,   public UpdateResponse process(SolrClient client) throws SolrServerException, IOException,   {,     long startTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     UpdateResponse res = new UpdateResponse();,     res.setResponse(client.request(this));,     res.setElapsedTime( TimeUnit.MILLISECONDS.convert(System.nanoTime()-startTime, TimeUnit.NANOSECONDS) );,     return res;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/DocumentAnalysisRequest.java,,43-206,[public class DocumentAnalysisRequest extends SolrRequest {, ,   private List<SolrInputDocument> documents = new ArrayList<>();,   private String query;,   private boolean showMatch = false;, ,   /**,    * Constructs a new request with a default uri of "/documentanalysis".,    */,   public DocumentAnalysisRequest() {,     super(METHOD.POST, "/analysis/document");,   }, ,   /**,    * Constructs a new request with the given request handler uri.,    *,    * @param uri The of the request handler.,    */,   public DocumentAnalysisRequest(String uri) {,     super(METHOD.POST, uri);,   }, ,   /**,    * {@inheritDoc},    */,   @Override,   public Collection<ContentStream> getContentStreams() throws IOException {,     return ClientUtils.toContentStreams(getXML(), ClientUtils.TEXT_XML);,   }, ,   /**,    * {@inheritDoc},    */,   @Override,   public ModifiableSolrParams getParams() {,     ModifiableSolrParams params = new ModifiableSolrParams();,     if (query != null) {,       params.add(AnalysisParams.QUERY, query);,       params.add(AnalysisParams.SHOW_MATCH, String.valueOf(showMatch));,     },     return params;,   }, ,   /**,    * {@inheritDoc},    */,   @Override,   public DocumentAnalysisResponse process(SolrClient client) throws SolrServerException, IOException {,     long startTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     DocumentAnalysisResponse res = new DocumentAnalysisResponse();,     res.setResponse(client.request(this));,     long endTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     res.setElapsedTime(endTime - startTime);,     return res;,   }, ,   //================================================ Helper Methods ==================================================, ,   /**,    * Returns the xml be be set as the request body.,    *,    * @return The xml be be set as the request body.,    *,    * @throws IOException When constructing the xml fails,    */,   String getXML() throws IOException {,     StringWriter writer = new StringWriter();,     writer.write("<docs>");,     for (SolrInputDocument document : documents) {,       ClientUtils.writeXML(document, writer);,     },     writer.write("</docs>");,     writer.flush();, ,     String xml = writer.toString();,     return (xml.length() > 0) ? xml : null;,   }, , ,   //============================================ Setter/Getter Methods ===============================================, ,   /**,    * Adds a document to be analyzed.,    *,    * @param doc The document to be analyzed.,    *,    * @return This DocumentAnalysisRequest (fluent interface support).,    */,   public DocumentAnalysisRequest addDocument(SolrInputDocument doc) {,     documents.add(doc);,     return this;,   }, ,   /**,    * Adds a collection of documents to be analyzed.,    *,    * @param docs The documents to be analyzed.,    *,    * @return This DocumentAnalysisRequest (fluent interface support).,    *,    * @see #addDocument(org.apache.solr.common.SolrInputDocument),    */,   public DocumentAnalysisRequest addDocuments(Collection<SolrInputDocument> docs) {,     documents.addAll(docs);,     return this;,   }, ,   /**,    * Sets the query to be analyzed. By default the query is set to null, meaning no query analysis will be performed.,    *,    * @param query The query to be analyzed.,    *,    * @return This DocumentAnalysisRequest (fluent interface support).,    */,   public DocumentAnalysisRequest setQuery(String query) {,     this.query = query;,     return this;,   }, ,   /**,    * Sets whether index time tokens that match query time tokens should be marked as a "match". By default this is set,    * to {@code false}. Obviously, this flag is ignored if when the query is set to {@code null}.,    *,    * @param showMatch Sets whether index time tokens that match query time tokens should be marked as a "match".,    *,    * @return This DocumentAnalysisRequest (fluent interface support).,    */,   public DocumentAnalysisRequest setShowMatch(boolean showMatch) {,     this.showMatch = showMatch;,     return this;,   }, ,   /**,    * Returns all documents that will be analyzed when processing the request.,    *,    * @return All documents that will be analyzed when processing the request.,    *,    * @see #addDocument(org.apache.solr.common.SolrInputDocument),    */,   public List<SolrInputDocument> getDocuments() {,     return documents;,   }, ,   /**,    * Returns the query that will be analyzed when processing the request. May return {@code null} indicating that no,    * query time analysis is taking place.,    *,    * @return The query that will be analyzed when processing the request.,    *,    * @see #setQuery(String),    */,   public String getQuery() {,     return query;,   }, ,   /**,    * Returns whether index time tokens that match query time tokens will be marked as a "match".,    *,    * @return Whether index time tokens that match query time tokens will be marked as a "match".,    *,    * @see #setShowMatch(boolean),    */,   public boolean isShowMatch() {,     return showMatch;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/FieldAnalysisRequest.java,,41-278,[public class FieldAnalysisRequest extends SolrRequest {, ,   private String fieldValue;,   private String query;,   private boolean showMatch;,   private List<String> fieldNames;,   private List<String> fieldTypes;, ,   /**,    * Constructs a new FieldAnalysisRequest with a default uri of "/fieldanalysis".,    */,   public FieldAnalysisRequest() {,     super(METHOD.GET, "/analysis/field");,   }, ,   /**,    * Constructs a new FieldAnalysisRequest with a given uri.,    *,    * @param uri the uri of the request handler.,    */,   public FieldAnalysisRequest(String uri) {,     super(METHOD.GET, uri);,   }, ,   /**,    * {@inheritDoc},    */,   @Override,   public Collection<ContentStream> getContentStreams() throws IOException {,     return null;,   }, ,   /**,    * {@inheritDoc},    */,   @Override,   public SolrParams getParams() {,     ModifiableSolrParams params = new ModifiableSolrParams();,     params.set(AnalysisParams.FIELD_VALUE, fieldValue);,     if (query != null) {,       params.add(AnalysisParams.QUERY, query);,       params.add(AnalysisParams.SHOW_MATCH, String.valueOf(showMatch));,     },     if (fieldNames != null) {,       String fieldNameValue = listToCommaDelimitedString(fieldNames);,       params.add(AnalysisParams.FIELD_NAME, fieldNameValue);,     },     if (fieldTypes != null) {,       String fieldTypeValue = listToCommaDelimitedString(fieldTypes);,       params.add(AnalysisParams.FIELD_TYPE, fieldTypeValue);,     },     return params;,   }, ,   /**,    * {@inheritDoc},    */,   @Override,   public FieldAnalysisResponse process(SolrClient server) throws SolrServerException, IOException {,     if (fieldTypes == null && fieldNames == null) {,       throw new IllegalStateException("At least one field type or field name need to be specified");,     },     if (fieldValue == null) {,       throw new IllegalStateException("The field value must be set");,     },     long startTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     FieldAnalysisResponse res = new FieldAnalysisResponse();,     res.setResponse(server.request(this));,     long endTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     res.setElapsedTime(endTime - startTime);,     return res;,   }, , ,   //================================================ Helper Methods ==================================================, ,   /**,    * Convers the given list of string to a comma-separated string.,    *,    * @param list The list of string.,    *,    * @return The comma-separated string.,    */,   static String listToCommaDelimitedString(List<String> list) {,     StringBuilder result = new StringBuilder();,     for (String str : list) {,       if (result.length() > 0) {,         result.append(",");,       },       result.append(str);,     },     return result.toString();,   }, , ,   //============================================ Setter/Getter Methods ===============================================, ,   /**,    * Sets the field value to be analyzed.,    *,    * @param fieldValue The field value to be analyzed.,    *,    * @return This FieldAnalysisRequest (fluent interface support).,    */,   public FieldAnalysisRequest setFieldValue(String fieldValue) {,     this.fieldValue = fieldValue;,     return this;,   }, ,   /**,    * Returns the field value that will be analyzed when this request is processed.,    *,    * @return The field value that will be analyzed when this request is processed.,    */,   public String getFieldValue() {,     return fieldValue;,   }, ,   /**,    * Sets the query to be analyzed. May be {@code null} indicated that no query analysis should take place.,    *,    * @param query The query to be analyzed.,    *,    * @return This FieldAnalysisRequest (fluent interface support).,    */,   public FieldAnalysisRequest setQuery(String query) {,     this.query = query;,     return this;,   }, ,   /**,    * Returns the query that will be analyzed. May return {@code null} indicating that no query analysis will be,    * performed.,    *,    * @return The query that will be analyzed. May return {@code null} indicating that no query analysis will be,    *         performed.,    */,   public String getQuery() {,     return query;,   }, ,   /**,    * Sets whether index time tokens that match query time tokens should be marked as a "match". By default this is set,    * to {@code false}. Obviously, this flag is ignored if when the query is set to {@code null}.,    *,    * @param showMatch Sets whether index time tokens that match query time tokens should be marked as a "match".,    *,    * @return This FieldAnalysisRequest (fluent interface support).,    */,   public FieldAnalysisRequest setShowMatch(boolean showMatch) {,     this.showMatch = showMatch;,     return this;,   }, ,   /**,    * Returns whether index time tokens that match query time tokens should be marked as a "match".,    *,    * @return Whether index time tokens that match query time tokens should be marked as a "match".,    *,    * @see #setShowMatch(boolean),    */,   public boolean isShowMatch() {,     return showMatch;,   }, ,   /**,    * Adds the given field name for analysis.,    *,    * @param fieldName A field name on which the analysis should be performed.,    *,    * @return this FieldAnalysisRequest (fluent interface support).,    */,   public FieldAnalysisRequest addFieldName(String fieldName) {,     if (fieldNames == null) {,       fieldNames = new LinkedList<>();,     },     fieldNames.add(fieldName);,     return this;,   }, ,   /**,      * Sets the field names on which the analysis should be performed.,      *,      * @param fieldNames The field names on which the analysis should be performed.,      *,      * @return this FieldAnalysisRequest (fluent interface support).,      */,   public FieldAnalysisRequest setFieldNames(List<String> fieldNames) {,     this.fieldNames = fieldNames;,     return this;,   }, ,   /**,    * Returns a list of field names the analysis should be performed on. May return {@code null} indicating that no,    * analysis will be performed on field names.,    *,    * @return The field names the analysis should be performed on.,    */,   public List<String> getFieldNames() {,     return fieldNames;,   }, ,   /**,    * Adds the given field type for analysis.,    *,    * @param fieldTypeName A field type name on which analysis should be performed.,    *,    * @return This FieldAnalysisRequest (fluent interface support).,    */,   public FieldAnalysisRequest addFieldType(String fieldTypeName) {,     if (fieldTypes == null) {,       fieldTypes = new LinkedList<>();,     },     fieldTypes.add(fieldTypeName);,     return this;,   }, , /**,    * Sets the field types on which analysis should be performed.,    *,    * @param fieldTypes The field type names on which analysis should be performed.,    *,    * @return This FieldAnalysisRequest (fluent interface support).,    */,   public FieldAnalysisRequest setFieldTypes(List<String> fieldTypes) {,     this.fieldTypes = fieldTypes;,     return this;,   }, , ,   /**,    * Returns a list of field types the analysis should be performed on. May return {@code null} indicating that no,    * analysis will be peformed on field types.,    *,    * @return The field types the analysis should be performed on.,    */,   public List<String> getFieldTypes() {,     return fieldTypes;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.java,unmarshal,190-190,[      docMap =  new ArrayList(((Map)docsMapObj).entrySet());],,unmarshal,192-192,[      docMap = (List<Entry<SolrInputDocument, Map<Object, Object>>>) docsMapObj;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.java,unmarshal,186-186,[    doclist = (List) namedList[0].get("docs");],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/LukeRequest.java,,40-125,[public class LukeRequest extends SolrRequest, {,   private List<String> fields;,   private int numTerms = -1;,   private boolean showSchema = false;,   ,   public LukeRequest(),   {,     super( METHOD.GET, "/admin/luke" );,   }, ,   public LukeRequest( String path ),   {,     super( METHOD.GET, path );,   }, ,   //---------------------------------------------------------------------------------,   //---------------------------------------------------------------------------------,   ,   public void addField( String f ),   {,     if( fields == null ) {,       fields = new ArrayList<>();,     },     fields.add( f );,   }, ,   public void setFields( List<String> f ),   {,     fields = f;,   },   ,   //---------------------------------------------------------------------------------,   //---------------------------------------------------------------------------------,   ,   public boolean isShowSchema() {,     return showSchema;,   }, ,   public void setShowSchema(boolean showSchema) {,     this.showSchema = showSchema;,   }, ,   public int getNumTerms() {,     return numTerms;,   }, ,   /**,    * the number of terms to return for a given field.  If the number is 0, it will not traverse the terms.  ,    */,   public void setNumTerms(int count) {,     this.numTerms = count;,   }, ,   //---------------------------------------------------------------------------------,   //---------------------------------------------------------------------------------,   ,   @Override,   public Collection<ContentStream> getContentStreams() {,     return null;,   }, ,   @Override,   public SolrParams getParams() {,     ModifiableSolrParams params = new ModifiableSolrParams();,     if( fields != null && fields.size() > 0 ) {,       params.add( CommonParams.FL, fields.toArray( new String[fields.size()] ) );,     },     if( numTerms >= 0 ) {,       params.add( "numTerms", numTerms+"" );,     },     if (showSchema) {,       params.add("show", "schema");,     },     return params;,   }, ,   @Override,   public LukeResponse process( SolrClient client ) throws SolrServerException, IOException,   {,     long startTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     LukeResponse res = new LukeResponse();,     res.setResponse(client.request(this));,     long endTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,     res.setElapsedTime(endTime - startTime);,     return res;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/QueryRequest.java,,37-100,[public class QueryRequest extends SolrRequest, {,   private SolrParams query;,   ,   public QueryRequest(),   {,     super( METHOD.GET, null );,   }, ,   public QueryRequest( SolrParams q ),   {,     super( METHOD.GET, null );,     query = q;,   },   ,   public QueryRequest( SolrParams q, METHOD method ),   {,     super( method, null );,     query = q;,   }, ,   /**,    * Use the params 'QT' parameter if it exists,    */,   @Override,   public String getPath() {,     String qt = query == null ? null : query.get( CommonParams.QT );,     if( qt == null ) {,       qt = super.getPath();,     },     if( qt != null && qt.startsWith( "/" ) ) {,       return qt;,     },     return "/select";,   },   ,   //---------------------------------------------------------------------------------,   //---------------------------------------------------------------------------------,   ,   @Override,   public Collection<ContentStream> getContentStreams() {,     return null;,   }, ,   @Override,   public SolrParams getParams() {,     return query;,   }, ,   @Override,   public QueryResponse process( SolrClient client ) throws SolrServerException,   {,     try {,       long startTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,       QueryResponse res = new QueryResponse( client.request( this ), client );,       long endTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);,       res.setElapsedTime(endTime - startTime);,       return res;,     } catch (SolrServerException e){,       throw e;,     } catch (SolrException s){,       throw s;,     } catch (Exception e) {,       throw new SolrServerException("Error executing query", e);],,
CORRECTNESS,RC_REF_COMPARISON,org/apache/solr/client/solrj/request/UpdateRequest.java,getDocLists,299-299,[        if (overwrite != lastOverwrite || commitWithin != lastCommitWithin],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/solr/client/solrj/request/UpdateRequest.java,getDocLists,299-299,[        if (overwrite != lastOverwrite || commitWithin != lastCommitWithin],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/request/UpdateRequest.java,,54-432,[  private Map<SolrInputDocument,Map<String,Object>> documents = null;,   private Iterator<SolrInputDocument> docIterator = null;,   private Map<String,Map<String,Object>> deleteById = null;,   private List<String> deleteQuery = null;,   ,   public UpdateRequest() {,     super(METHOD.POST, "/update");,   },   ,   public UpdateRequest(String url) {,     super(METHOD.POST, url);,   },   ,   // ---------------------------------------------------------------------------,   // ---------------------------------------------------------------------------,   ,   /**,    * clear the pending documents and delete commands,    */,   public void clear() {,     if (documents != null) {,       documents.clear();,     },     if (deleteById != null) {,       deleteById.clear();,     },     if (deleteQuery != null) {,       deleteQuery.clear();,     },   },   ,   // ---------------------------------------------------------------------------,   // ---------------------------------------------------------------------------,   ,   public UpdateRequest add(final SolrInputDocument doc) {,     if (documents == null) {,       documents = new LinkedHashMap<>();,     },     documents.put(doc, null);,     return this;,   },   ,   public UpdateRequest add(final SolrInputDocument doc, Boolean overwrite) {,     return add(doc, null, overwrite);,   },   ,   public UpdateRequest add(final SolrInputDocument doc, Integer commitWithin) {,     return add(doc, commitWithin, null);,   },   ,   public UpdateRequest add(final SolrInputDocument doc, Integer commitWithin,,       Boolean overwrite) {,     if (documents == null) {,       documents = new LinkedHashMap<>();,     },     Map<String,Object> params = new HashMap<>(2);,     if (commitWithin != null) params.put(COMMIT_WITHIN, commitWithin);,     if (overwrite != null) params.put(OVERWRITE, overwrite);,     ,     documents.put(doc, params);,     ,     return this;,   },   ,   public UpdateRequest add(final Collection<SolrInputDocument> docs) {,     if (documents == null) {,       documents = new LinkedHashMap<>();,     },     for (SolrInputDocument doc : docs) {,       documents.put(doc, null);,     },     return this;,   },   ,   public UpdateRequest deleteById(String id) {,     if (deleteById == null) {,       deleteById = new LinkedHashMap<>();,     },     deleteById.put(id, null);,     return this;,   },   ,   public UpdateRequest deleteById(List<String> ids) {,     if (deleteById == null) {,       deleteById = new LinkedHashMap<>();,     },     ,     for (String id : ids) {,       deleteById.put(id, null);,     },     ,     return this;,   },   ,   public UpdateRequest deleteById(String id, Long version) {,     if (deleteById == null) {,       deleteById = new LinkedHashMap<>();,     },     Map<String,Object> params = new HashMap<>(1);,     params.put(VER, version);,     deleteById.put(id, params);,     return this;,   },   ,   public UpdateRequest deleteByQuery(String q) {,     if (deleteQuery == null) {,       deleteQuery = new ArrayList<>();,     },     deleteQuery.add(q);,     return this;,   },   ,   /**,    * @param router to route updates with,    * @param col DocCollection for the updates,    * @param urlMap of the cluster,    * @param params params to use,    * @param idField the id field,    * @return a Map of urls to requests,    */,   public Map<String,LBHttpSolrClient.Req> getRoutes(DocRouter router,,       DocCollection col, Map<String,List<String>> urlMap,,       ModifiableSolrParams params, String idField) {,     ,     if ((documents == null || documents.size() == 0),         && (deleteById == null || deleteById.size() == 0)) {,       return null;,     },     ,     Map<String,LBHttpSolrClient.Req> routes = new HashMap<>();,     if (documents != null) {,       Set<Entry<SolrInputDocument,Map<String,Object>>> entries = documents.entrySet();,       for (Entry<SolrInputDocument,Map<String,Object>> entry : entries) {,         SolrInputDocument doc = entry.getKey();,         Object id = doc.getFieldValue(idField);,         if (id == null) {,           return null;,         },         Slice slice = router.getTargetSlice(id,             .toString(), doc, null, col);,         if (slice == null) {,           return null;,         },         List<String> urls = urlMap.get(slice.getName());,         String leaderUrl = urls.get(0);,         LBHttpSolrClient.Req request = (LBHttpSolrClient.Req) routes,             .get(leaderUrl);,         if (request == null) {,           UpdateRequest updateRequest = new UpdateRequest();,           updateRequest.setMethod(getMethod());,           updateRequest.setCommitWithin(getCommitWithin());,           updateRequest.setParams(params);,           updateRequest.setPath(getPath());,           request = new LBHttpSolrClient.Req(updateRequest, urls);,           routes.put(leaderUrl, request);,         },         UpdateRequest urequest = (UpdateRequest) request.getRequest();,         urequest.add(doc);,       },     },     ,     // Route the deleteById's,     ,     if (deleteById != null) {,       ,       Iterator<Map.Entry<String,Map<String,Object>>> entries = deleteById.entrySet(),           .iterator();,       while (entries.hasNext()) {,         ,         Map.Entry<String,Map<String,Object>> entry = entries.next();,         ,         String deleteId = entry.getKey();,         Map<String,Object> map = entry.getValue();,         Long version = null;,         if (map != null) {,           version = (Long) map.get(VER);,         },         Slice slice = router.getTargetSlice(deleteId, null, null, col);,         if (slice == null) {,           return null;,         },         List<String> urls = urlMap.get(slice.getName());,         String leaderUrl = urls.get(0);,         LBHttpSolrClient.Req request = routes.get(leaderUrl);,         if (request != null) {,           UpdateRequest urequest = (UpdateRequest) request.getRequest();,           urequest.deleteById(deleteId, version);,         } else {,           UpdateRequest urequest = new UpdateRequest();,           urequest.setParams(params);,           urequest.deleteById(deleteId, version);,           request = new LBHttpSolrClient.Req(urequest, urls);,           routes.put(leaderUrl, request);,         },       },     }, ,     return routes;,   },   ,   public void setDocIterator(Iterator<SolrInputDocument> docIterator) {,     this.docIterator = docIterator;,   },   ,   public void setDeleteQuery(List<String> deleteQuery) {,     this.deleteQuery = deleteQuery;,   },   ,   // --------------------------------------------------------------------------,   // --------------------------------------------------------------------------,   ,   @Override,   public Collection<ContentStream> getContentStreams() throws IOException {,     return ClientUtils.toContentStreams(getXML(), ClientUtils.TEXT_XML);,   },   ,   public String getXML() throws IOException {,     StringWriter writer = new StringWriter();,     writeXML(writer);,     writer.flush();,     ,     // If action is COMMIT or OPTIMIZE, it is sent with params,     String xml = writer.toString();,     // System.out.println( "SEND:"+xml );,     return (xml.length() > 0) ? xml : null;,   },   ,   private List<Map<SolrInputDocument,Map<String,Object>>> getDocLists(Map<SolrInputDocument,Map<String,Object>> documents) {,     List<Map<SolrInputDocument,Map<String,Object>>> docLists = new ArrayList<>();,     Map<SolrInputDocument,Map<String,Object>> docList = null;,     if (this.documents != null) {,       ,       Boolean lastOverwrite = true;,       Integer lastCommitWithin = -1;,       ,       Set<Entry<SolrInputDocument,Map<String,Object>>> entries = this.documents,           .entrySet();,       for (Entry<SolrInputDocument,Map<String,Object>> entry : entries) {,         Map<String,Object> map = entry.getValue();,         Boolean overwrite = null;,         Integer commitWithin = null;,         if (map != null) {,           overwrite = (Boolean) entry.getValue().get(OVERWRITE);,           commitWithin = (Integer) entry.getValue().get(COMMIT_WITHIN);,         },         if (overwrite != lastOverwrite || commitWithin != lastCommitWithin,             || docLists.size() == 0) {,           docList = new LinkedHashMap<>();,           docLists.add(docList);,         },         docList.put(entry.getKey(), entry.getValue());,         lastCommitWithin = commitWithin;,         lastOverwrite = overwrite;,       },     },     ,     if (docIterator != null) {,       docList = new LinkedHashMap<>();,       docLists.add(docList);,       while (docIterator.hasNext()) {,         SolrInputDocument doc = docIterator.next();,         if (doc != null) {,           docList.put(doc, null);,         },       },       ,     }, ,     return docLists;,   },   ,   /**,    * @since solr 1.4,    */,   public void writeXML(Writer writer) throws IOException {,     List<Map<SolrInputDocument,Map<String,Object>>> getDocLists = getDocLists(documents);,     ,     for (Map<SolrInputDocument,Map<String,Object>> docs : getDocLists) {,       ,       if ((docs != null && docs.size() > 0)) {,         Entry<SolrInputDocument,Map<String,Object>> firstDoc = docs.entrySet(),             .iterator().next();,         Map<String,Object> map = firstDoc.getValue();,         Integer cw = null;,         Boolean ow = null;,         if (map != null) {,           cw = (Integer) firstDoc.getValue().get(COMMIT_WITHIN);,           ow = (Boolean) firstDoc.getValue().get(OVERWRITE);,         },         if (ow == null) ow = true;,         int commitWithin = (cw != null && cw != -1) ? cw : this.commitWithin;,         boolean overwrite = ow;,         if (commitWithin > -1 || overwrite != true) {,           writer.write("<add commitWithin=\"" + commitWithin + "\" ",               + "overwrite=\"" + overwrite + "\">");,         } else {,           writer.write("<add>");,         },         ,         Set<Entry<SolrInputDocument,Map<String,Object>>> entries = docs,             .entrySet();,         for (Entry<SolrInputDocument,Map<String,Object>> entry : entries) {,           ClientUtils.writeXML(entry.getKey(), writer);,         },         ,         writer.write("</add>");,       },     },     ,     // Add the delete commands,     boolean deleteI = deleteById != null && deleteById.size() > 0;,     boolean deleteQ = deleteQuery != null && deleteQuery.size() > 0;,     if (deleteI || deleteQ) {,       if (commitWithin > 0) {,         writer.append("<delete commitWithin=\"" + commitWithin + "\">");,       } else {,         writer.append("<delete>");,       },       if (deleteI) {,         for (Map.Entry<String,Map<String,Object>> entry : deleteById.entrySet()) {,           writer.append("<id");,           Map<String,Object> map = entry.getValue();,           if (map != null) {,             Long version = (Long) map.get(VER);,             if (version != null) {,               writer.append(" version=\"" + version + "\"");,             },           },           writer.append(">");,           ,           XML.escapeCharData(entry.getKey(), writer);,           writer.append("</id>");,         },       },       if (deleteQ) {,         for (String q : deleteQuery) {,           writer.append("<query>");,           XML.escapeCharData(q, writer);,           writer.append("</query>");,         },       },       writer.append("</delete>");,     },   },   ,   // --------------------------------------------------------------------------,   // --------------------------------------------------------------------------,   ,   // --------------------------------------------------------------------------,   //,   // --------------------------------------------------------------------------,   ,   public List<SolrInputDocument> getDocuments() {,     if (documents == null) return null;,     List<SolrInputDocument> docs = new ArrayList<>(documents.size());,     docs.addAll(documents.keySet());,     return docs;,   },   ,   public Map<SolrInputDocument,Map<String,Object>> getDocumentsMap() {,     return documents;,   },   ,   public Iterator<SolrInputDocument> getDocIterator() {,     return docIterator;,   },   ,   public List<String> getDeleteById() {,     if (deleteById == null) return null;,     List<String> deletes = new ArrayList<>(deleteById.keySet());,     return deletes;,   },   ,   public Map<String,Map<String,Object>> getDeleteByIdMap() {,     return deleteById;,   },   ,   public List<String> getDeleteQuery() {,     return deleteQuery;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/AnalysisResponseBase.java,,32-106,[public class AnalysisResponseBase extends SolrResponseBase {, ,   /**,    * Parses the given named list and builds a list of analysis phases form it. Expects a named list of the form:,    * <p/>,    * <pre><code>,    *  &lt;lst name="index"&gt;,    *      &lt;arr name="Tokenizer"&gt;,    *          &lt;str name="text"&gt;the_text&lt;/str&gt;,    *          &lt;str name="rawText"&gt;the_raw_text&lt;/str&gt; (optional),    *          &lt;str name="type"&gt;the_type&lt;/str&gt;,    *          &lt;int name="start"&gt;1&lt;/str&gt;,    *          &lt;int name="end"&gt;3&lt;/str&gt;,    *          &lt;int name="position"&gt;1&lt;/str&gt;,    *          &lt;bool name="match"&gt;true | false&lt;/bool&gt; (optional),    *      &lt;/arr&gt;,    *      &lt;arr name="Filter1"&gt;,    *          &lt;str name="text"&gt;the_text&lt;/str&gt;,    *          &lt;str name="rawText"&gt;the_raw_text&lt;/str&gt; (optional),    *          &lt;str name="type"&gt;the_type&lt;/str&gt;,    *          &lt;int name="start"&gt;1&lt;/str&gt;,    *          &lt;int name="end"&gt;3&lt;/str&gt;,    *          &lt;int name="position"&gt;1&lt;/str&gt;,    *          &lt;bool name="match"&gt;true | false&lt;/bool&gt; (optional),    *      &lt;/arr&gt;,    *      ...,    *  &lt;/lst&gt;,    * </code></pre>,    *,    * @param phaseNL The names list to parse.,    *,    * @return The built analysis phases list.,    */,   protected List<AnalysisPhase> buildPhases(NamedList<List<NamedList<Object>>> phaseNL) {,     List<AnalysisPhase> phases = new ArrayList<>(phaseNL.size());,     for (Map.Entry<String, List<NamedList<Object>>> phaseEntry : phaseNL) {,       AnalysisPhase phase = new AnalysisPhase(phaseEntry.getKey());,       List<NamedList<Object>> tokens = phaseEntry.getValue();,       for (NamedList<Object> token : tokens) {,         TokenInfo tokenInfo = buildTokenInfo(token);,         phase.addTokenInfo(tokenInfo);,       },       phases.add(phase);,     },     return phases;,   }, ,   /**,    * Parses the given named list and builds a token infoform it. Expects a named list of the form:,    * <p/>,    * <pre><code>,    *  &lt;arr name="Tokenizer"&gt;,    *      &lt;str name="text"&gt;the_text&lt;/str&gt;,    *      &lt;str name="rawText"&gt;the_raw_text&lt;/str&gt; (optional),    *      &lt;str name="type"&gt;the_type&lt;/str&gt;,    *      &lt;int name="start"&gt;1&lt;/str&gt;,    *      &lt;int name="end"&gt;3&lt;/str&gt;,    *      &lt;int name="position"&gt;1&lt;/str&gt;,    *      &lt;bool name="match"&gt;true | false&lt;/bool&gt; (optional),    *  &lt;/arr&gt;,    * </code></pre>,    *,    * @param tokenNL The named list to parse.,    *,    * @return The built token info.,    */,   protected TokenInfo buildTokenInfo(NamedList<Object> tokenNL) {,     String text = (String) tokenNL.get("text");,     String rawText = (String) tokenNL.get("rawText");,     String type = (String) tokenNL.get("type");,     int start = (Integer) tokenNL.get("start");,     int end = (Integer) tokenNL.get("end");,     int position = (Integer) tokenNL.get("position");,     Boolean match = (Boolean) tokenNL.get("match");,     return new TokenInfo(text, rawText, type, start, end, position, (match == null ? false : match));],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/CollectionAdminResponse.java,,25-77,[public class CollectionAdminResponse extends SolrResponseBase, {,   @SuppressWarnings("unchecked"),   public NamedList<NamedList<Object>> getCollectionStatus(),   {,     return (NamedList<NamedList<Object>>) getResponse().get( "success" );,   }, ,   public boolean isSuccess(),   {,     return getResponse().get( "success" ) != null;,   }, ,   // this messages are typically from individual nodes, since,   // all the failures at the router are propagated as exceptions,   @SuppressWarnings("unchecked"),   public NamedList<String> getErrorMessages(),   {,      return (NamedList<String>) getResponse().get( "failure" );,   }, ,   @SuppressWarnings("unchecked"),   public Map<String, NamedList<Integer>> getCollectionCoresStatus(),   {,     Map<String, NamedList<Integer>> res = new HashMap<>();,     NamedList<NamedList<Object>> cols = getCollectionStatus();,     if( cols != null ) {,       for (Map.Entry<String, NamedList<Object>> e : cols) {,         NamedList<Object> item = e.getValue();,         String core = (String) item.get("core");,         if (core != null) {,           res.put(core, (NamedList<Integer>)item.get("responseHeader"));,         },       },     }, ,     return res;,   }, ,   @SuppressWarnings("unchecked"),   public Map<String, NamedList<Integer>> getCollectionNodesStatus(),   {,     Map<String, NamedList<Integer>> res = new HashMap<>();,     NamedList<NamedList<Object>> cols = getCollectionStatus();,     if( cols != null ) {,       for (Map.Entry<String,NamedList<Object>> e : cols) {,         if (e.getKey() != null) {,           res.put(e.getKey(), (NamedList<Integer>) (e.getValue().get("responseHeader")));,         },       },     }, ,     return res;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/CoreAdminResponse.java,,28-56,[public class CoreAdminResponse extends SolrResponseBase, { ,   @SuppressWarnings("unchecked"),   public NamedList<NamedList<Object>> getCoreStatus(),   {,     return (NamedList<NamedList<Object>>) getResponse().get( "status" );,   }, ,   public NamedList<Object> getCoreStatus( String core ),   {,     return getCoreStatus().get( core );,   },   ,   public Date getStartTime( String core ),   {,     NamedList<Object> v = getCoreStatus( core );,     if( v == null ) {,       return null;,     },     return (Date) v.get( "startTime" );,   },   ,   public Long getUptime( String core ),   {,     NamedList<Object> v = getCoreStatus( core );,     if( v == null ) {,       return null;,     },     return (Long) v.get( "uptime" );],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/response/DocumentAnalysisResponse.java,,116-158,[  public static class DocumentAnalysis implements Iterable<Map.Entry<String, FieldAnalysis>> {, ,     private final String documentKey;,     private Map<String, FieldAnalysis> fieldAnalysisByFieldName = new HashMap<>();, ,     private DocumentAnalysis(String documentKey) {,       this.documentKey = documentKey;,     }, ,     private void addFieldAnalysis(FieldAnalysis fieldAnalysis) {,       fieldAnalysisByFieldName.put(fieldAnalysis.getFieldName(), fieldAnalysis);,     }, ,     /**,      * Returns the unique key of the analyzed document.,      *,      * @return The unique key of the analyzed document.,      */,     public String getDocumentKey() {,       return documentKey;,     }, ,     /**,      * Returns the number of field analyses for the documents.,      *,      * @return The number of field analyses for the documents.,      */,     public int getFieldAnalysesCount() {,       return fieldAnalysisByFieldName.size();,     }, ,     public FieldAnalysis getFieldAnalysis(String fieldName) {,       return fieldAnalysisByFieldName.get(fieldName);,     }, ,     /**,      * Returns an iterator over the field analyses map.,      *,      * @return An iterator over the field analyses map.,      */,     @Override,     public Iterator<Map.Entry<String, FieldAnalysis>> iterator() {,       return fieldAnalysisByFieldName.entrySet().iterator();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/DocumentAnalysisResponse.java,,34-108,[public class DocumentAnalysisResponse extends AnalysisResponseBase implements Iterable<Map.Entry<String, DocumentAnalysisResponse.DocumentAnalysis>> {, ,   private final Map<String, DocumentAnalysis> documentAnalysisByKey = new HashMap<>();, ,   /**,    * {@inheritDoc},    */,   @Override,   public void setResponse(NamedList<Object> response) {,     super.setResponse(response);, ,     @SuppressWarnings("unchecked"),     NamedList<NamedList<NamedList<Object>>> analysis ,       = (NamedList<NamedList<NamedList<Object>>>) response.get("analysis");,     for (Map.Entry<String, NamedList<NamedList<Object>>> document : analysis) {,       DocumentAnalysis documentAnalysis = new DocumentAnalysis(document.getKey());,       for (Map.Entry<String, NamedList<Object>> fieldEntry : document.getValue()) {,         FieldAnalysis fieldAnalysis = new FieldAnalysis(fieldEntry.getKey());, ,         NamedList<Object> field = fieldEntry.getValue();, ,         @SuppressWarnings("unchecked"),         NamedList<List<NamedList<Object>>> query ,           = (NamedList<List<NamedList<Object>>>) field.get("query");,         if (query != null) {,           List<AnalysisPhase> phases = buildPhases(query);,           fieldAnalysis.setQueryPhases(phases);,         },         ,         @SuppressWarnings("unchecked"),         NamedList<NamedList<List<NamedList<Object>>>> index ,           = (NamedList<NamedList<List<NamedList<Object>>>>) field.get("index");,         for (Map.Entry<String, NamedList<List<NamedList<Object>>>> valueEntry : index) {,           String fieldValue = valueEntry.getKey();,           NamedList<List<NamedList<Object>>> valueNL = valueEntry.getValue();,           List<AnalysisPhase> phases = buildPhases(valueNL);,           fieldAnalysis.setIndexPhases(fieldValue, phases);,         }, ,         documentAnalysis.addFieldAnalysis(fieldAnalysis);,       }, ,       documentAnalysisByKey.put(documentAnalysis.getDocumentKey(), documentAnalysis);,     },   }, ,   /**,    * Returns the number of document analyses in this response.,    *,    * @return The number of document analyses in this response.,    */,   public int getDocumentAnalysesCount() {,     return documentAnalysisByKey.size();,   }, ,   /**,    * Returns the document analysis for the document associated with the given unique key (id), {@code null} if no such,    * association exists.,    *,    * @param documentKey The document unique key.,    *,    * @return The document analysis for the document associated with the given unique key (id).,    */,   public DocumentAnalysis getDocumentAnalysis(String documentKey) {,     return documentAnalysisByKey.get(documentKey);,   }, ,   /**,    * Returns an iterator over the document analyses map.,    *,    * @return An iterator over the document analyses map.,    */,   @Override,   public Iterator<Map.Entry<String, DocumentAnalysis>> iterator() {,     return documentAnalysisByKey.entrySet().iterator();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/client/solrj/response/FacetField.java,getEnd,119-119,[     return _end;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/client/solrj/response/FacetField.java,<init>,101-101,[     _end = end;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/FacetField.java,,34-174,[ public class FacetField implements Serializable,  {,    public static class Count implements Serializable ,    {,      private String _name = null;,      private long _count = 0;,      // hang onto the FacetField for breadcrumb creation convenience,      private FacetField _ff = null;,      ,      public Count( FacetField ff, String n, long c ),      {,        _name = n;,        _count = c;,        _ff = ff;,      },      ,      public String getName() {,        return _name;,      },      ,      public void setName( String n ),      {,        _name = n;,      }, ,      public long getCount() {,        return _count;,      },      ,      public void setCount( long c ),      {,        _count = c;,      },      ,      public FacetField getFacetField() {,        return _ff;,      },      ,      @Override,      public String toString(),      {,        return _name+" ("+_count+")";,      },      ,      public String getAsFilterQuery() {,        if (_ff.getName().equals("facet_queries")) {,          return _name;,        },        return ,           ClientUtils.escapeQueryChars( _ff._name ) + ":" + ,           ClientUtils.escapeQueryChars( _name );,      },    },    ,    private String      _name   = null;,    private List<Count> _values = null;,    private String _gap = null;,    private Date _end = null;,    ,    public FacetField( final String n ),    {,      _name = n;,    },    ,    public FacetField(String name, String gap, Date end) {,      _name = name;,      _gap = gap;,      _end = end;,    },    ,    /**,     * Date Gap Facet parameter,     * ,     * @return the value specified for facet.date.gap,     */,    public String getGap()   {,      return _gap;,    },    ,    /**,     * Date End Facet parameter,     * ,     * @return the value specified for facet.date.end,     */,    public Date getEnd() {,      return _end;,    }, ,    /**,     * Insert at the end of the list,     */,    public void add( String name, long cnt ),    {,      if( _values == null ) {,        _values = new ArrayList<>( 30 );,      },      _values.add( new Count( this, name, cnt ) );,    }, ,    /**,     * Insert at the beginning of the list.,     */,    public void insert( String name, long cnt ),    {,      if( _values == null ) {,        _values = new ArrayList<>( 30 );,      },      _values.add( 0, new Count( this, name, cnt ) );,    }, ,    public String getName() {,      return _name;,    }, ,    public List<Count> getValues() {,      return _values == null ? Collections.<Count>emptyList() : _values;,    },    ,    public int getValueCount(),    {,      return _values == null ? 0 : _values.size();,    }, ,    public FacetField getLimitingFields(long max) ,    {,      FacetField ff = new FacetField( _name );,      if( _values != null ) {,        ff._values = new ArrayList<>( _values.size() );,        for( Count c : _values ) {,          if( c._count < max ) { // !equal to,            ff._values.add( c );,          },        },      },      return ff;,    },    ,    @Override,    public String toString(),    {,      return _name + ":" + _values;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/FacetField.java,,36-84,[   public static class Count implements Serializable ,    {,      private String _name = null;,      private long _count = 0;,      // hang onto the FacetField for breadcrumb creation convenience,      private FacetField _ff = null;,      ,      public Count( FacetField ff, String n, long c ),      {,        _name = n;,        _count = c;,        _ff = ff;,      },      ,      public String getName() {,        return _name;,      },      ,      public void setName( String n ),      {,        _name = n;,      }, ,      public long getCount() {,        return _count;,      },      ,      public void setCount( long c ),      {,        _count = c;,      },      ,      public FacetField getFacetField() {,        return _ff;,      },      ,      @Override,      public String toString(),      {,        return _name+" ("+_count+")";,      },      ,      public String getAsFilterQuery() {,        if (_ff.getName().equals("facet_queries")) {,          return _name;,        },        return ,           ClientUtils.escapeQueryChars( _ff._name ) + ":" + ,           ClientUtils.escapeQueryChars( _name );],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/response/FieldAnalysisResponse.java,,141-200,[  public static class Analysis {, ,     private List<AnalysisPhase> queryPhases;,     private List<AnalysisPhase> indexPhases;, ,     /**,      * This class should only be instantiated internally.,      */,     private Analysis() {,     }, ,     /**,      * Returns the number of query time analysis phases in this analysis or ,      * {@code -1} if query time analysis doesn't exist.,      *,      * @return Returns the number of query time analysis phases in this ,      *         analysis or {@code -1} if query time analysis doesn't exist.,      */,     public int getQueryPhasesCount() {,       return queryPhases == null ? -1 : queryPhases.size();,     }, ,     /**,      * Returns the query time analysis phases for this analysis or {@code null},      * if query time analysis doesn't exist.,      * ,      *,      * @return The query time analysis phases for this analysis or {@code null},      *         if query time analysis doesn't exist.,      *         ,      */,     public Iterable<AnalysisPhase> getQueryPhases() {,       return queryPhases;,     }, ,     /**,      * Returns the index time analysis phases for this analysis.,      *,      * @return The index time analysis phases for this analysis.,      */,     public int getIndexPhasesCount() {,       return indexPhases.size();,     }, ,     /**,      * Returns the index time analysis phases for this analysis.,      *,      * @return The index time analysis phases for this analysis.,      */,     public Iterable<AnalysisPhase> getIndexPhases() {,       return indexPhases;,     }, ,     private void setQueryPhases(List<AnalysisPhase> queryPhases) {,       this.queryPhases = queryPhases;,     }, ,     private void setIndexPhases(List<AnalysisPhase> indexPhases) {,       this.indexPhases = indexPhases;,     }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/response/FieldAnalysisResponse.java,,141-200,[  public static class Analysis {, ,     private List<AnalysisPhase> queryPhases;,     private List<AnalysisPhase> indexPhases;, ,     /**,      * This class should only be instantiated internally.,      */,     private Analysis() {,     }, ,     /**,      * Returns the number of query time analysis phases in this analysis or ,      * {@code -1} if query time analysis doesn't exist.,      *,      * @return Returns the number of query time analysis phases in this ,      *         analysis or {@code -1} if query time analysis doesn't exist.,      */,     public int getQueryPhasesCount() {,       return queryPhases == null ? -1 : queryPhases.size();,     }, ,     /**,      * Returns the query time analysis phases for this analysis or {@code null},      * if query time analysis doesn't exist.,      * ,      *,      * @return The query time analysis phases for this analysis or {@code null},      *         if query time analysis doesn't exist.,      *         ,      */,     public Iterable<AnalysisPhase> getQueryPhases() {,       return queryPhases;,     }, ,     /**,      * Returns the index time analysis phases for this analysis.,      *,      * @return The index time analysis phases for this analysis.,      */,     public int getIndexPhasesCount() {,       return indexPhases.size();,     }, ,     /**,      * Returns the index time analysis phases for this analysis.,      *,      * @return The index time analysis phases for this analysis.,      */,     public Iterable<AnalysisPhase> getIndexPhases() {,       return indexPhases;,     }, ,     private void setQueryPhases(List<AnalysisPhase> queryPhases) {,       this.queryPhases = queryPhases;,     }, ,     private void setIndexPhases(List<AnalysisPhase> indexPhases) {,       this.indexPhases = indexPhases;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/FieldAnalysisResponse.java,,33-131,[public class FieldAnalysisResponse extends AnalysisResponseBase {, ,   private Map<String, Analysis> analysisByFieldTypeName = new HashMap<>();,   private Map<String, Analysis> analysisByFieldName = new HashMap<>();, ,   /**,    * {@inheritDoc},    */,   @Override,   public void setResponse(NamedList<Object> response) {,     super.setResponse(response);, ,     @SuppressWarnings("unchecked"),     NamedList<NamedList<NamedList<NamedList<List<NamedList<Object>>>>>> analysisNL ,       = (NamedList<NamedList<NamedList<NamedList<List<NamedList<Object>>>>>>) response.get("analysis");, ,     for (Map.Entry<String, NamedList<NamedList<List<NamedList<Object>>>>> entry ,            : analysisNL.get("field_types")) {, ,       analysisByFieldTypeName.put(entry.getKey(), buildAnalysis(entry.getValue()));,     }, ,     for (Map.Entry<String, NamedList<NamedList<List<NamedList<Object>>>>> entry ,            : analysisNL.get("field_names")) {, ,       analysisByFieldName.put(entry.getKey(), buildAnalysis(entry.getValue()));,     },   }, ,   private Analysis buildAnalysis(NamedList<NamedList<List<NamedList<Object>>>> value) {,       Analysis analysis = new Analysis();,       ,       NamedList<List<NamedList<Object>>> queryNL = value.get("query");,       List<AnalysisPhase> phases = (queryNL == null) ? null : buildPhases(queryNL);,       analysis.setQueryPhases(phases);, ,       NamedList<List<NamedList<Object>>> indexNL = value.get("index");,       phases = buildPhases(indexNL);,       analysis.setIndexPhases(phases);,       ,       return analysis;,   }, ,   /**,    * Returns the number of field type analyses.,    *,    * @return The number of field type analyses.,    */,   public int getFieldTypeAnalysisCount() {,     return analysisByFieldTypeName.size();,   }, ,   /**,    * Returns the analysis for the given field type or {@code null} if no such analysis exists.,    *,    * @param fieldTypeName The name of the field type.,    *,    * @return The analysis for the given field type.,    */,   public Analysis getFieldTypeAnalysis(String fieldTypeName) {,     return analysisByFieldTypeName.get(fieldTypeName);,   }, ,   /**,    * Returns all field type analyses with their associated field types.,    *,    * @return All field type analyses with their associated field types.,    */,   public Iterable<Map.Entry<String, Analysis>> getAllFieldTypeAnalysis() {,     return analysisByFieldTypeName.entrySet();,   }, ,   /**,    * Returns the number of field name analyses.,    *,    * @return The number of field name analyses.,    */,   public int getFieldNameAnalysisCount() {,     return analysisByFieldName.size();,   }, ,   /**,    * Returns the analysis for the given field name or {@code null} if no such analysis exists.,    *,    * @param fieldName The field name.,    *,    * @return The analysis for the given field name.,    */,   public Analysis getFieldNameAnalysis(String fieldName) {,     return analysisByFieldName.get(fieldName);,   }, ,   /**,    * Returns all field name analysese with their associated field names.,    *,    * @return all field name analysese with their associated field names.,    */,   public Iterable<Map.Entry<String, Analysis>> getAllFieldNameAnalysis() {,     return analysisByFieldName.entrySet();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/FieldStatsInfo.java,,44-188,[  Object mean = null;,   Double sumOfSquares = null;,   Double stddev = null;,   ,   Map<String,List<FieldStatsInfo>> facets;,   ,   public FieldStatsInfo( NamedList<Object> nl, String fname ),   {,     name = fname;,     ,     for( Map.Entry<String, Object> entry : nl ) {,       if( "min".equals( entry.getKey() ) ) {,         min = entry.getValue();,       },       else if( "max".equals( entry.getKey() ) ) {,         max = entry.getValue();,       },       else if( "sum".equals( entry.getKey() ) ) {,         sum = entry.getValue();,       },       else if( "count".equals( entry.getKey() ) ) {,         count = (Long)entry.getValue();,       },       else if ("countDistinct".equals(entry.getKey())) {,         countDistinct = (Long) entry.getValue();,       },       else if ("distinctValues".equals(entry.getKey())) {,         distinctValues = (Collection<Object>) entry.getValue();,       },       else if( "missing".equals( entry.getKey() ) ) {,         missing = (Long)entry.getValue();,       },       else if( "mean".equals( entry.getKey() ) ) {,         mean = entry.getValue();,       },       else if( "sumOfSquares".equals( entry.getKey() ) ) {,         sumOfSquares = (Double)entry.getValue();,       },       else if( "stddev".equals( entry.getKey() ) ) {,         stddev = (Double)entry.getValue();,       },       else if( "facets".equals( entry.getKey() ) ) {,         @SuppressWarnings("unchecked"),         NamedList<Object> fields = (NamedList<Object>)entry.getValue();,         facets = new HashMap<>();,         for( Map.Entry<String, Object> ev : fields ) {,           List<FieldStatsInfo> vals = new ArrayList<>();,           facets.put( ev.getKey(), vals );,           @SuppressWarnings("unchecked"),           NamedList<NamedList<Object>> vnl = (NamedList<NamedList<Object>>) ev.getValue();,           for( int i=0; i<vnl.size(); i++ ) {,             String n = vnl.getName(i);,             vals.add( new FieldStatsInfo( vnl.getVal(i), n ) );,           },         },       },       else {,         throw new RuntimeException( "unknown key: "+entry.getKey() + " ["+entry.getValue()+"]" );,       },     },   },   ,   @Override,   public String toString(),   {,     StringBuilder sb = new StringBuilder();,     sb.append( name );,     sb.append( ": {" );,     if( min != null ) {,       sb.append( " min:").append( min );,     },     if( max != null ) {,       sb.append( " max:").append( max );,     },     if( sum != null ) {,       sb.append( " sum:").append( sum );,     },     if( count != null ) {,       sb.append( " count:").append( count );,     },     if (countDistinct != null) {,       sb.append(" countDistinct:").append(countDistinct);,     },     if (distinctValues != null) {,       sb.append(" distinctValues:").append(distinctValues);,     },     if( missing != null ) {,       sb.append( " missing:").append( missing );,     },     if( mean != null ) {,       sb.append( " mean:").append( mean );,     },     if( stddev != null ) {,       sb.append( " stddev:").append(stddev);,     },     sb.append( " }" );,     return sb.toString();,   }, ,   public String getName() {,     return name;,   }, ,   public Object getMin() {,     return min;,   }, ,   public Object getMax() {,     return max;,   }, ,   public Object getSum() {,     return sum;,   }, ,   public Long getCount() {,     return count;,   }, ,   public Long getCountDistinct() {,     return countDistinct;,   }, ,   public Collection<Object> getDistinctValues() {,     return distinctValues;,   }, ,   public Long getMissing() {,     return missing;,   }, ,   public Object getMean() {,     return mean;,   }, ,   public Double getStddev() {,     return stddev;,   }, ,   public Double getSumOfSquares() {,     return sumOfSquares;,   }, ,   public Map<String, List<FieldStatsInfo>> getFacets() {,     return facets;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/Group.java,,44-66,[  public Group(String groupValue, SolrDocumentList result) {,     _groupValue = groupValue;,     _result = result;,   }, ,   /**,    * Returns the common group value that all documents share inside this group.,    * This is an indexed value, not a stored value.,    *,    * @return the common group value,    */,   public String getGroupValue() {,     return _groupValue;,   }, ,   /**,    * Returns the documents to be displayed that belong to this group.,    * How many documents are returned depend on the <code>group.offset</code> and <code>group.limit</code> parameters.,    *,    * @return the documents to be displayed that belong to this group,    */,   public SolrDocumentList getResult() {,     return _result;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/GroupCommand.java,,48-122,[  private final List<Group> _values = new ArrayList<>();,   private final int _matches;,   private final Integer _ngroups;, ,   /**,    * Creates a GroupCommand instance,    *,    * @param name    The name of this command,    * @param matches The total number of documents found for this command,    */,   public GroupCommand(String name, int matches) {,     _name = name;,     _matches = matches;,     _ngroups = null;,   }, ,   /**,    * Creates a GroupCommand instance.,    *,    * @param name    The name of this command,    * @param matches The total number of documents found for this command,    * @param nGroups The total number of groups found for this command.,    */,   public GroupCommand(String name, int matches, int nGroups) {,     _name = name;,     _matches = matches;,     _ngroups = nGroups;,   }, ,   /**,    * Returns the name of this command. This can be the field, function or query grouped by.,    *,    * @return the name of this command,    */,   public String getName() {,     return _name;,   }, ,   /**,    * Adds a group to this command.,    *,    * @param group A group to be added,    */,   public void add(Group group) {,     _values.add(group);,   }, ,   /**,    * Returns the groups to be displayed.,    * The number of groups returned depend on the <code>start</code> and <code>rows</code> parameters.,    *,    * @return the groups to be displayed.,    */,   public List<Group> getValues() {,     return _values;,   }, ,   /**,    * Returns the total number of documents found for this command.,    *,    * @return the total number of documents found for this command.,    */,   public int getMatches() {,     return _matches;,   }, ,   /**,    * Returns the total number of groups found for this command.,    * Returns <code>null</code> if the <code>group.ngroups</code> parameter is unset or <code>false</code> or,    * if this is a group command query (parameter = <code>group.query</code>).,    *,    * @return the total number of groups found for this command.,    */,   public Integer getNGroups() {,     return _ngroups;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/GroupResponse.java,,35-54,[public class GroupResponse implements Serializable {, ,   private final List<GroupCommand> _values = new ArrayList<>();, ,   /**,    * Adds a grouping command to the response.,    *,    * @param command The grouping command to add,    */,   public void add(GroupCommand command) {,     _values.add(command);,   }, ,   /**,    * Returns all grouping commands.,    *,    * @return all grouping commands,    */,   public List<GroupCommand> getValues() {,     return _values;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/LukeResponse.java,,33-266,[public class LukeResponse extends SolrResponseBase {, ,   public static class FieldTypeInfo implements Serializable {,     String name;,     String className;,     boolean tokenized;,     String analyzer;,     List<String> fields;, , ,     public FieldTypeInfo(String name) {,       this.name = name;,       fields = Collections.emptyList();,     }, , ,     public String getAnalyzer() {,       return analyzer;,     }, ,     public String getClassName() {,       return className;,     }, ,     public List<String> getFields() {,       return fields;,     }, ,     public String getName() {,       return name;,     }, ,     public boolean isTokenized() {,       return tokenized;,     }/*,      Sample:,      types={ignored={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@f94934},,      integer={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@3525a2},,      sfloat={fields=[price, weight],tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@39cf9c},,      text_ws={fields=[cat],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.WhitespaceTokenizerFactory@6d3ca2)},,      alphaOnlySort={fields=[alphaNameSort],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.KeywordTokenizerFactory@a7bd3b,,       org.apache.solr.analysis.LowerCaseFilterFactory@78aae2, org.apache.solr.analysis.TrimFilterFactory@1b16a7,,       org.apache.solr.analysis.PatternReplaceFilterFactory@6c6b08)},date={fields=[timestamp],tokenized=false,,       analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@e6e42e},sint={fields=[popularity],,       tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@8ea21d},,       boolean={fields=[inStock],tokenized=false,analyzer=org.apache.solr.schema.BoolField$1@354949},,       textTight={fields=[sku],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.WhitespaceTokenizerFactory@5e88f7,,        org.apache.solr.analysis.SynonymFilterFactory@723646, org.apache.solr.analysis.StopFilterFactory@492ff1,,        org.apache.solr.analysis.WordDelimiterFilterFactory@eaabad, org.apache.solr.analysis.LowerCaseFilterFactory@ad1355,,         org.apache.solr.analysis.EnglishPorterFilterFactory@d03a00, org.apache.solr.analysis.RemoveDuplicatesTokenFilterFactory@900079)},,         long={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@f3b83},,         double={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@c2b07},, ,       */, ,     @SuppressWarnings("unchecked"),     public void read(NamedList<Object> nl) {,       for (Map.Entry<String, Object> entry : nl) {,         String key = entry.getKey();,         if ("fields".equals(key) && entry.getValue() != null) {,           List<String> theFields = (List<String>) entry.getValue();,           fields = new ArrayList<>(theFields);,         } else if ("tokenized".equals(key) == true) {,           tokenized = Boolean.parseBoolean(entry.getValue().toString());,         } else if ("analyzer".equals(key) == true) {,           analyzer = entry.getValue().toString();,         } else if ("className".equals(key) == true) {,           className = entry.getValue().toString();,         },       },     },   }, ,   public static class FieldInfo implements Serializable {,     String name;,     String type;,     String schema;,     int docs;,     int distinct;,     EnumSet<FieldFlag> flags;,     boolean cacheableFaceting;,     NamedList<Integer> topTerms;, ,     public FieldInfo(String n) {,       name = n;,     }, ,     @SuppressWarnings("unchecked"),     public void read(NamedList<Object> nl) {,       for (Map.Entry<String, Object> entry : nl) {,         if ("type".equals(entry.getKey())) {,           type = (String) entry.getValue();,         },         if ("flags".equals(entry.getKey())) {,           flags = parseFlags((String) entry.getValue());,         } else if ("schema".equals(entry.getKey())) {,           schema = (String) entry.getValue();,         } else if ("docs".equals(entry.getKey())) {,           docs = (Integer) entry.getValue();,         } else if ("distinct".equals(entry.getKey())) {,           distinct = (Integer) entry.getValue();,         } else if ("cacheableFaceting".equals(entry.getKey())) {,           cacheableFaceting = (Boolean) entry.getValue();,         } else if ("topTerms".equals(entry.getKey())) {,           topTerms = (NamedList<Integer>) entry.getValue();,         },       },     }, ,     public static EnumSet<FieldFlag> parseFlags(String flagStr) {,       EnumSet<FieldFlag> result = EnumSet.noneOf(FieldFlag.class);,       char[] chars = flagStr.toCharArray();,       for (int i = 0; i < chars.length; i++) {,         if (chars[i] != '-') {,           FieldFlag flag = FieldFlag.getFlag(chars[i]);,           result.add(flag);,         },       },       return result;,     }, ,     public EnumSet<FieldFlag> getFlags() {,       return flags;,     }, ,     public boolean isCacheableFaceting() {,       return cacheableFaceting;,     }, ,     public String getType() {,       return type;,     }, ,     public int getDistinct() {,       return distinct;,     }, ,     public int getDocs() {,       return docs;,     }, ,     public String getName() {,       return name;,     }, ,     public String getSchema() {,       return schema;,     }, ,     public NamedList<Integer> getTopTerms() {,       return topTerms;,     },   }, ,   private NamedList<Object> indexInfo;,   private Map<String, FieldInfo> fieldInfo;,   private Map<String, FieldTypeInfo> fieldTypeInfo;, ,   @Override,   @SuppressWarnings("unchecked"),   public void setResponse(NamedList<Object> res) {,     super.setResponse(res);, ,     // Parse indexinfo,     indexInfo = (NamedList<Object>) res.get("index");, ,     NamedList<Object> schema = (NamedList<Object>) res.get("schema");,     NamedList<Object> flds = (NamedList<Object>) res.get("fields");,     if (flds == null && schema != null ) {,       flds = (NamedList<Object>) schema.get("fields");,     },     if (flds != null) {,       fieldInfo = new HashMap<>();,       for (Map.Entry<String, Object> field : flds) {,         FieldInfo f = new FieldInfo(field.getKey());,         f.read((NamedList<Object>) field.getValue());,         fieldInfo.put(field.getKey(), f);,       },     }, ,     if( schema != null ) {,       NamedList<Object> fldTypes = (NamedList<Object>) schema.get("types");,       if (fldTypes != null) {,         fieldTypeInfo = new HashMap<>();,         for (Map.Entry<String, Object> fieldType : fldTypes) {,           FieldTypeInfo ft = new FieldTypeInfo(fieldType.getKey());,           ft.read((NamedList<Object>) fieldType.getValue());,           fieldTypeInfo.put(fieldType.getKey(), ft);,         },       },     },   }, ,   //----------------------------------------------------------------,   //----------------------------------------------------------------, ,   public String getIndexDirectory() {,     if (indexInfo == null) return null;,     return (String) indexInfo.get("directory");,   }, ,   public Integer getNumDocs() {,     if (indexInfo == null) return null;,     return (Integer) indexInfo.get("numDocs");,   }, ,   public Integer getMaxDoc() {,     if (indexInfo == null) return null;,     return (Integer) indexInfo.get("maxDoc");,   }, ,   public Integer getNumTerms() {,     if (indexInfo == null) return null;,     return (Integer) indexInfo.get("numTerms");,   }, ,   public Map<String, FieldTypeInfo> getFieldTypeInfo() {,     return fieldTypeInfo;,   }, ,   public FieldTypeInfo getFieldTypeInfo(String name) {,     return fieldTypeInfo.get(name);,   }, ,   public NamedList<Object> getIndexInfo() {,     return indexInfo;,   }, ,   public Map<String, FieldInfo> getFieldInfo() {,     return fieldInfo;,   }, ,   public FieldInfo getFieldInfo(String f) {,     return fieldInfo.get(f);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/client/solrj/response/LukeResponse.java,getFieldInfo,266-266,[    return fieldInfo.get(f);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/client/solrj/response/LukeResponse.java,getFieldTypeInfo,254-254,[    return fieldTypeInfo.get(name);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/LukeResponse.java,,116-183,[    public FieldInfo(String n) {,       name = n;,     }, ,     @SuppressWarnings("unchecked"),     public void read(NamedList<Object> nl) {,       for (Map.Entry<String, Object> entry : nl) {,         if ("type".equals(entry.getKey())) {,           type = (String) entry.getValue();,         },         if ("flags".equals(entry.getKey())) {,           flags = parseFlags((String) entry.getValue());,         } else if ("schema".equals(entry.getKey())) {,           schema = (String) entry.getValue();,         } else if ("docs".equals(entry.getKey())) {,           docs = (Integer) entry.getValue();,         } else if ("distinct".equals(entry.getKey())) {,           distinct = (Integer) entry.getValue();,         } else if ("cacheableFaceting".equals(entry.getKey())) {,           cacheableFaceting = (Boolean) entry.getValue();,         } else if ("topTerms".equals(entry.getKey())) {,           topTerms = (NamedList<Integer>) entry.getValue();,         },       },     }, ,     public static EnumSet<FieldFlag> parseFlags(String flagStr) {,       EnumSet<FieldFlag> result = EnumSet.noneOf(FieldFlag.class);,       char[] chars = flagStr.toCharArray();,       for (int i = 0; i < chars.length; i++) {,         if (chars[i] != '-') {,           FieldFlag flag = FieldFlag.getFlag(chars[i]);,           result.add(flag);,         },       },       return result;,     }, ,     public EnumSet<FieldFlag> getFlags() {,       return flags;,     }, ,     public boolean isCacheableFaceting() {,       return cacheableFaceting;,     }, ,     public String getType() {,       return type;,     }, ,     public int getDistinct() {,       return distinct;,     }, ,     public int getDocs() {,       return docs;,     }, ,     public String getName() {,       return name;,     }, ,     public String getSchema() {,       return schema;,     }, ,     public NamedList<Integer> getTopTerms() {,       return topTerms;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/LukeResponse.java,,43-103,[    public FieldTypeInfo(String name) {,       this.name = name;,       fields = Collections.emptyList();,     }, , ,     public String getAnalyzer() {,       return analyzer;,     }, ,     public String getClassName() {,       return className;,     }, ,     public List<String> getFields() {,       return fields;,     }, ,     public String getName() {,       return name;,     }, ,     public boolean isTokenized() {,       return tokenized;,     }/*,      Sample:,      types={ignored={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@f94934},,      integer={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@3525a2},,      sfloat={fields=[price, weight],tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@39cf9c},,      text_ws={fields=[cat],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.WhitespaceTokenizerFactory@6d3ca2)},,      alphaOnlySort={fields=[alphaNameSort],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.KeywordTokenizerFactory@a7bd3b,,       org.apache.solr.analysis.LowerCaseFilterFactory@78aae2, org.apache.solr.analysis.TrimFilterFactory@1b16a7,,       org.apache.solr.analysis.PatternReplaceFilterFactory@6c6b08)},date={fields=[timestamp],tokenized=false,,       analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@e6e42e},sint={fields=[popularity],,       tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@8ea21d},,       boolean={fields=[inStock],tokenized=false,analyzer=org.apache.solr.schema.BoolField$1@354949},,       textTight={fields=[sku],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.WhitespaceTokenizerFactory@5e88f7,,        org.apache.solr.analysis.SynonymFilterFactory@723646, org.apache.solr.analysis.StopFilterFactory@492ff1,,        org.apache.solr.analysis.WordDelimiterFilterFactory@eaabad, org.apache.solr.analysis.LowerCaseFilterFactory@ad1355,,         org.apache.solr.analysis.EnglishPorterFilterFactory@d03a00, org.apache.solr.analysis.RemoveDuplicatesTokenFilterFactory@900079)},,         long={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@f3b83},,         double={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@c2b07},, ,       */, ,     @SuppressWarnings("unchecked"),     public void read(NamedList<Object> nl) {,       for (Map.Entry<String, Object> entry : nl) {,         String key = entry.getKey();,         if ("fields".equals(key) && entry.getValue() != null) {,           List<String> theFields = (List<String>) entry.getValue();,           fields = new ArrayList<>(theFields);,         } else if ("tokenized".equals(key) == true) {,           tokenized = Boolean.parseBoolean(entry.getValue().toString());,         } else if ("analyzer".equals(key) == true) {,           analyzer = entry.getValue().toString();,         } else if ("className".equals(key) == true) {,           className = entry.getValue().toString();,         },       },     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/PivotField.java,,38-96,[    this(f, v, count, pivot, null);,   }, ,   public PivotField( String f, Object v, int count, List<PivotField> pivot, Map<String,FieldStatsInfo> statsInfo),   {,     _field = f;,     _value = v;,     _count = count;,     _pivot = pivot;,     _statsInfo = statsInfo;,   },    ,   public String getField() {,    return _field;,   }, ,   public Object getValue() {,     return _value;,   }, ,   public int getCount() {,     return _count;,   }, ,   public List<PivotField> getPivot() {,     return _pivot;,   },    ,   public Map<String,FieldStatsInfo> getFieldStatsInfo() {,     return _statsInfo;,   }, ,   @Override,   public String toString(),   {,     return _field + ":" + _value + " ["+_count+"] "+_pivot;,   }, ,   public void write( PrintStream out, int indent ),   {,     for( int i=0; i<indent; i++ ) {,       out.print( "  " );,     },     out.print( _field + "=" + _value + " ("+_count+")" );,     if (null != _statsInfo) {,       out.print( "->stats:[" ); ,       for( FieldStatsInfo fieldStatsInfo : _statsInfo.values() ) {,         out.print(fieldStatsInfo.toString());,         out.print(",");,       },       out.print("]");,     },     out.println();,     if( _pivot != null ) {,       for( PivotField p : _pivot ) {,         p.write( out, indent+1 );,       },     },   }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/response/IntervalFacet.java,,37-53,[  IntervalFacet(String field, List<Count> values) {,     this.field = field;,     this.intervals = values;,   },   ,   /**,    * @return The field for which interval facets where calculated,    */,   public String getField() {,     return field;,   }, ,   /**,    * @return The list of interval facets calculated for {@link #field},    */,   public List<Count> getIntervals() {,     return intervals;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/response/SpellCheckResponse.java,,35-137,[  private List<Suggestion> suggestions = new ArrayList<>();,   Map<String, Suggestion> suggestionMap = new LinkedHashMap<>();, ,   public SpellCheckResponse(NamedList<Object> spellInfo) {,     @SuppressWarnings("unchecked"),     NamedList<Object> sugg = (NamedList<Object>) spellInfo.get("suggestions");,     if (sugg == null) {,       correctlySpelled = true;,       return;,     },     for (int i = 0; i < sugg.size(); i++) {,       String n = sugg.getName(i);,       @SuppressWarnings("unchecked"),       Suggestion s = new Suggestion(n, (NamedList<Object>) sugg.getVal(i));,       suggestionMap.put(n, s);,       suggestions.add(s);,     },     ,     Boolean correctlySpelled = (Boolean) spellInfo.get("correctlySpelled");,     if (correctlySpelled != null) {,       this.correctlySpelled = correctlySpelled;,     },     ,     @SuppressWarnings("unchecked"),     NamedList<Object> coll = (NamedList<Object>) spellInfo.get("collations");,     if (coll != null) {,       // The 'collationInternalRank' values are ignored so we only care 'collation's.,       List<Object> collationInfo = coll.getAll("collation");,       collations = new ArrayList<>(collationInfo.size());,       for (Object o : collationInfo) {,         if (o instanceof String) {,           collations.add(new Collation(),               .setCollationQueryString((String) o));,         } else if (o instanceof NamedList) {,           @SuppressWarnings("unchecked"),           NamedList<Object> expandedCollation = (NamedList<Object>) o;,           String collationQuery,             = (String) expandedCollation.get("collationQuery");,           int hits = (Integer) expandedCollation.get("hits");,           @SuppressWarnings("unchecked"),           NamedList<String> misspellingsAndCorrections,             = (NamedList<String>) expandedCollation.get("misspellingsAndCorrections");, ,           Collation collation = new Collation();,           collation.setCollationQueryString(collationQuery);,           collation.setNumberOfHits(hits);, ,           for (int ii = 0; ii < misspellingsAndCorrections.size(); ii++) {,             String misspelling = misspellingsAndCorrections.getName(ii);,             String correction = misspellingsAndCorrections.getVal(ii);,             collation.addMisspellingsAndCorrection(new Correction(,                 misspelling, correction));,           },           collations.add(collation);,         } else {,           throw new AssertionError(,               "Should get Lists of Strings or List of NamedLists here.");,         },       },     },   }, ,   public boolean isCorrectlySpelled() {,     return correctlySpelled;,   }, ,   public List<Suggestion> getSuggestions() {,     return suggestions;,   }, ,   public Map<String, Suggestion> getSuggestionMap() {,     return suggestionMap;,   }, ,   public Suggestion getSuggestion(String token) {,     return suggestionMap.get(token);,   }, ,   public String getFirstSuggestion(String token) {,     Suggestion s = suggestionMap.get(token);,     if (s==null || s.getAlternatives().isEmpty()) return null;,     return s.getAlternatives().get(0);,   }, ,   /**,    * <p>,    *  Return the first collated query string.  For convenience and backwards-compatibility.  Use getCollatedResults() for full data.,    * </p>,    * @return first collated query string,    */,   public String getCollatedResult() {,     return collations==null || collations.size()==0 ? null : collations.get(0).collationQueryString;,   },   ,   /**,    * <p>,    *  Return all collations.  ,    *  Will include # of hits and misspelling-to-correction details if "spellcheck.collateExtendedResults was true.,    * </p>,    * @return all collations,    */,   public List<Collation> getCollatedResults() {,     return collations;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/response/TermsResponse.java,,30-57,[  private Map<String, List<Term>> termMap = new HashMap<>();,   ,   public TermsResponse(NamedList<NamedList<Number>> termsInfo) {,     for (int i = 0; i < termsInfo.size(); i++) {,       String fieldName = termsInfo.getName(i);,       List<Term> itemList = new ArrayList<>();,       NamedList<Number> items = termsInfo.getVal(i);,       ,       for (int j = 0; j < items.size(); j++) {,         Term t = new Term(items.getName(j), items.getVal(j).longValue());,         itemList.add(t);,       },       ,       termMap.put(fieldName, itemList);,     },   }, ,   /**,    * Get's the term list for a given field,    * ,    * @return the term list or null if no terms for the given field exist,    */,   public List<Term> getTerms(String field) {,     return termMap.get(field);,   },   ,   public Map<String, List<Term>> getTermMap() {,     return termMap;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/solr/client/solrj/response/RangeFacet.java,,29-82,[  private final List<Count> counts = new ArrayList<>();, ,   private final B start;,   private final B end;,   private final G gap;, ,   private final Number before;,   private final Number after;,   private final Number between;, ,   protected RangeFacet(String name, B start, B end, G gap, Number before, Number after, Number between) {,     this.name = name;,     this.start = start;,     this.end = end;,     this.gap = gap;,     this.before = before;,     this.after = after;,     this.between = between;,   }, ,   public void addCount(String value, int count) {,     counts.add(new Count(value, count, this));,   }, ,   public String getName() {,     return name;,   }, ,   public List<Count> getCounts() {,     return counts;,   }, ,   public B getStart() {,     return start;,   }, ,   public B getEnd() {,     return end;,   }, ,   public G getGap() {,     return gap;,   }, ,   public Number getBefore() {,     return before;,   }, ,   public Number getAfter() {,     return after;,   }, ,   public Number getBetween() {,     return between;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/QueryResponse.java,,40-577,[@SuppressWarnings("unchecked"), public class QueryResponse extends SolrResponseBase , {,   // Direct pointers to known types,   private NamedList<Object> _header = null;,   private SolrDocumentList _results = null;,   private NamedList<ArrayList> _sortvalues = null;,   private NamedList<Object> _facetInfo = null;,   private NamedList<Object> _debugInfo = null;,   private NamedList<Object> _highlightingInfo = null;,   private NamedList<Object> _spellInfo = null;,   private NamedList<Object> _statsInfo = null;,   private NamedList<NamedList<Number>> _termsInfo = null;,   private String _cursorMarkNext = null;, ,   // Grouping response,   private NamedList<Object> _groupedInfo = null;,   private GroupResponse _groupResponse = null;, ,   private NamedList<Object> _expandedInfo = null;,   private Map<String, SolrDocumentList> _expandedResults = null;, ,   // Facet stuff,   private Map<String,Integer> _facetQuery = null;,   private List<FacetField> _facetFields = null;,   private List<FacetField> _limitingFacets = null;,   private List<FacetField> _facetDates = null;,   private List<RangeFacet> _facetRanges = null;,   private NamedList<List<PivotField>> _facetPivot = null;,   private List<IntervalFacet> _intervalFacets = null;, ,   // Highlight Info,   private Map<String,Map<String,List<String>>> _highlighting = null;, ,   // SpellCheck Response,   private SpellCheckResponse _spellResponse = null;, ,   // Terms Response,   private TermsResponse _termsResponse = null;,   ,   // Field stats Response,   private Map<String,FieldStatsInfo> _fieldStatsInfo = null;,   ,   // Debug Info,   private Map<String,Object> _debugMap = null;,   private Map<String,String> _explainMap = null;, ,   // utility variable used for automatic binding -- it should not be serialized,   private transient final SolrClient solrClient;,   ,   public QueryResponse(){,     solrClient = null;,   },   ,   /**,    * Utility constructor to set the solrServer and namedList,    */,   public QueryResponse( NamedList<Object> res , SolrClient solrClient){,     this.setResponse( res );,     this.solrClient = solrClient;,   }, ,   @Override,   public void setResponse( NamedList<Object> res ),   {,     super.setResponse( res );,     ,     // Look for known things,     for( int i=0; i<res.size(); i++ ) {,       String n = res.getName( i );,       if( "responseHeader".equals( n ) ) {,         _header = (NamedList<Object>) res.getVal( i );,       },       else if( "response".equals( n ) ) {,         _results = (SolrDocumentList) res.getVal( i );,       },       else if( "sort_values".equals( n ) ) {,         _sortvalues = (NamedList<ArrayList>) res.getVal( i );,       },       else if( "facet_counts".equals( n ) ) {,         _facetInfo = (NamedList<Object>) res.getVal( i );,         // extractFacetInfo inspects _results, so defer calling it,         // in case it hasn't been populated yet.,       },       else if( "debug".equals( n ) ) {,         _debugInfo = (NamedList<Object>) res.getVal( i );,         extractDebugInfo( _debugInfo );,       },       else if( "grouped".equals( n ) ) {,         _groupedInfo = (NamedList<Object>) res.getVal( i );,         extractGroupedInfo( _groupedInfo );,       },       else if("expanded".equals(n)) {,         _expandedResults = (Map<String, SolrDocumentList>) res.getVal( i );,       },       else if( "highlighting".equals( n ) ) {,         _highlightingInfo = (NamedList<Object>) res.getVal( i );,         extractHighlightingInfo( _highlightingInfo );,       },       else if ( "spellcheck".equals( n ) )  {,         _spellInfo = (NamedList<Object>) res.getVal( i );,         extractSpellCheckInfo( _spellInfo );,       },       else if ( "stats".equals( n ) )  {,         _statsInfo = (NamedList<Object>) res.getVal( i );,         extractStatsInfo( _statsInfo );,       },       else if ( "terms".equals( n ) ) {,         _termsInfo = (NamedList<NamedList<Number>>) res.getVal( i );,         extractTermsInfo( _termsInfo );,       },       else if ( CursorMarkParams.CURSOR_MARK_NEXT.equals( n ) ) {,         _cursorMarkNext = (String) res.getVal( i );,       },     },     if(_facetInfo != null) extractFacetInfo( _facetInfo );,   }, ,   private void extractSpellCheckInfo(NamedList<Object> spellInfo) {,     _spellResponse = new SpellCheckResponse(spellInfo);,   }, ,   private void extractTermsInfo(NamedList<NamedList<Number>> termsInfo) {,     _termsResponse = new TermsResponse(termsInfo);,   },   ,   private void extractStatsInfo(NamedList<Object> info) {,     _fieldStatsInfo = extractFieldStatsInfo(info);,   }, ,   private Map<String, FieldStatsInfo> extractFieldStatsInfo(NamedList<Object> info) {,     if( info != null ) {,        Map<String, FieldStatsInfo> fieldStatsInfoMap = new TreeMap<>();,       NamedList<NamedList<Object>> ff = (NamedList<NamedList<Object>>) info.get( "stats_fields" );,       if( ff != null ) {,         for( Map.Entry<String,NamedList<Object>> entry : ff ) {,           NamedList<Object> v = entry.getValue();,           if( v != null ) {,              fieldStatsInfoMap.put( entry.getKey(),,                 new FieldStatsInfo( v, entry.getKey() ) );,           },         },       },        return fieldStatsInfoMap;,     },     return null;,   }, ,   private void extractDebugInfo( NamedList<Object> debug ),   {,     _debugMap = new LinkedHashMap<>(); // keep the order,     for( Map.Entry<String, Object> info : debug ) {,       _debugMap.put( info.getKey(), info.getValue() );,     }, ,     // Parse out interesting bits from the debug info,     _explainMap = new HashMap<>();,     NamedList<String> explain = (NamedList<String>)_debugMap.get( "explain" );,     if( explain != null ) {,       for( Map.Entry<String, String> info : explain ) {,         String key = info.getKey();,         _explainMap.put( key, info.getValue() );,       },     },   }, ,   private void extractGroupedInfo( NamedList<Object> info ) {,     if ( info != null ) {,       _groupResponse = new GroupResponse();,       int size = info.size();,       for (int i=0; i < size; i++) {,         String fieldName = info.getName(i);,         Object fieldGroups =  info.getVal(i);,         SimpleOrderedMap<Object> simpleOrderedMap = (SimpleOrderedMap<Object>) fieldGroups;, ,         Object oMatches = simpleOrderedMap.get("matches");,         Object oNGroups = simpleOrderedMap.get("ngroups");,         Object oGroups = simpleOrderedMap.get("groups");,         Object queryCommand = simpleOrderedMap.get("doclist");,         if (oMatches == null) {,           continue;,         }, ,         if (oGroups != null) {,           Integer iMatches = (Integer) oMatches;,           ArrayList<Object> groupsArr = (ArrayList<Object>) oGroups;,           GroupCommand groupedCommand;,           if (oNGroups != null) {,             Integer iNGroups = (Integer) oNGroups;,             groupedCommand = new GroupCommand(fieldName, iMatches, iNGroups);,           } else {,             groupedCommand = new GroupCommand(fieldName, iMatches);,           }, ,           for (Object oGrp : groupsArr) {,             SimpleOrderedMap grpMap = (SimpleOrderedMap) oGrp;,             Object sGroupValue = grpMap.get( "groupValue");,             SolrDocumentList doclist = (SolrDocumentList) grpMap.get( "doclist");,             Group group = new Group(sGroupValue != null ? sGroupValue.toString() : null, doclist) ;,             groupedCommand.add(group);,           }, ,           _groupResponse.add(groupedCommand);,         } else if (queryCommand != null) {,           Integer iMatches = (Integer) oMatches;,           GroupCommand groupCommand;,           if (oNGroups != null) {,             Integer iNGroups = (Integer) oNGroups;,             groupCommand = new GroupCommand(fieldName, iMatches, iNGroups);,           } else {,             groupCommand = new GroupCommand(fieldName, iMatches);,           },           SolrDocumentList docList = (SolrDocumentList) queryCommand;,           groupCommand.add(new Group(fieldName, docList));,           _groupResponse.add(groupCommand);,         },       },     },   }, ,   private void extractHighlightingInfo( NamedList<Object> info ),   {,     _highlighting = new HashMap<>();,     for( Map.Entry<String, Object> doc : info ) {,       Map<String,List<String>> fieldMap = new HashMap<>();,       _highlighting.put( doc.getKey(), fieldMap );,       ,       NamedList<List<String>> fnl = (NamedList<List<String>>)doc.getValue();,       for( Map.Entry<String, List<String>> field : fnl ) {,         fieldMap.put( field.getKey(), field.getValue() );,       },     },   }, ,   private void extractFacetInfo( NamedList<Object> info ),   {,     // Parse the queries,     _facetQuery = new LinkedHashMap<>();,     NamedList<Integer> fq = (NamedList<Integer>) info.get( "facet_queries" );,     if (fq != null) {,       for( Map.Entry<String, Integer> entry : fq ) {,         _facetQuery.put( entry.getKey(), entry.getValue() );,       },     },     ,     // Parse the facet info into fields,     // TODO?? The list could be <int> or <long>?  If always <long> then we can switch to <Long>,     NamedList<NamedList<Number>> ff = (NamedList<NamedList<Number>>) info.get( "facet_fields" );,     if( ff != null ) {,       _facetFields = new ArrayList<>( ff.size() );,       _limitingFacets = new ArrayList<>( ff.size() );,       ,       long minsize = _results == null ? Long.MAX_VALUE :_results.getNumFound();,       for( Map.Entry<String,NamedList<Number>> facet : ff ) {,         FacetField f = new FacetField( facet.getKey() );,         for( Map.Entry<String, Number> entry : facet.getValue() ) {,           f.add( entry.getKey(), entry.getValue().longValue() );,         },         ,         _facetFields.add( f );,         FacetField nl = f.getLimitingFields( minsize );,         if( nl.getValueCount() > 0 ) {,           _limitingFacets.add( nl );,         },       },     },     ,     //Parse date facets,     NamedList<NamedList<Object>> df = (NamedList<NamedList<Object>>) info.get("facet_dates");,     if (df != null) {,       // System.out.println(df);,       _facetDates = new ArrayList<>( df.size() );,       for (Map.Entry<String, NamedList<Object>> facet : df) {,         // System.out.println("Key: " + facet.getKey() + " Value: " + facet.getValue());,         NamedList<Object> values = facet.getValue();,         String gap = (String) values.get("gap");,         Date end = (Date) values.get("end");,         FacetField f = new FacetField(facet.getKey(), gap, end);,         ,         for (Map.Entry<String, Object> entry : values)   {,           try {,             f.add(entry.getKey(), Long.parseLong(entry.getValue().toString()));,           } catch (NumberFormatException e) {,             //Ignore for non-number responses which are already handled above,           },         },         ,         _facetDates.add(f);,       },     }, ,     //Parse range facets,     NamedList<NamedList<Object>> rf = (NamedList<NamedList<Object>>) info.get("facet_ranges");,     if (rf != null) {,       _facetRanges = new ArrayList<>( rf.size() );,       for (Map.Entry<String, NamedList<Object>> facet : rf) {,         NamedList<Object> values = facet.getValue();,         Object rawGap = values.get("gap");, ,         RangeFacet rangeFacet;,         if (rawGap instanceof Number) {,           Number gap = (Number) rawGap;,           Number start = (Number) values.get("start");,           Number end = (Number) values.get("end");, ,           Number before = (Number) values.get("before");,           Number after = (Number) values.get("after");,           Number between = (Number) values.get("between");, ,           rangeFacet = new RangeFacet.Numeric(facet.getKey(), start, end, gap, before, after, between);,         } else {,           String gap = (String) rawGap;,           Date start = (Date) values.get("start");,           Date end = (Date) values.get("end");, ,           Number before = (Number) values.get("before");,           Number after = (Number) values.get("after");,           Number between = (Number) values.get("between");, ,           rangeFacet = new RangeFacet.Date(facet.getKey(), start, end, gap, before, after, between);,         }, ,         NamedList<Integer> counts = (NamedList<Integer>) values.get("counts");,         for (Map.Entry<String, Integer> entry : counts)   {,           rangeFacet.addCount(entry.getKey(), entry.getValue());,         }, ,         _facetRanges.add(rangeFacet);,       },     },     ,     //Parse pivot facets,     NamedList pf = (NamedList) info.get("facet_pivot");,     if (pf != null) {,       _facetPivot = new NamedList<>();,       for( int i=0; i<pf.size(); i++ ) {,         _facetPivot.add( pf.getName(i), readPivots( (List<NamedList>)pf.getVal(i) ) );,       },     },     ,     //Parse interval facets,     NamedList<NamedList<Object>> intervalsNL = (NamedList<NamedList<Object>>) info.get("facet_intervals");,     if (intervalsNL != null) {,       _intervalFacets = new ArrayList<>(intervalsNL.size());,       for (Map.Entry<String, NamedList<Object>> intervalField : intervalsNL) {,         String field = intervalField.getKey();,         List<IntervalFacet.Count> counts = new ArrayList<IntervalFacet.Count>(intervalField.getValue().size());,         for (Map.Entry<String, Object> interval : intervalField.getValue()) {,           counts.add(new IntervalFacet.Count(interval.getKey(), (Integer)interval.getValue()));,         },         _intervalFacets.add(new IntervalFacet(field, counts));,       },     },   },   ,   protected List<PivotField> readPivots( List<NamedList> list ),   {,     ArrayList<PivotField> values = new ArrayList<>( list.size() );,     for( NamedList nl : list ) {,       // NOTE, this is cheating, but we know the order they are written in, so no need to check,       assert "field".equals(nl.getName(0));,       String f = (String)nl.getVal( 0 );,       assert "value".equals(nl.getName(1));,       Object v = nl.getVal( 1 );,       assert "count".equals(nl.getName(2));,       int cnt = ((Integer)nl.getVal( 2 )).intValue();, ,       List<PivotField> subPivots = null;,       Map<String,FieldStatsInfo> fieldStatsInfos = null;, ,       if (4 <= nl.size()) {,         for(int index = 3; index < nl.size(); index++) {,           final String key = nl.getName(index);,           final Object val = nl.getVal(index);,           switch (key) {, ,           case "pivot": {,             assert null != val : "Server sent back 'null' for sub pivots?";,             assert val instanceof List : "Server sent non-List for sub pivots?";, ,             subPivots = readPivots( (List<NamedList>) val );,             break;,           },           case "stats": {,             assert null != val : "Server sent back 'null' for stats?";,             assert val instanceof NamedList : "Server sent non-NamedList for stats?";, ,             fieldStatsInfos = extractFieldStatsInfo((NamedList<Object>) val);,             break;,           },           default: ,             throw new RuntimeException( "unknown key in pivot: "+ key+ " ["+val+"]");, ,           },         },       }, ,       values.add( new PivotField( f, v, cnt, subPivots, fieldStatsInfos ) );,     },     return values;,   }, ,   //------------------------------------------------------,   //------------------------------------------------------, ,   /**,    * Remove the field facet info,    */,   public void removeFacets() {,     _facetFields = new ArrayList<>();,   },   ,   //------------------------------------------------------,   //------------------------------------------------------, ,   public NamedList<Object> getHeader() {,     return _header;,   }, ,   public SolrDocumentList getResults() {,     return _results;,   },  ,   public NamedList<ArrayList> getSortValues(){,     return _sortvalues;,   }, ,   public Map<String, Object> getDebugMap() {,     return _debugMap;,   }, ,   public Map<String, String> getExplainMap() {,     return _explainMap;,   }, ,   public Map<String,Integer> getFacetQuery() {,     return _facetQuery;,   }, ,   public Map<String, SolrDocumentList> getExpandedResults(){,     return this._expandedResults;,   }, ,   /**,    * Returns the {@link GroupResponse} containing the group commands.,    * A group command can be the result of one of the following parameters:,    * <ul>,    *   <li>group.field,    *   <li>group.func,    *   <li>group.query,    * </ul>,    *,    * @return the {@link GroupResponse} containing the group commands,    */,   public GroupResponse getGroupResponse() {,     return _groupResponse;,   },   ,   public Map<String, Map<String, List<String>>> getHighlighting() {,     return _highlighting;,   }, ,   public SpellCheckResponse getSpellCheckResponse() {,     return _spellResponse;,   }, ,   public TermsResponse getTermsResponse() {,     return _termsResponse;,   },   ,   /**,    * See also: {@link #getLimitingFacets()},    */,   public List<FacetField> getFacetFields() {,     return _facetFields;,   },   ,   public List<FacetField> getFacetDates()   {,     return _facetDates;,   }, ,   public List<RangeFacet> getFacetRanges() {,     return _facetRanges;,   }, ,   public NamedList<List<PivotField>> getFacetPivot()   {,     return _facetPivot;,   },   ,   public List<IntervalFacet> getIntervalFacets() {,     return _intervalFacets;,   },   ,   /** get,    * ,    * @param name the name of the,    * @return the FacetField by name or null if it does not exist,    */,   public FacetField getFacetField(String name) {,     if (_facetFields==null) return null;,     for (FacetField f : _facetFields) {,       if (f.getName().equals(name)) return f;,     },     return null;,   },   ,   public FacetField getFacetDate(String name)   {,     if (_facetDates == null),       return null;,     for (FacetField f : _facetDates),       if (f.getName().equals(name)),         return f;,     return null;,   },   ,   /**,    * @return a list of FacetFields where the count is less then,    * then #getResults() {@link SolrDocumentList#getNumFound()},    * ,    * If you want all results exactly as returned by solr, use:,    * {@link #getFacetFields()},    */,   public List<FacetField> getLimitingFacets() {,     return _limitingFacets;,   },   ,   public <T> List<T> getBeans(Class<T> type){,     return solrClient == null ?,       new DocumentObjectBinder().getBeans(type,_results):,       solrClient.getBinder().getBeans(type, _results);,   }, ,   public Map<String, FieldStatsInfo> getFieldStatsInfo() {,     return _fieldStatsInfo;,   }, ,   public String getNextCursorMark() {,     return _cursorMarkNext;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/SolrPingResponse.java,,25-25,[public class SolrPingResponse extends SolrResponseBase],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/SolrResponseBase.java,,28-89,[public class SolrResponseBase extends SolrResponse, {,   private long elapsedTime = -1;,   private NamedList<Object> response = null;,   private String requestUrl = null;,   ,   @Override,   public long getElapsedTime() {,     return elapsedTime;,   }, ,   public void setElapsedTime(long elapsedTime) {,     this.elapsedTime = elapsedTime;,   }, ,   @Override,   public NamedList<Object> getResponse() {,     return response;,   }, ,   @Override,   public void setResponse(NamedList<Object> response) {,     this.response = response;,   }, ,   @Override,   public String toString() {,     return response.toString();,   },   ,   public NamedList getResponseHeader() {,     return (NamedList) response.get("responseHeader");,   },   ,   // these two methods are based on the logic in SolrCore.setResponseHeaderValues(...),   public int getStatus() {,     NamedList header = getResponseHeader();,     if (header != null) {,         return (Integer) header.get("status");,     },     else {,         return 0;,     },   },   ,   public int getQTime() {,     NamedList header = getResponseHeader();,     if (header != null) {,         return (Integer) header.get("QTime");,     },     else {,         return 0;,     },   }, ,   public String getRequestUrl() {,     return requestUrl;,   }, ,   public void setRequestUrl(String requestUrl) {,     this.requestUrl = requestUrl;,   }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/client/solrj/response/SpellCheckResponse.java,,227-255,[  public class Collation {,     private String collationQueryString;,     private List<Correction> misspellingsAndCorrections = new ArrayList<>();,     private long numberOfHits;, ,     public long getNumberOfHits() {,       return numberOfHits;,     }, ,     public void setNumberOfHits(long numberOfHits) {,       this.numberOfHits = numberOfHits;,     }, ,     public String getCollationQueryString() {,       return collationQueryString;,     }, ,     public Collation setCollationQueryString(String collationQueryString) {,       this.collationQueryString = collationQueryString;,       return this;,     }, ,     public List<Correction> getMisspellingsAndCorrections() {,       return misspellingsAndCorrections;,     }, ,     public Collation addMisspellingsAndCorrection(Correction correction) {,       this.misspellingsAndCorrections.add(correction);,       return this;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/client/solrj/response/SpellCheckResponse.java,,264-283,[    public Correction(String original, String correction) {,       this.original = original;,       this.correction = correction;,     }, ,     public String getOriginal() {,       return original;,     }, ,     public void setOriginal(String original) {,       this.original = original;,     }, ,     public String getCorrection() {,       return correction;,     }, ,     public void setCorrection(String correction) {,       this.correction = correction;,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/client/solrj/response/UpdateResponse.java,,27-27,[public class UpdateResponse extends SolrResponseBase],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/client/solrj/util/ClientUtils.java,toXML,183-183,[    catch( Exception ex ){}],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/client/solrj/util/ClientUtils.java,,223-223,[  public static TimeZone UTC = DateUtil.UTC;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/client/solrj/util/ClientUtils.java,writeXML,129-129,[          writeVal(writer, boost, name, v, update);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/client/solrj/util/ClientUtils.java,,223-223,[  public static TimeZone UTC = DateUtil.UTC;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,ensureAllReplicasAreActive,1934-1934,[        } catch (Exception ignoreMe) {}],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,checkShardConsistency,1090-1090,[    long num = -1;],,
CORRECTNESS,IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,startCloudJetty,452-452,[    collection = DEFAULT_COLLECTION;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,,1539-1539,[    if (commondCloudSolrClient != null) {],,,1540-1540,[      commondCloudSolrClient.shutdown();],,,1782-1782,[    return commondCloudSolrClient;],,,1773-1773,[      if (commondCloudSolrClient == null) {],,,1775-1775,[            random().nextBoolean());],,,1776-1776,[        commondCloudSolrClient.getLbClient().setConnectionTimeout(30000);],,,1777-1777,[        commondCloudSolrClient.setParallelUpdates(random().nextBoolean());],,,1778-1778,[        commondCloudSolrClient.setDefaultCollection(DEFAULT_COLLECTION);],,,1779-1779,[        commondCloudSolrClient.connect();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,createNewSolrClient,1637-1637,[        if (adminClient != null) adminClient.shutdown();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,createJettys,396-396,[      jettyDir.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,startCloudJetty,460-460,[      jettyDir.mkdirs();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,createServers,318-318,[    createJettys(numServers, checkCreatedVsState).size();],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,checkQueries,854-854,[      ids = ids + ',' + Integer.toString(i);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,checkCollectionExpectations,1731-1731,[        for (Replica replica : slices.get(sliceName).getReplicas()) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,checkShardConsistency,1273-1273,[      int times = shardToJetty.get(s).size();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,showCounts,1164-1164,[      List<CloudJettyRunner> solrJetties = shardToJetty.get(shard);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,,659-659,[            csc.info = replica;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/cloud/AbstractFullDistribZkTestBase.java,getClient,1316-1316,[      if (client.shardName.equals(nodeName)) {],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/solr/cloud/AbstractZkTestCase.java,azt_afterClass,157-159,[    if (zkServer != null) {,       zkServer.shutdown();,       zkServer = null;],,
MALICIOUS_CODE,MS_CANNOT_BE_FINAL,org/apache/solr/cloud/AbstractZkTestCase.java,,51-51,[      SOLRHOME = new File(TEST_HOME());],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/cloud/AbstractZkTestCase.java,,45-45,[      .getLogger(AbstractZkTestCase.class);],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/cloud/ChaosMonkey.java,startTheMonkey,450-450,[      DirectUpdateHandler2.commitOnClose = false;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/cloud/ChaosMonkey.java,stopTheMonkey,531-531,[    DirectUpdateHandler2.commitOnClose = true;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/CloudDescriptor.java,,42-42,[  volatile String shardParent = null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/CloudDescriptor.java,,40-40,[  volatile String shardRange = null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/CloudDescriptor.java,,41-41,[  volatile String shardState = Slice.ACTIVE;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/cloud/CloudUtil.java,,38-38,[  protected static Logger log = LoggerFactory.getLogger(CloudUtil.class);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/cloud/DistributedMap.java,,73-99,[    Object lock = new Object();,     private WatchedEvent event = null;, ,     public LatchChildWatcher() {}, ,     public LatchChildWatcher(Object lock) {,       this.lock = lock;,     }, ,     @Override,     public void process(WatchedEvent event) {,       LOG.info("LatchChildWatcher fired on path: " + event.getPath() + " state: ",           + event.getState() + " type " + event.getType());,       synchronized (lock) {,         this.event = event;,         lock.notifyAll();,       },     }, ,     public void await(long timeout) throws InterruptedException {,       synchronized (lock) {,         lock.wait(timeout);,       },     }, ,     public WatchedEvent getWatchedEvent() {,       return event;],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/solr/cloud/DistributedMap.java,await,94-94,[        lock.wait(timeout);],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/solr/cloud/DistributedMap.java,await,94-94,[        lock.wait(timeout);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/cloud/DistributedMap.java,getBytes,225-225,[      return bytes;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/cloud/DistributedMap.java,setBytes,221-221,[      this.bytes = bytes;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/cloud/DistributedQueue.java,orderedChildren,102-102,[        Long childId = new Long(suffix);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/DistributedQueue.java,orderedChildren,493-493,[    if(orderedChildren == null || orderedChildren.isEmpty()) return null;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/solr/cloud/DistributedQueue.java,peekTopN,438-438,[    LOG.debug("Peeking for top {} elements. ExcludeSet: " + excludeSet.toString());],,peekTopN,449-449,[            if (excludeSet != null && excludeSet.contains(id)) continue;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/cloud/DistributedQueue.java,,244-278,[      this(lock, null);,     }, ,     LatchWatcher(Event.EventType eventType) {,       this(new Object(), eventType);,     }, ,     LatchWatcher(Object lock, Event.EventType eventType) {,       this.lock = lock;,       this.latchEventType = eventType;,     }, ,     @Override,     public void process(WatchedEvent event) {,       Event.EventType eventType = event.getType();,       // None events are ignored,       // If latchEventType is not null, only fire if the type matches,       if (eventType != Event.EventType.None && (latchEventType == null || eventType == latchEventType)) {,         LOG.info("{} fired on path {} state {}", eventType, event.getPath(), event.getState());,         synchronized (lock) {,           this.event = event;,           lock.notifyAll();,         },       },     }, ,     public void await(long timeout) throws InterruptedException {,       synchronized (lock) {,         if (this.event != null) return;,         lock.wait(timeout);,       },     }, ,     public WatchedEvent getWatchedEvent() {,       return event;],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/solr/cloud/DistributedQueue.java,await,273-273,[        lock.wait(timeout);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/cloud/DistributedQueue.java,getBytes,552-552,[      return bytes;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/cloud/DistributedQueue.java,setBytes,548-548,[      this.bytes = bytes;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/solr/cloud/LeaderElector.java,joinElection,336-336,[          context = null;],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_COMPARE,org/apache/solr/cloud/LeaderElector.java,compare,416-416,[        int i = Integer.valueOf(getSeq(o1)).compareTo(],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/LeaderElector.java,,361-361,[      this.watchedNode = watchedNode;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/cloud/LeaderInitiatedRecoveryThread.java,sendRecoveryCommandWithRetry,99-99,[    String replicaCoreNodeName = ((Replica) nodeProps.getNodeProps()).getName();],,
CORRECTNESS,ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND,org/apache/solr/cloud/LeaderInitiatedRecoveryThread.java,run,88-88,[    log.info(getName()+" completed successfully after running for "+Math.round(diffMs/1000L)+" secs");    ],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/LeaderInitiatedRecoveryThread.java,sendRecoveryCommandWithRetry,236-236,[          } catch (Exception ignoreMe) {],,
STYLE,UC_USELESS_CONDITION,org/apache/solr/cloud/LeaderInitiatedRecoveryThread.java,sendRecoveryCommandWithRetry,196-196,[        if (continueTrying && collection != null && shardId != null) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/cloud/MockSolrZkClient.java,getData,43-43,[    return null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/cloud/Overseer.java,,436-436,[                overseerCollectionProcessor.close();],,,359-359,[        if(overseerCollectionProcessor.getId().equals(id)){],,,903-903,[    overseerCollectionProcessor = new OverseerCollectionProcessor(reader, id, shardHandler, adminPath, stats);],,,904-904,[    ccThread = new OverseerThread(ccTg, overseerCollectionProcessor, "OverseerCollectionProcessor-" + id);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/Overseer.java,handleProp,479-479,[      } catch (Exception e) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/Overseer.java,,127-127,[      clusterProps = reader.getClusterProps();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/Overseer.java,,124-124,[      this.completedMap = getCompletedMap(zkClient);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/Overseer.java,,122-122,[      this.failureMap = getFailureMap(zkClient);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/Overseer.java,,123-123,[      this.runningMap = getRunningMap(zkClient);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/cloud/Overseer.java,,119-119,[      this.zkStats = zkStats;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/Overseer.java,<init>,572-572,[      if (collection == null) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/cloud/Overseer.java,<init>,832-832,[      super(tg, (Runnable) thread);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/cloud/Overseer.java,<init>,837-837,[      super(ccTg, (Runnable) thread, name);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/cloud/Overseer.java,,831-848,[    public OverseerThread(ThreadGroup tg, Closeable thread) {,       super(tg, (Runnable) thread);,       this.thread = thread;,     }, ,     public OverseerThread(ThreadGroup ccTg, Closeable thread, String name) {,       super(ccTg, (Runnable) thread, name);,       this.thread = thread;,     }, ,     @Override,     public void close() throws IOException {,       thread.close();,       this.isClosed = true;,     }, ,     public boolean isClosed() {,       return this.isClosed;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/cloud/Overseer.java,,816-823,[  private class SliceReplica {,     private Slice slice;,     private Replica replica;, ,     SliceReplica(Slice slice, Replica replica) {,       this.slice = slice;,       this.replica = replica;,     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/OverseerAutoReplicaFailoverThread.java,getBestCreateUrl,354-354,[                if (c != null) {],,
CORRECTNESS,RC_REF_COMPARISON,org/apache/solr/cloud/OverseerAutoReplicaFailoverThread.java,doWork,154-154,[      if (lastClusterStateVersion == clusterState.getZkClusterStateVersion() && baseUrlForBadNodes.size() == 0) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/OverseerAutoReplicaFailoverThread.java,createSolrCore,436-436,[    } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/cloud/OverseerAutoReplicaFailoverThread.java,addReplica,241-241,[      updateExecutor.submit(new Callable<Boolean>() {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/cloud/OverseerAutoReplicaFailoverThread.java,toString,502-502,[          + slice.getName() + ", collection=" + collection.getName() + "]";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/cloud/OverseerAutoReplicaFailoverThread.java,toString,502-502,[          + slice.getName() + ", collection=" + collection.getName() + "]";],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/solr/cloud/OverseerAutoReplicaFailoverThread.java,,447-458,[  private static class ValueComparator implements Comparator<String> {,     Map<String,Counts> map;,     ,     public ValueComparator(Map<String,Counts> map) {,       this.map = map;,     },     ,     public int compare(String a, String b) {,       if (map.get(a).negRankingWeight >= map.get(b).negRankingWeight) {,         return 1;,       } else {,         return -1;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/solr/cloud/OverseerCollectionProcessor.java,processMessage,637-638,[            processRoleCommand(message, operation);,             break;],,processMessage,640-641,[            processRoleCommand(message, operation);,             break;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/solr/cloud/OverseerCollectionProcessor.java,splitShard,1502-1502,[      List<String> subSlices = new ArrayList<>(subRanges.size());],,splitShard,1440-1440,[    List<DocRouter.Range> subRanges = null;],,splitShard,1475-1475,[      if (router instanceof CompositeIdRouter) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/OverseerCollectionProcessor.java,addReplica,2523-2523,[    if (coll == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/OverseerCollectionProcessor.java,migrate,1966-1966,[    if (sourceCollection == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/OverseerCollectionProcessor.java,migrate,1970-1970,[    if (targetCollection == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/OverseerCollectionProcessor.java,waitForCoreNodeGone,1138-1138,[      if (docCollection == null || deleted) break;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/OverseerCollectionProcessor.java,waitForNewShard,1855-1855,[      if (collection == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/OverseerCollectionProcessor.java,waitForCoreNodeGone,1131-1131,[      if(docCollection != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/OverseerCollectionProcessor.java,processMessage,671-671,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/OverseerCollectionProcessor.java,createCollection,2481-2481,[    } catch (Exception ex) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/OverseerCollectionProcessor.java,deleteShard,1954-1954,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/OverseerCollectionProcessor.java,migrateKey,2236-2236,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/OverseerCollectionProcessor.java,run,386-386,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/OverseerCollectionProcessor.java,splitShard,1781-1781,[    } catch (Exception e) {],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/solr/cloud/OverseerCollectionProcessor.java,getClusterStatus,904-904,[          s += slice.getName() + ",";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/solr/cloud/OverseerCollectionProcessor.java,splitShard,1493-1493,[            rangesStr += ',';],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/solr/cloud/OverseerCollectionProcessor.java,run,322-322,[              waitLock.wait(100);//wait for 100 ms or till a task is complete],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/cloud/OverseerCollectionProcessor.java,cleanUpWorkQueue,418-418,[        workQueue.remove(completedTasks.get(id));],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/cloud/OverseerCollectionProcessor.java,waitForAsyncCallsToComplete,2748-2748,[      log.debug("I am Waiting for :{}/{}", k, requestMap.get(k));],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/cloud/OverseerSolrResponse.java,,25-44,[  NamedList responseList = null;,   ,   public OverseerSolrResponse(NamedList list) {,     responseList = list;,   },   ,   @Override,   public long getElapsedTime() {,     // TODO Auto-generated method stub,     return 0;,   },   ,   @Override,   public void setResponse(NamedList<Object> rsp) {,     this.responseList = rsp;,   },   ,   @Override,   public NamedList<Object> getResponse() {,     return responseList;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/RecoveryStrategy.java,doRecovery,485-485,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/RecoveryStrategy.java,doRecovery,253-550,[    boolean replayed = false;,     boolean successfulRecovery = false;, ,     UpdateLog ulog;,     ulog = core.getUpdateHandler().getUpdateLog();,     if (ulog == null) {,       SolrException.log(log, "No UpdateLog found - cannot recover. core=" + coreName);,       recoveryFailed(core, zkController, baseUrl, coreZkNodeName,,           core.getCoreDescriptor());,       return;,     }, ,     boolean firstTime = true;, ,     List<Long> recentVersions;,     UpdateLog.RecentUpdates recentUpdates = null;,     try {,       recentUpdates = ulog.getRecentUpdates();,       recentVersions = recentUpdates.getVersions(ulog.numRecordsToKeep);,     } catch (Exception e) {,       SolrException.log(log, "Corrupt tlog - ignoring. core=" + coreName, e);,       recentVersions = new ArrayList<>(0);,     } finally {,       if (recentUpdates != null) {,         recentUpdates.close();,       },     }, ,     List<Long> startingVersions = ulog.getStartingVersions();, ,     if (startingVersions != null && recoveringAfterStartup) {,       try {,         int oldIdx = 0; // index of the start of the old list in the current,                         // list,         long firstStartingVersion = startingVersions.size() > 0 ? startingVersions,             .get(0) : 0;,         ,         for (; oldIdx < recentVersions.size(); oldIdx++) {,           if (recentVersions.get(oldIdx) == firstStartingVersion) break;,         },         ,         if (oldIdx > 0) {,           log.info("####### Found new versions added after startup: num=",               + oldIdx);,           log.info("###### currentVersions=" + recentVersions);,         },         ,         log.info("###### startupVersions=" + startingVersions);,       } catch (Exception e) {,         SolrException.log(log, "Error getting recent versions. core=" + coreName, e);,         recentVersions = new ArrayList<>(0);,       },     }, ,     if (recoveringAfterStartup) {,       // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were,       // when we went down.  We may have received updates since then.,       recentVersions = startingVersions;,       try {,         if ((ulog.getStartingOperation() & UpdateLog.FLAG_GAP) != 0) {,           // last operation at the time of startup had the GAP flag set...,           // this means we were previously doing a full index replication,           // that probably didn't complete and buffering updates in the,           // meantime.,           log.info("Looks like a previous replication recovery did not complete - skipping peer sync. core=",               + coreName);,           firstTime = false; // skip peersync,         },       } catch (Exception e) {,         SolrException.log(log, "Error trying to get ulog starting operation. core=",             + coreName, e);,         firstTime = false; // skip peersync,       },     }, ,     while (!successfulRecovery && !isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though,       try {,         CloudDescriptor cloudDesc = core.getCoreDescriptor(),             .getCloudDescriptor();,         ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(,             cloudDesc.getCollectionName(), cloudDesc.getShardId());,       ,         final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);,         final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);, ,         String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);, ,         String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);, ,         boolean isLeader = leaderUrl.equals(ourUrl);,         if (isLeader && !cloudDesc.isLeader()) {,           throw new SolrException(ErrorCode.SERVER_ERROR, "Cloud state still says we are leader.");,         },         if (cloudDesc.isLeader()) {,           // we are now the leader - no one else must have been suitable,           log.warn("We have not yet recovered - but we are now the leader! core=" + coreName);,           log.info("Finished recovery process. core=" + coreName);,           zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);,           return;,         },         ,         log.info("Publishing state of core "+core.getName()+" as recovering, leader is "+leaderUrl+" and I am "+ourUrl);,         zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);,         ,         ,         final Slice slice = zkStateReader.getClusterState().getSlice(cloudDesc.getCollectionName(), cloudDesc.getShardId());, ,         try {,           prevSendPreRecoveryHttpUriRequest.abort();,         } catch (NullPointerException e) {,           // okay,         },         ,         if (isClosed()) {,           log.info("Recovery was cancelled");,           break;,         }, ,         sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName, slice);,         ,         if (isClosed()) {,           log.info("Recovery was cancelled");,           break;,         },         ,         // we wait a bit so that any updates on the leader,         // that started before they saw recovering state ,         // are sure to have finished,         try {,           Thread.sleep(2000);,         } catch (InterruptedException e) {,           Thread.currentThread().interrupt();,         }, ,         // first thing we just try to sync,         if (firstTime) {,           firstTime = false; // only try sync the first time through the loop,           log.info("Attempting to PeerSync from " + leaderUrl + " core=" + coreName + " - recoveringAfterStartup="+recoveringAfterStartup);,           // System.out.println("Attempting to PeerSync from " + leaderUrl,           // + " i am:" + zkController.getNodeName());,           PeerSync peerSync = new PeerSync(core,,               Collections.singletonList(leaderUrl), ulog.numRecordsToKeep, false, false);,           peerSync.setStartingVersions(recentVersions);,           boolean syncSuccess = peerSync.sync();,           if (syncSuccess) {,             SolrQueryRequest req = new LocalSolrQueryRequest(core,,                 new ModifiableSolrParams());,             // force open a new searcher,             core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));,             log.info("PeerSync Recovery was successful - registering as Active. core=" + coreName);, ,             // solrcloud_debug,             if (log.isDebugEnabled()) {,               try {,                 RefCounted<SolrIndexSearcher> searchHolder = core,                     .getNewestSearcher(false);,                 SolrIndexSearcher searcher = searchHolder.get();,                 try {,                   log.debug(core.getCoreDescriptor(),                       .getCoreContainer().getZkController().getNodeName(),                       + " synched ",                       + searcher.search(new MatchAllDocsQuery(), 1).totalHits);,                 } finally {,                   searchHolder.decref();,                 },               } catch (Exception e) {,                 throw new SolrException(ErrorCode.SERVER_ERROR, null, e);,               },             }, ,             // sync success - register as active and return,             zkController.publish(core.getCoreDescriptor(),,                 ZkStateReader.ACTIVE);,             successfulRecovery = true;,             close = true;,             return;,           }, ,           log.info("PeerSync Recovery was not successful - trying replication. core=" + coreName);,         }, ,         if (isClosed()) {,           log.info("Recovery was cancelled");,           break;,         },         ,         log.info("Starting Replication Recovery. core=" + coreName);,         ,         log.info("Begin buffering updates. core=" + coreName);,         ulog.bufferUpdates();,         replayed = false;,         ,         try {, ,           replicate(zkController.getNodeName(), core, leaderprops);, ,           if (isClosed()) {,             log.info("Recovery was cancelled");,             break;,           },           ,           replay(core);,           replayed = true;,           ,           if (isClosed()) {,             log.info("Recovery was cancelled");,             break;,           }, ,           log.info("Replication Recovery was successful - registering as Active. core=" + coreName);,           // if there are pending recovery requests, don't advert as active,           zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);,           close = true;,           successfulRecovery = true;,           recoveryListener.recovered();,         } catch (InterruptedException e) {,           Thread.currentThread().interrupt();,           log.warn("Recovery was interrupted", e);,           retries = INTERRUPTED;,         } catch (Exception e) {,           SolrException.log(log, "Error while trying to recover", e);,         } finally {,           if (!replayed) {,             try {,               ulog.dropBufferedUpdates();,             } catch (Exception e) {,               SolrException.log(log, "", e);,             },           }, ,         }, ,       } catch (Exception e) {,         SolrException.log(log, "Error while trying to recover. core=" + coreName, e);,       }, ,       if (!successfulRecovery) {,         // lets pause for a moment and we need to try again...,         // TODO: we don't want to retry for some problems?,         // Or do a fall off retry...,         try {, ,           log.error("Recovery failed - trying again... (" + retries + ") core=" + coreName);,           ,           if (isClosed()) {,             retries = INTERRUPTED;,           },           ,           retries++;,           if (retries >= MAX_RETRIES) {,             if (retries >= INTERRUPTED) {,               SolrException.log(log, "Recovery failed - interrupted. core=",                   + coreName);,               try {,                 recoveryFailed(core, zkController, baseUrl, coreZkNodeName,,                     core.getCoreDescriptor());,               } catch (Exception e) {,                 SolrException.log(log,,                     "Could not publish that recovery failed", e);,               },             } else {,               SolrException.log(log,,                   "Recovery failed - max retries exceeded (" + retries + "). core=" + coreName);,               try {,                 recoveryFailed(core, zkController, baseUrl, coreZkNodeName,,                     core.getCoreDescriptor());,               } catch (Exception e) {,                 SolrException.log(log,,                     "Could not publish that recovery failed", e);,               },             },             break;,           }, ,         } catch (Exception e) {,           SolrException.log(log, "core=" + coreName, e);,         }, ,         try {,           // start at 1 sec and work up to a min,           double loopCount = Math.min(Math.pow(2, retries), 60);,           log.info("Wait {} seconds before trying to recover again ({})", loopCount, retries);,           for (int i = 0; i < loopCount; i++) {,             if (isClosed()) break; // check if someone closed us,             Thread.sleep(STARTING_RECOVERY_DELAY);,           },         } catch (InterruptedException e) {,           Thread.currentThread().interrupt();,           log.warn("Recovery was interrupted. core=" + coreName, e);,           retries = INTERRUPTED;,         },       }, ,     },     log.info("Finished recovery process. core=" + coreName);, ,     ,   }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/RecoveryStrategy.java,doRecovery,418-418,[              } catch (Exception e) {],,doRecovery,485-485,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/RecoveryStrategy.java,replay,582-582,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/RecoveryStrategy.java,replicate,194-194,[      } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/cloud/ElectionContext.java,startLeaderInitiatedRecoveryOnReplicas,375-375,[                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/cloud/ElectionContext.java,runLeaderProcess,331-331,[      } catch (Exception exc) {],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/solr/cloud/ElectionContext.java,startLeaderInitiatedRecoveryOnReplicas,381-381,[              LeaderInitiatedRecoveryThread lirThread = ],,startLeaderInitiatedRecoveryOnReplicas,373-373,[              ZkCoreNodeProps coreNodeProps = null;],,startLeaderInitiatedRecoveryOnReplicas,374-374,[              for (ZkCoreNodeProps p : replicaProps) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ElectionContext.java,runLeaderProcess,292-292,[        } catch (Exception e) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/cloud/SocketProxy.java,close,402-402,[      } catch (IOException ignored) {}],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/SocketProxy.java,run,336-336,[        } catch (Exception e) {],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/cloud/SolrZkServer.java,getProperties,182-182,[        cfg.load(new InputStreamReader(in, StandardCharsets.UTF_8));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/StopableIndexingThread.java,run,90-90,[        } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/cloud/SyncStrategy.java,syncToMe,211-211,[             requestRecovery(leaderProps, ((ShardCoreRequest)srsp.getShardRequest()).baseUrl, ((ShardCoreRequest)srsp.getShardRequest()).coreName);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/SyncStrategy.java,syncToMe,213-213,[         } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/cloud/ZkController.java,persistConfigResourceToZooKeeper,2157-2157,[    final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/cloud/ZkController.java,ensureReplicaInLeaderInitiatedRecovery,1949-1949,[    String replicaCoreNodeName = ((Replica)replicaCoreProps.getNodeProps()).getName();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/cloud/ZkController.java,unregister,1212-1212,[      if (((ZkSolrResourceLoader)solrCore.getResourceLoader()).getConfigSetZkPath().equals(configLocation))],,
STYLE,DB_DUPLICATE_BRANCHES,org/apache/solr/cloud/ZkController.java,preRegister,1549-1549,[      doGetShardIdAndNodeNameProcess(cd);],,preRegister,1552-1552,[      doGetShardIdAndNodeNameProcess(cd);],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/solr/cloud/ZkController.java,getLeader,932-932,[      int maxTries = (int)Math.floor(leaderConflictResolveWait/msInSec);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/cloud/ZkController.java,unregister,1197-1197,[    if (collection == null || collection.trim().length() == 0) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ZkController.java,persistConfigResourceToZooKeeper,2175-2175,[            } catch (Exception e1) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ZkController.java,getLeader,954-954,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ZkController.java,registerAllCoresAsDown,390-390,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ZkController.java,rejoinOverseerElection,1864-1864,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ZkController.java,rejoinShardLeaderElection,1889-1889,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ZkController.java,updateLeaderInitiatedRecoveryState,2105-2105,[    } catch (Exception exc) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ZkController.java,waitForLeaderToSeeDownState,1598-1598,[      } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/cloud/ZkController.java,downloadFromZK,1489-1489,[        dir.mkdirs(); ],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/cloud/ZkSolrResourceLoader.java,openResource,88-88,[    } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/cloud/ZkTestServer.java,,402-415,[    zkServer.zooKeeperServer.expire(new Session() {,       @Override,       public long getSessionId() {,         return sessionId;,       }, ,       @Override,       public int getTimeout() {,         return 4000;,       }, ,       @Override,       public boolean isClosing() {,         return false;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/cloud/ZkTestServer.java,shutdown,327-327,[      zooKeeperServer.shutdown();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/cloud/ZkTestServer.java,updateForFire,205-216,[        switch (event.getType()) {,           case None:,             break;,           case NodeCreated:,           case NodeDeleted:,             statLimit.updateForFire(event);,             break;,           case NodeDataChanged:,             dataLimit.updateForFire(event);,             break;,           case NodeChildrenChanged:,             childrenLimit.updateForFire(event);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/cloud/overseer/SliceMutator.java,addRoutingRule,208-208,[    String targetShard = message.getStr("targetShard");],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/cloud/overseer/ZkStateWriter.java,,41-41,[  public static ZkWriteCommand NO_OP = ZkWriteCommand.noop();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/cloud/overseer/ZkWriteCommand.java,,30-30,[    this.noop = false;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/EnumFieldValue.java,,27-112,[public final class EnumFieldValue implements Serializable, Comparable<EnumFieldValue> {,   private final Integer intValue;,   private final String stringValue;, ,   @Override,   public int hashCode() {,     int result = intValue != null ? intValue.hashCode() : 0;,     result = 31 * result + (stringValue != null ? stringValue.hashCode() : 0);,     return result;,   }, ,   public EnumFieldValue(Integer intValue, String stringValue) {,     this.intValue = intValue;,     this.stringValue = stringValue;,   }, ,   @Override,   public boolean equals(Object obj) {,     if (obj == null),       return false;,     if (!(obj instanceof EnumFieldValue)),       return false;, ,     EnumFieldValue otherEnumFieldValue = (EnumFieldValue) obj;,     return equalsIntegers(intValue, otherEnumFieldValue.intValue) && equalStrings(stringValue, otherEnumFieldValue.stringValue);,   }, ,   /**,    * @return string (displayed) value,    */,   @Override,   public String toString() {,     return stringValue;,   }, ,   /**,    * @return integer value (indicating the sort order),    */,   public Integer toInt() {,     return intValue;,   }, ,   @Override,   public int compareTo(EnumFieldValue o) {,     if (o == null),       return 1;,     return compareIntegers(intValue, o.intValue);,   }, ,   private boolean equalStrings(String str1, String str2) {,     if ((str1 == null) && (str2 == null)),       return true;, ,     if (str1 == null),       return false;, ,     if (str2 == null),       return false;, ,     return str1.equals(str2);,   }, ,   private boolean equalsIntegers(Integer int1, Integer int2) {,     if ((int1 == null) && (int2 == null)),       return true;, ,     if (int1 == null),       return false;, ,     if (int2 == null),       return false;, ,     return int1.equals(int2);,   }, ,   private int compareIntegers(Integer int1, Integer int2) {,     if ((int1 == null) && (int2 == null)),       return 0;, ,     if (int1 == null),       return -1;, ,     if (int2 == null),       return 1;, ,     return int1.compareTo(int2);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/SolrDocument.java,,44-394,[public class SolrDocument implements Map<String,Object>, Iterable<Map.Entry<String, Object>>, Serializable, {,   private final Map<String,Object> _fields;,   ,   private List<SolrDocument> _childDocuments;,   ,   public SolrDocument(),   {,     _fields = new LinkedHashMap<>();,   }, ,   /**,    * @return a list of field names defined in this document - this Collection is directly backed by this SolrDocument.,    * @see #keySet,    */,   public Collection<String> getFieldNames() {,     return this.keySet();,   }, ,   ///////////////////////////////////////////////////////////////////,   // Add / Set / Remove Fields,   ///////////////////////////////////////////////////////////////////, ,   /**,    * Remove all fields from the document,    */,   @Override,   public void clear(),   {,     _fields.clear();, ,     if(_childDocuments != null) {,       _childDocuments.clear();,     },   },   ,   /**,    * Remove all fields with the name,    */,   public boolean removeFields(String name) ,   {,     return this.remove( name ) != null;,   }, ,   /**,    * Set a field with the given object.  If the object is an Array, it will ,    * set multiple fields with the included contents.  This will replace any existing ,    * field with the given name,    */,   @SuppressWarnings("unchecked"),   public void setField(String name, Object value) ,   {,     if( value instanceof Object[] ) {,       value = new ArrayList(Arrays.asList( (Object[])value ));,     },     else if( value instanceof Collection ) {,       // nothing,     },     else if( value instanceof NamedList ) {,       // nothing,     },     else if( value instanceof Iterable ) {,       ArrayList<Object> lst = new ArrayList<>();,       for( Object o : (Iterable)value ) {,         lst.add( o );,       },       value = lst;,     },     _fields.put(name, value);,   },   ,   /**,    * This will add a field to the document.  If fields already exist with this,    * name it will append value to the collection. If the value is Collection,,    * each value will be added independently. ,    * ,    * The class type of value and the name parameter should match schema.xml. ,    * schema.xml can be found in conf directory under the solr home by default.,    * ,    * @param name Name of the field, should match one of the field names defined under "fields" tag in schema.xml.,    * @param value Value of the field, should be of same class type as defined by "type" attribute of the corresponding field in schema.xml. ,    */,   @SuppressWarnings("unchecked"),   public void addField(String name, Object value) ,   { ,     Object existing = _fields.get(name);,     if (existing == null) {,       if( value instanceof Collection ) {,         Collection<Object> c = new ArrayList<>( 3 );,         for ( Object o : (Collection<Object>)value ) {,           c.add(o);,         },         this.setField( name, c );,       } else {,         this.setField( name, value );,       },       return;,     },     ,     Collection<Object> vals = null;,     if( existing instanceof Collection ) {,       vals = (Collection<Object>)existing;,     },     else {,       vals = new ArrayList<>( 3 );,       vals.add( existing );,     },     ,     // Add the values to the collection,     if( value instanceof Iterable ) {,       for( Object o : (Iterable<Object>)value ) {,         vals.add( o );,       },     },     else if( value instanceof Object[] ) {,       for( Object o : (Object[])value ) {,         vals.add( o );,       },     },     else {,       vals.add( value );,     },     _fields.put( name, vals );,   }, ,   ///////////////////////////////////////////////////////////////////,   // Get the field values,   ///////////////////////////////////////////////////////////////////, ,   /**,    * returns the first value for a field,    */,   public Object getFirstValue(String name) {,     Object v = _fields.get( name );,     if (v == null || !(v instanceof Collection)) return v;,     Collection c = (Collection)v;,     if (c.size() > 0 ) {,       return c.iterator().next();,     },     return null;,   },   ,   /**,    * Get the value or collection of values for a given field.  ,    */,   public Object getFieldValue(String name) {,     return _fields.get( name );,   }, ,   /**,    * Get a collection of values for a given field name,    */,   @SuppressWarnings("unchecked"),   public Collection<Object> getFieldValues(String name) {,     Object v = _fields.get( name );,     if( v instanceof Collection ) {,       return (Collection<Object>)v;,     },     if( v != null ) {,       ArrayList<Object> arr = new ArrayList<>(1);,       arr.add( v );,       return arr;,     },     return null;,   },     ,   @Override,   public String toString(),   {,     return "SolrDocument"+_fields;,   }, ,   /**,    * Iterate of String->Object keys,    */,   @Override,   public Iterator<Entry<String, Object>> iterator() {,     return _fields.entrySet().iterator();,   }, ,   //-----------------------------------------------------------------------------------------,   // JSTL Helpers,   //-----------------------------------------------------------------------------------------,   ,   /**,    * Expose a Map interface to the solr field value collection.,    */,   public Map<String,Collection<Object>> getFieldValuesMap(),   {,     return new Map<String,Collection<Object>>() {,       /** Get the field Value */,       @Override,       public Collection<Object> get(Object key) { ,         return getFieldValues( (String)key ); ,       },       ,       // Easily Supported methods,       @Override,       public boolean containsKey(Object key) { return _fields.containsKey( key ); },       @Override,       public Set<String>  keySet()           { return _fields.keySet();  },       @Override,       public int          size()             { return _fields.size();    },       @Override,       public boolean      isEmpty()          { return _fields.isEmpty(); }, ,       // Unsupported operations.  These are not necessary for JSTL,       @Override,       public void clear() { throw new UnsupportedOperationException(); },       @Override,       public boolean containsValue(Object value) {throw new UnsupportedOperationException();},       @Override,       public Set<java.util.Map.Entry<String, Collection<Object>>> entrySet() {throw new UnsupportedOperationException();},       @Override,       public void putAll(Map<? extends String, ? extends Collection<Object>> t) {throw new UnsupportedOperationException();},       @Override,       public Collection<Collection<Object>> values() {throw new UnsupportedOperationException();},       @Override,       public Collection<Object> put(String key, Collection<Object> value) {throw new UnsupportedOperationException();},       @Override,       public Collection<Object> remove(Object key) {throw new UnsupportedOperationException();},       @Override,       public String toString() {return _fields.toString();},     };,   }, ,   /**,    * Expose a Map interface to the solr fields.  This function is useful for JSTL,    */,   public Map<String,Object> getFieldValueMap() {,     return new Map<String,Object>() {,       /** Get the field Value */,       @Override,       public Object get(Object key) { ,         return getFirstValue( (String)key ); ,       },       ,       // Easily Supported methods,       @Override,       public boolean containsKey(Object key) { return _fields.containsKey( key ); },       @Override,       public Set<String>  keySet()           { return _fields.keySet();  },       @Override,       public int          size()             { return _fields.size();    },       @Override,       public boolean      isEmpty()          { return _fields.isEmpty(); }, ,       // Unsupported operations.  These are not necessary for JSTL,       @Override,       public void clear() { throw new UnsupportedOperationException(); },       @Override,       public boolean containsValue(Object value) {throw new UnsupportedOperationException();},       @Override,       public Set<java.util.Map.Entry<String, Object>> entrySet() {throw new UnsupportedOperationException();},       @Override,       public void putAll(Map<? extends String, ? extends Object> t) {throw new UnsupportedOperationException();},       @Override,       public Collection<Object> values() {throw new UnsupportedOperationException();},       @Override,       public Collection<Object> put(String key, Object value) {throw new UnsupportedOperationException();},       @Override,       public Collection<Object> remove(Object key) {throw new UnsupportedOperationException();}      ,       @Override,       public String toString() {return _fields.toString();},    };,   }, ,   //---------------------------------------------------,   // MAP interface,   //---------------------------------------------------, ,   @Override,   public boolean containsKey(Object key) {,     return _fields.containsKey(key);,   }, ,   @Override,   public boolean containsValue(Object value) {,     return _fields.containsValue(value);,   }, ,   @Override,   public Set<Entry<String, Object>> entrySet() {,     return _fields.entrySet();,   },   //TODO: Shouldn't the input parameter here be a String?  The _fields map requires a String.,   @Override,   public Object get(Object key) {,     return _fields.get(key);,   }, ,   @Override,   public boolean isEmpty() {,     return _fields.isEmpty();,   }, ,   @Override,   public Set<String> keySet() {,     return _fields.keySet();,   }, ,   @Override,   public Object put(String key, Object value) {,     return _fields.put(key, value);,   }, ,   @Override,   public void putAll(Map<? extends String, ? extends Object> t) {,     _fields.putAll( t );,   }, ,   @Override,   public Object remove(Object key) {,     return _fields.remove(key);,   }, ,   @Override,   public int size() {,     return _fields.size();,   }, ,   @Override,   public Collection<Object> values() {,     return _fields.values();,   },   ,   public void addChildDocument(SolrDocument child) {,     if (_childDocuments == null) {,       _childDocuments = new ArrayList<>();,     },      _childDocuments.add(child);,    },    ,    public void addChildDocuments(Collection<SolrDocument> childs) {,      for (SolrDocument child : childs) {,        addChildDocument(child);,      },    }, ,    /** Returns the list of child documents, or null if none. */,    public List<SolrDocument> getChildDocuments() {,      return _childDocuments;,    },    ,    public boolean hasChildDocuments() {,      boolean isEmpty = (_childDocuments == null || _childDocuments.isEmpty());,      return !isEmpty;,    }, ,   public int getChildDocumentCount() {,     return _childDocuments.size();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/SolrDocumentList.java,,30-65,[public class SolrDocumentList extends ArrayList<SolrDocument>, { ,   private long numFound = 0;,   private long start = 0;,   private Float maxScore = null;,   ,   public Float getMaxScore() {,     return maxScore;,   },   ,   public void setMaxScore(Float maxScore) {,     this.maxScore = maxScore;,   },   ,   public long getNumFound() {,     return numFound;,   },   ,   public void setNumFound(long numFound) {,     this.numFound = numFound;,   },   ,   public long getStart() {,     return start;,   },   ,   public void setStart(long start) {,     this.start = start;,   }, ,   @Override,   public String toString() {,     return "{numFound="+numFound,             +",start="+start,             + (maxScore!=null ? ",maxScore="+maxScore : ""),             +",docs="+super.toString()],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/SolrInputDocument.java,,38-299,[public class SolrInputDocument implements Map<String,SolrInputField>, Iterable<SolrInputField>, Serializable, {,   private final Map<String,SolrInputField> _fields;,   private float _documentBoost = 1.0f;,   private List<SolrInputDocument> _childDocuments;,   ,   public SolrInputDocument() {,     _fields = new LinkedHashMap<>();,   },   ,   public SolrInputDocument(Map<String,SolrInputField> fields) {,     _fields = fields;,   },   ,   /**,    * Remove all fields and boosts from the document,    */,   @Override,   public void clear(),   {,     if( _fields != null ) {,       _fields.clear();      ,     },     _childDocuments = null;,   }, ,   ///////////////////////////////////////////////////////////////////,   // Add / Set fields,   ///////////////////////////////////////////////////////////////////, ,   /** ,    * Add a field with implied null value for boost.,    * ,    * The class type of value and the name parameter should match schema.xml. ,    * schema.xml can be found in conf directory under the solr home by default.,    * ,    * @param name Name of the field, should match one of the field names defined under "fields" tag in schema.xml.,    * @param value Value of the field, should be of same class type as defined by "type" attribute of the corresponding field in schema.xml. ,    * @see #addField(String, Object, float),    */,   public void addField(String name, Object value) ,   {,     addField(name, value, 1.0f );,   },   ,   /** Get the first value for a field.,    * ,    * @param name name of the field to fetch,    * @return first value of the field or null if not present,    */,   public Object getFieldValue(String name) ,   {,     SolrInputField field = getField(name);,     Object o = null;,     if (field!=null) o = field.getFirstValue();,     return o;,   },   ,   /** Get all the values for a field.,    * ,    * @param name name of the field to fetch,    * @return value of the field or null if not set,    */,   public Collection<Object> getFieldValues(String name) ,   {,     SolrInputField field = getField(name);,     if (field!=null) {,       return field.getValues();,     },     return null;,   } ,   ,   /** Get all field names.,    * ,    * @return Set of all field names.,    */,   public Collection<String> getFieldNames() ,   {,     return _fields.keySet();,   },   ,   /** Set a field with implied null value for boost.,    * ,    * @see #setField(String, Object, float),    * @param name name of the field to set,    * @param value value of the field,    */,   public void setField(String name, Object value) ,   {,     setField(name, value, 1.0f );,   },   ,   public void setField(String name, Object value, float boost ) ,   {,     SolrInputField field = new SolrInputField( name );,     _fields.put( name, field );,     field.setValue( value, boost );,   }, ,   /**,    * Adds a field with the given name, value and boost.  If a field with the,    * name already exists, then the given value is appended to the value of that,    * field, with the new boost. If the value is a collection, then each of its,    * values will be added to the field.,    *,    * The class type of value and the name parameter should match schema.xml. ,    * schema.xml can be found in conf directory under the solr home by default.,    * ,    * @param name Name of the field, should match one of the field names defined under "fields" tag in schema.xml.,    * @param value Value of the field, should be of same class type as defined by "type" attribute of the corresponding field in schema.xml. ,    * @param boost Boost value for the field,    */,   public void addField(String name, Object value, float boost ) ,   {,     SolrInputField field = _fields.get( name );,     if( field == null || field.value == null ) {,       setField(name, value, boost);,     },     else {,       field.addValue( value, boost );,     },   }, ,   /**,    * Remove a field from the document,    * ,    * @param name The field name whose field is to be removed from the document,    * @return the previous field with <tt>name</tt>, or,    *         <tt>null</tt> if there was no field for <tt>key</tt>.,    */,   public SolrInputField removeField(String name) {,     return _fields.remove( name );,   }, ,   ///////////////////////////////////////////////////////////////////,   // Get the field values,   ///////////////////////////////////////////////////////////////////, ,   public SolrInputField getField( String field ),   {,     return _fields.get( field );,   }, ,   @Override,   public Iterator<SolrInputField> iterator() {,     return _fields.values().iterator();,   },   ,   public float getDocumentBoost() {,     return _documentBoost;,   }, ,   public void setDocumentBoost(float documentBoost) {,     _documentBoost = documentBoost;,   },   ,   @Override,   public String toString(),   {,     return "SolrInputDocument(fields: " + _fields.values(),         + ( _childDocuments == null ? "" : (", children: " + _childDocuments) ),         + ")";,   },   ,   public SolrInputDocument deepCopy() {,     SolrInputDocument clone = new SolrInputDocument();,     Set<Entry<String,SolrInputField>> entries = _fields.entrySet();,     for (Map.Entry<String,SolrInputField> fieldEntry : entries) {,       clone._fields.put(fieldEntry.getKey(), fieldEntry.getValue().deepCopy());,     },     clone._documentBoost = _documentBoost;, ,     if (_childDocuments != null) {,       clone._childDocuments = new ArrayList<>(_childDocuments.size());,       for (SolrInputDocument child : _childDocuments) {,         clone._childDocuments.add(child.deepCopy());,       },     },     ,     return clone;,   }, ,   //---------------------------------------------------,   // MAP interface,   //---------------------------------------------------, ,   @Override,   public boolean containsKey(Object key) {,     return _fields.containsKey(key);,   }, ,   @Override,   public boolean containsValue(Object value) {,     return _fields.containsValue(value);,   }, ,   @Override,   public Set<Entry<String, SolrInputField>> entrySet() {,     return _fields.entrySet();,   }, ,   @Override,   public SolrInputField get(Object key) {,     return _fields.get(key);,   }, ,   @Override,   public boolean isEmpty() {,     return _fields.isEmpty();,   }, ,   @Override,   public Set<String> keySet() {,     return _fields.keySet();,   }, ,   @Override,   public SolrInputField put(String key, SolrInputField value) {,     return _fields.put(key, value);,   }, ,   @Override,   public void putAll(Map<? extends String, ? extends SolrInputField> t) {,     _fields.putAll( t );,   }, ,   @Override,   public SolrInputField remove(Object key) {,     return _fields.remove(key);,   }, ,   @Override,   public int size() {,     return _fields.size();,   }, ,   @Override,   public Collection<SolrInputField> values() {,     return _fields.values();,   }, ,   public void addChildDocument(SolrInputDocument child) {,    if (_childDocuments == null) {,      _childDocuments = new ArrayList<>();,    },     _childDocuments.add(child);,   },   ,   public void addChildDocuments(Collection<SolrInputDocument> childs) {,     for (SolrInputDocument child : childs) {,       addChildDocument(child);,     },   }, ,   /** Returns the list of child documents, or null if none. */,   public List<SolrInputDocument> getChildDocuments() {,     return _childDocuments;,   },   ,   public boolean hasChildDocuments() {,     boolean isEmpty = (_childDocuments == null || _childDocuments.isEmpty());,     return !isEmpty;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/SolrInputField.java,,32-230,[  Object value = null; ,   float boost = 1.0f;,   ,   public SolrInputField( String n ),   {,     this.name = n;,   }, ,   //---------------------------------------------------------------,   //---------------------------------------------------------------, ,   /**,    * Set the value for a field.  Arrays will be converted to a collection. If,    * a collection is given, then that collection will be used as the backing,    * collection for the values.,    */,   public void setValue(Object v, float b) {,     boost = b;, ,     if( v instanceof Object[] ) {,       Object[] arr = (Object[])v;,       Collection<Object> c = new ArrayList<>( arr.length );,       for( Object o : arr ) {,         c.add( o );,       },       value = c;,     },     else {,       value = v;,     },   }, ,   /**,    * Add values to a field.  If the added value is a collection, each value,    * will be added individually.,    */,   @SuppressWarnings("unchecked"),   public void addValue(Object v, float b) {,     if( value == null ) {,       if ( v instanceof Collection ) {,         Collection<Object> c = new ArrayList<>( 3 );,         for ( Object o : (Collection<Object>)v ) {,           c.add( o );,         },         setValue(c, b);,       } else {,         setValue(v, b);,       }, ,       return;,     },     ,     // The lucene API and solr XML field specification make it possible to set boosts,     // on multi-value fields even though lucene indexing does not support this.,     // To keep behavior consistent with what happens in the lucene index, we accumulate,     // the product of all boosts specified for this field.,     boost *= b;,     ,     Collection<Object> vals = null;,     if( value instanceof Collection ) {,       vals = (Collection<Object>)value;,     },     else {,       vals = new ArrayList<>( 3 );,       vals.add( value );,       value = vals;,     },     ,     // Add the new values to a collection,     if( v instanceof Iterable ) {,       for( Object o : (Iterable<Object>)v ) {,         vals.add( o );,       },     },     else if( v instanceof Object[] ) {,       for( Object o : (Object[])v ) {,         vals.add( o );,       },     },     else {,       vals.add( v );,     },   }, ,   //---------------------------------------------------------------,   //---------------------------------------------------------------,   ,   @SuppressWarnings("unchecked"),   public Object getFirstValue() {,     if( value instanceof Collection ) {,       Collection c = (Collection<Object>)value;,       if( c.size() > 0 ) {,         return c.iterator().next();,       },       return null;,     },     return value;,   }, ,   /**,    * @return the value for this field.  If the field has multiple values, this,    * will be a collection.,    */,   public Object getValue() {,     return value;,   }, ,   /**,    * @return the values for this field.  This will return a collection even,    * if the field is not multi-valued,    */,   @SuppressWarnings("unchecked"),   public Collection<Object> getValues() {,     if( value instanceof Collection ) {,       return (Collection<Object>)value;,     },     if( value != null ) {,       Collection<Object> vals = new ArrayList<>(1);,       vals.add( value );,       return vals;,     },     return null;,   }, ,   /**,    * @return the number of values for this field,    */,   public int getValueCount() {,     if( value instanceof Collection ) {,       return ((Collection)value).size();,     },     return (value == null) ? 0 : 1;,   },   ,   //---------------------------------------------------------------,   //---------------------------------------------------------------,   ,   public float getBoost() {,     return boost;,   }, ,   public void setBoost(float boost) {,     this.boost = boost;,   }, ,   public String getName() {,     return name;,   }, ,   public void setName(String name) {,     this.name = name;,   }, ,   @Override,   @SuppressWarnings("unchecked"),   public Iterator<Object> iterator() {,     if( value instanceof Collection ) {,       return ((Collection)value).iterator();,     },     return new Iterator<Object>() {,       boolean nxt = (value!=null);,       ,       @Override,       public boolean hasNext() {,         return nxt;,       }, ,       @Override,       public Object next() {,         nxt = false;,         return value;,       }, ,       @Override,       public void remove() {,         throw new UnsupportedOperationException();,       },     };,   }, ,   @Override,   public String toString(),   {,     return name + ((boost == 1.0) ? "=" : ("("+boost+")=")) + value;,   }, ,   public SolrInputField deepCopy() {,     SolrInputField clone = new SolrInputField(name);,     clone.boost = boost;,     // We can't clone here, so we rely on simple primitives,     if (value instanceof Collection) {,       Collection<Object> values = (Collection<Object>) value;,       Collection<Object> cloneValues = new ArrayList<>(values.size());,       cloneValues.addAll(values);,       clone.value = cloneValues;,     } else {,       clone.value = value;,     },     return clone;],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/solr/common/SolrInputField.java,next,201-202,[        nxt = false;,         return value;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/common/cloud/CompositeIdRouter.java,partitionRange,143-143,[    long targetEnd = targetStart;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/solr/common/cloud/CompositeIdRouter.java,partitionRange,149-149,[    boolean round = rangeStep >= (1 << bits) * 16;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/common/cloud/CompositeIdRouter.java,,191-191,[      this.key = key;],,
MT_CORRECTNESS,DC_DOUBLECHECK,org/apache/solr/common/cloud/DefaultZkACLProvider.java,getACLsToAdd,32-34,[    if (globalACLsToAdd == null) {,       synchronized (this) {,         if (globalACLsToAdd == null) globalACLsToAdd = createGlobalACLsToAdd();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/common/cloud/DefaultZkACLProvider.java,,32-32,[    if (globalACLsToAdd == null) {],,,37-37,[    return globalACLsToAdd;],,,34-34,[        if (globalACLsToAdd == null) globalACLsToAdd = createGlobalACLsToAdd();],,
MT_CORRECTNESS,DC_DOUBLECHECK,org/apache/solr/common/cloud/DefaultZkCredentialsProvider.java,getCredentials,29-31,[    if (zkCredentials == null) {,       synchronized (this) {,         if (zkCredentials == null) zkCredentials = createCredentials();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/common/cloud/DefaultZkCredentialsProvider.java,,29-29,[    if (zkCredentials == null) {],,,34-34,[    return zkCredentials;],,,31-31,[        if (zkCredentials == null) zkCredentials = createCredentials();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/solr/common/cloud/DocCollection.java,getZNodeVersion,147-147,[    return znodeVersion;],,getZnodeVersion,478-478,[    return zkVersion;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/solr/common/cloud/DocCollection.java,<init>,86-86,[    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();],,<init>,95-95,[    assert name != null && slices != null;],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_COMPARE,org/apache/solr/common/cloud/DocRouter.java,compareTo,147-147,[      int mincomp = Integer.valueOf(this.min).compareTo(that.min);],,compareTo,148-148,[      return mincomp == 0 ? Integer.valueOf(this.max).compareTo(that.max) : mincomp;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/common/cloud/DocRouter.java,equals,135-137,[      if (obj.getClass() != getClass()) return false;,       Range other = (Range)obj;,       return this.min == other.min && this.max == other.max;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/common/cloud/HashBasedRouter.java,getTargetSlice,74-74,[    return slice == null ? Collections.<Slice>emptyList() : Collections.singletonList(slice);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/common/cloud/RoutingRule.java,<init>,39-39,[    if (rangesArr != null && rangesArr.length > 0)  {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,36-36,[  public static String ACTIVE = "active";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,38-38,[  public static String CONSTRUCTION = "construction";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,37-37,[  public static String INACTIVE = "inactive";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,35-35,[  public static String LEADER = "leader";       // FUTURE: do we want to record the leader as a slice property in the JSON (as opposed to isLeader as a replica property?)],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,40-40,[  public static String PARENT = "parent";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,33-33,[  public static String RANGE = "range";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,39-39,[  public static String RECOVERY = "recovery";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,32-32,[  public static String REPLICAS = "replicas";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/cloud/Slice.java,,34-34,[  public static String STATE = "state";],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/common/cloud/Slice.java,,87-87,[    replicationFactor = null;  // future],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/common/cloud/SolrZkClient.java,prettyPrint,629-629,[    } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/common/cloud/SolrZkClient.java,process,264-264,[        zkCallbackExecutor.submit(new Runnable () {],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/solr/common/cloud/SolrZooKeeper.java,run,62-62,[              sendThreadFld.setAccessible(true);],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/solr/common/cloud/SolrZooKeeper.java,run,66-66,[                method.setAccessible(true);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/common/cloud/SolrZooKeeper.java,run,73-73,[            } catch (Exception e) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/common/cloud/ZkCredentialsProvider.java,<init>,31-31,[      this.auth = auth;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/common/cloud/ZkStateReader.java,,253-253,[    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);],,,819-819,[      cmdExecutor.ensureExists(fullpath, zkClient);],,,296-296,[      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);],,,297-297,[      cmdExecutor.ensureExists(ALIASES, zkClient);],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/solr/common/cloud/ZkStateReader.java,checkValid,272-272,[    if (collection == null) return null;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/common/cloud/ZkStateReader.java,getClusterProps,746-746,[    } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/common/cloud/ZkStateReader.java,,617-619,[    public RunnableWatcher(Watcher watcher){,       this.watcher = watcher;,     }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/common/cloud/ZkStateReader.java,,618-618,[      this.watcher = watcher;],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/solr/common/luke/FieldFlag.java,<init>,48-48,[    this.display.intern();//QUESTION:  Need we bother here?],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/params/AppendedSolrParams.java,,32-53,[    super(main, extra);,   }, ,   @Override,   public String[] getParams(String param) {,     String[] main = params.getParams(param);,     String[] extra = defaults.getParams(param);,     if (null == extra || 0 == extra.length) {,       return main;,     },     if (null == main || 0 == main.length) {,       return extra;,     },     String[] result = new String[main.length + extra.length];,     System.arraycopy(main,0,result,0,main.length);,     System.arraycopy(extra,0,result,main.length,extra.length);,     return result;,   }, ,   @Override,   public String toString() {,     return "{main("+params+"),extra("+defaults+")}";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/params/DefaultSolrParams.java,,26-69,[public class DefaultSolrParams extends SolrParams {,   protected final SolrParams params;,   protected final SolrParams defaults;, ,   /**,    * @deprecated (3.6) Use {@link SolrParams#wrapDefaults(SolrParams, SolrParams)} instead.,    */,   @Deprecated,   public DefaultSolrParams(SolrParams params, SolrParams defaults) {,     assert params != null && defaults != null;,     this.params = params;,     this.defaults = defaults;,   }, ,   @Override,   public String get(String param) {,     String val = params.get(param);,     return val!=null ? val : defaults.get(param);,   }, ,   @Override,   public String[] getParams(String param) {,     String[] vals = params.getParams(param);,     return vals!=null ? vals : defaults.getParams(param);,   }, ,   @Override,   public Iterator<String> getParameterNamesIterator() {,     // We need to compute the set of all param names in advance ,     // So we don't wind up with an iterator that returns the same,     // String more then once (SOLR-6780),     LinkedHashSet<String> allKeys = new LinkedHashSet<>();,     for (SolrParams p : new SolrParams [] {params, defaults}) {,       Iterator<String> localKeys = p.getParameterNamesIterator();,       while (localKeys.hasNext()) {,         allKeys.add(localKeys.next());,       },     },     return allKeys.iterator();,   }, ,   @Override,   public String toString() {,     return "{params("+params+"),defaults("+defaults+")}";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/params/MapSolrParams.java,,32-73,[  public MapSolrParams(Map<String,String> map) {,     this.map = map;,   }, ,   @Override,   public String get(String name) {,     return map.get(name);,   }, ,   @Override,   public String[] getParams(String name) {,     String val = map.get(name);,     return val==null ? null : new String[]{val};,   }, ,   @Override,   public Iterator<String> getParameterNamesIterator() {,     return map.keySet().iterator();,   }, ,   public Map<String,String> getMap() { return map; }, ,   @Override,   public String toString() {,     StringBuilder sb = new StringBuilder(128);,     try {,       boolean first=true;, ,       for (Map.Entry<String,String> entry : map.entrySet()) {,         String key = entry.getKey();,         String val = entry.getValue();, ,         if (!first) sb.append('&');,         first=false;,         sb.append(key);,         sb.append('=');,         StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);,       },     },     catch (IOException e) {throw new RuntimeException(e);}  // can't happen, ,     return sb.toString();],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/solr/common/params/ModifiableSolrParams.java,remove,147-147,[           tmp2 = null;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/params/ModifiableSolrParams.java,,40-208,[  {,     // LinkedHashMap so params show up in CGI in the same order as they are entered,     vals = new LinkedHashMap<>();,   }, ,   /** Constructs a new ModifiableSolrParams directly using the provided Map&lt;String,String[]&gt; */,   public ModifiableSolrParams( Map<String,String[]> v ),   {,     vals = v;,   }, ,   /** Constructs a new ModifiableSolrParams, copying values from an existing SolrParams */,   public ModifiableSolrParams(SolrParams params),   {,     vals = new LinkedHashMap<>();,     if( params != null ) {,       this.add( params );,     },   }, ,   //----------------------------------------------------------------,   //----------------------------------------------------------------, ,   /**,    * Replace any existing parameter with the given name.  if val==null remove key from params completely.,    */,   public ModifiableSolrParams set( String name, String ... val ) {,     if (val==null || (val.length==1 && val[0]==null)) {,       vals.remove(name);,     } else {,       vals.put( name, val );,     },     return this;,   },   ,   public ModifiableSolrParams set( String name, int val ) {,     set( name, String.valueOf(val) );,     return this;,   },   ,   public ModifiableSolrParams set( String name, boolean val ) {,     set( name, String.valueOf(val) );,     return this;,   }, ,   /**,    * Add the given values to any existing name,    * @param name Key,    * @param val Array of value(s) added to the name. NOTE: If val is null ,    *     or a member of val is null, then a corresponding null reference ,    *     will be included when a get method is called on the key later.,    *  @return this,    */,   public ModifiableSolrParams add( String name, String ... val ) {,     String[] old = vals.put(name, val);,     if( old != null ) {,       if( val == null || val.length < 1 ) {,         String[] both = new String[old.length+1];,         System.arraycopy(old, 0, both, 0, old.length);,         both[old.length] = null;,         vals.put( name, both );,       },       else {,         String[] both = new String[old.length+val.length];,         System.arraycopy(old, 0, both, 0, old.length);,         System.arraycopy(val, 0, both, old.length, val.length);,         vals.put( name, both );,       },     },     return this;,   }, ,   public void add(SolrParams params),   {,     Iterator<String> names = params.getParameterNamesIterator();,     while (names.hasNext()) {,       String name = names.next();,       set(name, params.getParams(name));,     },   },   ,   /**,    * remove a field at the given name,    */,   public String[] remove( String name ),   {,     return vals.remove( name );,   },   ,   /** clear all parameters */,   public void clear(),   {,     vals.clear();,   },   ,   /** ,    * remove the given value for the given name,    * ,    * @return true if the item was removed, false if null or not present,    */,   public boolean remove(String name, String value) {,      String[] tmp = vals.get(name);,      if (tmp==null) return false;,      for (int i=0; i<tmp.length; i++) {,        if (tmp[i].equals(value)) {,          String[] tmp2 = new String[tmp.length-1];,          if (tmp2.length==0) {,            tmp2 = null;,            remove(name);,          } else {,            System.arraycopy(tmp, 0, tmp2, 0, i);,            System.arraycopy(tmp, i+1, tmp2, i, tmp.length-i-1);,            set(name, tmp2);,          },          return true;,        },      },      return false;,   }, ,   //----------------------------------------------------------------,   //----------------------------------------------------------------, ,   @Override,   public String get(String param) {,     String[] v = vals.get( param );,     if( v!= null && v.length > 0 ) {,       return v[0];,     },     return null;,   }, ,   @Override,   public Iterator<String> getParameterNamesIterator() {,     return vals.keySet().iterator();,   },   ,   public Set<String> getParameterNames() {,     return vals.keySet();,   }, ,   @Override,   public String[] getParams(String param) {,     return vals.get( param );,   }, ,   @Override,   public String toString() {,     StringBuilder sb = new StringBuilder(128);,     try {,       boolean first=true;, ,       for (Map.Entry<String,String[]> entry : vals.entrySet()) {,         String key = entry.getKey();,         String[] valarr = entry.getValue();,         for (String val : valarr) {,           if (!first) sb.append('&');,           first=false;,           sb.append(key);,           sb.append('=');,           if( val != null ) {,             sb.append( URLEncoder.encode( val, "UTF-8" ) );,           },         },       },     },     catch (IOException e) {throw new RuntimeException(e);}  // can't happen, ,     return sb.toString();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/params/MultiMapSolrParams.java,,33-88,[      String[] arr = map.get(name);,       if (arr ==null) {,         arr =new String[]{val};,       } else {,         String[] newarr = new String[arr.length+1];,         System.arraycopy(arr,0,newarr,0,arr.length);,         newarr[arr.length]=val;,         arr =newarr;,       },       map.put(name, arr);,   }, ,   public MultiMapSolrParams(Map<String,String[]> map) {,     this.map = map;,   }, ,   @Override,   public String get(String name) {,     String[] arr = map.get(name);,     return arr==null ? null : arr[0];,   }, ,   @Override,   public String[] getParams(String name) {,     return map.get(name);,   }, ,   @Override,   public Iterator<String> getParameterNamesIterator() {,     return map.keySet().iterator();,   }, ,   public Map<String,String[]> getMap() { return map; }, ,   @Override,   public String toString() {,     StringBuilder sb = new StringBuilder(128);,     try {,       boolean first=true;, ,       for (Map.Entry<String,String[]> entry : map.entrySet()) {,         String key = entry.getKey();,         String[] valarr = entry.getValue();, ,         for (String val : valarr) {,           if (!first) sb.append('&');,           first=false;,           sb.append(key);,           sb.append('=');,           StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);,         },       },     },     catch (IOException e) {throw new RuntimeException(e);}  // can't happen, ,     return sb.toString();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/params/RequiredSolrParams.java,,40-154,[  public RequiredSolrParams(SolrParams params) {,     this.params = params;,   }, ,   /** get the param from params, fail if not found **/,   @Override,   public String get(String param) {,     String val = params.get(param);,     if( val == null )  {,       throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );,     },     return val;,   },   ,   @Override,   public String getFieldParam(final String field, final String param) {,     final String fpname = fpname(field,param);,     String val = params.get(fpname);,     if (null == val) {,       // don't call this.get, we want a specified exception message,       val = params.get(param);,       if (null == val)  {,         throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,,                                  "Missing required parameter: "+fpname+,                                  " (or default: "+param+")" );,       },     },     return val;,   }, ,   @Override,   public String[] getFieldParams(final String field, final String param) {,     final String fpname = fpname(field,param);,     String[] val = params.getParams(fpname);,     if (null == val) {,       // don't call this.getParams, we want a specified exception message,       val = params.getParams(param);,       if (null == val)  {,         throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,,                                  "Missing required parameter: "+fpname+,                                  " (or default: "+param+")" );,       },     },     return val;,   }, ,   ,   @Override,   public String[] getParams(String param) {,     String[] vals = params.getParams(param);,     if( vals == null || vals.length == 0 ) {,       throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );,     },     return vals;,   },   ,   /** returns an Iterator over the parameter names */,   @Override,   public Iterator<String> getParameterNamesIterator() {,     return params.getParameterNamesIterator();,   }, ,   @Override,   public String toString() {,     return "{required("+params+")}";  ,   }    , ,   //----------------------------------------------------------,   // Functions with a default value - pass directly to the,   // wrapped SolrParams (they won't return null - unless it's the default),   //----------------------------------------------------------, ,   @Override,   public String get(String param, String def) {,     return params.get(param, def);,   }, ,   @Override,   public int getInt(String param, int def) {,     return params.getInt(param, def);,   }, ,   @Override,   public float getFloat(String param, float def) {,     return params.getFloat(param, def);,   },   ,   @Override,   public boolean getBool(String param, boolean def) {,     return params.getBool(param, def);,   }, ,   @Override,   public int getFieldInt(String field, String param, int def) {,     return params.getFieldInt(field, param, def);,   },   ,   @Override,   public boolean getFieldBool(String field, String param, boolean def) {,     return params.getFieldBool(field, param, def);,   }, ,   @Override,   public float getFieldFloat(String field, String param, float def) {,     return params.getFieldFloat(field, param, def);,   }, ,   @Override,   public String getFieldParam(String field, String param, String def) {,     return params.getFieldParam(field, param, def);,   }, ,   public void check(String... params){,     for (String param : params) get(param);,   }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/common/util/ContentStreamBase.java,<init>,250-250,[      size = new Long(bytes.length);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/common/util/ContentStreamBase.java,<init>,246-246,[      this.bytes = bytes; ],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/common/util/ContentStreamBase.java,getContentType,120-120,[        } catch(Exception ex) {],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/common/util/ContentStreamBase.java,<init>,149-149,[      size = new Long( str.length() );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/common/util/ContentStreamBase.java,getStream,86-86,[      size = new Long( conn.getContentLength() );],,
MALICIOUS_CODE,MS_MUTABLE_COLLECTION,org/apache/solr/common/util/DateUtil.java,,74-74,[  public static final Collection<String> DEFAULT_DATE_FORMATS = new ArrayList<>();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/util/DateUtil.java,,178-178,[  public static TimeZone UTC = TimeZone.getTimeZone("UTC");],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/common/util/ExecutorUtil.java,,28-28,[  public static Logger log = LoggerFactory.getLogger(ExecutorUtil.class);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/common/util/FastInputStream.java,<init>,40-40,[    this.buf = tempBuffer;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/common/util/FastInputStream.java,readUTF,251-251,[    return new DataInputStream(this).readUTF();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/common/util/FastOutputStream.java,<init>,39-39,[    this.buf = tempBuffer;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/common/util/FastOutputStream.java,writeUTF,184-184,[    DataOutputStream daos = new DataOutputStream(this);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,94-94,[        b ^= a; b -= (a<<25)|(a>>>-25);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,98-98,[        c ^= b; c -= (b<<24)|(b>>>-24);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,78-78,[        b -= a;  b ^= (a<<19)|(a>>>-19); a += c;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,95-95,[        c ^= b; c -= (b<<16)|(b>>>-16);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,77-77,[        a -= c;  a ^= (c<<16)|(c>>>-16); c += b;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,97-97,[        b ^= a; b -= (a<<14)|(a>>>-14);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,92-92,[        c ^= b; c -= (b<<14)|(b>>>-14);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,93-93,[        a ^= c; a -= (c<<11)|(c>>>-11);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,76-76,[        c -= b;  c ^= (b<<8)|(b>>>-8);   b += a;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,75-75,[        b -= a;  b ^= (a<<6)|(a>>>-6);   a += c;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,79-79,[        c -= b;  c ^= (b<<4)|(b>>>-4);   b += a;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3,74-74,[        a -= c;  a ^= (c<<4)|(c>>>-4);   c += b;],,lookup3,96-96,[        a ^= c; a -= (c<<4)|(c>>>-4);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,169-169,[        b ^= a; b -= (a<<25)|(a>>>-25);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,173-173,[        c ^= b; c -= (b<<24)|(b>>>-24);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,158-158,[        b -= a;  b ^= (a<<19)|(a>>>-19); a += c;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,170-170,[        c ^= b; c -= (b<<16)|(b>>>-16);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,157-157,[        a -= c;  a ^= (c<<16)|(c>>>-16); c += b;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,172-172,[        b ^= a; b -= (a<<14)|(a>>>-14);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,167-167,[        c ^= b; c -= (b<<14)|(b>>>-14);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,168-168,[        a ^= c; a -= (c<<11)|(c>>>-11);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,156-156,[        c -= b;  c ^= (b<<8)|(b>>>-8);   b += a;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,155-155,[        b -= a;  b ^= (a<<6)|(a>>>-6);   a += c;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,159-159,[        c -= b;  c ^= (b<<4)|(b>>>-4);   b += a;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs,154-154,[        a -= c;  a ^= (c<<4)|(c>>>-4);   c += b;],,lookup3ycs,171-171,[        a ^= c; a -= (c<<4)|(c>>>-4);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,229-229,[        b ^= a; b -= (a<<25)|(a>>>-25);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,233-233,[        c ^= b; c -= (b<<24)|(b>>>-24);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,218-218,[        b -= a;  b ^= (a<<19)|(a>>>-19); a += c;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,230-230,[        c ^= b; c -= (b<<16)|(b>>>-16);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,217-217,[        a -= c;  a ^= (c<<16)|(c>>>-16); c += b;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,232-232,[        b ^= a; b -= (a<<14)|(a>>>-14);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,227-227,[        c ^= b; c -= (b<<14)|(b>>>-14);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,228-228,[        a ^= c; a -= (c<<11)|(c>>>-11);],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,216-216,[        c -= b;  c ^= (b<<8)|(b>>>-8);   b += a;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,215-215,[        b -= a;  b ^= (a<<6)|(a>>>-6);   a += c;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,219-219,[        c -= b;  c ^= (b<<4)|(b>>>-4);   b += a;],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/solr/common/util/Hash.java,lookup3ycs64,214-214,[        a -= c;  a ^= (c<<4)|(c>>>-4);   c += b;],,lookup3ycs64,231-231,[        a ^= c; a -= (c<<4)|(c>>>-4);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/solr/common/util/Hash.java,lookup3,87-88,[      case 3 : c+=k[i+2];  // fall through,       case 2 : b+=k[i+1];  // fall through],,lookup3,88-89,[      case 2 : b+=k[i+1];  // fall through,       case 1 : a+=k[i+0];  // fall through],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/solr/common/util/Hash.java,murmurhash3_x86_32,268-271,[        k1 = (data[roundedEnd + 2] & 0xff) << 16;,         // fallthrough,       case 2:,         k1 |= (data[roundedEnd + 1] & 0xff) << 8;],,murmurhash3_x86_32,271-274,[        k1 |= (data[roundedEnd + 1] & 0xff) << 8;,         // fallthrough,       case 1:,         k1 |= (data[roundedEnd] & 0xff);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/common/util/Hash.java,lookup3,86-98,[    switch(length) {,       case 3 : c+=k[i+2];  // fall through,       case 2 : b+=k[i+1];  // fall through,       case 1 : a+=k[i+0];  // fall through,         // final(a,b,c);,       {,         c ^= b; c -= (b<<14)|(b>>>-14);,         a ^= c; a -= (c<<11)|(c>>>-11);,         b ^= a; b -= (a<<25)|(a>>>-25);,         c ^= b; c -= (b<<16)|(b>>>-16);,         a ^= c; a -= (c<<4)|(c>>>-4);,         b ^= a; b -= (a<<14)|(a>>>-14);,         c ^= b; c -= (b<<24)|(b>>>-24);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/common/util/Hash.java,murmurhash3_x86_32,266-278,[    switch(len & 0x03) {,       case 3:,         k1 = (data[roundedEnd + 2] & 0xff) << 16;,         // fallthrough,       case 2:,         k1 |= (data[roundedEnd + 1] & 0xff) << 8;,         // fallthrough,       case 1:,         k1 |= (data[roundedEnd] & 0xff);,         k1 *= c1;,         k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);,         k1 *= c2;,         h1 ^= k1;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/common/util/IteratorChain.java,recursiveHasNext,53-53,[      if(itit.hasNext()) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/common/util/JavaBinCodec.java,writeVal,156-156,[      Object tmpVal = val;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/common/util/JavaBinCodec.java,readExternString,805-805,[      return stringsList.get(idx - 1);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/common/util/JavaBinCodec.java,,528-567,[    return new Map.Entry<Object,Object>() {, ,       @Override,       public Object getKey() {,         return key;,       }, ,       @Override,       public Object getValue() {,         return value;,       }, ,       @Override,       public String toString() {,         return "MapEntry[" + key.toString() + ":" + value.toString() + "]";,       }, ,       @Override,       public Object setValue(Object value) {,         throw new UnsupportedOperationException();,       }, ,       @Override,       public int hashCode() {,         int result = 31;,         result *=31 + getKey().hashCode();,         result *=31 + getValue().hashCode();,         return result;,       }, ,       @Override,       public boolean equals(Object obj) {,         if(this == obj) {,           return true;,         },         if(!(obj instanceof Entry)) {,           return false;,         },         Map.Entry<Object, Object> entry = (Entry<Object, Object>) obj;,         return (this.getKey().equals(entry.getKey()) && this.getValue().equals(entry.getValue()));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/common/util/JsonRecordReader.java,,115-119,[    streamRecords(r, new Handler() {,       @Override,       public void handle(Map<String, Object> record, String path) {,         results.add(record);,       }],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/solr/common/util/NamedList.java,clone,478-480,[    ArrayList<Object> newList = new ArrayList<>(nvPairs.size());,     newList.addAll(nvPairs);,     return new NamedList<>(newList);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/common/util/NamedList.java,removeAll,561-561,[    List<T> result = new ArrayList<>();],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/solr/common/util/NamedList.java,getAll,285-285,[      if (name==n || (name!=null && name.equals(n))) {],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/solr/common/util/NamedList.java,killAll,302-302,[      if (name==n || (name!=null && name.equals(n))) {],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/solr/common/util/NamedList.java,getBooleanArg,615-615,[      return null;],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/solr/common/util/NamedList.java,next,506-528,[        final int index = idx++;,         Map.Entry<String,T> nv = new Map.Entry<String,T>() {,           @Override,           public String getKey() {,             return list.getName( index );,           }, ,           @Override,           public T getValue() {,             return list.getVal( index );,           }, ,           @Override,           public String toString() {,             return getKey()+"="+getValue();,           }, ,           @Override,           public T setValue(T value) {,             return list.setVal(index, value);,           },         };,         return nv;],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/solr/common/util/SimpleOrderedMap.java,clone,63-65,[    ArrayList<Object> newList = new ArrayList<>(nvPairs.size());,     newList.addAll(nvPairs);,     return new SimpleOrderedMap<>(newList);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/common/util/SimpleOrderedMap.java,,40-65,[public class SimpleOrderedMap<T> extends NamedList<T> {,   /** Creates an empty instance */,   public SimpleOrderedMap() {,     super();,   }, ,   /**,    * Creates an instance backed by an explicitly specified list of,    * pairwise names/values.,    *,    * @param nameValuePairs underlying List which should be used to implement a SimpleOrderedMap; modifying this List will affect the SimpleOrderedMap.,    */,   @Deprecated,   public SimpleOrderedMap(List<Object> nameValuePairs) {,     super(nameValuePairs);,   },   ,   public SimpleOrderedMap(Map.Entry<String, T>[] nameValuePairs) { ,     super(nameValuePairs);,   }, ,   @Override,   public SimpleOrderedMap<T> clone() {,     ArrayList<Object> newList = new ArrayList<>(nvPairs.size());,     newList.addAll(nvPairs);,     return new SimpleOrderedMap<>(newList);],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/solr/common/util/StrUtils.java,,32-32,[  public static final char[] HEX_DIGITS = { '0', '1', '2', '3', '4', '5', '6',],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/common/util/StrUtils.java,splitSmart,107-112,[          switch(ch) {,             case 'n' : ch='\n'; break;,             case 't' : ch='\t'; break;,             case 'r' : ch='\r'; break;,             case 'b' : ch='\b'; break;,             case 'f' : ch='\f'; break;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/common/util/StrUtils.java,splitWS,186-191,[          switch(ch) {,             case 'n' : ch='\n'; break;,             case 't' : ch='\t'; break;,             case 'r' : ch='\r'; break;,             case 'b' : ch='\b'; break;,             case 'f' : ch='\f'; break;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/core/CachingDirectoryFactory.java,exists,325-325,[    return dirFile.canRead() && dirFile.list().length > 0;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/CachingDirectoryFactory.java,close,192-192,[        } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/core/CachingDirectoryFactory.java,,61-94,[  protected class CacheValue {,     final public String path;,     final public Directory directory;,     // for debug,     //final Exception originTrace;,     // use the setter!,     private boolean deleteOnClose = false;,     ,     public CacheValue(String path, Directory directory) {,       this.path = path;,       this.directory = directory;,       this.closeEntries.add(this);,       // for debug,       // this.originTrace = new RuntimeException("Originated from:");,     },     public int refCnt = 1;,     // has doneWithDirectory(Directory) been called on this?,     public boolean closeCacheValueCalled = false;,     public boolean doneWithDir = false;,     private boolean deleteAfterCoreClose = false;,     public Set<CacheValue> removeEntries = new HashSet<>();,     public Set<CacheValue> closeEntries = new HashSet<>();, ,     public void setDeleteOnClose(boolean deleteOnClose, boolean deleteAfterCoreClose) {,       if (deleteOnClose) {,         removeEntries.add(this);,       },       this.deleteOnClose = deleteOnClose;,       this.deleteAfterCoreClose = deleteAfterCoreClose;,     },     ,     @Override,     public String toString() {,       return "CachedDir<<" + "refCount=" + refCnt + ";path=" + path + ";done=" + doneWithDir + ">>";],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/core/CoreContainer.java,,917-917,[    this.cfg = cfg;],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/solr/core/CoreContainer.java,run,929-929,[          solrCores.getModifyLock().wait();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/ConfigSetService.java,,194-198,[          return schemaCache.get(cacheName(schemaFile), new Callable<IndexSchema>() {,             @Override,             public IndexSchema call() throws Exception {,               logger.info("Creating new index schema for core {}", cd.getName());,               return IndexSchemaFactory.buildIndexSchema(cd.getSchemaName(), solrConfig);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/ConfigSolr.java,,47-47,[  protected static Logger log = LoggerFactory.getLogger(ConfigSolr.class);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/core/ConfigSolrXml.java,fillPropMap,114-114,[    NamedList<Object> unknownConfigParams = new NamedList<>();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/ConfigSolrXml.java,,45-45,[  protected static Logger log = LoggerFactory.getLogger(ConfigSolrXml.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/ConfigSolrXmlOld.java,,48-48,[  protected static Logger log = LoggerFactory.getLogger(ConfigSolrXmlOld.class);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/core/CoreContainer.java,unload,687-687,[    String configSetZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getConfigSetZkPath() : null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/CoreContainer.java,getCores,298-298,[      if (cores != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/CoreContainer.java,reload,608-608,[    catch (Exception e) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/CoreDescriptor.java,,95-95,[  public static ImmutableList<String> standardPropNames = ImmutableList.of(],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/core/CoreDescriptor.java,loadExtraProperties,230-230,[        externalProps.load(new InputStreamReader(in, StandardCharsets.UTF_8));],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/core/CorePropertiesLocator.java,discoverUnder,132-132,[    for (File child : root.listFiles()) {],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/core/CorePropertiesLocator.java,buildCoreDescriptor,155-155,[      coreProperties.load(new InputStreamReader(fis, StandardCharsets.UTF_8));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/core/CorePropertiesLocator.java,delete,102-102,[      propertiesFile.renameTo(new File(instanceDir, PROPERTIES_FILENAME + ".unloaded"));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/core/CorePropertiesLocator.java,writePropertiesFile,81-81,[      propfile.getParentFile().mkdirs();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/Diagnostics.java,,27-27,[  protected static Logger log = LoggerFactory.getLogger(Diagnostics.class);],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/solr/core/HdfsDirectoryFactory.java,initKerberos,337-337,[        kerberosInit = new Boolean(true);],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/solr/core/HdfsDirectoryFactory.java,create,131-132,[    if (metrics == null) {,       metrics = new Metrics(conf);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/HdfsDirectoryFactory.java,,56-56,[      .getLogger(HdfsDirectoryFactory.class);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/HdfsDirectoryFactory.java,removeDirectory,263-263,[    } catch (Exception e) {],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/solr/core/IndexDeletionPolicyWrapper.java,clone,259-259,[    return this;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/JarRepository.java,,50-50,[  public static Logger log = LoggerFactory.getLogger(JarRepository.class);],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/solr/core/JmxMonitoredMap.java,put,158-158,[    return super.put(key, infoBean);],,put,146-146,[    if (server != null && infoBean != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/JmxMonitoredMap.java,<init>,79-79,[      } else if (jmxConfig.agentId != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/JmxMonitoredMap.java,<init>,83-83,[        if (servers == null || servers.isEmpty())],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/JmxMonitoredMap.java,<init>,88-88,[      if (servers == null || servers.isEmpty()) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/JmxMonitoredMap.java,<init>,104-104,[      } catch (Exception e) {],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/core/JmxMonitoredMap.java,,51-207,[public class JmxMonitoredMap<K, V> extends,         ConcurrentHashMap<String, SolrInfoMBean> {,   private static final Logger LOG = LoggerFactory.getLogger(JmxMonitoredMap.class,           .getName());, ,   // set to true to use cached statistics NamedLists between getMBeanInfo calls to work,   // around over calling getStatistics on MBeanInfos when iterating over all attributes (SOLR-6586),   private boolean useCachedStatsBetweenGetMBeanInfoCalls = Boolean.getBoolean("useCachedStatsBetweenGetMBeanInfoCalls");,   ,   private MBeanServer server = null;, ,   private String jmxRootName;, ,   private String coreHashCode;, ,   public JmxMonitoredMap(String coreName, String coreHashCode,,                          final JmxConfiguration jmxConfig) {,     this.coreHashCode = coreHashCode;,     jmxRootName = (null != jmxConfig.rootName ?,                    jmxConfig.rootName,                    : ("solr" + (null != coreName ? "/" + coreName : "")));,       ,     if (jmxConfig.serviceUrl == null) {,       List<MBeanServer> servers = null;, ,       if (jmxConfig.agentId == null) {,         // Try to find the first MBeanServer,         servers = MBeanServerFactory.findMBeanServer(null);,       } else if (jmxConfig.agentId != null) {,         // Try to find the first MBean server with the given agentId,         servers = MBeanServerFactory.findMBeanServer(jmxConfig.agentId);,         // throw Exception if no servers were found with the given agentId,         if (servers == null || servers.isEmpty()),           throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,,                   "No JMX Servers found with agentId: " + jmxConfig.agentId);,       }, ,       if (servers == null || servers.isEmpty()) {,         LOG.info("No JMX servers found, not exposing Solr information with JMX.");,         return;,       },       server = servers.get(0);,       LOG.info("JMX monitoring is enabled. Adding Solr mbeans to JMX Server: ",                + server);,     } else {,       try {,         // Create a new MBeanServer with the given serviceUrl,         server = MBeanServerFactory.newMBeanServer();,         JMXConnectorServer connector = JMXConnectorServerFactory,                 .newJMXConnectorServer(new JMXServiceURL(jmxConfig.serviceUrl),,                         null, server);,         connector.start();,         LOG.info("JMX monitoring is enabled at " + jmxConfig.serviceUrl);,       } catch (Exception e) {,         // Release the reference,         server = null;,         throw new RuntimeException("Could not start JMX monitoring ", e);,       },     },   }, ,   /**,    * Clears the map and unregisters all SolrInfoMBeans in the map from,    * MBeanServer,    */,   @Override,   public void clear() {,     if (server != null) {,       QueryExp exp = Query.eq(Query.attr("coreHashCode"), Query.value(coreHashCode));,       Set<ObjectName> objectNames = server.queryNames(null, exp);,       if (objectNames != null)  {,         for (ObjectName name : objectNames) {,           try {,             server.unregisterMBean(name);,           } catch (Exception e) {,             LOG.error("Exception un-registering mbean {}", name, e);,           },         },       },     }, ,     super.clear();,   }, ,   /**,    * Adds the SolrInfoMBean to the map and registers the given SolrInfoMBean,    * instance with the MBeanServer defined for this core. If a SolrInfoMBean is,    * already registered with the MBeanServer then it is unregistered and then,    * re-registered.,    *,    * @param key      the JMX type name for this SolrInfoMBean,    * @param infoBean the SolrInfoMBean instance to be registered,    */,   @Override,   public SolrInfoMBean put(String key, SolrInfoMBean infoBean) {,     if (server != null && infoBean != null) {,       try {,         ObjectName name = getObjectName(key, infoBean);,         if (server.isRegistered(name)),           server.unregisterMBean(name);,         SolrDynamicMBean mbean = new SolrDynamicMBean(coreHashCode, infoBean, useCachedStatsBetweenGetMBeanInfoCalls);,         server.registerMBean(mbean, name);,       } catch (Exception e) {,         LOG.warn( "Failed to register info bean: " + key, e);,       },     }, ,     return super.put(key, infoBean);,   }, ,   /**,    * Removes the SolrInfoMBean object at the given key and unregisters it from,    * MBeanServer,    *,    * @param key the JMX type name for this SolrInfoMBean,    */,   @Override,   public SolrInfoMBean remove(Object key) {,     SolrInfoMBean infoBean = get(key);,     if (infoBean != null) {,       try {,         unregister((String) key, infoBean);,       } catch (RuntimeException e) {,         LOG.warn( "Failed to unregister info bean: " + key, e);,       },     },     return super.remove(key);,   }, ,   private void unregister(String key, SolrInfoMBean infoBean) {,     if (server == null),       return;, ,     try {,       ObjectName name = getObjectName(key, infoBean);,       if (server.isRegistered(name) && coreHashCode.equals(server.getAttribute(name, "coreHashCode"))) {,         server.unregisterMBean(name);,       },     } catch (Exception e) {,       throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,,               "Failed to unregister info bean: " + key, e);,     },   }, ,   private ObjectName getObjectName(String key, SolrInfoMBean infoBean),           throws MalformedObjectNameException {,     Hashtable<String, String> map = new Hashtable<>();,     map.put("type", key);,     if (infoBean.getName() != null && !"".equals(infoBean.getName())) {,       map.put("id", infoBean.getName());,     },     return ObjectName.getInstance(jmxRootName, map);,   }, ,   /** For test verification */,   public MBeanServer getServer() {,     return server;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/JmxMonitoredMap.java,getAttribute,320-320,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/JmxMonitoredMap.java,determineType,301-301,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/JmxMonitoredMap.java,getAttributes,357-357,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/QuerySenderListener.java,newSearcher,83-83,[      } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/QuerySenderListener.java,,57-59,[        req = new LocalSolrQueryRequest(getCore(),params) {,           @Override public SolrIndexSearcher getSearcher() { return searcher; },           @Override public void close() { }],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/RAMDirectoryFactory.java,,36-36,[  public static Logger LOG = LoggerFactory.getLogger(RAMDirectoryFactory.class);],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/solr/core/RequestHandlers.java,register,126-126,[    if (0 != norm.length() && handler instanceof SolrInfoMBean) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/RequestHandlers.java,,61-61,[  public static Logger log = LoggerFactory.getLogger(RequestHandlers.class);],,
CORRECTNESS,SIO_SUPERFLUOUS_INSTANCEOF,org/apache/solr/core/RequestHandlers.java,register,126-126,[    if (0 != norm.length() && handler instanceof SolrInfoMBean) {],,
MALICIOUS_CODE,DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED,org/apache/solr/core/RequestHandlers.java,init,444-444,[      classLoader = new MemClassLoader(this);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/RequestHandlers.java,createRequestHandler,483-483,[      } catch (Exception e) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/core/RequestHandlers.java,getDocs,367-367,[        return null;],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/solr/core/RequestParams.java,setParams,106-106,[        meta = new LinkedHashMap<>(meta);],,setParams,102-102,[        if(meta!=null) {],,
PERFORMANCE,BX_UNBOXING_IMMEDIATELY_REBOXED,org/apache/solr/core/RequestParams.java,getVersion,206-206,[      return meta == null? 0l : (Long)meta.get("v");],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/core/RequestParams.java,,197-206,[      super(map);,       this.meta = meta;,     },     public Map getRawMap(){,       return meta;,     }, , ,     public Long getVersion() {,       return meta == null? 0l : (Long)meta.get("v");],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/core/SolrConfig.java,getInt,707-707,[    Object v = overlay.getXPathProperty(path);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/SolrConfig.java,,321-321,[      .build();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/SolrConfig.java,,664-667,[          loader.addToClassLoader(file.getParent(), new FileFilter() {,             @Override,             public boolean accept(File pathname) {,               return pathname.equals(file);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/core/SolrCore.java,createInstance,582-582,[        SolrException inner = (SolrException) e.getCause();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/core/SolrCore.java,createReloadedUpdateHandler,611-611,[        SolrException inner = (SolrException) e.getCause();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/core/SolrCore.java,getListener,2668-2668,[      ManagedIndexSchema mis = (ManagedIndexSchema) core.getLatestSchema();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/SolrCore.java,,1238-1238,[  public static boolean VERBOSE = Boolean.parseBoolean(System.getProperty("tests.verbose","false"));],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/SolrCore.java,,164-164,[  public static Logger log = LoggerFactory.getLogger(SolrCore.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/SolrCore.java,,161-161,[  public static Map<SolrCore,Exception> openHandles = Collections.synchronizedMap(new IdentityHashMap<SolrCore, Exception>());],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/solr/core/SolrCore.java,getSearcher,1886-1886,[          searcherLock.notify();],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/solr/core/SolrCore.java,setName,349-349,[    this.coreDescriptor = new CoreDescriptor(v, this.coreDescriptor);],,setName,348-348,[    this.logid = (v==null)?"":("["+v+"] ");],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/core/SolrCore.java,getNewIndexDir,300-300,[          p.load(new InputStreamReader(is, StandardCharsets.UTF_8));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/core/SolrCore.java,getDocs,2488-2488,[    return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/SolrCore.java,getCoreDescriptor,2502-2502,[      if (null != cd && cd.getCoreContainer() != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/SolrCore.java,registerConfListener,2652-2652,[    if(zkSolrResourceLoader != null)],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/solr/core/SolrCore.java,<init>,732-732,[    String updateLogDir = cd.getUlogDir();],,<init>,744-744,[    if (null != cd && null != cd.getCloudDescriptor()) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/SolrCore.java,openNewSearcher,1623-1623,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/SolrCore.java,initQParsers,2254-2254,[     } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/SolrCore.java,openNewSearcher,1623-1623,[    } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/core/SolrCore.java,<init>,835-835,[      searcherExecutor.submit(new Callable<Void>() {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/core/SolrCore.java,booleanQueryMaxClauseCount,209-209,[        boolean_query_max_clause_count = solrConfig.booleanQueryMaxClauseCount;],,
STYLE,UC_USELESS_OBJECT,org/apache/solr/core/SolrCore.java,getSearcher,1729-1729,[    final boolean[] decrementOnDeckCount=new boolean[]{true};],,
MT_CORRECTNESS,UL_UNRELEASED_LOCK_EXCEPTION_PATH,org/apache/solr/core/SolrCore.java,getSearcher,1734-1734,[    openSearcherLock.lock();],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/solr/core/SolrCore.java,getSearcher,1693-1693,[          searcherLock.wait();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/SolrCore.java,,835-839,[      searcherExecutor.submit(new Callable<Void>() {,         @Override,         public Void call() throws Exception {,           latch.await();,           return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/SolrCore.java,,2543-2560,[      addCloseHook(new CloseHook() {,         @Override,         public void preClose(SolrCore core) {,         }, ,         @Override,         public void postClose(SolrCore core) {,           CoreDescriptor cd = core.getCoreDescriptor();,           if (cd != null) {,             File instanceDir = new File(cd.getInstanceDir());,             try {,               FileUtils.deleteDirectory(instanceDir);,             } catch (IOException e) {,               SolrException.log(log, "Failed to delete instance dir for core:",                   + core.getName() + " dir:" + instanceDir.getAbsolutePath());,             },           },         }],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/core/SolrCore.java,run,2685-2685,[            managedSchemaVersion = ((ManagedIndexSchema) core.getLatestSchema()).getSchemaZkVersion();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/SolrCore.java,,958-961,[      factory = new CodecFactory() {,         @Override,         public Codec getCodec() {,           return Codec.getDefault();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/SolrCore.java,,1776-1787,[          future = searcherExecutor.submit(new Callable() {,             @Override,             public Object call() throws Exception {,               try {,                 newSearcher.warm(currSearcher);,               } catch (Throwable e) {,                 SolrException.log(log, e);,                 if (e instanceof Error) {,                   throw (Error) e;,                 },               },               return null;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/SolrCore.java,close,1925-1925,[        } catch (Exception e) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/core/SolrCores.java,remove,235-235,[      ret = (ret == null) ? tmp : ret;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/core/SolrCores.java,remove,235-235,[      ret = (ret == null) ? tmp : ret;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/SolrCores.java,,68-80,[      transientCores = new LinkedHashMap<String, SolrCore>(cacheSize, 0.75f, true) {,         @Override,         protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {,           if (size() > cacheSize) {,             synchronized (modifyLock) {,               SolrCore coreToClose = eldest.getValue();,               logger.info("Closing transient core [{}]", coreToClose.getName());,               pendingCloses.add(coreToClose); // Essentially just queue this core up for closing.,               modifyLock.notifyAll(); // Wakes up closer thread too,             },             return true;,           },           return false;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/core/SolrDeletionPolicy.java,,230-230,[    return maxCommitsToKeep;],,,59-59,[      maxCommitsToKeep = Integer.parseInt(maxCommitsToKeepString);],,,70-70,[        maxOptimizedCommitsToKeep = Math.max(maxOptimizedCommitsToKeep, maxCommitsToKeep);],,,71-71,[        maxCommitsToKeep=0;],,,195-195,[        if (totalKept < maxCommitsToKeep) {],,,239-239,[      this.maxCommitsToKeep = maxCommitsToKeep;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/core/SolrDeletionPolicy.java,,234-234,[    return maxOptimizedCommitsToKeep;],,,63-63,[      maxOptimizedCommitsToKeep = Integer.parseInt(maxOptimizedCommitsToKeepString);],,,70-70,[        maxOptimizedCommitsToKeep = Math.max(maxOptimizedCommitsToKeep, maxCommitsToKeep);],,,189-189,[        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {],,,245-245,[      this.maxOptimizedCommitsToKeep = maxOptimizedCommitsToKeep;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/SolrDeletionPolicy.java,,45-45,[  public static Logger log = LoggerFactory.getLogger(SolrCore.class);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/SolrDeletionPolicy.java,updateCommits,185-185,[        } catch (Exception e) {],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/solr/core/SolrDeletionPolicy.java,getId,207-222,[    StringBuilder sb = new StringBuilder();,     Directory dir = commit.getDirectory();, ,     // For anything persistent, make something that will,     // be the same, regardless of the Directory instance.,     if (dir instanceof FSDirectory) {,       FSDirectory fsd = (FSDirectory) dir;,       File fdir = fsd.getDirectory().toFile();,       sb.append(fdir.getPath());,     } else {,       sb.append(dir);,     }, ,     sb.append('/');,     sb.append(commit.getGeneration());,     return sb.toString();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/core/SolrResourceLoader.java,persistConfLocally,851-851,[      org.apache.commons.io.IOUtils.closeQuietly(writer);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/solr/core/SolrResourceLoader.java,persistConfLocally,843-843,[      final FileOutputStream out = new FileOutputStream(managedSchemaFile);],,persistConfLocally,844-844,[      out.write(content);],,persistConfLocally,845-845,[      log.info("Upgraded to managed schema at " + managedSchemaFile.getPath());],,persistConfLocally,851-851,[      org.apache.commons.io.IOUtils.closeQuietly(writer);],,persistConfLocally,853-853,[        FileUtils.sync(managedSchemaFile);],,persistConfLocally,857-857,[      }],,persistConfLocally,859-859,[  }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/core/SolrResourceLoader.java,persistConfLocally,843-843,[      final FileOutputStream out = new FileOutputStream(managedSchemaFile);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/SolrResourceLoader.java,findClass,561-561,[    if( clazz == null ) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/SolrResourceLoader.java,findClass,524-524,[    if( clazz == null ) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/SolrResourceLoader.java,findClass,596-596,[    if( clazz == null ) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/core/SolrResourceLoader.java,addToClassLoader,180-180,[    if (base != null && base.exists() && base.isDirectory()) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/core/SolrResourceLoader.java,newAdminHandlerInstance,571-571,[    catch (Exception e) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/core/SolrXMLCoresLocator.java,,228-228,[      this.xml = originalXML;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/core/StandardDirectoryFactory.java,exists,90-90,[    return dirFile.canRead() && dirFile.list().length > 0;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/core/ZkContainer.java,,42-42,[  protected static Logger log = LoggerFactory.getLogger(ZkContainer.class);],,
MT_CORRECTNESS,RU_INVOKE_RUN,org/apache/solr/core/ZkContainer.java,registerInZk,232-232,[        thread.run();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/core/ZkContainer.java,,137-147,[            new CurrentCoreDescriptorProvider() {, ,               @Override,               public List<CoreDescriptor> getCurrentDescriptors() {,                 List<CoreDescriptor> descriptors = new ArrayList<>(,                     cc.getCoreNames().size());,                 Collection<SolrCore> cores = cc.getCores();,                 for (SolrCore core : cores) {,                   descriptors.add(core.getCoreDescriptor());,                 },                 return descriptors;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/solr/hadoop/AlphaNumericComparator.java,,42-74,[    public AlphaNumericComparator() {,     }, ,     public int compare(Object o1, Object o2) {,         String s1 = o1.toString();,         String s2 = o2.toString();,         int n1 = s1.length(), n2 = s2.length();,         int i1 = 0, i2 = 0;,         while (i1 < n1 && i2 < n2) {,             int p1 = i1;,             int p2 = i2;,             char c1 = s1.charAt(i1++);,             char c2 = s2.charAt(i2++);,             if(c1 != c2) {,                 if (Character.isDigit(c1) && Character.isDigit(c2)) {,                     int value1 = 0, value2 = 0;,                     while (i1 < n1 && Character.isDigit(c1 = s1.charAt(i1))) {,                       i1++;,                     },                     value1 = Integer.parseInt(s1.substring(p1, i1));,                     while (i2 < n2 && Character.isDigit(c2 = s2.charAt(i2))) {,                       i2++;,                     },                     value2 = Integer.parseInt(s2.substring(p2, i2));                    ,                     if (value1 != value2) {,                       return value1 - value2;,                     },                 },                 return c1 - c2;,             },         }, ,         return n1 - n2;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/hadoop/GoLive.java,goLive,119-119,[      while (pending != null && pending.size() > 0) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/hadoop/GoLive.java,goLive,167-167,[      } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/GoLive.java,,89-112,[          Callable<Request> task = new Callable<Request>() {,             @Override,             public Request call() {,               Request req = new Request();,               LOG.info("Live merge " + dir.getPath() + " into " + mergeUrl);,               final HttpSolrClient server = new HttpSolrClient(mergeUrl);,               try {,                 CoreAdminRequest.MergeIndexes mergeRequest = new CoreAdminRequest.MergeIndexes();,                 mergeRequest.setCoreName(name);,                 mergeRequest.setIndexDirs(Arrays.asList(dir.getPath().toString() + "/data/index"));,                 try {,                   mergeRequest.process(server);,                   req.success = true;,                 } catch (SolrServerException e) {,                   req.e = e;,                   return req;,                 } catch (IOException e) {,                   req.e = e;,                   return req;,                 },               } finally {,                 server.shutdown();,               },               return req;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/hadoop/HeartBeater.java,,50-50,[  public static Logger LOG = LoggerFactory.getLogger(HeartBeater.class);],,
MT_CORRECTNESS,SC_START_IN_CTOR,org/apache/solr/hadoop/HeartBeater.java,<init>,78-78,[    start();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/solr/hadoop/HeartBeater.java,needHeartBeat,128-128,[    if (threadsNeedingHeartBeat == 1) {],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/solr/hadoop/HeartBeater.java,cancelHeartBeat,140-140,[      threadsNeedingHeartBeat--;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/solr/hadoop/HeartBeater.java,needHeartBeat,122-122,[    threadsNeedingHeartBeat++;],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/solr/hadoop/MapReduceIndexerTool.java,run,795-795,[      mtreeMergeIterations = (int) Math.round(log(options.fanout, reducers / options.shards));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/solr/hadoop/MapReduceIndexerTool.java,createTreeMergeInputDirList,1157-1157,[      Writer writer = new BufferedWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/MapReduceIndexerTool.java,,932-935,[          PathFilter pathFilter = new PathFilter() {      ,             @Override,             public boolean accept(Path path) { // ignore "hidden" files and dirs,               return !(path.getName().startsWith(".") || path.getName().startsWith("_")); ],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/MapReduceIndexerTool.java,,1178-1181,[    FileStatus[] dirs = fs.listStatus(outputReduceDir, new PathFilter() {      ,       @Override,       public boolean accept(Path path) {,         return path.getName().startsWith(dirPrefix);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/MapReduceIndexerTool.java,,1191-1194,[    Arrays.sort(dirs, new Comparator<FileStatus>() {,       @Override,       public int compare(FileStatus f1, FileStatus f2) {,         return new AlphaNumericComparator().compare(f1.getPath().getName(), f2.getPath().getName());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/MapReduceIndexerTool.java,,1232-1235,[    FileStatus[] dirs = fs.listStatus(outputTreeMergeStep, new PathFilter() {      ,       @Override,       public boolean accept(Path path) {,         return path.getName().startsWith(dirPrefix);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/MapReduceIndexerTool.java,,182-236,[        .action(new HelpArgumentAction() {,           @Override,           public void run(ArgumentParser parser, Argument arg, Map<String, Object> attrs, String flag, Object value) throws ArgumentParserException {,             parser.printHelp();,             System.out.println();,             System.out.print(ToolRunnerHelpFormatter.getGenericCommandUsage());,             //ToolRunner.printGenericCommandUsage(System.out);,             System.out.println(,               "Examples: \n\n" + , ,               "# (Re)index an Avro based Twitter tweet file:\n" +,               "sudo -u hdfs hadoop \\\n" + ,               "  --config /etc/hadoop/conf.cloudera.mapreduce1 \\\n" +,               "  jar target/solr-map-reduce-*.jar \\\n" +,               "  -D 'mapred.child.java.opts=-Xmx500m' \\\n" + , //            "  -D 'mapreduce.child.java.opts=-Xmx500m' \\\n" + ,               "  --log4j src/test/resources/log4j.properties \\\n" + ,               "  --morphline-file ../search-core/src/test/resources/test-morphlines/tutorialReadAvroContainer.conf \\\n" + ,               "  --solr-home-dir src/test/resources/solr/minimr \\\n" +,               "  --output-dir hdfs://c2202.mycompany.com/user/$USER/test \\\n" + ,               "  --shards 1 \\\n" + ,               "  hdfs:///user/$USER/test-documents/sample-statuses-20120906-141433.avro\n" +,               "\n" +,               "# Go live by merging resulting index shards into a live Solr cluster\n" +,               "# (explicitly specify Solr URLs - for a SolrCloud cluster see next example):\n" +,               "sudo -u hdfs hadoop \\\n" + ,               "  --config /etc/hadoop/conf.cloudera.mapreduce1 \\\n" +,               "  jar target/solr-map-reduce-*.jar \\\n" +,               "  -D 'mapred.child.java.opts=-Xmx500m' \\\n" + , //            "  -D 'mapreduce.child.java.opts=-Xmx500m' \\\n" + ,               "  --log4j src/test/resources/log4j.properties \\\n" + ,               "  --morphline-file ../search-core/src/test/resources/test-morphlines/tutorialReadAvroContainer.conf \\\n" + ,               "  --solr-home-dir src/test/resources/solr/minimr \\\n" + ,               "  --output-dir hdfs://c2202.mycompany.com/user/$USER/test \\\n" + ,               "  --shard-url http://solr001.mycompany.com:8983/solr/collection1 \\\n" + ,               "  --shard-url http://solr002.mycompany.com:8983/solr/collection1 \\\n" + ,               "  --go-live \\\n" + ,               "  hdfs:///user/foo/indir\n" +  ,               "\n" +,               "# Go live by merging resulting index shards into a live SolrCloud cluster\n" +,               "# (discover shards and Solr URLs through ZooKeeper):\n" +,               "sudo -u hdfs hadoop \\\n" + ,               "  --config /etc/hadoop/conf.cloudera.mapreduce1 \\\n" +,               "  jar target/solr-map-reduce-*.jar \\\n" +,               "  -D 'mapred.child.java.opts=-Xmx500m' \\\n" + , //            "  -D 'mapreduce.child.java.opts=-Xmx500m' \\\n" + ,               "  --log4j src/test/resources/log4j.properties \\\n" + ,               "  --morphline-file ../search-core/src/test/resources/test-morphlines/tutorialReadAvroContainer.conf \\\n" + ,               "  --output-dir hdfs://c2202.mycompany.com/user/$USER/test \\\n" + ,               "  --zk-host zk01.mycompany.com:2181/solr \\\n" + ,               "  --collection collection1 \\\n" + ,               "  --go-live \\\n" + ,               "  hdfs:///user/foo/indir\n",             );,             throw new FoundHelpArgument(); // Trick to prevent processing of any remaining arguments],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/MapReduceIndexerTool.java,,244-252,[        .type(new PathArgumentType(conf) {,           @Override,           public Path convert(ArgumentParser parser, Argument arg, String value) throws ArgumentParserException {,             Path path = super.convert(parser, arg, value);,             if ("hdfs".equals(path.toUri().getScheme()) && path.toUri().getAuthority() == null) {,               // TODO: consider defaulting to hadoop's fs.default.name here or in SolrRecordWriter.createEmbeddedSolrServer(),               throw new ArgumentParserException("Missing authority in path URI: " + path, parser); ,             },             return path;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/MapReduceIndexerTool.java,,284-291,[        .type(new FileArgumentType() {,           @Override,           public File convert(ArgumentParser parser, Argument arg, String value) throws ArgumentParserException {,             File solrHomeDir = super.convert(parser, arg, value);,             File solrConfigFile = new File(new File(solrHomeDir, "conf"), "solrconfig.xml");,             new FileArgumentType().verifyExists().verifyIsFile().verifyCanRead().convert(,                 parser, arg, solrConfigFile.getPath());,             return solrHomeDir;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/hadoop/PathParts.java,<init>,41-41,[      throw new IllegalArgumentException("Path must not be null: " + uploadURL);    ],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/solr/hadoop/SolrOutputFormat.java,listFiles,261-261,[    for (File f : list) {],,listFiles,256-256,[    if (list == null && dir.isFile())  {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/solr/hadoop/SolrOutputFormat.java,createZip,235-235,[      InputStream is = new FileInputStream(f);],,createZip,237-237,[      while ((cnt = is.read(buf)) >= 0) {],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/solr/hadoop/SolrOutputFormat.java,createZip,235-235,[      InputStream is = new FileInputStream(f);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/solr/hadoop/SolrOutputFormat.java,createZip,230-230,[    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(out));],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/solr/hadoop/SolrRecordWriter.java,close,317-317,[    context.setStatus("Done");],,close,284-284,[    if (context != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/hadoop/SolrRecordWriter.java,close,303-303,[    } catch (Exception e) {],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/solr/hadoop/SolrRecordWriter.java,findSolrConfig,219-219,[        lsCmd.redirectErrorStream();],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/solr/hadoop/TreeMergeOutputFormat.java,writeShardNumberFile,190-190,[      Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/ZooKeeperInspector.java,,117-121,[    Collections.sort(sorted, new Comparator<Slice>() {,       @Override,       public int compare(Slice slice1, Slice slice2) {,         Comparator c = new AlphaNumericComparator();,         return c.compare(slice1.getName(), slice2.getName());],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/solr/hadoop/dedup/SolrInputDocumentComparator.java,,28-52,[public final class SolrInputDocumentComparator implements Comparator<SolrInputDocument> {,   ,   private Comparator child;,   private String fieldName;, ,   SolrInputDocumentComparator(String fieldName, Comparator child) {,     this.child = child;,     this.fieldName = fieldName;,   }, ,   @Override,   public int compare(SolrInputDocument doc1, SolrInputDocument doc2) {,     SolrInputField f1 = doc1.getField(fieldName);,     SolrInputField f2 = doc2.getField(fieldName);,     if (f1 == f2) {,       return 0;,     } else if (f1 == null) {,       return -1;,     } else if (f2 == null) {,       return 1;,     },     ,     Object v1 = f1.getFirstValue();,     Object v2 = f2.getFirstValue();          ,     return child.compare(v1, v2);],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/solr/hadoop/dedup/SolrInputDocumentComparator.java,,58-78,[  public static final class TimeStampComparator implements Comparator {, ,     @Override,     public int compare(Object v1, Object v2) {,       if (v1 == v2) {,         return 0;,       } else if (v1 == null) {,         return -1;,       } else if (v2 == null) {,         return 1;,       },       long t1 = getLong(v1);,       long t2 = getLong(v2);          ,       return (t1 < t2 ? -1 : (t1==t2 ? 0 : 1));,     },     ,     private long getLong(Object v) {,       if (v instanceof Long) {,         return ((Long) v).longValue();,       } else {,         return Long.parseLong(v.toString());],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/solr/hadoop/morphline/MorphlineMapRunner.java,map,185-185,[      PathParts parts = new PathParts(value.toString(), configuration);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/hadoop/morphline/MorphlineMapRunner.java,,127-129,[      public MySolrLocator(MorphlineContext ctx) {,         super(ctx);,       }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/AnalysisRequestHandlerBase.java,,222-240,[    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {,       @Override,       public int compare(AttributeSource a, AttributeSource b) {,         return arrayCompare(,           a.getAttribute(TokenTrackingAttribute.class).getPositions(),,           b.getAttribute(TokenTrackingAttribute.class).getPositions(),         );,       },       ,       private int arrayCompare(int[] a, int[] b) {,         int p = 0;,         final int stop = Math.min(a.length, b.length);,         while(p < stop) {,           int diff = a[p] - b[p];,           if (diff != 0) return diff;,           p++;,         },         // One is a prefix of the other, or, they are equal:,         return a.length - b.length;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/AnalysisRequestHandlerBase.java,,266-290,[      token.reflectWith(new AttributeReflector() {,         @Override,         public void reflect(Class<? extends Attribute> attClass, String key, Object value) {,           // leave out position and bytes term,           if (TermToBytesRefAttribute.class.isAssignableFrom(attClass)),             return;,           if (CharTermAttribute.class.isAssignableFrom(attClass)),             return;,           if (PositionIncrementAttribute.class.isAssignableFrom(attClass)),             return;,           ,           String k = attClass.getName() + '#' + key;,           ,           // map keys for "standard attributes":,           if (ATTRIBUTE_MAPPING.containsKey(k)) {,             k = ATTRIBUTE_MAPPING.get(k);,           },           ,           if (value instanceof BytesRef) {,             final BytesRef p = (BytesRef) value;,             value = p.toString();,           }, ,           tokenNamedList.add(k, value);,         }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/handler/AnalysisRequestHandlerBase.java,getPositions,396-396,[      return cachedPositions;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/handler/AnalysisRequestHandlerBase.java,reset,401-401,[      this.basePositions = basePositions;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/BlobHandler.java,handleRequestBody,122-122,[        indexMap(req, makeMap(],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/BlobHandler.java,,152-166,[            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){, ,               @Override,               public void write(OutputStream os) throws IOException {,                 StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);,                 StorableField sf = doc.getField("blob");,                 FieldType fieldType = req.getSchema().getField("blob").getType();,                 ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);,                 if(buf == null){,                   //should never happen unless a user wrote this document directly,                   throw new SolrException(SolrException.ErrorCode.NOT_FOUND, "Invalid document . No field called blob");,                 } else {,                   os.write(buf.array(),0,buf.limit());,                 },               }],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/ContentStreamHandlerBase.java,,38-38,[  public static Logger log = LoggerFactory.getLogger(ContentStreamHandlerBase.class);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/handler/DocumentAnalysisRequestHandler.java,handleAnalysisRequest,230-230,[          } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/DocumentAnalysisRequestHandler.java,handleAnalysisRequest,221-221,[        } catch (Exception e) {],,handleAnalysisRequest,230-230,[          } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/MoreLikeThisHandler.java,handleRequestBody,119-119,[            sortSpec = parser.getSort(true);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/MoreLikeThisHandler.java,,83-83,[  protected static Logger log = LoggerFactory.getLogger(MoreLikeThisHandler.class);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/MoreLikeThisHandler.java,getDocs,490-490,[    catch( MalformedURLException ex ) { return null; }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/MoreLikeThisHandler.java,handleRequestBody,257-257,[            if (null != dbgInfo) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/MoreLikeThisHandler.java,,285-285,[    public static Comparator<InterestingTerm> BOOST_ORDER = new Comparator<InterestingTerm>() {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/handler/MoreLikeThisHandler.java,,285-285,[    public static Comparator<InterestingTerm> BOOST_ORDER = new Comparator<InterestingTerm>() {],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/solr/handler/MoreLikeThisHandler.java,compare,292-292,[        return (d>0)?1:-1;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/PingRequestHandler.java,,130-130,[  public static Logger log = LoggerFactory.getLogger(PingRequestHandler.class);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/RealTimeGetHandler.java,getDocs,45-45,[    return null;],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/handler/ReplicationHandler.java,addVal,792-792,[        l.add(new Date(Long.valueOf(ss[i])).toString());],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/solr/handler/ReplicationHandler.java,getReplicationDetails,731-731,[                percentDownloaded = (currFileSizeDownloaded * 100) / currFileSize;],,getReplicationDetails,750-750,[            totalPercent = (bytesDownloaded * 100) / bytesToDownload;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/handler/ReplicationHandler.java,loadReplicationProperties,836-836,[          props.load(new InputStreamReader(is, StandardCharsets.UTF_8));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/ReplicationHandler.java,doFetch,339-339,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/ReplicationHandler.java,doSnapShoot,381-381,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/ReplicationHandler.java,getCheckSum,317-317,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/ReplicationHandler.java,getReplicationDetails,762-762,[        } catch (Exception e) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/RequestHandlerBase.java,getDocs,203-203,[    return null;  // this can be overridden, but not required],,
CORRECTNESS,BC_IMPOSSIBLE_INSTANCEOF,org/apache/solr/handler/SchemaHandler.java,handleGET,115-115,[            refreshIfBelowVersion = (refreshParam instanceof Number) ? ((Number)refreshParam).intValue()],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/handler/SchemaHandler.java,handleGET,125-125,[              ZkSolrResourceLoader zkSolrResourceLoader = (ZkSolrResourceLoader)req.getCore().getResourceLoader();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/SchemaHandler.java,handleGET,143-143,[    } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/SnapPuller.java,<init>,186-186,[    final SolrParams params = SolrParams.toSolrParams(initArgs);],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/handler/SnapPuller.java,logReplicationTimeAndConfFiles,582-582,[        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;],,logReplicationTimeAndConfFiles,593-593,[          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;],,logReplicationTimeAndConfFiles,602-602,[          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/handler/SnapPuller.java,makeTmpConfDirFileList,886-886,[    for (File file : files) {],,makeTmpConfDirFileList,885-885,[    File[] files = dir.listFiles();],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/handler/SnapPuller.java,modifyIndexProps,952-952,[          p.load(new InputStreamReader(is, StandardCharsets.UTF_8));],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/SnapPuller.java,readInterval,1677-1677,[    if (interval != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/SnapPuller.java,logReplicationTimeAndConfFiles,618-618,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/SnapPuller.java,getStream,1378-1378,[      } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/handler/SnapPuller.java,fetchFile,1206-1206,[        fsyncService.submit(new Runnable(){],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/SnapPuller.java,getStream,1645-1645,[      } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/handler/SnapPuller.java,fetchFile,1474-1474,[        fsyncService.submit(new Runnable(){],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/handler/SnapShooter.java,deleteOldBackups,161-161,[    for(File f : files) {],,deleteOldBackups,159-159,[    File[] files = new File(snapDir).listFiles();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/handler/SnapShooter.java,validateDeleteSnapshot,97-97,[    for(File f : files) {],,validateDeleteSnapshot,96-96,[    File[] files = new File(snapDir).listFiles();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/SnapShooter.java,createSnapshot,148-148,[    } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/handler/SnapShooter.java,<init>,66-66,[      if (!dir.exists())  dir.mkdirs();],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/handler/SnapShooter.java,compareTo,219-219,[      return that.timestamp.compareTo(this.timestamp);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/SnapShooter.java,,198-219,[  private class OldBackupDirectory implements Comparable<OldBackupDirectory>{,     File dir;,     Date timestamp;,     final Pattern dirNamePattern = Pattern.compile("^snapshot[.](.*)$");,     ,     OldBackupDirectory(File dir) {,       if(dir.isDirectory()) {,         Matcher m = dirNamePattern.matcher(dir.getName());,         if(m.find()) {,           try {,             this.dir = dir;,             this.timestamp = new SimpleDateFormat(DATE_FMT, Locale.ROOT).parse(m.group(1));,           } catch(Exception e) {,             this.dir = null;,             this.timestamp = null;,           },         },       },     },     @Override,     public int compareTo(OldBackupDirectory that) {,       return that.timestamp.compareTo(this.timestamp);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/handler/SolrConfigHandler.java,handleCommands,257-275,[      switch (op.name) {,         case SET_PROPERTY:,           overlay = applySetProp(op, overlay);,           break;,         case UNSET_PROPERTY:,           overlay = applyUnset(op, overlay);,           break;,         case SET_USER_PROPERTY:,           overlay = applySetUserProp(op, overlay);,           break;,         case UNSET_USER_PROPERTY:,           overlay = applyUnsetUserProp(op, overlay);,           break;,         case UPDATE_REQHANDLER:,         case CREATE_REQHANDLER:,           overlay = applyRequestHandler(op, overlay);,           break;,         case DELETE_REQHANDLER:,           overlay = applyDeleteHandler(op,overlay);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/SolrConfigHandler.java,,96-96,[      this.method = httpMethod;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/StandardRequestHandler.java,getDocs,58-58,[    catch( MalformedURLException ex ) { return null; }],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/UpdateRequestHandler.java,,55-55,[  public static Logger log = LoggerFactory.getLogger(UpdateRequestHandler.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/AdminHandlers.java,,43-43,[  public static Logger log = LoggerFactory.getLogger(AdminHandlers.class);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/admin/AdminHandlers.java,getDocs,143-143,[    return null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/admin/CollectionsHandler.java,makeReplicaFirstWatcher,432-432,[    List<String> electionNodesTmp = OverseerCollectionProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/solr/handler/admin/CollectionsHandler.java,copyIfNotNull,927-927,[    String prefix = null;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CollectionsHandler.java,,637-637,[  public static long DEFAULT_ZK_TIMEOUT = 180*1000;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CollectionsHandler.java,,124-124,[  protected static Logger log = LoggerFactory.getLogger(CollectionsHandler.class);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/admin/CollectionsHandler.java,handleBalanceLeaders,299-299,[    if (dc == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/admin/CollectionsHandler.java,handleCreateAction,834-834,[    if (name == null) {],,
CORRECTNESS,ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND,org/apache/solr/handler/admin/CoreAdminHandler.java,handleWaitForStateAction,918-918,[            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,107-107,[  public static String COMPLETED = "completed";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,108-108,[  public static String FAILED = "failed";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,105-105,[  protected static int MAX_TRACKED_REQUESTS = 100;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,109-109,[  public static String RESPONSE = "Response";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,111-111,[  public static String RESPONSE_MESSAGE = "msg";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,110-110,[  public static String RESPONSE_STATUS = "STATUS";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,106-106,[  public static String RUNNING = "running";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,97-97,[  protected static Logger log = LoggerFactory.getLogger(CoreAdminHandler.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,509-509,[      .build();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/CoreAdminHandler.java,,99-99,[  protected static HashMap<String, Map<String, TaskObject>> requestStatusMap =],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/admin/CoreAdminHandler.java,handleWaitForStateAction,958-958,[              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/admin/CoreAdminHandler.java,buildCoreDescriptor,598-598,[      if (coreContainer.isZooKeeperAware() && dcore != null && !preExisitingZkEntry) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/admin/CoreAdminHandler.java,handleMergeAction,463-463,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/admin/CoreAdminHandler.java,handleSplitAction,389-389,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/admin/CoreAdminHandler.java,handleRequestSyncAction,842-842,[          } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/admin/CoreAdminHandler.java,handleWaitForStateAction,982-982,[          } catch (Exception exc) {],,handleWaitForStateAction,1021-1021,[          } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/admin/CoreAdminHandler.java,,1241-1255,[    public TaskObject(String taskId) {,       this.taskId = taskId;,     }, ,     public String getRspObject() {,       return rspInfo;,     }, ,     public void setRspObject(SolrQueryResponse rspObject) {,       this.rspInfo = rspObject.getToLogAsString("TaskId: " + this.taskId + " ");,     }, ,     public void setRspObjectFromException(Exception e) {,       this.rspInfo = e.getMessage();,     }],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/handler/admin/EditFileRequestHandler.java,testReloadSuccess,285-285,[          String confPath = ((ZkSolrResourceLoader) core.getResourceLoader()).getConfigSetZkPath();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/admin/EditFileRequestHandler.java,handleRequestBody,166-166,[          } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/admin/EditFileRequestHandler.java,testReloadSuccess,289-289,[        } catch (Exception ex) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/admin/InfoHandler.java,,33-33,[  protected static Logger log = LoggerFactory.getLogger(InfoHandler.class);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/handler/admin/LukeRequestHandler.java,handleRequestBody,141-141,[      catch( Exception ex ) {}],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/handler/admin/LukeRequestHandler.java,getFirstLiveDoc,397-397,[      docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/admin/LukeRequestHandler.java,getDocs,659-659,[    catch( MalformedURLException ex ) { return null; }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/admin/LukeRequestHandler.java,getDocumentFieldsInfo,277-277,[      f.add( "docFreq", t.text()==null ? 0 : reader.docFreq( t ) ); // this can be 0 for non-indexed fields],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/admin/LukeRequestHandler.java,getIndexedFieldsInfo,368-368,[          catch( Exception ex ) {],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/solr/handler/admin/LukeRequestHandler.java,toListOfStrings,633-637,[    List<String> result = new ArrayList<>(raw.length);,     for (SchemaField f : raw) {,       result.add(f.getName());,     },     return result;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/handler/admin/ShowFileRequestHandler.java,getAdminFileFromZooKeeper,306-306,[        .getResourceLoader();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/handler/admin/ShowFileRequestHandler.java,showFromFileSystem,220-220,[      for( File f : adminFile.listFiles() ) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/handler/admin/SystemInfoHandler.java,addGetterIfAvaliable,212-212,[    catch( Exception ex ) {} // don't worry, this only works for 1.6],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/solr/handler/admin/SystemInfoHandler.java,addGetterIfAvaliable,206-206,[      m.setAccessible(true);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/admin/SystemInfoHandler.java,addGetterIfAvaliable,212-212,[    catch( Exception ex ) {} // don't worry, this only works for 1.6],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/handler/clustering/ClusteringComponent.java,finishStage,247-247,[        Object clusters = engine.cluster(rb.getQuery(), solrDocList, docIds, rb.req);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine.java,,340-343,[        req = new LocalSolrQueryRequest(core, query.toString(), "", 0, 1, args) {,           @Override,           public SolrIndexSearcher getSearcher() {,             return sreq.getSearcher();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,33-33,[  public static String ALGORITHM = CARROT_PREFIX + "algorithm";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,39-39,[  public static String CUSTOM_FIELD_NAME = CARROT_PREFIX + "custom";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,48-48,[  public static String LANGUAGE_CODE_MAP = CARROT_PREFIX + "lcmap";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,38-38,[  public static String LANGUAGE_FIELD_NAME = CARROT_PREFIX + "lang";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,54-54,[  public static String LEXICAL_RESOURCES_DIR = CARROT_PREFIX + "lexicalResourcesDir";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,45-45,[  public static String NUM_DESCRIPTIONS = CARROT_PREFIX + "numDescriptions";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,46-46,[  public static String OUTPUT_SUB_CLUSTERS = CARROT_PREFIX + "outputSubClusters";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,41-41,[  public static String PRODUCE_SUMMARY = CARROT_PREFIX + "produceSummary";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,60-60,[  public static String RESOURCES_DIR = CARROT_PREFIX + "resourcesDir";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,37-37,[  public static String SNIPPET_FIELD_NAME = CARROT_PREFIX + "snippet";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,42-42,[  public static String SUMMARY_FRAGSIZE = CARROT_PREFIX + "fragSize";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,43-43,[  public static String SUMMARY_SNIPPETS = CARROT_PREFIX + "summarySnippets";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,35-35,[  public static String TITLE_FIELD_NAME = CARROT_PREFIX + "title";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/clustering/carrot2/CarrotParams.java,,36-36,[  public static String URL_FIELD_NAME = CARROT_PREFIX + "url";],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/clustering/carrot2/LuceneCarrot2TokenizerFactory.java,reset,161-161,[        } catch (Exception e) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/handler/clustering/carrot2/SolrResourceLocator.java,toString,132-132,[    } catch (Exception ignored) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/clustering/carrot2/SolrResourceLocator.java,toString,132-132,[    } catch (Exception ignored) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/clustering/carrot2/SolrResourceLocator.java,,84-106,[    final IResource foundResource = new IResource() {,       @Override,       public InputStream open() {,         return new ByteArrayInputStream(asBytes);,       }, ,       @Override,       public int hashCode() {,         // In case multiple resources are found they will be deduped, but we don't use it in Solr,,         // so simply rely on instance equivalence.,         return super.hashCode();,       },       ,       @Override,       public boolean equals(Object obj) {,         // In case multiple resources are found they will be deduped, but we don't use it in Solr,,         // so simply rely on instance equivalence.,         return super.equals(obj);,       }, ,       @Override,       public String toString() {,         return "Solr config resource: " + resourceName;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/handler/component/DebugComponent.java,merge,334-334,[          if (skey == dkey || (skey!=null && skey.equals(dkey))) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/component/DebugComponent.java,getDocs,373-373,[    return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/component/ExpandComponent.java,,309-364,[  private class GroupExpandCollector implements Collector {,     private SortedDocValues docValues;,     private IntObjectMap<Collector> groups;,     private int docBase;,     private FixedBitSet groupBits;,     private IntOpenHashSet collapsedSet;, ,     public GroupExpandCollector(SortedDocValues docValues, FixedBitSet groupBits, IntOpenHashSet collapsedSet, int limit, Sort sort) throws IOException {,       int numGroups = collapsedSet.size();,       groups = new IntObjectOpenHashMap<>(numGroups * 2);,       DocIdSetIterator iterator = new BitSetIterator(groupBits, 0); // cost is not useful here,       int group;,       while ((group = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {,         Collector collector = (sort == null) ? TopScoreDocCollector.create(limit, true) : TopFieldCollector.create(sort, limit, false, false, false, true);,         groups.put(group, collector);,       }, ,       this.collapsedSet = collapsedSet;,       this.groupBits = groupBits;,       this.docValues = docValues;,     }, ,     public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {,       final int docBase = context.docBase;,       final IntObjectMap<LeafCollector> leafCollectors = new IntObjectOpenHashMap<>();,       for (IntObjectCursor<Collector> entry : groups) {,         leafCollectors.put(entry.key, entry.value.getLeafCollector(context));,       },       return new LeafCollector() {, ,         @Override,         public void setScorer(Scorer scorer) throws IOException {,           for (ObjectCursor<LeafCollector> c : leafCollectors.values()) {,             c.value.setScorer(scorer);,           },         }, ,         @Override,         public void collect(int docId) throws IOException {,           int doc = docId + docBase;,           int ord = docValues.getOrd(doc);,           if (ord > -1 && groupBits.get(ord) && !collapsedSet.contains(doc)) {,             LeafCollector c = leafCollectors.get(ord);,             c.collect(docId);,           },         }, ,         @Override,         public boolean acceptsDocsOutOfOrder() {,           return false;,         },       };,     }, ,     public IntObjectMap<Collector> getGroups() {,       return groups;],,
STYLE,DB_DUPLICATE_BRANCHES,org/apache/solr/handler/component/FacetComponent.java,finishStage,1007-1007,[        counts = dff.getLexSorted();],,finishStage,1009-1009,[        counts = dff.getLexSorted();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/component/FacetComponent.java,enqueuePivotFacetShardRequests,270-270,[      String pivotFacetKey = fi.pivotFacets.getName(pivotIndex);],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/solr/handler/component/FacetComponent.java,refineFacets,900-900,[            log.error("Unexpected term returned for facet refining. key=" + key],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/FacetComponent.java,,61-61,[  public static Logger log = LoggerFactory.getLogger(FacetComponent.class);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/component/FacetComponent.java,getDocs,1097-1097,[    return null;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/solr/handler/component/FacetComponent.java,num,1081-1082,[    if (val.longValue() < Integer.MAX_VALUE) return val.intValue();,     else return val;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/component/FacetComponent.java,,1332-1335,[      Arrays.sort(arr, new Comparator<ShardFacetCount>() {,         @Override,         public int compare(ShardFacetCount o1, ShardFacetCount o2) {,           return o1.indexed.compareTo(o2.indexed);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/component/FacetComponent.java,,1345-1350,[      Arrays.sort(arr, new Comparator<ShardFacetCount>() {,         @Override,         public int compare(ShardFacetCount o1, ShardFacetCount o2) {,           if (o2.count < o1.count) return -1;,           else if (o1.count < o2.count) return 1;,           return o1.indexed.compareTo(o2.indexed);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/handler/component/FacetComponent.java,,1242-1242,[      this.prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/handler/component/FacetComponent.java,compare,1335-1335,[          return o1.indexed.compareTo(o2.indexed);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/handler/component/FacetComponent.java,compare,1350-1350,[          return o1.indexed.compareTo(o2.indexed);],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE,org/apache/solr/handler/component/FieldFacetStats.java,facetTermNum,109-109,[      if (term == -1) {],,
STYLE,UC_USELESS_CONDITION,org/apache/solr/handler/component/FieldFacetStats.java,facetTermNum,110-110,[        key = null;],,facetTermNum,109-109,[      if (term == -1) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/component/FieldFacetStats.java,,66-66,[    this.facet_sf = facet_sf;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/handler/component/FieldFacetStats.java,facet,89-89,[    final String key = values.exists(docID)],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/component/TermVectorComponent.java,,198-198,[              option.fieldName = field;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/component/HighlightComponent.java,getDocs,220-220,[    return null;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/handler/component/HttpShardHandler.java,,81-98,[  private static class SimpleSolrResponse extends SolrResponse {,     long elapsedTime;,     NamedList<Object> nl;, ,     @Override,     public long getElapsedTime() {,       return elapsedTime;,     }, ,     @Override,     public NamedList<Object> getResponse() {,       return nl;,     }, ,     @Override,     public void setResponse(NamedList<Object> rsp) {,       nl = rsp;,     }],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/HttpShardHandlerFactory.java,,49-49,[  protected static Logger log = LoggerFactory.getLogger(HttpShardHandlerFactory.class);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/component/MoreLikeThisComponent.java,mergeSolrDocumentList,248-248,[    List<SolrDocument> l = new ArrayList<>();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/component/MoreLikeThisComponent.java,getDocs,412-412,[    return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/component/MoreLikeThisComponent.java,,266-281,[    Comparator<SolrDocument> c = new Comparator<SolrDocument>() {,       public int compare(SolrDocument o1, SolrDocument o2) {,         Float f1 = getFloat(o1);,         Float f2 = getFloat(o2);,         return f2.compareTo(f1);,       },       ,       private Float getFloat(SolrDocument doc) {,         Float f = 0f;,         if (doc != null) {,           Object o = doc.getFieldValue("score");,           if (o != null && o instanceof Float) {,             f = (Float) o;,           },         },         return f;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/component/PivotFacetFieldValueCollection.java,,305-309,[  public class PivotFacetCountComparator implements Comparator<PivotFacetValue> {    ,     public int compare(PivotFacetValue left, PivotFacetValue right) {,       int countCmp = right.getCount() - left.getCount();,       return (0 != countCmp) ? countCmp : ,         compareWithNullLast(left.getValue(), right.getValue());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/component/PivotFacetFieldValueCollection.java,,314-316,[  public class PivotFacetValueComparator implements Comparator<PivotFacetValue> {,     public int compare(PivotFacetValue left, PivotFacetValue right) {,       return compareWithNullLast(left.getValue(), right.getValue());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/component/PivotFacetProcessor.java,process,93-93,[          if (sfield == null) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/component/QueryComponent.java,getDocs,1316-1316,[    return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/component/QueryComponent.java,createMainQuery,848-848,[    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/component/QueryComponent.java,,570-583,[      new InPlaceMergeSorter() {,         @Override,         protected void swap(int i, int j) {,           long tmpId = sortedIds[i];,           float tmpScore = scores[i];,           sortedIds[i] = sortedIds[j];,           scores[i] = scores[j];,           sortedIds[j] = tmpId;,           scores[j] = tmpScore;,         }, ,         @Override,         protected int compare(int i, int j) {,           return Long.compare(sortedIds[i], sortedIds[j]);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/handler/component/QueryComponent.java,retrieve,783-783,[        ShardDoc solrDoc = (ShardDoc) doc;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/component/QueryComponent.java,,779-784,[    EndResultTransformer.SolrDocumentSource solrDocumentSource = new EndResultTransformer.SolrDocumentSource() {, ,       @Override,       public SolrDocument retrieve(ScoreDoc doc) {,         ShardDoc solrDoc = (ShardDoc) doc;,         return rb.retrievedDocuments.get(solrDoc.id);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/solr/handler/component/QueryElevationComponent.java,,138-166,[    ElevationObj(String qstr, List<String> elevate, List<String> exclude) throws IOException {,       this.text = qstr;,       this.analyzed = getAnalyzedQuery(this.text);,       this.ids = new HashSet<>();,       this.excludeIds = new HashSet<>();, ,       this.include = new BooleanQuery();,       this.include.setBoost(0);,       this.priority = new HashMap<>();,       int max = elevate.size() + 5;,       for (String id : elevate) {,         id = idSchemaFT.readableToIndexed(id);,         ids.add(id);,         TermQuery tq = new TermQuery(new Term(idField, id));,         include.add(tq, BooleanClause.Occur.SHOULD);,         this.priority.put(new BytesRef(id), max--);,       }, ,       if (exclude == null || exclude.isEmpty()) {,         this.exclude = null;,       } else {,         this.exclude = new TermQuery[exclude.size()];,         for (int i = 0; i < exclude.size(); i++) {,           String id = idSchemaFT.readableToIndexed(exclude.get(i));,           excludeIds.add(id);,           this.exclude[i] = new TermQuery(new Term(idField, id));,         },       },     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/component/RealTimeGetComponent.java,processGetUpdates,565-565,[    SolrQueryResponse rsp = rb.rsp;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/component/RealTimeGetComponent.java,processGetVersions,510-510,[    SolrQueryResponse rsp = rb.rsp;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/RealTimeGetComponent.java,,209-209,[  public static SolrInputDocument DELETED = new SolrInputDocument();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/RealTimeGetComponent.java,,71-71,[  public static Logger log = LoggerFactory.getLogger(UpdateLog.class);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/handler/component/RealTimeGetComponent.java,getInputDocument,252-252,[        if (searcher == null) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/component/RealTimeGetComponent.java,getDocs,498-498,[    return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/handler/component/RealTimeGetComponent.java,getInputDocument,252-252,[        if (searcher == null) {],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/solr/handler/component/ResponseBuilder.java,getShardNum,143-143,[      if (shards[i] == shard || shards[i].equals(shard)) return i;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/ResponseBuilder.java,,127-127,[  public static int STAGE_DONE = Integer.MAX_VALUE;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/ResponseBuilder.java,,125-125,[  public static int STAGE_EXECUTE_QUERY = 2000;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/ResponseBuilder.java,,126-126,[  public static int STAGE_GET_FIELDS = 3000;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/ResponseBuilder.java,,123-123,[  public static int STAGE_PARSE_QUERY = 1000;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/ResponseBuilder.java,,122-122,[  public static int STAGE_START = 0;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/ResponseBuilder.java,,124-124,[  public static int STAGE_TOP_GROUPS = 1500;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/handler/component/ResponseBuilder.java,,409-409,[      this.dfMap = dfMap;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/handler/component/ResponseBuilder.java,,408-408,[      this.numDocs = numDocs;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/handler/component/SearchComponent.java,getDocs,118-118,[    return null;  // this can be overridden, but not required],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/handler/component/SearchHandler.java,handleRequestBody,335-335,[                  throw (SolrException)srsp.getException();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/component/SearchHandler.java,,66-66,[  protected static Logger log = LoggerFactory.getLogger(SearchHandler.class);],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/handler/component/ShardDoc.java,lessThan,145-145,[    if (docA.shard == docB.shard) {],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/solr/handler/component/ShardDoc.java,lessThan,166-166,[      c = -docA.shard.compareTo(docB.shard);],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/solr/handler/component/ShardDoc.java,compare,219-219,[        if (f1 > f2)],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/component/ShardDoc.java,,192-192,[      this.sortField = sortField;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/component/ShardHandlerFactory.java,newInstance,52-52,[    catch (Exception e) {],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/solr/handler/component/ShardRequest.java,,27-27,[  public final static String[] ALL_SHARDS = null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/component/ShardResponse.java,,87-87,[    this.rspCode = rspCode;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/component/SpellCheckComponent.java,inform,659-659,[          if (checker != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/component/SpellCheckComponent.java,collectShardCollations,463-463,[      if(collationList != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/component/SpellCheckComponent.java,collectShardCollations,470-470,[            if(collationRankList!= null && collationRankList.size()>0)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/component/SpellCheckComponent.java,toNamedList,602-602,[      if (theSuggestions != null && (theSuggestions.size() > 0 || shardRequest)) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/component/StatsComponent.java,,186-186,[    this.rb = rb;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/handler/component/TermVectorComponent.java,getInts,410-410,[          result.add(new Integer(vals[i]));],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/handler/component/TermVectorComponent.java,,463-463,[    this.initParams = args;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/component/TermVectorComponent.java,,268-286,[    final StoredFieldVisitor getUniqValue = new StoredFieldVisitor() {,       @Override ,       public void stringField(FieldInfo fieldInfo, String value) {,         uniqValues.add(value);,       }, ,       @Override ,       public void intField(FieldInfo fieldInfo, int value) {,         uniqValues.add(Integer.toString(value));,       }, ,       @Override ,       public void longField(FieldInfo fieldInfo, long value) {,         uniqValues.add(Long.toString(value));,       }, ,       @Override,       public Status needsField(FieldInfo fieldInfo) {,         return (fieldInfo.name.equals(finalUniqFieldName)) ? Status.YES : Status.NO;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/component/TermsComponent.java,process,151-151,[        lowerBytes = new BytesRef();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/component/TermsComponent.java,,330-475,[    public TermsHelper() {,       fieldmap = new HashMap<>(5);,     }, ,     public void init(SolrParams params) {,       this.params = params;,       String[] fields = params.getParams(TermsParams.TERMS_FIELD);,       if (fields != null) {,         for (String field : fields) {,           // TODO: not sure 128 is the best starting size,           // It use it because that is what is used for facets,           fieldmap.put(field, new HashMap<String, TermsResponse.Term>(128));,         },       },     }, ,     public void parse(NamedList<NamedList<Number>> terms) {,       // exit if there is no terms,       if (terms == null) {,         return;,       }, ,       TermsResponse termsResponse = new TermsResponse(terms);,       ,       // loop though each field and add each term+freq to map,       for (String key : fieldmap.keySet()) {,         HashMap<String, TermsResponse.Term> termmap = fieldmap.get(key);,         List<TermsResponse.Term> termlist = termsResponse.getTerms(key); , ,         // skip this field if there are no terms,         if (termlist == null) {,           continue;,         }, ,         // loop though each term,         for (TermsResponse.Term tc : termlist) {,           String term = tc.getTerm();,           if (termmap.containsKey(term)) {,             TermsResponse.Term oldtc = termmap.get(term);,             oldtc.addFrequency(tc.getFrequency());,             termmap.put(term, oldtc);,           } else {,             termmap.put(term, tc);,           },         },       },     }, ,     public NamedList buildResponse() {,       NamedList<Object> response = new SimpleOrderedMap<>();, ,       // determine if we are going index or count sort,       boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(params.get(,           TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));, ,       // init minimum frequency,       long freqmin = 1;,       String s = params.get(TermsParams.TERMS_MINCOUNT);,       if (s != null)  freqmin = Long.parseLong(s);, ,       // init maximum frequency, default to max int,       long freqmax = -1;,       s = params.get(TermsParams.TERMS_MAXCOUNT);,       if (s != null)  freqmax = Long.parseLong(s);,       if (freqmax < 0) {,         freqmax = Long.MAX_VALUE;,       }, ,       // init limit, default to max int,       long limit = 10;,       s = params.get(TermsParams.TERMS_LIMIT);,       if (s != null)  limit = Long.parseLong(s);,       if (limit < 0) {,         limit = Long.MAX_VALUE;,       }, ,       // loop though each field we want terms from,       for (String key : fieldmap.keySet()) {,         NamedList<Number> fieldterms = new SimpleOrderedMap<>();,         TermsResponse.Term[] data = null;,         if (sort) {,           data = getCountSorted(fieldmap.get(key));,         } else {,           data = getLexSorted(fieldmap.get(key));,         }, ,         // loop though each term until we hit limit,         int cnt = 0;,         for (TermsResponse.Term tc : data) {,           if (tc.getFrequency() >= freqmin && tc.getFrequency() <= freqmax) {,             fieldterms.add(tc.getTerm(), num(tc.getFrequency()));,             cnt++;,           }, ,           if (cnt >= limit) {,             break;,           },         }, ,         response.add(key, fieldterms);,       }, ,       return response;,     }, ,     // use <int> tags for smaller facet counts (better back compatibility),     private Number num(long val) {,       if (val < Integer.MAX_VALUE) return (int) val;,       else return val;,     }, ,     // based on code from facets,     public TermsResponse.Term[] getLexSorted(HashMap<String, TermsResponse.Term> data) {,       TermsResponse.Term[] arr = data.values().toArray(new TermsResponse.Term[data.size()]);, ,       Arrays.sort(arr, new Comparator<TermsResponse.Term>() {,         @Override,         public int compare(TermsResponse.Term o1, TermsResponse.Term o2) {,           return o1.getTerm().compareTo(o2.getTerm());,         },       });, ,       return arr;,     }, ,     // based on code from facets,     public TermsResponse.Term[] getCountSorted(HashMap<String, TermsResponse.Term> data) {,       TermsResponse.Term[] arr = data.values().toArray(new TermsResponse.Term[data.size()]);, ,       Arrays.sort(arr, new Comparator<TermsResponse.Term>() {,         @Override,         public int compare(TermsResponse.Term o1, TermsResponse.Term o2) {,           long freq1 = o1.getFrequency();,           long freq2 = o2.getFrequency();,           ,           if (freq2 < freq1) {,             return -1;,           } else if (freq1 < freq2) {,             return 1;,           } else {,             return o1.getTerm().compareTo(o2.getTerm());,           },         },       });, ,       return arr;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/handler/component/TermsComponent.java,buildResponse,411-411,[          data = getCountSorted(fieldmap.get(key));],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/handler/component/TermsComponent.java,parse,356-356,[        HashMap<String, TermsResponse.Term> termmap = fieldmap.get(key);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/BinURLDataSource.java,getData,86-86,[    } catch (Exception e) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/dataimport/ConfigParseUtil.java,getStringAttribute,31-31,[    if (r == null || "".equals(r.trim()))],,
BAD_PRACTICE,NM_CONFUSING,org/apache/solr/handler/dataimport/ContextImpl.java,getDataSource,99-109,[    if (ds != null) return ds;,     if(epw==null) { return null; },     if (epw!=null && epw.getDatasource() == null) {,       epw.setDatasource(dataImporter.getDataSourceInstance(epw.getEntity(), epw.getEntity().getDataSourceName(), this));,     },     if (epw!=null && epw.getDatasource() != null && docBuilder != null && docBuilder.verboseDebug &&,              Context.FULL_DUMP.equals(currentProcess())) {,       //debug is not yet implemented properly for deltas,       epw.setDatasource(docBuilder.getDebugLogger().wrapDs(epw.getDatasource()));,     },     return epw.getDatasource();],,getDatasource,313-313,[    return datasource;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/dataimport/ContextImpl.java,getDataSource,101-101,[    if (epw!=null && epw.getDatasource() == null) {],,getDataSource,104-104,[    if (epw!=null && epw.getDatasource() != null && docBuilder != null && docBuilder.verboseDebug &&],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/DIHCacheSupport.java,instantiateCache,113-113,[    } catch (Exception e) {],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/handler/dataimport/DIHWriterBase.java,,34-34,[        if (keyFieldName != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/dataimport/DataImportHandler.java,getStatistics,300-300,[    if (requestStatistics != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/DataImportHandler.java,getSolrWriter,254-254,[      } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/dataimport/DataImportHandler.java,,259-266,[      return new SolrWriter(processor, req) {,         @Override,         public boolean upload(SolrInputDocument document) {,           try {,             return super.upload(document);,           } catch (RuntimeException e) {,             LOG.error("Exception while adding: " + document, e);,             return false;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/DataImporter.java,getEvaluators,534-534,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/DataImporter.java,loadDataConfig,219-219,[    } catch (Exception e) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/solr/handler/dataimport/DateFormatEvaluator.java,getNow,211-211,[        return new Date();],,getNOW,83-95,[    if (now != null) return now;, ,     long ms = 0;,     String nowStr = req.getParams().get(CommonParams.NOW);, ,     if (nowStr != null) {,       ms = Long.parseLong(nowStr);,     } else {,       ms = req.getStartTime();,     }, ,     now = new Date(ms);,     return now;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/dataimport/DateFormatEvaluator.java,,208-211,[    return new DateMathParser(tz, l) {,       @Override,       public Date getNow() {,         return new Date();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/dataimport/DateFormatEvaluator.java,,66-66,[      this.dateFormat = df;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/dataimport/DateFormatEvaluator.java,,64-64,[      this.locale = l;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/dataimport/DateFormatEvaluator.java,,65-65,[      this.timezone = tz;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/dataimport/DebugLogger.java,,61-68,[    debugStack = new Stack<DebugInfo>() {, ,       @Override,       public DebugInfo pop() {,         if (size() == 1),           throw new DataImportHandlerException(,                   DataImportHandlerException.SEVERE, "Stack is becoming empty");,         return super.pop();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/dataimport/DebugLogger.java,,267-267,[      this.name = name;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/dataimport/DebugLogger.java,,269-269,[      this.parent = parent;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/solr/handler/dataimport/DocBuilder.java,doDelta,355-355,[    deletedKeys = null;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/solr/handler/dataimport/DocBuilder.java,getVariableResolver,120-120,[      resolver.setEvaluators(dataImporter.getEvaluators());],,getVariableResolver,114-114,[      if(dataImporter != null && dataImporter.getCore() != null],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/DocBuilder.java,execute,269-269,[    } catch(Exception e)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/DocBuilder.java,getVariableResolver,145-145,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/DocBuilder.java,loadClass,919-919,[      } catch (Exception e1) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/dataimport/DocBuilder.java,,185-188,[      statusMessages.put(TIME_ELAPSED, new Object() {,         @Override,         public String toString() {,           return getTimeElapsedSince(startTime.get());],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/handler/dataimport/DocBuilder.java,,562-572,[  static class DocWrapper extends SolrInputDocument {,     //final SolrInputDocument solrDocument = new SolrInputDocument();,     Map<String ,Object> session;, ,     public void setSessionAttribute(String key, Object val){,       if(session == null) session = new HashMap<>();,       session.put(key, val);,     }, ,     public Object getSessionAttribute(String key) {,       return session == null ? null : session.get(key);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/dataimport/EntityProcessorWrapper.java,,141-141,[      this.clazz = clazz;],,
BAD_PRACTICE,NP_TOSTRING_COULD_RETURN_NULL,org/apache/solr/handler/dataimport/Evaluator.java,toString,132-132,[      return o == null ? null : o.toString();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/FieldReaderDataSource.java,getData,88-88,[      } catch (Exception e) {],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/solr/handler/dataimport/FieldStreamDataSource.java,getData,77-77,[          m.setAccessible(true);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/FieldStreamDataSource.java,getData,80-80,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/FieldStreamDataSource.java,getData,63-89,[    Object o = wrapper.getVariableResolver().resolve(dataField);,     if (o == null) {,       throw new DataImportHandlerException(SEVERE, "No field available for name : " + dataField);,     },     if (o instanceof Blob) {,       Blob blob = (Blob) o;,       try {,         //Most of the JDBC drivers have getBinaryStream defined as public,         // so let us just check it,         Method m = blob.getClass().getDeclaredMethod("getBinaryStream");,         if (Modifier.isPublic(m.getModifiers())) {,           return (InputStream) m.invoke(blob);,         } else {,           // force invoke,           m.setAccessible(true);,           return (InputStream) m.invoke(blob);,         },       } catch (Exception e) {,         LOG.info("Unable to get data from BLOB");,         return null;, ,       },     } else if (o instanceof byte[]) {,       byte[] bytes = (byte[]) o;,       return new ByteArrayInputStream(bytes);,     } else {,       throw new RuntimeException("unsupported type : " + o.getClass());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/dataimport/HTMLStripTransformer.java,stripHTML,64-64,[        if (o != null)],,stripHTML,57-57,[          if (o != null)],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/handler/dataimport/JdbcDataSource.java,closeConnection,443-443,[        } catch(Exception ex) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/handler/dataimport/JdbcDataSource.java,,410-410,[      return conn;],,,405-405,[        return conn = tmpConn;],,,439-439,[      if (conn != null) {],,,442-442,[          conn.commit();],,,446-446,[        conn.close();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/handler/dataimport/JdbcDataSource.java,,133-133,[    return factory = new Callable<Connection>() {],,,402-402,[        Connection tmpConn = factory.call();],,,68-68,[    factory = createConnectionFactory(context, initProps);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/solr/handler/dataimport/JdbcDataSource.java,getData,240-240,[    ResultSetIterator r = new ResultSetIterator(query);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/dataimport/JdbcDataSource.java,,133-225,[    return factory = new Callable<Connection>() {,       @Override,       public Connection call() throws Exception {,         LOG.info("Creating a connection for entity ",                 + context.getEntityAttribute(DataImporter.NAME) + " with URL: ",                 + url);,         long start = System.nanoTime();,         Connection c = null;, ,         if (jndiName != null) {,           c = getFromJndi(initProps, jndiName);,         } else if (url != null) {,           try {,             c = DriverManager.getConnection(url, initProps);,           } catch (SQLException e) {,             // DriverManager does not allow you to use a driver which is not loaded through,             // the class loader of the class which is trying to make the connection.,             // This is a workaround for cases where the user puts the driver jar in the,             // solr.home/lib or solr.home/core/lib directories.,             Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();,             c = d.connect(url, initProps);,           },         },         if (c != null) {,           try {,             initializeConnection(c, initProps);,           } catch (SQLException e) {,             try {,               c.close();,             } catch (SQLException e2) {,               LOG.warn("Exception closing connection during cleanup", e2);,             }, ,             throw new DataImportHandlerException(SEVERE, "Exception initializing SQL connection", e);,           },         },         LOG.info("Time taken for getConnection(): ",             + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));,         return c;,       }, ,       private void initializeConnection(Connection c, final Properties initProps),           throws SQLException {,         if (Boolean.parseBoolean(initProps.getProperty("readOnly"))) {,           c.setReadOnly(true);,           // Add other sane defaults,           c.setAutoCommit(true);,           c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);,           c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);,         },         if (!Boolean.parseBoolean(initProps.getProperty("autoCommit"))) {,           c.setAutoCommit(false);,         },         String transactionIsolation = initProps.getProperty("transactionIsolation");,         if ("TRANSACTION_READ_UNCOMMITTED".equals(transactionIsolation)) {,           c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);,         } else if ("TRANSACTION_READ_COMMITTED".equals(transactionIsolation)) {,           c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);,         } else if ("TRANSACTION_REPEATABLE_READ".equals(transactionIsolation)) {,           c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);,         } else if ("TRANSACTION_SERIALIZABLE".equals(transactionIsolation)) {,           c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);,         } else if ("TRANSACTION_NONE".equals(transactionIsolation)) {,           c.setTransactionIsolation(Connection.TRANSACTION_NONE);,         },         String holdability = initProps.getProperty("holdability");,         if ("CLOSE_CURSORS_AT_COMMIT".equals(holdability)) {,           c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);,         } else if ("HOLD_CURSORS_OVER_COMMIT".equals(holdability)) {,           c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);,         },       }, ,       private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,,           SQLException {, ,         Connection c = null;,         InitialContext ctx =  new InitialContext();,         Object jndival =  ctx.lookup(jndiName);,         if (jndival instanceof javax.sql.DataSource) {,           javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;,           String user = (String) initProps.get("user");,           String pass = (String) initProps.get("password");,           if(user == null || user.trim().equals("")){,             c = dataSource.getConnection();,           } else {,             c = dataSource.getConnection(user, pass);,           },         } else {,           throw new DataImportHandlerException(SEVERE,,                   "the jndi name : '"+jndiName +"' is not a valid javax.sql.DataSource");,         },         return c;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/solr/handler/dataimport/JdbcDataSource.java,<init>,281-281,[        colNames = readFieldNames(resultSet.getMetaData());],,<init>,285-285,[      if (resultSet == null) {],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/solr/handler/dataimport/JdbcDataSource.java,<init>,276-276,[        if (stmt.execute(query)) {],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/solr/handler/dataimport/JdbcDataSource.java,next,298-298,[          return getARow();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/handler/dataimport/MailEntityProcessor.java,getIntFromContext,845-845,[        v = Integer.valueOf(val);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/dataimport/MailEntityProcessor.java,init,148-148,[      if (lastIndexTime != null && lastIndexTime.length() == 0)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/MailEntityProcessor.java,createFilters,421-421,[      } catch (Exception e) {],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/solr/handler/dataimport/MailEntityProcessor.java,init,119-119,[        tmp = sinceDateParser.parse((String)varValue);],,init,160-160,[        fetchMailsSince = sinceDateParser.parse(lastIndexTime);],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/solr/handler/dataimport/MailEntityProcessor.java,next,495-533,[        boolean hasMessages = false;,         Folder next;,         do {,           if (lastFolder != null) {,             lastFolder.close(false);,             lastFolder = null;,           },           if (folders.isEmpty()) {,             mailbox.close();,             return null;,           },           next = folders.remove(0);,           if (next != null) {,             String fullName = next.getFullName();,             if (!excludeFolder(fullName)) {,               hasMessages = (next.getType() & Folder.HOLDS_MESSAGES) != 0;,               next.open(Folder.READ_ONLY);,               lastFolder = next;,               LOG.info("Opened folder : " + fullName);,             },             if (recurse && ((next.getType() & Folder.HOLDS_FOLDERS) != 0)) {,               Folder[] children = next.list();,               LOG.info("Added its children to list  : ");,               for (int i = children.length - 1; i >= 0; i--) {,                 folders.add(0, children[i]);,                 LOG.info("child name : " + children[i].getFullName());,               },               if (children.length == 0) LOG.info("NO children : ");,             },           },         } while (!hasMessages);,         return next;,       } catch (Exception e) {,         LOG.warn("Failed to read folders due to: "+e);,         // throw new,         // DataImportHandlerException(DataImportHandlerException.SEVERE,,         // "Folder open failed", e);,       },       return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/dataimport/MailEntityProcessor.java,,730-742,[  class MailsSinceLastCheckFilter implements CustomFilter {,     ,     private Date since;,     ,     public MailsSinceLastCheckFilter(Date date) {,       since = date;,     },     ,     @SuppressWarnings("serial"),     public SearchTerm getCustomSearch(final Folder folder) {,       LOG.info("Building mail filter for messages in " + folder.getName(),           + " that occur after " + sinceDateParser.format(since));,       return new DateTerm(ComparisonTerm.GE, since) {],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/solr/handler/dataimport/RequestInfo.java,<init>,101-101,[      entitiesToRun = Collections.unmodifiableList(modifiableEntities);],,<init>,91-91,[    List<String> modifiableEntities = null;],,<init>,96-96,[      } else if (o instanceof List<?>) {],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/handler/dataimport/SimplePropertiesWriter.java,readIndexerProperties,227-227,[      props.load(new InputStreamReader(propInput, StandardCharsets.UTF_8));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/SimplePropertiesWriter.java,readIndexerProperties,229-229,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/SimplePropertiesWriter.java,persist,208-208,[    } catch (Exception e) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/solr/handler/dataimport/SolrWriter.java,,41-165,[  private static final Logger log = LoggerFactory.getLogger(SolrWriter.class);, ,   public static final String LAST_INDEX_KEY = "last_index_time";, ,   private final UpdateRequestProcessor processor;,   private final int commitWithin;,   ,   SolrQueryRequest req;, ,   public SolrWriter(UpdateRequestProcessor processor, SolrQueryRequest req) {,     this.processor = processor;,     this.req = req;,     commitWithin = (req != null) ? req.getParams().getInt(UpdateParams.COMMIT_WITHIN, -1): -1;,   },   ,   @Override,   public void close() {,     try {,       processor.finish();,     } catch (IOException e) {,       throw new DataImportHandlerException(DataImportHandlerException.SEVERE,,           "Unable to call finish() on UpdateRequestProcessor", e);,     },   },   @Override,   public boolean upload(SolrInputDocument d) {,     try {,       AddUpdateCommand command = new AddUpdateCommand(req);,       command.solrDoc = d;,       command.commitWithin = commitWithin;,       processor.processAdd(command);,     } catch (Exception e) {,       log.warn("Error creating document : " + d, e);,       return false;,     }, ,     return true;,   },   ,   @Override,   public void deleteDoc(Object id) {,     try {,       log.info("Deleting document: " + id);,       DeleteUpdateCommand delCmd = new DeleteUpdateCommand(req);,       delCmd.setId(id.toString());,       processor.processDelete(delCmd);,     } catch (IOException e) {,       log.error("Exception while deleteing: " + id, e);,     },   }, ,   @Override,   public void deleteByQuery(String query) {,     try {,       log.info("Deleting documents from Solr with query: " + query);,       DeleteUpdateCommand delCmd = new DeleteUpdateCommand(req);,       delCmd.query = query;,       processor.processDelete(delCmd);,     } catch (IOException e) {,       log.error("Exception while deleting by query: " + query, e);,     },   }, ,   @Override,   public void commit(boolean optimize) {,     try {,       CommitUpdateCommand commit = new CommitUpdateCommand(req,optimize);,       processor.processCommit(commit);,     } catch (Exception e) {,       log.error("Exception while solr commit.", e);,     },   }, ,   @Override,   public void rollback() {,     try {,       RollbackUpdateCommand rollback = new RollbackUpdateCommand(req);,       processor.processRollback(rollback);,     } catch (Exception e) {,       log.error("Exception during rollback command.", e);,     },   }, ,   @Override,   public void doDeleteAll() {,     try {,       DeleteUpdateCommand deleteCommand = new DeleteUpdateCommand(req);,       deleteCommand.query = "*:*";,       processor.processDelete(deleteCommand);,     } catch (IOException e) {,       throw new DataImportHandlerException(DataImportHandlerException.SEVERE,,               "Exception in full dump while deleting all documents.", e);,     },   }, ,   static String getResourceAsString(InputStream in) throws IOException {,     ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);,     byte[] buf = new byte[1024];,     int sz = 0;,     try {,       while ((sz = in.read(buf)) != -1) {,         baos.write(buf, 0, sz);,       },     } finally {,       try {,         in.close();,       } catch (Exception e) {, ,       },     },     return new String(baos.toByteArray(), StandardCharsets.UTF_8);,   }, ,   static String getDocCount() {,     if (DocBuilder.INSTANCE.get() != null) {,       return "",               + (DocBuilder.INSTANCE.get().importStatistics.docCount.get() + 1);,     } else {,       return null;,     },   },   @Override,   public void init(Context context) {,     /* NO-OP */,   }],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/solr/handler/dataimport/SqlEntityProcessor.java,getDeltaImportQuery,151-151,[        sb.append("'").append(val.toString()).append("'");],,getDeltaImportQuery,141-141,[      if (val == null) {],,getDeltaImportQuery,143-143,[        if (m.find()) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/URLDataSource.java,getData,113-113,[    } catch (Exception e) {],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/solr/handler/dataimport/UrlEvaluator.java,evaluate,42-42,[      return URLEncoder.encode(s.toString(), "UTF-8");],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/dataimport/VariableResolver.java,getResolved,184-184,[    if (r == null) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/dataimport/VariableResolver.java,,211-214,[    CurrentLevel(int level, Map<String,Object> map) {,       this.level = level;,       this.map = map;,     }   ],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/handler/dataimport/VariableResolver.java,,59-62,[  class Resolved {,     List<Integer> startIndexes = new ArrayList<>(2);,     List<Integer> endOffsets = new ArrayList<>(2);,     List<String> variables = new ArrayList<>(2);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/XPathEntityProcessor.java,initXpathReader,138-138,[      } catch (Exception e) {],,
MT_CORRECTNESS,NN_NAKED_NOTIFY,org/apache/solr/handler/dataimport/XPathEntityProcessor.java,offer,468-468,[            notifyAll();],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/solr/handler/dataimport/XPathEntityProcessor.java,next,491-518,[            row = blockingQueue.poll(blockingQueueTimeOut, blockingQueueTimeOutUnits);,             if (row == null) {,               LOG.debug("Timeout elapsed reading records.");,             },           } catch (InterruptedException e) {,             LOG.debug("Caught InterruptedException while waiting for row.  Aborting.");,             isEnd.set(true);,             return null;,           },         } while (row == null);,         ,         if (row == END_MARKER) {,           isEnd.set(true);,           if (exp.get() != null) {,             String msg = "Parsing failed for xml, url:" + s + " rows processed in this xml:" + count;,             if (lastRow != null) msg += " last row in this xml:" + lastRow;,             if (ABORT.equals(onError)) {,               wrapAndThrow(SEVERE, exp.get(), msg);,             } else if (SKIP.equals(onError)) {,               wrapAndThrow(DataImportHandlerException.SKIP, exp.get());,             } else {,               LOG.warn(msg, exp.get());,             },           },           return null;,         } ,         count++;,         return lastRow = row;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/XPathRecordReader.java,streamRecords,188-188,[    } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/dataimport/XPathRecordReader.java,,166-170,[    streamRecords(r, new Handler() {,       @Override,       public void handle(Map<String, Object> record, String s) {,         results.add(record);,       }],,
BAD_PRACTICE,DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS,org/apache/solr/handler/dataimport/XPathRecordReader.java,getOrAddNode,582-582,[          n.attribAndValues.addAll(attribs.entrySet());],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/dataimport/XPathRecordReader.java,,225-225,[      parent = p;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/handler/dataimport/ZKPropertiesWriter.java,readIndexerProperties,95-95,[    } catch (Exception e) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/dataimport/config/ConfigParseUtil.java,getStringAttribute,39-39,[    if (r == null || "".equals(r.trim())) r = def;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/handler/dataimport/config/Entity.java,,53-53,[    this.config = config;],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/handler/dataimport/config/Field.java,,48-48,[    this.entity = b.entity;],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/handler/dataimport/config/Field.java,,47-47,[    this.dynamicName = b.dynamicName;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/dataimport/config/Script.java,<init>,30-30,[    if (script != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/handler/extraction/ExtractingDocumentLoader.java,load,208-208,[            if(is != null) {],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/handler/extraction/RegexRulesPasswordProvider.java,parseRulesFile,77-77,[    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/handler/extraction/SolrContentHandler.java,transformValue,332-332,[      } catch (Exception e) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/handler/extraction/SolrContentHandler.java,addField,215-215,[    if (sf == null && unknownFieldPrefix.length()==0 && name == TikaMetadataKeys.RESOURCE_NAME_KEY) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/handler/loader/CSVLoaderBase.java,<init>,222-222,[        hasHeader=true;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/handler/loader/CSVLoaderBase.java,doAdd,388-388,[      String val = literals.get(fname);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/loader/JavabinLoader.java,,51-51,[  public static Logger log = LoggerFactory.getLogger(JavabinLoader.class);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/solr/handler/loader/JsonLoader.java,processUpdate,178-184,[          log.info( "can't have a value here! ",               +JSONParser.getEventString(ev)+" "+parser.getPosition() );, ,         case JSONParser.OBJECT_START:,         case JSONParser.OBJECT_END:,         case JSONParser.ARRAY_END:,           break;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/handler/loader/JsonLoader.java,,415-429,[      SolrParams p = new SolrParams() {,         @Override,         public String get(String param) {,           Object o = map.get(param);,           return o == null ? null : o.toString();,         }, ,         @Override,         public String[] getParams(String param) {,           return new String[]{get(param)};,         }, ,         @Override,         public Iterator<String> getParameterNamesIterator() {,           return map.keySet().iterator();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/handler/loader/XMLLoader.java,,70-70,[  public static Logger log = LoggerFactory.getLogger(XMLLoader.class);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/handler/loader/XMLLoader.java,processDelete,313-357,[      switch (event) {,         case XMLStreamConstants.START_ELEMENT:,           String mode = parser.getLocalName();,           if (!("id".equals(mode) || "query".equals(mode))) {,             String msg = "XML element <delete> has invalid XML child element: " + mode;,             log.warn(msg);,             throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,,                                     msg);,           },           text.setLength(0);,           ,           if ("id".equals(mode)) {,             for (int i = 0; i < parser.getAttributeCount(); i++) {,               String attrName = parser.getAttributeLocalName(i);,               String attrVal = parser.getAttributeValue(i);,               if (UpdateRequestHandler.VERSION.equals(attrName)) {,                 deleteCmd.setVersion(Long.parseLong(attrVal));,               },             },           },           break;, ,         case XMLStreamConstants.END_ELEMENT:,           String currTag = parser.getLocalName();,           if ("id".equals(currTag)) {,             deleteCmd.setId(text.toString());         ,           } else if ("query".equals(currTag)) {,             deleteCmd.setQuery(text.toString());,           } else if ("delete".equals(currTag)) {,             return;,           } else {,             String msg = "XML element <delete> has invalid XML (closing) child element: " + currTag;,             log.warn(msg);,             throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,,                                     msg);,           },           processor.processDelete(deleteCmd);,           deleteCmd.clear();,           break;, ,           // Add everything to the text,         case XMLStreamConstants.SPACE:,         case XMLStreamConstants.CDATA:,         case XMLStreamConstants.CHARACTERS:,           text.append(parser.getText());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/handler/loader/XMLLoader.java,processUpdate,214-278,[      switch (event) {,         case XMLStreamConstants.END_DOCUMENT:,           parser.close();,           return;, ,         case XMLStreamConstants.START_ELEMENT:,           String currTag = parser.getLocalName();,           if (currTag.equals(UpdateRequestHandler.ADD)) {,             log.trace("SolrCore.update(add)");, ,             addCmd = new AddUpdateCommand(req);, ,             // First look for commitWithin parameter on the request, will be overwritten for individual <add>'s,             addCmd.commitWithin = params.getInt(UpdateParams.COMMIT_WITHIN, -1);,             addCmd.overwrite = params.getBool(UpdateParams.OVERWRITE, true);,             ,             for (int i = 0; i < parser.getAttributeCount(); i++) {,               String attrName = parser.getAttributeLocalName(i);,               String attrVal = parser.getAttributeValue(i);,               if (UpdateRequestHandler.OVERWRITE.equals(attrName)) {,                 addCmd.overwrite = StrUtils.parseBoolean(attrVal);,               } else if (UpdateRequestHandler.COMMIT_WITHIN.equals(attrName)) {,                 addCmd.commitWithin = Integer.parseInt(attrVal);,               } else {,                 log.warn("XML element <add> has invalid XML attr: " + attrName);,               },             }, ,           } else if ("doc".equals(currTag)) {,             if(addCmd != null) {,               log.trace("adding doc...");,               addCmd.clear();,               addCmd.solrDoc = readDoc(parser);,               processor.processAdd(addCmd);,             } else {,               throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Unexpected <doc> tag without an <add> tag surrounding it.");,             },           } else if (UpdateRequestHandler.COMMIT.equals(currTag) || UpdateRequestHandler.OPTIMIZE.equals(currTag)) {,             log.trace("parsing " + currTag);, ,             CommitUpdateCommand cmd = new CommitUpdateCommand(req, UpdateRequestHandler.OPTIMIZE.equals(currTag));,             ModifiableSolrParams mp = new ModifiableSolrParams();,             ,             for (int i = 0; i < parser.getAttributeCount(); i++) {,               String attrName = parser.getAttributeLocalName(i);,               String attrVal = parser.getAttributeValue(i);,               mp.set(attrName, attrVal);,             }, ,             RequestHandlerUtils.validateCommitParams(mp);,             SolrParams p = SolrParams.wrapDefaults(mp, req.getParams());   // default to the normal request params for commit options,             RequestHandlerUtils.updateCommit(cmd, p);, ,             processor.processCommit(cmd);,           } // end commit,           else if (UpdateRequestHandler.ROLLBACK.equals(currTag)) {,             log.trace("parsing rollback");, ,             RollbackUpdateCommand cmd = new RollbackUpdateCommand(req);, ,             processor.processRollback(cmd);,           } // end rollback,           else if (UpdateRequestHandler.DELETE.equals(currTag)) {,             log.trace("parsing delete");,             processDelete(req, processor, parser);],,
PERFORMANCE,DM_STRING_CTOR,org/apache/solr/highlight/DefaultSolrHighlighter.java,alternateField,681-681,[                encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/highlight/DefaultSolrHighlighter.java,,81-81,[  public static Logger log = LoggerFactory.getLogger(DefaultSolrHighlighter.class);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/highlight/DefaultSolrHighlighter.java,,582-585,[      Collections.sort(frags, new Comparator<TextFragment>() {,         @Override,         public int compare(TextFragment arg0, TextFragment arg1) {,           return Math.round(arg1.getScore() - arg0.getScore());],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/highlight/HighlightingPluginBase.java,getDocs,70-70,[    return null;  // this can be overridden, but not required],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/highlight/GapFragmenter.java,isNewFragment,90-90,[    int endOffset = offsetAtt.endOffset();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/highlight/GapFragmenter.java,isNewFragment,93-93,[      posIncAtt.getPositionIncrement() > INCREMENT_THRESHOLD;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/highlight/RegexFragmenter.java,getFragmenter,78-78,[    Pattern p = rawpat == defaultPatternRaw ? defaultPattern : Pattern.compile(rawpat);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/solr/highlight/SolrBoundaryScanner.java,,25-32,[public abstract class SolrBoundaryScanner extends HighlightingPluginBase implements,     SolrInfoMBean, NamedListInitializedPlugin {, ,   public BoundaryScanner getBoundaryScanner(String fieldName, SolrParams params){,     numRequests++;,     params = SolrParams.wrapDefaults(params, defaults);, ,     return get(fieldName, params);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/solr/highlight/SolrFragmentsBuilder.java,,28-79,[public abstract class SolrFragmentsBuilder extends HighlightingPluginBase,   implements SolrInfoMBean, NamedListInitializedPlugin {,   ,   public static final String DEFAULT_PRE_TAGS = "<em>";,   public static final String DEFAULT_POST_TAGS = "</em>";, ,   /**,    * Return a {@link org.apache.lucene.search.vectorhighlight.FragmentsBuilder} appropriate for this field.,    * ,    * @param params The params controlling Highlighting,    * @return An appropriate {@link org.apache.lucene.search.vectorhighlight.FragmentsBuilder}.,    */,   public FragmentsBuilder getFragmentsBuilder(SolrParams params, BoundaryScanner bs) {,     numRequests++;,     params = SolrParams.wrapDefaults(params, defaults);, ,     return getFragmentsBuilder( params, getPreTags( params, null ), getPostTags( params, null ), bs );,   },   ,   public String[] getPreTags( SolrParams params, String fieldName ){,     return getTags( params, HighlightParams.TAG_PRE, fieldName, DEFAULT_PRE_TAGS );,   },   ,   public String[] getPostTags( SolrParams params, String fieldName ){,     return getTags( params, HighlightParams.TAG_POST, fieldName, DEFAULT_POST_TAGS );,   },   ,   private String[] getTags( SolrParams params, String paramName, String fieldName, String def ){,     params = SolrParams.wrapDefaults(params, defaults);, ,     String value = null;,     if( fieldName == null ),       value = params.get( paramName, def );,     else,       value = params.getFieldParam( fieldName, paramName, def );,     String[] tags = value.split( "," );,     for( int i = 0; i < tags.length; i++ ){,       tags[i] = tags[i].trim();,     },     return tags;,   },   ,   protected abstract FragmentsBuilder getFragmentsBuilder( SolrParams params,,       String[] preTags, String[] postTags, BoundaryScanner bs );,   ,   protected char getMultiValuedSeparatorChar( SolrParams params ){,     String separator = params.get( HighlightParams.MULTI_VALUED_SEPARATOR, " " );,     if( separator.length() > 1 ){,       throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,,           HighlightParams.MULTI_VALUED_SEPARATOR + " parameter must be a char, but is \"" + separator + "\"" );,     },     return separator.charAt( 0 );],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/highlight/SolrHighlighter.java,,38-38,[  public static int DEFAULT_PHRASE_LIMIT = 5000;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/highlight/SolrHighlighter.java,,39-39,[  public static Logger log = LoggerFactory.getLogger(SolrHighlighter.class);],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/solr/internal/csv/CSVParser.java,getLine,234-235,[                record.add(reusableToken.content.toString());,                 break;],,getLine,237-238,[                record.add(reusableToken.content.toString());,                 break;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/internal/csv/CSVParser.java,unicodeEscapeLexer,514-514,[    c = in.read();],,
CORRECTNESS,IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN,org/apache/solr/internal/csv/CSVParser.java,unicodeEscapeLexer,514-514,[    c = in.read();],,
CORRECTNESS,IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN,org/apache/solr/internal/csv/CSVParser.java,encapsulatedTokenLexer,451-451,[      c = in.read();],,
CORRECTNESS,IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN,org/apache/solr/internal/csv/CSVParser.java,readEscape,535-535,[    c = in.read();],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/solr/internal/csv/CSVPrinter.java,printlnComment,108-112,[            i++;,           },           // break intentionally excluded.,         case '\n' :,           println();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/internal/csv/CSVStrategy.java,,44-44,[    public static char COMMENTS_DISABLED       = (char)-2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/internal/csv/CSVStrategy.java,,48-48,[    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, ],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/internal/csv/CSVStrategy.java,,46-46,[    public static char ENCAPSULATOR_DISABLED   = (char)-2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/internal/csv/CSVStrategy.java,,45-45,[    public static char ESCAPE_DISABLED         = (char)-2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/internal/csv/CSVStrategy.java,,50-50,[    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(',', '"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, ],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/internal/csv/CSVStrategy.java,,52-52,[    public static CSVStrategy TDF_STRATEGY     = new CSVStrategy('\t', '"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, ],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/internal/csv/CSVStrategy.java,,38-148,[    private String printerNewline = "\n";, ,     // -2 is used to signal disabled, because it won't be confused with,     // an EOF signal (-1), and because \ufffe in UTF-16 would be,     // encoded as two chars (using surrogates) and thus there should never,     // be a collision with a real text char.,     public static char COMMENTS_DISABLED       = (char)-2;,     public static char ESCAPE_DISABLED         = (char)-2;,     public static char ENCAPSULATOR_DISABLED   = (char)-2;, ,     public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, ,                                                                  true, false, true);,     public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(',', '"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, ,                                                                  false, false, false);,     public static CSVStrategy TDF_STRATEGY     = new CSVStrategy('\t', '"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, ,                                                                  true, false, true);, , ,     public CSVStrategy(char delimiter, char encapsulator, char commentStart) {,         this(delimiter, encapsulator, commentStart, true, false, true);,     },   ,     /**,      * Customized CSV strategy setter.,      * ,      * @param delimiter a Char used for value separation,      * @param encapsulator a Char used as value encapsulation marker,      * @param commentStart a Char used for comment identification,      * @param ignoreLeadingWhitespace TRUE when leading whitespaces should be,      *                                ignored,      * @param interpretUnicodeEscapes TRUE when unicode escapes should be ,      *                                interpreted,      * @param ignoreEmptyLines TRUE when the parser should skip emtpy lines,      */,     public CSVStrategy(,         char delimiter, ,         char encapsulator, ,         char commentStart,,         char escape,,         boolean ignoreLeadingWhitespace, ,         boolean ignoreTrailingWhitespace, ,         boolean interpretUnicodeEscapes,,         boolean ignoreEmptyLines) ,     {,         setDelimiter(delimiter);,         setEncapsulator(encapsulator);,         setCommentStart(commentStart);,         setEscape(escape);,         setIgnoreLeadingWhitespaces(ignoreLeadingWhitespace);,         setIgnoreTrailingWhitespaces(ignoreTrailingWhitespace);,         setUnicodeEscapeInterpretation(interpretUnicodeEscapes);,         setIgnoreEmptyLines(ignoreEmptyLines);,     }, ,     /** @deprecated Use {@link #CSVStrategy(char, char, char, char, boolean, boolean, boolean, boolean)} */,     public CSVStrategy(,         char delimiter,,         char encapsulator,,         char commentStart,,         boolean ignoreLeadingWhitespace,,         boolean interpretUnicodeEscapes,,         boolean ignoreEmptyLines),     {,         this(delimiter, encapsulator, commentStart, CSVStrategy.ESCAPE_DISABLED, ignoreLeadingWhitespace, ,              true, interpretUnicodeEscapes, ignoreEmptyLines);,     }, ,     public void setDelimiter(char delimiter) { this.delimiter = delimiter; },     public char getDelimiter() { return this.delimiter; }, ,     public void setEncapsulator(char encapsulator) { this.encapsulator = encapsulator; },     public char getEncapsulator() { return this.encapsulator; }, ,     public void setCommentStart(char commentStart) { this.commentStart = commentStart; },     public char getCommentStart() { return this.commentStart; },     public boolean isCommentingDisabled() { return this.commentStart == COMMENTS_DISABLED; }, ,     public void setEscape(char escape) { this.escape = escape; },     public char getEscape() { return this.escape; }, ,     public void setIgnoreLeadingWhitespaces(boolean ignoreLeadingWhitespaces) { ,         this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces; ,     },     public boolean getIgnoreLeadingWhitespaces() { return this.ignoreLeadingWhitespaces; }, ,     public void setIgnoreTrailingWhitespaces(boolean ignoreTrailingWhitespaces) { ,         this.ignoreTrailingWhitespaces = ignoreTrailingWhitespaces; ,     },     public boolean getIgnoreTrailingWhitespaces() { return this.ignoreTrailingWhitespaces; }, ,     public void setUnicodeEscapeInterpretation(boolean interpretUnicodeEscapes) { ,         this.interpretUnicodeEscapes = interpretUnicodeEscapes; ,     },     public boolean getUnicodeEscapeInterpretation() { return this.interpretUnicodeEscapes; }, ,     public void setIgnoreEmptyLines(boolean ignoreEmptyLines) { this.ignoreEmptyLines = ignoreEmptyLines; },     public boolean getIgnoreEmptyLines() { return this.ignoreEmptyLines; }, ,     public void setPrinterNewline(String newline) {,       this.printerNewline = newline;,     },     public String getPrinterNewline() {,       return this.printerNewline;,     }, ,     @Override,     public Object clone() {,       try {,         return super.clone();,       } catch (CloneNotSupportedException e) {,         throw new RuntimeException(e);  // impossible],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/internal/csv/CharBuffer.java,getCharacters,176-176,[            return c;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/solr/internal/csv/writer/CSVConfig.java,equals,251-254,[        if (obj == null && !(obj instanceof CSVConfig)) {,             return false;,         },         return super.equals(obj);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/internal/csv/writer/CSVConfig.java,equals,251-251,[        if (obj == null && !(obj instanceof CSVConfig)) {],,
CORRECTNESS,NP_NULL_INSTANCEOF,org/apache/solr/internal/csv/writer/CSVConfig.java,equals,251-251,[        if (obj == null && !(obj instanceof CSVConfig)) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/internal/csv/writer/CSVConfigGuesser.java,guess,99-99,[                } catch(Exception e) {],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/internal/csv/writer/CSVConfigGuesser.java,guess,78-78,[            BufferedReader bIn = new BufferedReader(new InputStreamReader(getInputStream(), StandardCharsets.UTF_8));],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/logging/CircularList.java,,77-77,[    return data.length;],,,65-65,[    return (index + head) % data.length;],,,87-87,[    return data[convert(index)];],,,113-113,[      list.add( data[convert(i)] );],,,91-91,[    data[tail] = o;],,,92-92,[    tail = (tail+1)%data.length;],,,93-93,[    if( size == data.length ) {],,,97-97,[    if( size > data.length ) {],,,94-94,[      head = (head+1)%data.length;],,,98-98,[      size = data.length;],,,59-59,[    data = vals;],,,56-56,[        vals[i] = data[convert(i+off)];],,,50-50,[        vals[i] = data[convert(i)];],,,103-103,[    for( int i=0; i<data.length; i++ ) {],,,104-104,[      data[i] = null;  // for GC],,,127-127,[      str.append( data[convert(i)] );],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/logging/CircularList.java,,69-69,[    return head == tail; // or size == 0],,,65-65,[    return (index + head) % data.length;],,,94-94,[      head = (head+1)%data.length;],,,60-60,[    head = 0;],,,106-106,[    head = tail = size = 0;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/logging/CircularList.java,,81-81,[    if (index >= size || index < 0)],,,82-82,[      throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);],,,73-73,[    return size;],,,111-111,[    ArrayList<T> list = new ArrayList<>( size );],,,112-112,[    for( int i=0; i<size; i++ ) {],,,93-93,[    if( size == data.length ) {],,,96-96,[    size++;],,,97-97,[    if( size > data.length ) {],,,98-98,[      size = data.length;],,,44-44,[    if(newsize==this.size) return;],,,48-48,[    if(newsize>size) {],,,54-54,[      int off=size-newsize;],,,49-49,[      for(i=0; i<size; i++) {],,,106-106,[    head = tail = size = 0;],,,123-123,[    for( int i=0; i<size; i++ ) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/logging/CircularList.java,,69-69,[    return head == tail; // or size == 0],,,91-91,[    data[tail] = o;],,,92-92,[    tail = (tail+1)%data.length;],,,61-61,[    tail = i;],,,106-106,[    head = tail = size = 0;],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/solr/logging/CircularList.java,next,145-145,[        return get( idx++ );],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/solr/logging/LogWatcher.java,createWatcher,157-157,[        } else if (slf4jImpl.indexOf("JDK") > 0) {],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/logging/LoggerInfo.java,compareTo,55-66,[    if (this.equals(other)),       return 0;, ,     String tN = this.getName();,     String oN = other.getName();, ,     if(ROOT_NAME.equals(tN)),       return -1;,     if(ROOT_NAME.equals(oN)),       return 1;, ,     return tN.compareTo(oN);],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/logging/LoggerInfo.java,,36-36,[    return level;],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/solr/logging/jul/JulWatcher.java,toSolrDocument,160-160,[    doc.setField("message", event.getMessage().toString());],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/solr/morphlines/solr/AbstractSolrMorphlineTestBase.java,testDocumentContent,275-275,[            for (Iterator<Object> it = actualFieldValues.iterator(); it.hasNext(); ) {],,testDocumentContent,277-277,[              if (actualFieldValues != null && actualValue.contains(expectedFieldValue)) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/morphlines/solr/AbstractSolrMorphlineTestBase.java,queryResultSetSize,213-213,[    } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/morphlines/solr/AbstractSolrMorphlineTestBase.java,setupMorphline,315-315,[    new File(tempDir + "/" + file + ".conf").getParentFile().mkdirs();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/morphlines/solr/AbstractSolrMorphlineZkTestBase.java,uploadConfFiles,184-184,[    for (File f : dir.listFiles()) {],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/morphlines/solr/EmbeddedTestSolrServer.java,,33-43,[    super(coreContainer, coreName);,   }, ,   @Override,   public void shutdown() {,     ; // NOP,   }, ,   @Override,   public UpdateResponse rollback() throws SolrServerException, IOException {,     return new UpdateResponse();],,
CORRECTNESS,RV_ABSOLUTE_VALUE_OF_RANDOM_INT,org/apache/solr/morphlines/solr/GenerateSolrSequenceKeyBuilder.java,doProcess,125-125,[        id = String.valueOf(Math.abs(randomIdPrefix.nextInt())) + "#" + id;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/morphlines/solr/SafeConcurrentUpdateSolrClient.java,,28-66,[final class SafeConcurrentUpdateSolrClient extends ConcurrentUpdateSolrClient {, ,   private Throwable currentException = null;,   private final Object myLock = new Object();, ,   private static final Logger LOGGER = LoggerFactory.getLogger(SafeConcurrentUpdateSolrClient.class);, ,   public SafeConcurrentUpdateSolrClient(String solrServerUrl, int queueSize, int threadCount) {,     this(solrServerUrl, null, queueSize, threadCount);,   }, ,   public SafeConcurrentUpdateSolrClient(String solrServerUrl, HttpClient client, int queueSize, int threadCount) {,     super(solrServerUrl, client, queueSize, threadCount);,   }, ,   @Override,   public void handleError(Throwable ex) {,     assert ex != null;,     synchronized (myLock) {,       currentException = ex;,     },     LOGGER.error("handleError", ex);,   }, ,   @Override,   public void blockUntilFinished() {,     super.blockUntilFinished();,     synchronized (myLock) {,       if (currentException != null) {,         throw new RuntimeException(currentException);,       },     },   }, ,   public void clearException() {,     synchronized (myLock) {,       currentException = null;,     },   }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/solr/morphlines/solr/SolrMorphlineZkAvroTest.java,toString,165-169,[    Record record = new Record();,     for (Field field : avroRecord.getSchema().getFields()) {,       record.put(field.name(), avroRecord.get(field.pos()));,     },     return record.toString(); // prints sorted by key for human readability],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/morphlines/solr/SolrMorphlineZkAvroTest.java,,89-92,[    Collections.sort(collector.getRecords(), new Comparator<Record>() {,       @Override,       public int compare(Record r1, Record r2) {,         return r1.get("id").toString().compareTo(r2.get("id").toString());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/morphlines/solr/SolrMorphlineZkAvroTest.java,,104-107,[    Collections.sort(records, new Comparator<GenericData.Record>() {,       @Override,       public int compare(GenericData.Record r1, GenericData.Record r2) {,         return r1.get("id").toString().compareTo(r2.get("id").toString());],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/FastCharStream.java,BeginToken,82-83,[    tokenStart = bufferPosition;,     return readChar();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/FastCharStream.java,Done,106-109,[      input.close();,     } catch (IOException e) {,     },   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/FastCharStream.java,GetImage,93-93,[    return new String(buffer, tokenStart, bufferPosition - tokenStart);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/FastCharStream.java,GetSuffix,98-100,[    char[] value = new char[len];,     System.arraycopy(buffer, bufferPosition - len, value, 0, len);,     return value;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/parser/ParseException.java,<init>,36-36,[    expectedTokenSequences = expectedTokenSequencesVal;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/parser/ParseException.java,<init>,37-37,[    tokenImage = tokenImageVal;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/solr/parser/ParseException.java,initialise,117-117,[      retval += " \"";],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParser.java,Clause,152-219,[  Token fieldToken=null, boost=null;,   Token localParams=null;,     if (jj_2_1(2)) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case TERM:,         fieldToken = jj_consume_token(TERM);,         jj_consume_token(COLON);,                                field=discardEscapeChar(fieldToken.image);,         break;,       case STAR:,         jj_consume_token(STAR);,         jj_consume_token(COLON);,                       field="*";,         break;,       default:,         jj_la1[5] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     } else {,       ;,     },     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case BAREOPER:,     case STAR:,     case QUOTED:,     case TERM:,     case PREFIXTERM:,     case WILDTERM:,     case REGEXPTERM:,     case RANGEIN_START:,     case RANGEEX_START:,     case NUMBER:,       q = Term(field);,       break;,     case LPAREN:,       jj_consume_token(LPAREN);,       q = Query(field);,       jj_consume_token(RPAREN);,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[6] = jj_gen;,         ;,       },       break;,     case LPARAMS:,       localParams = jj_consume_token(LPARAMS);,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[7] = jj_gen;,         ;,       },                                                           q=getLocalParams(field, localParams.image);,       break;,     default:,       jj_la1[8] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },        {if (true) return handleBoost(q, boost);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParser.java,Conjunction,33-56,[  int ret = CONJ_NONE;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case AND:,     case OR:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case AND:,         jj_consume_token(AND);,             ret = CONJ_AND;,         break;,       case OR:,         jj_consume_token(OR);,               ret = CONJ_OR;,         break;,       default:,         jj_la1[0] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[1] = jj_gen;,       ;,     },     {if (true) return ret;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParser.java,Modifiers,61-89,[  int ret = MOD_NONE;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case NOT:,     case PLUS:,     case MINUS:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case PLUS:,         jj_consume_token(PLUS);,               ret = MOD_REQ;,         break;,       case MINUS:,         jj_consume_token(MINUS);,                  ret = MOD_NOT;,         break;,       case NOT:,         jj_consume_token(NOT);,                ret = MOD_NOT;,         break;,       default:,         jj_la1[2] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[3] = jj_gen;,       ;,     },     {if (true) return ret;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParser.java,Query,103-145,[  List<BooleanClause> clauses = new ArrayList<>();,   Query q, firstQuery=null;,   int conj, mods;,     mods = Modifiers();,     q = Clause(field);,     addClause(clauses, CONJ_NONE, mods, q);,     if (mods == MOD_NONE),         firstQuery=q;,     label_1:,     while (true) {,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case AND:,       case OR:,       case NOT:,       case PLUS:,       case MINUS:,       case BAREOPER:,       case LPAREN:,       case STAR:,       case QUOTED:,       case TERM:,       case PREFIXTERM:,       case WILDTERM:,       case REGEXPTERM:,       case RANGEIN_START:,       case RANGEEX_START:,       case LPARAMS:,       case NUMBER:,         ;,         break;,       default:,         jj_la1[4] = jj_gen;,         break label_1;,       },       conj = Conjunction();,       mods = Modifiers();,       q = Clause(field);,       addClause(clauses, conj, mods, q);,     },       if (clauses.size() == 1 && firstQuery != null),         {if (true) return firstQuery;},       else {,   {if (true) return getBooleanQuery(clauses);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParser.java,ReInit,482-488,[    token_source.ReInit(stream);,     token = new Token();,     jj_ntk = -1;,     jj_gen = 0;,     for (int i = 0; i < 22; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParser.java,ReInit,502-508,[    token_source = tm;,     token = new Token();,     jj_ntk = -1;,     jj_gen = 0;,     for (int i = 0; i < 22; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParser.java,Term,224-410,[  Token term, boost=null, fuzzySlop=null, goop1, goop2;,   boolean prefix = false;,   boolean wildcard = false;,   boolean fuzzy = false;,   boolean regexp = false;,   boolean startInc=false;,   boolean endInc=false;,   Query q;,     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,     case BAREOPER:,     case STAR:,     case TERM:,     case PREFIXTERM:,     case WILDTERM:,     case REGEXPTERM:,     case NUMBER:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case TERM:,         term = jj_consume_token(TERM);,         break;,       case STAR:,         term = jj_consume_token(STAR);,                       wildcard=true;,         break;,       case PREFIXTERM:,         term = jj_consume_token(PREFIXTERM);,                             prefix=true;,         break;,       case WILDTERM:,         term = jj_consume_token(WILDTERM);,                           wildcard=true;,         break;,       case REGEXPTERM:,         term = jj_consume_token(REGEXPTERM);,                             regexp=true;,         break;,       case NUMBER:,         term = jj_consume_token(NUMBER);,         break;,       case BAREOPER:,         term = jj_consume_token(BAREOPER);,                           term.image = term.image.substring(0,1);,         break;,       default:,         jj_la1[9] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case FUZZY_SLOP:,         fuzzySlop = jj_consume_token(FUZZY_SLOP);,                                fuzzy=true;,         break;,       default:,         jj_la1[10] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,         case FUZZY_SLOP:,           fuzzySlop = jj_consume_token(FUZZY_SLOP);,                                                         fuzzy=true;,           break;,         default:,           jj_la1[11] = jj_gen;,           ;,         },         break;,       default:,         jj_la1[12] = jj_gen;,         ;,       },       q = handleBareTokenQuery(getField(field), term, fuzzySlop, prefix, wildcard, fuzzy, regexp);,       break;,     case RANGEIN_START:,     case RANGEEX_START:,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGEIN_START:,         jj_consume_token(RANGEIN_START);,                            startInc=true;,         break;,       case RANGEEX_START:,         jj_consume_token(RANGEEX_START);,         break;,       default:,         jj_la1[13] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_GOOP:,         goop1 = jj_consume_token(RANGE_GOOP);,         break;,       case RANGE_QUOTED:,         goop1 = jj_consume_token(RANGE_QUOTED);,         break;,       default:,         jj_la1[14] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_TO:,         jj_consume_token(RANGE_TO);,         break;,       default:,         jj_la1[15] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGE_GOOP:,         goop2 = jj_consume_token(RANGE_GOOP);,         break;,       case RANGE_QUOTED:,         goop2 = jj_consume_token(RANGE_QUOTED);,         break;,       default:,         jj_la1[16] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case RANGEIN_END:,         jj_consume_token(RANGEIN_END);,                          endInc=true;,         break;,       case RANGEEX_END:,         jj_consume_token(RANGEEX_END);,         break;,       default:,         jj_la1[17] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[18] = jj_gen;,         ;,       },          boolean startOpen=false;,          boolean endOpen=false;,          if (goop1.kind == RANGE_QUOTED) {,            goop1.image = goop1.image.substring(1, goop1.image.length()-1);,          } else if ("*".equals(goop1.image)) {,            startOpen=true;,          },          if (goop2.kind == RANGE_QUOTED) {,            goop2.image = goop2.image.substring(1, goop2.image.length()-1);,          } else if ("*".equals(goop2.image)) {,            endOpen=true;,          },          q = getRangeQuery(getField(field), startOpen ? null : discardEscapeChar(goop1.image), endOpen ? null : discardEscapeChar(goop2.image), startInc, endInc);,       break;,     case QUOTED:,       term = jj_consume_token(QUOTED);,       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case FUZZY_SLOP:,         fuzzySlop = jj_consume_token(FUZZY_SLOP);,         break;,       default:,         jj_la1[19] = jj_gen;,         ;,       },       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {,       case CARAT:,         jj_consume_token(CARAT);,         boost = jj_consume_token(NUMBER);,         break;,       default:,         jj_la1[20] = jj_gen;,         ;,       },         q = handleQuotedTerm(getField(field), term, fuzzySlop);,       break;,     default:,       jj_la1[21] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     {if (true) return handleBoost(q, boost);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParser.java,TopLevelQuery,96-98,[    q = Query(field);,     jj_consume_token(0);,     {if (true) return q;}],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/parser/QueryParser.java,jj_rescan_token,668-669,[          switch (i) {,             case 0: jj_3_1(); break;],,
MALICIOUS_CODE,MS_OOI_PKGPROTECT,org/apache/solr/parser/QueryParserConstants.java,,88-88,[  String[] tokenImage = {],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/solr/parser/QueryParserTokenManager.java,jjMoveNfa_2,429-434,[                  if ((0x97ffffff87ffffffL & l) == 0L),                      break;,                   if (kind > 24),                      kind = 24;,                   jjCheckNAddTwoStates(27, 28);,                   break;],,jjMoveNfa_2,436-441,[                  if ((0x97ffffff87ffffffL & l) == 0L),                      break;,                   if (kind > 24),                      kind = 24;,                   jjCheckNAddTwoStates(27, 28);,                   break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/solr/parser/QueryParserTokenManager.java,jjMoveNfa_2,561-566,[                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2)),                      break;,                   if (kind > 24),                      kind = 24;,                   jjCheckNAddTwoStates(27, 28);,                   break;],,jjMoveNfa_2,596-601,[                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2)),                      break;,                   if (kind > 24),                      kind = 24;,                   jjCheckNAddTwoStates(27, 28);,                   break;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/parser/QueryParserTokenManager.java,jjMoveNfa_0,756-756,[         int i1 = hiByte >> 6;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/parser/QueryParserTokenManager.java,jjMoveNfa_0,758-758,[         int i2 = (curChar & 0xff) >> 6;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/parser/QueryParserTokenManager.java,jjMoveNfa_0,744-744,[         long l = 1L << (curChar & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/parser/QueryParserTokenManager.java,jjMoveNfa_0,757-757,[         long l1 = 1L << (hiByte & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/parser/QueryParserTokenManager.java,jjMoveNfa_0,759-759,[         long l2 = 1L << (curChar & 077);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/solr/parser/QueryParserTokenManager.java,,1034-1034,[public static final int[] jjnewLexState = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/solr/parser/QueryParserTokenManager.java,,1021-1021,[public static final String[] jjstrLiteralImages = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/solr/parser/QueryParserTokenManager.java,,1027-1027,[public static final String[] lexStateNames = {],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParserTokenManager.java,ReInit,1062-1066,[   jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParserTokenManager.java,ReInit,1078-1080,[   ReInit(stream);,    SwitchTo(lexState);, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParserTokenManager.java,SwitchTo,1085-1089,[   if (lexState >= 3 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/QueryParserTokenManager.java,ReInitRounds,1070-1073,[   jjround = 0x80000001;,    for (i = 61; i-- > 0;),       jjrounds[i] = 0x80000000;, }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/parser/QueryParserTokenManager.java,getNextToken,1142-1157,[   switch(curLexState),    {,      case 0:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_0();,        break;,      case 1:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_1();,        break;,      case 2:,        jjmatchedKind = 0x7fffffff;,        jjmatchedPos = 0;,        curPos = jjMoveStringLiteralDfa0_2();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/solr/parser/QueryParserTokenManager.java,jjStartNfa_2,35-35,[   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/parser/QueryParserTokenManager.java,,24-24,[  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/solr/parser/SolrQueryParserBase.java,analyzeIfMultitermTermText,710-710,[    if (sf == null || ! (fieldType instanceof TextField)) return part;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/parser/SolrQueryParserBase.java,handleBareTokenQuery,530-530,[      } catch (Exception ignored) { }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/parser/SolrQueryParserBase.java,handleQuotedTerm,552-552,[      catch (Exception ignored) { }],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/parser/SolrQueryParserBase.java,handleBareTokenQuery,533-533,[      } else if (fms >= 1.0f && fms != (int) fms) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/parser/SolrQueryParserBase.java,getReversedWildcardFilterFactory,675-675,[    if (fac != null || leadingWildcards.containsKey(fac)) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/parser/SolrQueryParserBase.java,,793-804,[      return new AutomatonQuery(term, automaton) {,         // override toString so it's completely transparent,         @Override,         public String toString(String field) {,           StringBuilder buffer = new StringBuilder();,           if (!getField().equals(field)) {,             buffer.append(getField());,             buffer.append(":");,           },           buffer.append(term.text());,           buffer.append(ToStringUtils.boost(getBoost()));,           return buffer.toString();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/parser/TokenMgrError.java,LexicalError,108-112,[    return("Lexical error at line " +,           errorLine + ", column " +,           errorColumn + ".  Encountered: " +,           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +,           "after : \"" + addEscapes(errorAfter) + "\"");],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/request/DocValuesStats.java,getCounts,59-59,[    final boolean calcDistinct = statsField.getCalcDistinct();],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/solr/request/IntervalFacets.java,getCountNumeric,180-181,[            longs = DocValues.getNumeric(ctx.reader(), fieldName);,             break;],,getCountNumeric,183-184,[            longs = DocValues.getNumeric(ctx.reader(), fieldName);,             break;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/request/IntervalFacets.java,,125-144,[    Arrays.sort(sortedIntervals, new Comparator<FacetInterval>() {, ,       @Override,       public int compare(FacetInterval o1, FacetInterval o2) {,         assert o1 != null;,         assert o2 != null;,         return compareStart(o1, o2);,       }, ,       private int compareStart(FacetInterval o1, FacetInterval o2) {,         if (o1.start == null) {,           if (o2.start == null) {,             return 0;,           },           return -1;,         },         if (o2.start == null) {,           return 1;,         },         return o1.start.compareTo(o2.start);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/request/IntervalFacets.java,,188-193,[            longs = new NumericDocValues() {,               @Override,               public long get(int docID) {,                 long bits = floats.get(docID);,                 if (bits < 0) bits ^= 0x7fffffffffffffffL;,                 return bits;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/request/IntervalFacets.java,,200-205,[            longs = new NumericDocValues() {,               @Override,               public long get(int docID) {,                 long bits = doubles.get(docID);,                 if (bits < 0) bits ^= 0x7fffffffffffffffL;,                 return bits;],,
MALICIOUS_CODE,MS_MUTABLE_COLLECTION_PKGPROTECT,org/apache/solr/request/LocalSolrQueryRequest.java,,37-37,[  public final static Map emptyArgs = new HashMap(0,1);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/solr/request/NumericFacets.java,getCounts,159-160,[            longs = DocValues.getNumeric(ctx.reader(), fieldName);,             break;],,getCounts,162-163,[            longs = DocValues.getNumeric(ctx.reader(), fieldName);,             break;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/request/PerSegmentSingleValuedFaceting.java,,97-101,[      Callable<SegFacet> task = new Callable<SegFacet>() {,         @Override,         public SegFacet call() throws Exception {,           segFacet.countTerms();,           return segFacet;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/request/PerSegmentSingleValuedFaceting.java,,116-119,[    PriorityQueue<SegFacet> queue = new PriorityQueue<SegFacet>(leaves.size()) {,       @Override,       protected boolean lessThan(SegFacet a, SegFacet b) {,         return a.tempBR.compareTo(b.tempBR) < 0;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/request/PerSegmentSingleValuedFaceting.java,getFacetCounts,185-185,[        count += seg.counts[seg.pos - seg.startTermIndex];],,getFacetCounts,151-151,[          missingCount += seg.counts[0];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/request/PerSegmentSingleValuedFaceting.java,getFacetCounts,157-157,[          seg.tenum = seg.si.termsEnum();],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/solr/request/SimpleFacets.java,parseParams,161-161,[    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/solr/request/SimpleFacets.java,getListedTermCounts,638-639,[    List<String> terms = StrUtils.splitSmart(termList, ",", true);,     return getListedTermCounts(field, this.docs, terms);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/request/SimpleFacets.java,,497-501,[      searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), new FilterCollector(collector) {,         @Override,         public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {,           LeafReader insane = Insanity.wrapInsanity(context.reader(), groupField);,           return in.getLeafCollector(insane.getContext());],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/request/SimpleFacets.java,parseAndAddGap,1395-1395,[      return new Double(value.doubleValue() + Double.valueOf(gap).doubleValue());],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/request/SimpleFacets.java,parseAndAddGap,1382-1382,[      return new Float(value.floatValue() + Float.valueOf(gap).floatValue());],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/request/SimpleFacets.java,parseAndAddGap,1408-1408,[      return new Integer(value.intValue() + Integer.valueOf(gap).intValue());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/request/SimpleFacets.java,parseAndAddGap,1408-1408,[      return new Integer(value.intValue() + Integer.valueOf(gap).intValue());],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/request/SimpleFacets.java,parseAndAddGap,1421-1421,[      return new Long(value.longValue() + Long.valueOf(gap).longValue());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/request/SimpleFacets.java,parseAndAddGap,1421-1421,[      return new Long(value.longValue() + Long.valueOf(gap).longValue());],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/request/SolrRequestInfo.java,getNOW,83-83,[    if (now != null) return now;],,getNOW,95-95,[    return now;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/request/SolrRequestInfo.java,,63-63,[      if (info != null && info.closeHooks != null) {],,,64-64,[        for (Closeable hook : info.closeHooks) {],,,134-134,[      if (closeHooks == null) {],,,137-137,[      closeHooks.add(hook);],,,135-135,[        closeHooks = new LinkedList<>();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/request/UnInvertedField.java,getStats,484-484,[    SchemaField sf = statsField.getSchemaField();],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/solr/request/UnInvertedField.java,memSize,161-161,[    sz += bigTerms.size() * 64;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/request/UnInvertedField.java,memSize,94-94,[      return 8 +   // obj header],,
MALICIOUS_CODE,MS_MUTABLE_COLLECTION_PKGPROTECT,org/apache/solr/response/BinaryResponseWriter.java,,44-44,[  public static final Set<Class> KNOWN_TYPES = new HashSet<>();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/BinaryResponseWriter.java,getDoc,193-193,[        SchemaField sf = schema.getFieldOrNull(fieldName);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/response/CSVResponseWriter.java,writeResponse,288-288,[      if (returnOnlyStored && sf != null && !sf.stored()) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/response/CSVResponseWriter.java,,149-149,[    List<IndexableField> values = new ArrayList<>(1);  // low starting amount in case there are many fields],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/CSVResponseWriter.java,writeSolrDocument,407-407,[        csvField.mvPrinter.reset();],,writeSolrDocument,428-428,[          csvField.mvPrinter.reset();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/response/JSONResponseWriter.java,writeNamedListAsMapMangled,145-145,[          String newKey = key;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/response/JSONResponseWriter.java,writeNamedList,305-305,[    } else if (namedListStyle==JSON_NL_ARROFARR) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/response/JSONResponseWriter.java,writeNamedList,307-307,[    } else if (namedListStyle==JSON_NL_ARROFMAP) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/response/JSONResponseWriter.java,writeNamedList,301-301,[    } else if (namedListStyle==JSON_NL_FLAT) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/response/JSONResponseWriter.java,writeNamedList,303-303,[    } else if (namedListStyle==JSON_NL_MAP){],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/response/JSONResponseWriter.java,,317-317,[      this.sfield = sfield;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/response/PHPSerializedResponseWriter.java,writeSolrDocument,143-143,[      Object val = single.get(fname);],,writeSolrDocument,151-151,[      Object val = multi.get(fname);],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/response/PageTool.java,<init>,43-43,[      results_per_page = new Integer(rows);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/response/PageTool.java,<init>,43-43,[      results_per_page = new Integer(rows);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/response/PythonResponseWriter.java,,27-27,[  static String CONTENT_TYPE_PYTHON_ASCII="text/x-python;charset=US-ASCII";],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/response/RubyResponseWriter.java,,26-26,[  static String CONTENT_TYPE_RUBY_UTF8="text/x-ruby;charset=UTF-8";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/response/SortingResponseWriter.java,,1064-1075,[  public class DoubleAsc implements DoubleComp {,     public double resetValue() {,       return Double.MAX_VALUE;,     }, ,     public int compare(double a, double b) {,       if(a < b) {,         return 1;,       } else if (a > b) {,         return -1;,       } else {,         return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/response/SortingResponseWriter.java,,1048-1059,[  public class DoubleDesc implements DoubleComp {,     public double resetValue() {,       return -Double.MAX_VALUE;,     }, ,     public int compare(double a, double b) {,       if(a < b) {,         return -1;,       } else if (a > b) {,         return 1;,       } else {,         return 0;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,1029-1029,[      DoubleValue dv = (DoubleValue)sv;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,1003-1003,[  class DoubleValue implements SortValue {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,1025-1025,[      currentValue = Double.longBitsToDouble(vals.get(docId));],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setValues,531-531,[      value1.setCurrentValue(((DoubleValueSortDoc)sortDoc).value1);],,setValues,532-532,[      value2.setCurrentValue(((DoubleValueSortDoc)sortDoc).value2);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,564-569,[      DoubleValueSortDoc sd = (DoubleValueSortDoc)o;,       int comp = value1.compareTo(sd.value1);,       if(comp == 0) {,         return value2.compareTo(sd.value2);,       } else {,         return comp;],,
CORRECTNESS,RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE,org/apache/solr/response/SortingResponseWriter.java,lessThan,547-547,[      if(comp == -1) {],,lessThan,553-553,[        if(comp == -1) {],,
CORRECTNESS,RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE,org/apache/solr/response/SortingResponseWriter.java,lessThan,549-549,[      } else if (comp == 1) {],,lessThan,555-555,[        } else if (comp == 1) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/response/SortingResponseWriter.java,,987-998,[  public class FloatAsc implements FloatComp {,     public float resetValue() {,       return Float.MAX_VALUE;,     }, ,     public int compare(float a, float b) {,       if(a < b) {,         return 1;,       } else if (a > b) {,         return -1;,       } else {,         return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/response/SortingResponseWriter.java,,971-982,[  public class FloatDesc implements FloatComp {,     public float resetValue() {,       return -Float.MAX_VALUE;,     }, ,     public int compare(float a, float b) {,       if(a < b) {,         return -1;,       } else if (a > b) {,         return 1;,       } else {,         return 0;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,952-952,[      FloatValue fv = (FloatValue)sv;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,926-926,[  class FloatValue implements SortValue {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,948-948,[      currentValue = Float.intBitsToFloat((int)vals.get(docId));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/response/SortingResponseWriter.java,,830-842,[  class IntAsc implements IntComp {, ,     public int resetValue() {,       return Integer.MAX_VALUE;,     }, ,     public int compare(int a, int b) {,       if(a < b) {,         return 1;,       } else if (a > b) {,         return -1;,       } else {,         return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/response/SortingResponseWriter.java,,813-825,[  class IntDesc implements IntComp {, ,     public int resetValue() {,       return Integer.MIN_VALUE;,     }, ,     public int compare(int a, int b) {,       if(a < b) {,         return -1;,       } else if (a > b) {,         return 1;,       } else {,         return 0;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,800-800,[      currentValue = ((IntValue)value).currentValue;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,769-769,[  class IntValue implements SortValue {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,791-791,[      currentValue = (int)vals.get(docId);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/response/SortingResponseWriter.java,,909-921,[  class LongAsc implements LongComp {, ,     public long resetValue() {,       return Long.MAX_VALUE;,     }, ,     public int compare(long a, long b) {,       if(a < b) {,         return 1;,       } else if (a > b) {,         return -1;,       } else {,         return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/response/SortingResponseWriter.java,,892-904,[  class LongDesc implements LongComp {, ,     public long resetValue() {,       return Long.MIN_VALUE;,     }, ,     public int compare(long a, long b) {,       if(a < b) {,         return -1;,       } else if (a > b) {,         return 1;,       } else {,         return 0;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,873-873,[      LongValue lv = (LongValue)sv;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,847-847,[  class LongValue implements SortValue {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,869-869,[      currentValue = vals.get(docId);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/response/SortingResponseWriter.java,write,1194-1194,[      long ord = -1;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setValues,691-691,[      value1.setCurrentValue(((QuadValueSortDoc)sortDoc).value1);],,setValues,692-692,[      value2.setCurrentValue(((QuadValueSortDoc)sortDoc).value2);],,setValues,693-693,[      value3.setCurrentValue(((QuadValueSortDoc)sortDoc).value3);],,setValues,694-694,[      value4.setCurrentValue(((QuadValueSortDoc)sortDoc).value4);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,741-756,[      QuadValueSortDoc sd = (QuadValueSortDoc)o;,       int comp = value1.compareTo(sd.value1);,       if(comp == 0) {,         comp = value2.compareTo(sd.value2);,         if(comp == 0) {,           comp = value3.compareTo(sd.value3);,           if(comp == 0) {,             return value4.compareTo(sd.value4);,           } else {,             return comp;,           },         } else {,           return comp;,         },       } else {,         return comp;],,
CORRECTNESS,RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE,org/apache/solr/response/SortingResponseWriter.java,lessThan,710-710,[      if(comp == -1) {],,lessThan,716-716,[        if(comp == -1) {],,lessThan,722-722,[          if(comp == -1) {],,lessThan,728-728,[            if(comp == -1) {],,
CORRECTNESS,RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE,org/apache/solr/response/SortingResponseWriter.java,lessThan,712-712,[      } else if (comp == 1) {],,lessThan,718-718,[        } else if (comp == 1) {],,lessThan,724-724,[          } else if (comp == 1) {],,lessThan,730-730,[            } else if (comp == 1) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setValues,472-472,[      value1.setCurrentValue(((SingleValueSortDoc)sortDoc).value1);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,497-498,[      SingleValueSortDoc sd = (SingleValueSortDoc)o;,       return value1.compareTo(sd.value1);],,
CORRECTNESS,RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE,org/apache/solr/response/SortingResponseWriter.java,lessThan,487-487,[      if(comp == -1) {],,
CORRECTNESS,RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE,org/apache/solr/response/SortingResponseWriter.java,lessThan,489-489,[      } else if (comp == 1) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,1123-1123,[      StringValue v = (StringValue)sv;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,1080-1080,[  class StringValue implements SortValue {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/SortingResponseWriter.java,setCurrentValue,1110-1110,[      int ord = currentVals.getOrd(docId);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/response/SortingResponseWriter.java,setValues,602-602,[      value1.setCurrentValue(((TripleValueSortDoc)sortDoc).value1);],,setValues,603-603,[      value2.setCurrentValue(((TripleValueSortDoc)sortDoc).value2);],,setValues,604-604,[      value3.setCurrentValue(((TripleValueSortDoc)sortDoc).value3);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/response/SortingResponseWriter.java,compareTo,645-655,[      TripleValueSortDoc sd = (TripleValueSortDoc)o;,       int comp = value1.compareTo(sd.value1);,       if(comp == 0) {,         comp = value2.compareTo(sd.value2);,         if(comp == 0) {,           return value3.compareTo(sd.value3);,         } else {,           return comp;,         },       } else {,         return comp;],,
CORRECTNESS,RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE,org/apache/solr/response/SortingResponseWriter.java,lessThan,620-620,[      if(comp == -1) {],,lessThan,626-626,[        if(comp == -1) {],,lessThan,632-632,[          if(comp == -1) {],,
CORRECTNESS,RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE,org/apache/solr/response/SortingResponseWriter.java,lessThan,622-622,[      } else if (comp == 1) {],,lessThan,628-628,[        } else if (comp == 1) {],,lessThan,634-634,[          } else if (comp == 1) {],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/solr/response/TextResponseWriter.java,writeDocuments,239-239,[        context.wantsScores ? new Float(ids.maxScore()) : null );],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/response/VelocityResponseWriter.java,getEngine,148-148,[          props.load(new InputStreamReader(is, StandardCharsets.UTF_8));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/response/VelocityResponseWriter.java,getEngine,156-156,[    catch (Exception e) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/response/XMLWriter.java,,42-42,[  public static float CURRENT_VERSION=2.2f;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/solr/response/XMLWriter.java,writeResponse,66-66,[      xmlWriter.close();],,writeResponse,61-61,[    XMLWriter xmlWriter = null;],,writeResponse,63-63,[      xmlWriter = new XMLWriter(writer, req, rsp);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/transform/ExcludedMarkerFactory.java,getIdSet,54-54,[    return (Set<String>)context.req.getContext().get(QueryElevationComponent.EXCLUDED);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/transform/ElevatedMarkerFactory.java,getIdSet,52-52,[    return (Set<String>) context.req.getContext().get("BOOSTED");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/transform/ChildDocTransformerFactory.java,transform,136-136,[      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/transform/ExplainAugmenterFactory.java,transform,94-94,[          Explanation exp = context.searcher.explain(context.query, docid);],,
MALICIOUS_CODE,MS_MUTABLE_COLLECTION,org/apache/solr/response/transform/TransformerFactory.java,,44-44,[  public static final Map<String,TransformerFactory> defaultFactories = new HashMap<>();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/transform/ValueSourceAugmenter.java,transform,93-93,[      FunctionValues values = docValuesArr[idx];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/response/transform/ValueSourceAugmenter.java,transform,92-92,[      LeafReaderContext rcontext = readerContexts.get(idx);],,
CORRECTNESS,BC_IMPOSSIBLE_INSTANCEOF,org/apache/solr/rest/BaseSolrResource.java,doInit,130-130,[              updateTimeoutSecs = (updateTimeoutSecsParam instanceof Number)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/rest/BaseSolrResource.java,handlePostExecution,180-180,[      log.info(solrResponse.getToLogAsString(solrCore.getLogId()));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/rest/BaseSolrResource.java,handlePostExecution,179-179,[    if (log.isInfoEnabled() && solrResponse.getToLog().size() > 0) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/rest/ManagedResourceStorage.java,load,506-506,[        } catch (Exception ignore){}],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/rest/ManagedResourceStorage.java,configure,163-163,[        dir.mkdirs();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/rest/ManagedResourceStorage.java,store,445-445,[          } catch (Exception ignore){}],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/ManagedResourceStorage.java,configure,232-232,[      } catch (Exception exc) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/ManagedResourceStorage.java,delete,341-341,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/ManagedResourceStorage.java,openInputStream,264-264,[      } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/ManagedResourceStorage.java,close,298-298,[          } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/RestManager.java,createManagedResource,690-690,[    } catch (Exception e) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/rest/RestManager.java,attachManagedResources,767-767,[        attachManagedResource(managed.get(resourceId), path, router);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/rest/RestManager.java,,636-636,[    registry.initializedRestManager = this;],,,230-230,[      if (initializedRestManager != null) {],,,231-231,[        initializedRestManager.addRegisteredResource(registered.get(resourceId));],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/rest/schema/BaseFieldResource.java,waitForSchemaUpdateToPropagate,121-121,[            cd.getCloudDescriptor().getCoreNodeName(),],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/BaseFieldResource.java,waitForSchemaUpdateToPropagate,119-119,[        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) newSchema.getResourceLoader();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/BaseFieldTypeResource.java,addNewFieldTypes,90-90,[        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) newSchema.getResourceLoader();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/BaseFieldTypeResource.java,addNewFieldTypes,78-78,[        oldSchema = (ManagedIndexSchema)getSolrCore().getLatestSchema();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/CopyFieldCollectionResource.java,post,132-132,[            ManagedIndexSchema oldSchema = (ManagedIndexSchema) getSchema();],,post,186-186,[                  oldSchema = (ManagedIndexSchema)getSolrCore().getLatestSchema();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/schema/CopyFieldCollectionResource.java,post,193-193,[    } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/DynamicFieldCollectionResource.java,post,126-126,[            ManagedIndexSchema oldSchema = (ManagedIndexSchema)getSchema();],,post,191-191,[                oldSchema = (ManagedIndexSchema)getSolrCore().getLatestSchema();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/schema/DynamicFieldCollectionResource.java,post,200-200,[    } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/DynamicFieldResource.java,put,148-148,[                ManagedIndexSchema oldSchema = (ManagedIndexSchema)getSchema();],,put,181-181,[                    oldSchema = (ManagedIndexSchema)getSolrCore().getLatestSchema();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/schema/DynamicFieldResource.java,put,191-191,[    } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/schema/FieldCollectionResource.java,post,219-219,[    } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/FieldResource.java,put,151-151,[                ManagedIndexSchema oldSchema = (ManagedIndexSchema) getSchema();],,put,185-185,[                    oldSchema = (ManagedIndexSchema)getSolrCore().getLatestSchema();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/rest/schema/FieldResource.java,put,194-194,[    } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/FieldTypeCollectionResource.java,addOrUpdateFieldTypes,184-184,[    ManagedIndexSchema oldSchema = (ManagedIndexSchema) getSchema();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/rest/schema/FieldTypeResource.java,addOrUpdateFieldType,165-165,[    ManagedIndexSchema oldSchema = (ManagedIndexSchema) getSchema();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/rest/schema/analysis/BaseManagedTokenFilterFactory.java,inform,60-60,[    SolrResourceLoader solrResourceLoader = (SolrResourceLoader)loader;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/rest/schema/analysis/ManagedStopFilterFactory.java,onManagedResourceInitialized,79-79,[    Set<String> managedWords = ((ManagedWordSetResource)res).getWordSet(); ],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/rest/schema/analysis/ManagedSynonymFilterFactory.java,onManagedDataLoadedFromStorage,145-145,[          Object mapping = storedSyns.get(key);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/schema/AbstractSubTypeFieldType.java,,112-112,[      dynFieldProps = proto.getProperties();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/schema/AbstractSubTypeFieldType.java,subField,132-132,[    return schema.getField(base.getName() + suffixes[i]);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/schema/BBoxField.java,newSpatialStrategy,118-118,[    FieldType numberType = schema.getFieldTypeByName(numberTypeName);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/solr/schema/BoolField.java,,71-71,[  protected final static char[] FALSE_TOKEN = {'F'};],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/solr/schema/BoolField.java,,70-70,[  protected final static char[] TRUE_TOKEN = {'T'};],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/solr/schema/BoolField.java,equals,241-241,[    return o.getClass() == BoolFieldSource.class && this.field.equals(((BoolFieldSource)o).field);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/schema/BoolField.java,equals,241-241,[    return o.getClass() == BoolFieldSource.class && this.field.equals(((BoolFieldSource)o).field);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/schema/BoolField.java,,207-220,[    return new BoolDocValues(this) {,       @Override,       public boolean boolVal(int doc) {,         return sindex.getOrd(doc) == trueOrd;,       }, ,       @Override,       public boolean exists(int doc) {,         return sindex.getOrd(doc) != -1;,       }, ,       @Override,       public ValueFiller getValueFiller() {,         return new ValueFiller() {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/schema/CurrencyField.java,,84-84,[  public static Logger log = LoggerFactory.getLogger(CurrencyField.class);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/CurrencyField.java,init,151-151,[    } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/schema/CurrencyField.java,getValues,397-397,[      final int sourceFractionDigits = source.getTargetCurrency().getDefaultFractionDigits();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/schema/CurrencyField.java,hashCode,459-459,[      result = 31 * result + (source != null ? source.hashCode() : 0);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/schema/CurrencyField.java,equals,450-450,[      return !(source != null ? !source.equals(that.source) : that.source != null) &&],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/solr/schema/CurrencyField.java,,372-461,[  class ConvertedCurrencyValueSource extends ValueSource {,     private final Currency targetCurrency;,     private final RawCurrencyValueSource source;,     private final double rate;,     public ConvertedCurrencyValueSource(String targetCurrencyCode, ,                                         RawCurrencyValueSource source) {,       this.source = source;,       this.targetCurrency = getCurrency(targetCurrencyCode);,       if (null == targetCurrency) {,         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Currency code not supported by this JVM: " + targetCurrencyCode);,       },       // the target digits & currency of our source, ,       // become the source digits & currency of ourselves,       this.rate = provider.getExchangeRate,         (source.getTargetCurrency().getCurrencyCode(), ,          targetCurrency.getCurrencyCode());,     }, ,     @Override,     public FunctionValues getValues(Map context, LeafReaderContext reader) ,       throws IOException {,       final FunctionValues amounts = source.getValues(context, reader);,       // the target digits & currency of our source, ,       // become the source digits & currency of ourselves,       final String sourceCurrencyCode = source.getTargetCurrency().getCurrencyCode();,       final int sourceFractionDigits = source.getTargetCurrency().getDefaultFractionDigits();,       final double divisor = Math.pow(10D, targetCurrency.getDefaultFractionDigits());,       return new FunctionValues() {,         @Override,         public boolean exists(int doc) {,           return amounts.exists(doc);,         },         @Override,         public long longVal(int doc) {,           return (long) doubleVal(doc);,         },         @Override,         public int intVal(int doc) {,           return (int) doubleVal(doc);,         }, ,         @Override,         public double doubleVal(int doc) {,           return CurrencyValue.convertAmount(rate, sourceCurrencyCode, amounts.longVal(doc), targetCurrency.getCurrencyCode()) / divisor;,         }, ,         @Override,         public float floatVal(int doc) {,           return CurrencyValue.convertAmount(rate, sourceCurrencyCode, amounts.longVal(doc), targetCurrency.getCurrencyCode()) / ((float)divisor);,         }, ,         @Override,         public String strVal(int doc) {,           return Double.toString(doubleVal(doc));,         }, ,         @Override,         public String toString(int doc) {,           return name() + '(' + strVal(doc) + ')';,         },       };,     },     public String name() {,       return "currency";,     }, ,     @Override,     public String description() {,       return name() + "(" + source.getField().getName() + "," + targetCurrency.getCurrencyCode()+")";,     }, ,     @Override,     public boolean equals(Object o) {,       if (this == o) return true;,       if (o == null || getClass() != o.getClass()) return false;, ,       ConvertedCurrencyValueSource that = (ConvertedCurrencyValueSource) o;, ,       return !(source != null ? !source.equals(that.source) : that.source != null) &&,         (rate == that.rate) && ,         !(targetCurrency != null ? !targetCurrency.equals(that.targetCurrency) : that.targetCurrency != null);, ,     }, ,     @Override,     public int hashCode() {,       int result = targetCurrency != null ? targetCurrency.hashCode() : 0;,       result = 31 * result + (source != null ? source.hashCode() : 0);,       result = 31 * (int) Double.doubleToLongBits(rate);,       return result;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/schema/CurrencyField.java,,509-509,[        private final int MAX_CURRENCIES_TO_CACHE = 256;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/schema/DateRangeField.java,,160-163,[      parser = new QParser("", null, requestInfo.getReq().getParams(), requestInfo.getReq()) {,         @Override,         public Query parse() throws SyntaxError {,           throw new IllegalStateException();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/schema/EnumField.java,readableToIndexed,289-289,[    if (s == null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/schema/FieldType.java,getNonFieldPropertyArgs,804-804,[      if (null != fieldTypeArgs) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/schema/FieldType.java,getAnalyzerProperties,906-906,[                    props.add(key, factoryArgs.get(key));],,getAnalyzerProperties,928-928,[                tokenizerProps.add(key, factoryArgs.get(key));],,getAnalyzerProperties,950-950,[                    props.add(key, factoryArgs.get(key));],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/schema/FieldType.java,getNamedPropertyValues,850-850,[          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/schema/FieldType.java,getNamedPropertyValues,807-807,[            namedPropertyValues.add(key, fieldTypeArgs.get(key));],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/FieldTypePluginLoader.java,readAnalyzer,277-277,[      } catch (Exception e) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/schema/CurrencyField.java,listAvailableCurrencies,778-778,[      for(String to : rates.get(from).keySet()) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/schema/IndexSchema.java,getDynamicCopyFields,154-154,[  public DynamicCopy[] getDynamicCopyFields() { return dynamicCopyFields; }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/schema/IndexSchema.java,getDynamicFields,138-138,[  public DynamicField[] getDynamicFields() { return dynamicFields; }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/schema/IndexSchema.java,readSchema,529-529,[        if (defaultSearchFieldName!=null) {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/solr/schema/IndexSchema.java,readSchema,579-579,[        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/IndexSchema.java,readSchema,599-599,[    } catch(Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/schema/IndexSchema.java,,1407-1411,[      Collections.sort(copyFields, new Comparator<CopyField>() {,         @Override,         public int compare(CopyField cf1, CopyField cf2) {,           // sources are all be the same, just sorting by destination here,           return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/schema/IndexSchema.java,compareTo,1044-1044,[      return other.pattern.length() - pattern.length();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/schema/JsonPreAnalyzedParser.java,parse,172-172,[            if (data != null && data.length > 0) {],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/queries/function/valuesource/VectorValueSource.java,equals,208-213,[    if (this == o) return true;,     if (!(o instanceof VectorValueSource)) return false;, ,     VectorValueSource that = (VectorValueSource) o;, ,     return sources.equals(that.sources);],,
STYLE,BC_BAD_CAST_TO_CONCRETE_COLLECTION,org/apache/solr/schema/ManagedIndexSchema.java,addFieldTypes,543-543,[    HashMap<String,FieldType> clone =],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/schema/ManagedIndexSchema.java,persistManagedSchemaToZooKeeper,165-165,[    final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/ManagedIndexSchema.java,persistManagedSchemaToZooKeeper,200-200,[    } catch (Exception e) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/schema/ManagedIndexSchema.java,mergeFieldTypesFromZk,889-889,[      fieldTypes.put(newTypeName, newFieldTypes.get(newTypeName));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/schema/ManagedIndexSchema.java,,381-383,[    public FieldExistsException(ErrorCode code, String msg) {,       super(code, msg);,     }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/ManagedIndexSchema.java,call,353-353,[          } catch (Exception e) {],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/schema/ManagedIndexSchema.java,,313-375,[  private static class GetZkSchemaVersionCallable extends SolrRequest implements Callable<Integer> {, ,     private String coreUrl;,     private int expectedZkVersion;, ,     GetZkSchemaVersionCallable(String coreUrl, int expectedZkVersion) {,       super(METHOD.GET, "/schema/zkversion");, ,       this.coreUrl = coreUrl;,       this.expectedZkVersion = expectedZkVersion;,     }, ,     @Override,     public SolrParams getParams() {,       ModifiableSolrParams wparams = new ModifiableSolrParams();,       wparams.set("refreshIfBelowVersion", expectedZkVersion);,       return wparams;,     }, ,     @Override,     public Integer call() throws Exception {,       HttpSolrClient solr = new HttpSolrClient(coreUrl);,       int remoteVersion = -1;,       try {,         // eventually, this loop will get killed by the ExecutorService's timeout,         while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {,           try {,             HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);,             NamedList<Object> zkversionResp = mrr.future.get();,             if (zkversionResp != null),               remoteVersion = (Integer)zkversionResp.get("zkversion");, ,             if (remoteVersion < expectedZkVersion) {,               // rather than waiting and re-polling, let's be proactive and tell the replica,               // to refresh its schema from ZooKeeper, if that fails, then the,               //Thread.sleep(1000); // slight delay before requesting version again,               log.error("Replica "+coreUrl+" returned schema version "+,                   remoteVersion+" and has not applied schema version "+expectedZkVersion);,             }, ,           } catch (Exception e) {,             if (e instanceof InterruptedException) {,               break; // stop looping,             } else {,               log.warn("Failed to get /schema/zkversion from " + coreUrl + " due to: " + e);,             },           },         },       } finally {,         solr.shutdown();,       }, ,       return remoteVersion;,     }, ,     @Override,     public Collection<ContentStream> getContentStreams() throws IOException {,       return null;,     }, ,     @Override,     public SolrResponse process(SolrClient server) throws SolrServerException, IOException {,       return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/schema/ManagedIndexSchema.java,,387-389,[    public SchemaChangedInZkException(ErrorCode code, String msg) {,       super(code, msg);,     }],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/schema/ManagedIndexSchemaFactory.java,zkUgradeToManagedSchema,351-351,[      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/ManagedIndexSchemaFactory.java,create,156-156,[          } catch (Exception e1) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/ManagedIndexSchemaFactory.java,zkUgradeToManagedSchema,374-374,[      } catch (Exception e) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/schema/OpenExchangeRatesOrgProvider.java,,56-56,[  public static Logger log = LoggerFactory.getLogger(OpenExchangeRatesOrgProvider.class);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/OpenExchangeRatesOrgProvider.java,reload,139-139,[      } catch (Exception e) {],,reload,145-145,[    } catch (Exception e) {],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/queries/function/valuesource/VectorValueSource.java,equals,208-213,[    if (this == o) return true;,     if (!(o instanceof VectorValueSource)) return false;, ,     VectorValueSource that = (VectorValueSource) o;, ,     return sources.equals(that.sources);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/schema/PreAnalyzedField.java,init,83-83,[        } catch (Exception e) {],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/util/AttributeSource.java,equals,324-355,[    if (obj == this) {,       return true;,     }, ,     if (obj instanceof AttributeSource) {,       AttributeSource other = (AttributeSource) obj;  ,     ,       if (hasAttributes()) {,         if (!other.hasAttributes()) {,           return false;,         },         ,         if (this.attributeImpls.size() != other.attributeImpls.size()) {,           return false;,         },   ,         // it is only equal if all attribute impls are the same in the same order,         State thisState = this.getCurrentState();,         State otherState = other.getCurrentState();,         while (thisState != null && otherState != null) {,           if (otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute)) {,             return false;,           },           thisState = thisState.next;,           otherState = otherState.next;,         },         return true;,       } else {,         return !other.hasAttributes();,       },     } else,       return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/schema/RandomSortField.java,,165-197,[  public class RandomValueSource extends ValueSource {,     private final String field;, ,     public RandomValueSource(String field) {,       this.field=field;,     }, ,     @Override,     public String description() {,       return field;,     }, ,     @Override,     public FunctionValues getValues(Map context, final LeafReaderContext readerContext) throws IOException {,       return new IntDocValues(this) {,           private final int seed = getSeed(field, readerContext);,           @Override,           public int intVal(int doc) {,             return hash(doc+seed);,           },         };,     }, ,     @Override,     public boolean equals(Object o) {,       if (!(o instanceof RandomValueSource)) return false;,       RandomValueSource other = (RandomValueSource)o;,       return this.field.equals(other.field);,     }, ,     @Override,     public int hashCode() {,       return field.hashCode();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/schema/SchemaManager.java,getFreshManagedSchema,292-292,[      return (ManagedIndexSchema) req.getCore().getLatestSchema();],,getFreshManagedSchema,288-288,[        return (ManagedIndexSchema) req.getCore().getLatestSchema();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/schema/SchemaManager.java,waitForOtherReplicasToUpdate,192-192,[        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) managedIndexSchema.getResourceLoader();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/schema/SchemaManager.java,getFreshManagedSchema,277-277,[      ZkSolrResourceLoader loader = (ZkSolrResourceLoader) resourceLoader;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/solr/schema/SchemaManager.java,doOperations,117-117,[    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/schema/LatLonType.java,equals,578-578,[    return     this.latCenter == other.latCenter],,equals,591-591,[            && this.getBoost() == other.getBoost()],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/schema/LatLonType.java,,539-539,[      maxdoc = context.reader().maxDoc();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/schema/LatLonType.java,collect,532-532,[      spatialScorer.doc = doc;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/schema/LatLonType.java,,319-319,[      this.searcher = searcher;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/schema/TrieDateField.java,parseMath,155-155,[    if (null == math || math.equals("")) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/schema/TrieDateField.java,parseMathLenient,238-238,[    if (null == math || math.equals("")) {],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/schema/TrieDateField.java,,258-319,[  private static class ISO8601CanonicalDateFormat extends SimpleDateFormat {, ,     protected NumberFormat millisParser,         = NumberFormat.getIntegerInstance(CANONICAL_LOCALE);, ,     protected NumberFormat millisFormat = new DecimalFormat,         (".###", new DecimalFormatSymbols(CANONICAL_LOCALE));, ,     public ISO8601CanonicalDateFormat() {,       super("yyyy-MM-dd'T'HH:mm:ss", CANONICAL_LOCALE);,       this.setTimeZone(CANONICAL_TZ);,     }, ,     @Override,     public Date parse(String i, ParsePosition p) {,       /* delegate to SimpleDateFormat for easy stuff */,       Date d = super.parse(i, p);,       int milliIndex = p.getIndex();,       /* worry about the milliseconds ourselves */,       if (null != d &&,           -1 == p.getErrorIndex() &&,           milliIndex + 1 < i.length() &&,           '.' == i.charAt(milliIndex)) {,         p.setIndex(++milliIndex); // NOTE: ++ to chomp '.',         Number millis = millisParser.parse(i, p);,         if (-1 == p.getErrorIndex()) {,           int endIndex = p.getIndex();,           d = new Date(d.getTime(),               + (long)(millis.doubleValue() * Math.pow(10, (3 - endIndex + milliIndex))));,         },       },       return d;,     }, ,     @Override,     public StringBuffer format(Date d, StringBuffer toAppendTo, FieldPosition pos) {,       /* delegate to SimpleDateFormat for easy stuff */,       super.format(d, toAppendTo, pos);,       /* worry about the milliseconds ourselves */,       long millis = d.getTime() % 1000l;,       if (0L == millis) {,         return toAppendTo;,       },       if (millis < 0L) {,         // original date was prior to epoch,         millis += 1000L;,       },       int posBegin = toAppendTo.length();,       toAppendTo.append(millisFormat.format(millis / 1000d));,       if (DateFormat.MILLISECOND_FIELD == pos.getField()) {,         pos.setBeginIndex(posBegin);,         pos.setEndIndex(toAppendTo.length());,       },       return toAppendTo;,     }, ,     @Override,     public DateFormat clone() {,       ISO8601CanonicalDateFormat c = (ISO8601CanonicalDateFormat)super.clone();,       c.millisParser = NumberFormat.getIntegerInstance(CANONICAL_LOCALE);,       c.millisFormat = new DecimalFormat(".###", new DecimalFormatSymbols(CANONICAL_LOCALE));,       return c;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/solr/schema/TrieField.java,createField,615-616,[        ft.setNumericType(NumericType.LONG);,         break;],,createField,621-622,[        ft.setNumericType(NumericType.LONG);,         break;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/schema/ZkIndexSchemaReader.java,<init>,44-44,[    ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)managedIndexSchemaFactory.getResourceLoader();],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/solr/search/BitDocSet.java,equals,37-37,[public class BitDocSet extends DocSetBase {],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/solr/search/ValueSourceParser.java,equals,1225-1225,[    if (BoolConstValueSource.class != o.getClass()) return false;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/search/ValueSourceParser.java,equals,1225-1227,[    if (BoolConstValueSource.class != o.getClass()) return false;,     BoolConstValueSource other = (BoolConstValueSource) o;,     return this.constant == other.constant;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/search/BoostQParserPlugin.java,,41-41,[  public static String BOOSTFUNC = "b";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/BoostQParserPlugin.java,,49-87,[    return new QParser(qstr, localParams, params, req) {,       QParser baseParser;,       ValueSource vs;,       String b;, ,       @Override,       public Query parse() throws SyntaxError {,         b = localParams.get(BOOSTFUNC);,         baseParser = subQuery(localParams.get(QueryParsing.V), null);,         Query q = baseParser.getQuery();, ,         if (b == null) return q;,         Query bq = subQuery(b, FunctionQParserPlugin.NAME).getQuery();,         if (bq instanceof FunctionQuery) {,           vs = ((FunctionQuery)bq).getValueSource();,         } else {,           vs = new QueryValueSource(bq, 0.0f);,         },         return new BoostedQuery(q, vs);,       }, , ,       @Override,       public String[] getDefaultHighlightFields() {,         return baseParser.getDefaultHighlightFields();,       },                                            ,       @Override,       public Query getHighlightQuery() throws SyntaxError {,         return baseParser.getHighlightQuery();,       }, ,       @Override,       public void addDebugInfo(NamedList<Object> debugInfo) {,         // encapsulate base debug info in a sub-list?,         baseParser.addDebugInfo(debugInfo);,         debugInfo.add("boost_str",b);,         debugInfo.add("boost_parsed",vs);,       }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/BoostQParserPlugin.java,addDebugInfo,84-84,[        baseParser.addDebugInfo(debugInfo);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/BoostQParserPlugin.java,getDefaultHighlightFields,73-73,[        return baseParser.getDefaultHighlightFields();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/BoostQParserPlugin.java,getHighlightQuery,78-78,[        return baseParser.getHighlightQuery();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/search/CacheConfig.java,getMultipleConfigs,75-75,[    if (nodes==null || nodes.getLength()==0) return null;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/search/CacheConfig.java,newInstance,131-131,[    } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/search/CollapsingQParserPlugin.java,getFilterCollector,222-222,[        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/search/CollapsingQParserPlugin.java,equals,175-175,[           this.getBoost()==c.getBoost()) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/search/CollapsingQParserPlugin.java,getFilterCollector,301-301,[      } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/CollapsingQParserPlugin.java,,345-370,[    public DummyScorer() {,       super(null);,     }, ,     public float score() {,       return score;,     }, ,     public int freq() {,       return 0;,     }, ,     public int advance(int i) {,       return -1;,     }, ,     public int nextDoc() {,       return 0;,     }, ,     public int docID() {,       return docId;,     }, ,     public long cost() {,       return 0;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/CollapsingQParserPlugin.java,,675-675,[      this.max = max;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/CollapsingQParserPlugin.java,collapse,912-912,[      float val = Float.intBitsToFloat((int)vals.get(contextDoc));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/CollapsingQParserPlugin.java,collapse,775-775,[      int val = (int) vals.get(contextDoc);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/CollapsingQParserPlugin.java,collapse,843-843,[      long val = vals.get(contextDoc);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/CollapsingQParserPlugin.java,,1056-1058,[  private class MaxFloatComp implements FloatCompare {,     public boolean test(float i1, float i2) {,       return i1 > i2;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/CollapsingQParserPlugin.java,,1044-1046,[  private class MaxIntComp implements IntCompare {,     public boolean test(int i1, int i2) {,       return i1 > i2;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/CollapsingQParserPlugin.java,,1068-1070,[  private class MaxLongComp implements LongCompare {,     public boolean test(long i1, long i2) {,       return i1 > i2;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/CollapsingQParserPlugin.java,,1062-1064,[  private class MinFloatComp implements FloatCompare {,     public boolean test(float i1, float i2) {,       return i1 < i2;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/CollapsingQParserPlugin.java,,1050-1052,[  private class MinIntComp implements IntCompare {,     public boolean test(int i1, int i2) {,       return i1 < i2;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/CollapsingQParserPlugin.java,,1074-1076,[  private class MinLongComp implements LongCompare {,     public boolean test(long i1, long i2) {,       return i1 < i2;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/search/CursorMark.java,parseSerializedTotem,208-208,[    } catch (Exception ex) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/ValueSourceParser.java,,936-944,[      return new DualFloatFunction(new LongConstValueSource(ms1), v2) {,         @Override,         protected String name() {,           return "ms";,         }, ,         @Override,         protected float func(int doc, FunctionValues aVals, FunctionValues bVals) {,           return ms1 - bVals.longVal(doc);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/ValueSourceParser.java,,950-958,[      return new DualFloatFunction(v1, new LongConstValueSource(ms2)) {,         @Override,         protected String name() {,           return "ms";,         }, ,         @Override,         protected float func(int doc, FunctionValues aVals, FunctionValues bVals) {,           return aVals.longVal(doc) - ms2;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/ValueSourceParser.java,,964-972,[      return new DualFloatFunction(v1, v2) {,         @Override,         protected String name() {,           return "ms";,         }, ,         @Override,         protected float func(int doc, FunctionValues aVals, FunctionValues bVals) {,           return aVals.longVal(doc) - bVals.longVal(doc);],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/search/DelegatingCollector.java,setLastDelegate,55-55,[    setLastDelegateCount++;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/DelegatingCollector.java,,73-73,[    this.context = context;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/DisMaxQParser.java,getDefaultHighlightFields,263-263,[    return queryFields.keySet().toArray(new String[queryFields.keySet().size()]);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/search/DisMaxQParser.java,addBoostFunctions,127-127,[          Float b = ff.get(f);],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/solr/search/DocSetBase.java,equals,51-67,[    if (!(obj instanceof DocSet)) return false;,     DocSet other = (DocSet)obj;,     if (this.size() != other.size()) return false;, ,     if (this instanceof DocList && other instanceof DocList) {,       // compare ordering,       DocIterator i1=this.iterator();,       DocIterator i2=other.iterator();,       while(i1.hasNext() && i2.hasNext()) {,         if (i1.nextDoc() != i2.nextDoc()) return false;,       },       return true;,       // don't compare matches,     }, ,     // if (this.size() != other.size()) return false;,     return this.getBits().equals(toBitSet(other));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/DocSetBase.java,,167-182,[    return new Filter() {,       @Override,       public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs) {,         LeafReader reader = context.reader();,         // all Solr DocSets that are used as filters only include live docs,         final Bits acceptDocs2 = acceptDocs == null ? null : (reader.getLiveDocs() == acceptDocs ? null : acceptDocs);, ,         if (context.isTopLevel) {,           return BitsFilteredDocIdSet.wrap(new BitDocIdSet(bs), acceptDocs);,         }, ,         final int base = context.docBase;,         final int maxDoc = reader.maxDoc();,         final int max = base + maxDoc;   // one past the max doc in this segment., ,         return BitsFilteredDocIdSet.wrap(new DocIdSet() {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/search/DocSetCollector.java,,44-44,[    this.smallSetSize = smallSetSize;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/DocSetCollector.java,getDocSet,77-77,[      for (int i=0; i<scratch.length; i++) bits.set(scratch[i]);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/search/DocSlice.java,<init>,49-49,[    this.docs=docs;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/search/DocSlice.java,<init>,50-50,[    this.scores=scores;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/solr/search/DocSlice.java,equals,28-28,[public class DocSlice extends DocSetBase implements DocList {],,
BAD_PRACTICE,NP_CLONE_COULD_RETURN_NULL,org/apache/solr/search/DocSlice.java,clone,176-176,[    return null;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/search/ValueSourceParser.java,equals,1186-1189,[      if (this.getClass() != o.getClass()) return false;,       Function other = (Function)o;,       return this.a.equals(other.a),           && this.b.equals(other.b);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/ExportQParserPlugin.java,,129-178,[  private class ExportCollector extends TopDocsCollector  {, ,     private FixedBitSet[] sets;,     private FixedBitSet set;, ,     public ExportCollector(FixedBitSet[] sets) {,       super(null);,       this.sets = sets;,     },     ,     public void doSetNextReader(LeafReaderContext context) throws IOException {,       this.set = new FixedBitSet(context.reader().maxDoc());,       this.sets[context.ord] = set;, ,     },     ,     public void collect(int docId) throws IOException{,       ++totalHits;,       set.set(docId);,     }, ,     private ScoreDoc[] getScoreDocs(int howMany) {,       ScoreDoc[] docs = new ScoreDoc[Math.min(totalHits, howMany)];,       for(int i=0; i<docs.length; i++) {,         docs[i] = new ScoreDoc(i,0);,       }, ,       return docs;,     }, ,     public TopDocs topDocs(int start, int howMany) {,       SolrRequestInfo info = SolrRequestInfo.getRequestInfo();,       SolrQueryRequest req = null;,       if(info != null && ((req = info.getReq()) != null)) {,         Map context = req.getContext();,         context.put("export", sets);,         context.put("totalHits", totalHits);,       }, ,       ScoreDoc[] scoreDocs = getScoreDocs(howMany);,       assert scoreDocs.length <= totalHits;,       return new TopDocs(totalHits, scoreDocs, 0.0f);,     }, ,     public void setScorer(Scorer scorer) throws IOException {, ,     },     ,     public boolean acceptsDocsOutOfOrder() {,       return false;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/ExportQParserPlugin.java,collect,147-147,[      set.set(docId);],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/solr/search/ExportQParserPlugin.java,clone,67-71,[      ExportQuery clone = new ExportQuery();,       clone.id = id;,       clone.leafCount = leafCount;,       clone.mainQuery = mainQuery;,       return clone;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/search/ExportQParserPlugin.java,equals,109-109,[        return (this.id == q.id && getBoost() == q.getBoost());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/ExportQParserPlugin.java,createWeight,84-84,[      return mainQuery.createWeight(searcher);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/ExportQParserPlugin.java,extractTerms,92-92,[      this.mainQuery.extractTerms(terms);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/ExportQParserPlugin.java,rewrite,88-88,[      return this.mainQuery.rewrite(reader);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/search/ExtendedDismaxQParser.java,parseOriginalQuery,329-329,[    } catch (Exception e) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/search/ExtendedDismaxQParser.java,splitIntoClauses,802-823,[          switch (ch) {,             case '!':,             case '(':,             case ')':,             case ':':,             case '^':,             case '[':,             case ']':,             case '{':,             case '}':,             case '~':,             case '*':,             case '?':,             case '"':,             case '+':,             case '-':,             case '\\':,             case '|':,             case '&':,             case '/':,               clause.hasSpecialSyntax = true;,               sb.append('\\');],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/search/ExtendedDismaxQParser.java,getBoostFunctions,472-472,[          Float b = ff.get(f);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/ExtendedDismaxQParser.java,,822-822,[              clause.hasSpecialSyntax = true;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/ExtendedDismaxQParser.java,,792-792,[          clause.hasWhitespace=true;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/ExtendedDismaxQParser.java,,759-759,[        clause.rawField = s.substring(pos, colon);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/ExtendedDismaxQParser.java,,845-845,[          clause.syntaxError = true;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/search/ExtendedDismaxQParser.java,compareTo,1440-1440,[      return other.wildcard.length() - wildcard.length();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/ExtendedDismaxQParser.java,,1490-1555,[        SolrParams params, SolrQueryRequest req) {,       solrParams = SolrParams.wrapDefaults(localParams, params);,       minShouldMatch = DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams); // req.getSearcher() here causes searcher refcount imbalance,       userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));,       try {,         queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);  // req.getSearcher() here causes searcher refcount imbalance,       } catch (SyntaxError e) {,         throw new RuntimeException();,       },       // Phrase slop array,       int pslop[] = new int[4];,       pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);,       pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);,       pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);,       ,       List<FieldParams> phraseFields = U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);,       List<FieldParams> phraseFields2 = U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);,       List<FieldParams> phraseFields3 = U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);,       ,       allPhraseFields = new ArrayList<>(phraseFields.size() + phraseFields2.size() + phraseFields3.size());,       allPhraseFields.addAll(phraseFields);,       allPhraseFields.addAll(phraseFields2);,       allPhraseFields.addAll(phraseFields3);,       ,       tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);,       ,       qslop = solrParams.getInt(DisMaxParams.QS, 0);,       ,       stopwords = solrParams.getBool(DMP.STOPWORDS, true);,       ,       altQ = solrParams.get( DisMaxParams.ALTQ );,       ,       lowercaseOperators = solrParams.getBool(DMP.LOWERCASE_OPS, true);,       ,       /* * * Boosting Query * * */,       boostParams = solrParams.getParams(DisMaxParams.BQ);,       ,       boostFuncs = solrParams.getParams(DisMaxParams.BF);,       ,       multBoosts = solrParams.getParams(DMP.MULT_BOOST);,     },     /**,      * ,      * @return true if there are valid multiplicative boost queries,      */,     public boolean hasMultiplicativeBoosts() {,       return multBoosts!=null && multBoosts.length>0;,     },     ,     /**,      * ,      * @return true if there are valid boost functions,      */,     public boolean hasBoostFunctions() {,       return null != boostFuncs && 0 != boostFuncs.length;,     },     /**,      * ,      * @return true if there are valid boost params,      */,     public boolean hasBoostParams() {,       return boostParams!=null && boostParams.length>0;,     },     ,     public List<FieldParams> getAllPhraseFields() {,       return allPhraseFields;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/search/ExtendedDismaxQParser.java,getQuery,1260-1260,[      } catch (Exception e) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/search/ExtendedDismaxQParser.java,,973-973,[    boolean allowWildcard=true;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/ExtendedDismaxQParser.java,,966-966,[    protected class Alias {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/ExtendedDismaxQParser.java,getQueries,1204-1204,[      if (a.fields.size()==0) return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/ExtendedDismaxQParser.java,validateField,1189-1189,[      for(String referencedField:this.getAlias(field).fields.keySet()) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/search/FastLRUCache.java,warm,148-148,[    FastLRUCache other = (FastLRUCache) old;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/FieldQParserPlugin.java,,43-50,[    return new QParser(qstr, localParams, params, req) {,       @Override,       public Query parse() {,         String field = localParams.get(QueryParsing.F);,         String queryText = localParams.get(QueryParsing.V);,         SchemaField sf = req.getSchema().getField(field);,         FieldType ft = sf.getType();,         return ft.getFieldQuery(this, sf, queryText);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/search/SolrIndexSearcher.java,,2477-2477,[    this.filter = filter;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/search/FunctionQParser.java,parseNestedQuery,255-255,[          sub = subQuery(qs, null);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/FunctionRangeQParserPlugin.java,,47-69,[    return new QParser(qstr, localParams, params, req) {,       ValueSource vs;,       String funcStr;, ,       @Override,       public Query parse() throws SyntaxError {,         funcStr = localParams.get(QueryParsing.V, null);,         Query funcQ = subQuery(funcStr, FunctionQParserPlugin.NAME).getQuery();,         if (funcQ instanceof FunctionQuery) {,           vs = ((FunctionQuery)funcQ).getValueSource();,         } else {,           vs = new QueryValueSource(funcQ, 0.0f);,         }, ,         String l = localParams.get("l");,         String u = localParams.get("u");,         boolean includeLower = localParams.getBool("incl",true);,         boolean includeUpper = localParams.getBool("incu",true);, ,         // TODO: add a score=val option to allow score to be the value,         ValueSourceRangeFilter rf = new ValueSourceRangeFilter(vs, l, u, includeLower, includeUpper);,         FunctionRangeQuery frq = new FunctionRangeQuery(rf);,         return frq;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/solr/search/SolrConstantScoreQuery.java,equals,225-228,[    if (this == o) return true;,     if (!(o instanceof SolrConstantScoreQuery)) return false;,     SolrConstantScoreQuery other = (SolrConstantScoreQuery)o;,     return this.getBoost()==other.getBoost() && filter.equals(other.filter);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/FunctionRangeQuery.java,collect,56-56,[      if (doc<maxdoc && scorer.matches(doc)) {],,
PERFORMANCE,BX_UNBOXING_IMMEDIATELY_REBOXED,org/apache/solr/search/Grouping.java,commonResponse,609-609,[        groupResult.add("ngroups", totalNrOfGroups == null ? 0 : totalNrOfGroups);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/Grouping.java,createSecondPassCollector,744-744,[      topGroups = format == Format.grouped ? firstPass.getTopGroups(offset, false) : firstPass.getTopGroups(0, false);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/Grouping.java,createSecondPassCollector,964-964,[      topGroups = format == Format.grouped ? firstPass.getTopGroups(offset, false) : firstPass.getTopGroups(0, false);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/Grouping.java,prepare,934-934,[      groupBy.createWeight(context, searcher);],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/solr/search/Grouping.java,,950-950,[      firstPass = new FunctionFirstPassGroupingCollector(groupBy, context, searcher.weightSort(sort), actualGroupsToFind);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/Grouping.java,finish,893-893,[      TopDocsCollector topDocsCollector = (TopDocsCollector) collector.getDelegate();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/Grouping.java,getMatches,909-909,[      return collector.getMatches();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/Grouping.java,finish,895-895,[      GroupDocs<String> groupDocs = new GroupDocs<>(Float.NaN, topDocs.getMaxScore(), topDocs.totalHits, topDocs.scoreDocs, query.toString(), null);],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/solr/search/HashDocSet.java,equals,32-32,[public final class HashDocSet extends DocSetBase {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/JoinQParserPlugin.java,,70-108,[    return new QParser(qstr, localParams, params, req) {,       @Override,       public Query parse() throws SyntaxError {,         String fromField = getParam("from");,         String fromIndex = getParam("fromIndex");,         String toField = getParam("to");,         String v = localParams.get("v");,         Query fromQuery;,         long fromCoreOpenTime = 0;, ,         if (fromIndex != null && !fromIndex.equals(req.getCore().getCoreDescriptor().getName()) ) {,           CoreContainer container = req.getCore().getCoreDescriptor().getCoreContainer();, ,           final SolrCore fromCore = container.getCore(fromIndex);,           RefCounted<SolrIndexSearcher> fromHolder = null;, ,           if (fromCore == null) {,             throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Cross-core join: no such core " + fromIndex);,           }, ,           LocalSolrQueryRequest otherReq = new LocalSolrQueryRequest(fromCore, params);,           try {,             QParser parser = QParser.getParser(v, "lucene", otherReq);,             fromQuery = parser.getQuery();,             fromHolder = fromCore.getRegisteredSearcher();,             if (fromHolder != null) fromCoreOpenTime = fromHolder.get().getOpenTime();,           } finally {,             otherReq.close();,             fromCore.close();,             if (fromHolder != null) fromHolder.decref();,           },         } else {,           QParser fromQueryParser = subQuery(v, null);,           fromQuery = fromQueryParser.getQuery();,         }, ,         JoinQuery jq = new JoinQuery(fromField, toField, fromIndex, fromQuery);,         jq.fromCoreOpenTime = fromCoreOpenTime;,         return jq;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/search/JoinQParserPlugin.java,createWeight,143-143,[    return new JoinQueryWeight((SolrIndexSearcher)searcher);],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/search/JoinQParserPlugin.java,equals,584-584,[           && this.q.equals(other.q)],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/search/JoinQParserPlugin.java,equals,583-583,[           && this.getBoost() == other.getBoost()],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/search/JoinQParserPlugin.java,,530-530,[    int doc = -1;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/search/LFUCache.java,warm,170-170,[    LFUCache other = (LFUCache) old;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/search/LFUCache.java,getDocs,231-231,[    return null;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/search/LRUCache.java,warm,156-156,[    LRUCache<K,V> other = (LRUCache<K,V>)old;],,
STYLE,IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD,org/apache/solr/search/LRUCache.java,size,72-72,[          if (size() > limit) {],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/solr/search/ValueSourceParser.java,equals,1036-1036,[    if (LongConstValueSource.class != o.getClass()) return false;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/search/ValueSourceParser.java,equals,1036-1038,[    if (LongConstValueSource.class != o.getClass()) return false;,     LongConstValueSource other = (LongConstValueSource) o;,     return this.constant == other.constant;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/LuceneQueryOptimizer.java,,48-51,[    this.cache = new LinkedHashMap(cacheSize, 0.75f, true) {,         @Override,         protected boolean removeEldestEntry(Map.Entry eldest) {,           return size() > cacheSize;              // limit size of cache],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/NestedQParserPlugin.java,,43-68,[    return new QParser(qstr, localParams, params, req) {,       QParser baseParser;,       ValueSource vs;,       String b;, ,       @Override,       public Query parse() throws SyntaxError {,         baseParser = subQuery(localParams.get(QueryParsing.V), null);,         return baseParser.getQuery();,       }, ,       @Override,       public String[] getDefaultHighlightFields() {,         return baseParser.getDefaultHighlightFields();,       }, ,       @Override,       public Query getHighlightQuery() throws SyntaxError {,         return baseParser.getHighlightQuery();,       }, ,       @Override,       public void addDebugInfo(NamedList<Object> debugInfo) {,         // encapsulate base debug info in a sub-list?,         baseParser.addDebugInfo(debugInfo);,       }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/NestedQParserPlugin.java,addDebugInfo,67-67,[        baseParser.addDebugInfo(debugInfo);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/NestedQParserPlugin.java,getDefaultHighlightFields,56-56,[        return baseParser.getDefaultHighlightFields();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/NestedQParserPlugin.java,getHighlightQuery,61-61,[        return baseParser.getHighlightQuery();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/PrefixQParserPlugin.java,,43-47,[    return new QParser(qstr, localParams, params, req) {,       @Override,       public Query parse() {,         SchemaField sf = req.getSchema().getField(localParams.get(QueryParsing.F));,         return sf.getType().getPrefixQuery(this, sf, localParams.get(QueryParsing.V));],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/QParser.java,,317-317,[    parser.stringIncludingLocalParams = stringIncludingLocalParams;],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/solr/search/QParserPlugin.java,,41-41,[  public static final Object[] standardPlugins = {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/search/QueryParsing.java,toString,475-475,[      FieldType ft = writeFieldName(fname, schema, out, flags);],,toString,551-551,[      FieldType ft = writeFieldName(prefix.field(), schema, out, flags);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/search/QueryParsing.java,parseSortSpec,325-325,[          } catch (Exception e) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/solr/search/QueryParsing.java,getQuotedString,868-889,[          switch (ch) {,             case 'n':,               ch = '\n';,               break;,             case 't':,               ch = '\t';,               break;,             case 'r':,               ch = '\r';,               break;,             case 'b':,               ch = '\b';,               break;,             case 'f':,               ch = '\f';,               break;,             case 'u':,               if (pos + 4 >= end) {,                 throw new SyntaxError("bad unicode escape \\uxxxx at pos" + (val_start - 1) + " str='" + val + "'");,               },               ch = (char) Integer.parseInt(val.substring(pos + 1, pos + 5), 16);,               pos += 4;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/RawQParserPlugin.java,,45-48,[    return new QParser(qstr, localParams, params, req) {,       @Override,       public Query parse() {,         return new TermQuery(new Term(localParams.get(QueryParsing.F), localParams.get(QueryParsing.V)));],,
BAD_PRACTICE,CO_COMPARETO_INCORRECT_FLOATING,org/apache/solr/search/ReRankQParserPlugin.java,compare,422-422,[      } else if(score1 < score2) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/solr/search/ReRankQParserPlugin.java,,395-425,[    public BoostedComp(IntIntOpenHashMap boostedDocs, ScoreDoc[] scoreDocs, float maxScore) {,       this.boostedMap = new IntFloatOpenHashMap(boostedDocs.size()*2);, ,       for(int i=0; i<scoreDocs.length; i++) {,         if(boostedDocs.containsKey(scoreDocs[i].doc)) {,           boostedMap.put(scoreDocs[i].doc, maxScore+boostedDocs.lget());,         } else {,           break;,         },       },     }, ,     public int compare(Object o1, Object o2) {,       ScoreDoc doc1 = (ScoreDoc) o1;,       ScoreDoc doc2 = (ScoreDoc) o2;,       float score1 = doc1.score;,       float score2 = doc2.score;,       if(boostedMap.containsKey(doc1.doc)) {,         score1 = boostedMap.lget();,       }, ,       if(boostedMap.containsKey(doc2.doc)) {,         score2 = boostedMap.lget();,       }, ,       if(score1 > score2) {,         return -1;,       } else if(score1 < score2) {,         return 1;,       } else {,         return 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/ReRankQParserPlugin.java,,395-425,[    public BoostedComp(IntIntOpenHashMap boostedDocs, ScoreDoc[] scoreDocs, float maxScore) {,       this.boostedMap = new IntFloatOpenHashMap(boostedDocs.size()*2);, ,       for(int i=0; i<scoreDocs.length; i++) {,         if(boostedDocs.containsKey(scoreDocs[i].doc)) {,           boostedMap.put(scoreDocs[i].doc, maxScore+boostedDocs.lget());,         } else {,           break;,         },       },     }, ,     public int compare(Object o1, Object o2) {,       ScoreDoc doc1 = (ScoreDoc) o1;,       ScoreDoc doc2 = (ScoreDoc) o2;,       float score1 = doc1.score;,       float score2 = doc2.score;,       if(boostedMap.containsKey(doc1.doc)) {,         score1 = boostedMap.lget();,       }, ,       if(boostedMap.containsKey(doc2.doc)) {,         score2 = boostedMap.lget();,       }, ,       if(score1 > score2) {,         return -1;,       } else if(score1 < score2) {,         return 1;,       } else {,         return 0;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/search/ReRankQParserPlugin.java,topDocs,295-295,[          IntIntOpenHashMap boostedDocs = QueryElevationComponent.getBoostDocs((SolrIndexSearcher)searcher, boostedPriority, requestContext);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/search/ReRankQParserPlugin.java,equals,118-118,[                getBoost() == rrq.getBoost());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/ReRankQParserPlugin.java,,180-220,[  private class ReRankWeight extends Weight{,     private Query reRankQuery;,     private IndexSearcher searcher;,     private Weight mainWeight;,     private double reRankWeight;, ,     public ReRankWeight(Query mainQuery, Query reRankQuery, double reRankWeight, IndexSearcher searcher) throws IOException {,       this.reRankQuery = reRankQuery;,       this.searcher = searcher;,       this.reRankWeight = reRankWeight;,       this.mainWeight = mainQuery.createWeight(searcher);,     }, ,     public float getValueForNormalization() throws IOException {,       return mainWeight.getValueForNormalization();,     }, ,     public Scorer scorer(LeafReaderContext context, Bits bits) throws IOException {,       return mainWeight.scorer(context, bits);,     }, ,     public Query getQuery() {,       return mainWeight.getQuery();,     }, ,     public void normalize(float norm, float topLevelBoost) {,       mainWeight.normalize(norm, topLevelBoost);,     }, ,     public Explanation explain(LeafReaderContext context, int doc) throws IOException {,       Explanation mainExplain = mainWeight.explain(context, doc);,       return new QueryRescorer(reRankQuery) {,         @Override,         protected float combine(float firstPassScore, boolean secondPassMatches, float secondPassScore) {,           float score = firstPassScore;,           if (secondPassMatches) {,             score += reRankWeight * secondPassScore;,           },           return score;,         },       }.explain(searcher, mainExplain, context.docBase+doc);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/solr/search/SolrCacheBase.java,isAutowarmingOn,127-127,[    return autowarm.isAutoWarmingOn();],,isAutoWarmingOn,82-82,[      return doAutoWarming;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/search/SolrCacheBase.java,getDocs,111-111,[    return null;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/search/SolrConstantScoreQuery.java,equals,228-228,[    return this.getBoost()==other.getBoost() && filter.equals(other.filter);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/solr/search/SolrConstantScoreQuery.java,,155-201,[    int doc = -1;, ,     public ConstantScorer(LeafReaderContext context, ConstantWeight w, float theScore, Bits acceptDocs) throws IOException {,       super(w);,       this.theScore = theScore;,       this.acceptDocs = acceptDocs;,       DocIdSet docIdSet = filter instanceof SolrFilter ? ((SolrFilter)filter).getDocIdSet(w.context, context, acceptDocs) : filter.getDocIdSet(context, acceptDocs);,       if (docIdSet == null) {,         docIdSetIterator = DocIdSetIterator.empty();,       } else {,         DocIdSetIterator iter = docIdSet.iterator();,         if (iter == null) {,           docIdSetIterator = DocIdSetIterator.empty();,         } else {,           docIdSetIterator = iter;,         },       },     }, ,     @Override,     public int nextDoc() throws IOException {,       return docIdSetIterator.nextDoc();,     }, ,     @Override,     public int docID() {,       return docIdSetIterator.docID();,     }, ,     @Override,     public float score() throws IOException {,       return theScore;,     },     ,     @Override,     public int freq() throws IOException {,       return 1;,     }, ,     @Override,     public int advance(int target) throws IOException {,       return docIdSetIterator.advance(target);,     }, ,     @Override,     public long cost() {,       return docIdSetIterator.cost();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/search/SolrConstantScoreQuery.java,,155-155,[    int doc = -1;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/search/SolrConstantScoreQuery.java,,160-160,[      this.acceptDocs = acceptDocs;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/search/SolrFieldCacheMBean.java,getDocs,49-49,[    return null;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/search/SolrIndexSearcher.java,getDocSet,1229-1229,[        if (fbs == null) fbs = new FixedBitSet(maxDoc());],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/search/SolrIndexSearcher.java,getDocs,2271-2271,[    return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/search/SolrIndexSearcher.java,getDocSet,1492-1492,[        if (bigFilt != null) out.docSet = out.docSet.intersection(bigFilt);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/search/SolrIndexSearcher.java,getDocSet,1229-1229,[        if (fbs == null) fbs = new FixedBitSet(maxDoc());],,
STYLE,UC_USELESS_CONDITION,org/apache/solr/search/SolrIndexSearcher.java,close,447-447,[        if (debug) log.debug("Closing " + name);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/search/SolrIndexSearcher.java,compare,971-971,[      return ((ExtendedQuery)q1).getCost() - ((ExtendedQuery)q2).getCost();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/search/SolrIndexSearcher.java,compare,971-971,[      return ((ExtendedQuery)q1).getCost() - ((ExtendedQuery)q2).getCost();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/SolrIndexSearcher.java,,1642-1649,[        collector = new SimpleCollector () {,           @Override,           public void collect(int doc) {,             numHits[0]++;,           },           @Override,           public boolean acceptsDocsOutOfOrder() {,             return true;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/SolrIndexSearcher.java,,1653-1667,[        collector = new SimpleCollector() {,           Scorer scorer;,           @Override,           public void setScorer(Scorer scorer) {,             this.scorer = scorer;,           },           @Override,           public void collect(int doc) throws IOException {,             numHits[0]++;,             float score = scorer.score();,             if (score > topscore[0]) topscore[0]=score;            ,           },           @Override,           public boolean acceptsDocsOutOfOrder() {,             return true;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/SolrIndexSearcher.java,collect,1662-1662,[            float score = scorer.score();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/SolrIndexSearcher.java,,1739-1756,[         final Collector topScoreCollector = new SimpleCollector() {,           ,            Scorer scorer;,            ,            @Override,           public void setScorer(Scorer scorer) throws IOException {,             this.scorer = scorer;,           },            ,           @Override,           public void collect(int doc) throws IOException {,             float score = scorer.score();,             if (score > topscore[0]) topscore[0] = score;,           },           ,           @Override,           public boolean acceptsDocsOutOfOrder() {,             return true;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/SolrIndexSearcher.java,collect,1750-1750,[            float score = scorer.score();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/SolrIndexSearcher.java,getDocSet,1180-1180,[    int largestPossible = deState.termsEnum.docFreq();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/SolrIndexSearcher.java,getDocList,2438-2438,[    public DocList getDocList() { return docListAndSet.docList; }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/SolrIndexSearcher.java,getDocSet,2446-2446,[    public DocSet getDocSet() { return docListAndSet.docSet; }],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/search/SolrQueryTimeoutImpl.java,,35-35,[  public static ThreadLocal<Long> timeoutAt = new ThreadLocal<Long>() {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/search/SolrReturnFields.java,add,224-224,[        if (field == null) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/search/SolrReturnFields.java,add,201-201,[              addField(field, key, augmenters, false);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/search/SolrReturnFields.java,add,224-224,[        if (field == null) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/search/SortedIntDocSet.java,getDocs,52-52,[  public int[] getDocs() { return docs; }],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/search/SortedIntDocSet.java,<init>,40-40,[    this.docs = docs;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/solr/search/SortedIntDocSet.java,equals,33-33,[public class SortedIntDocSet extends DocSetBase {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/search/SortedIntDocSet.java,,62-62,[  public static int[] zeroInts = new int[0];],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/search/SortedIntDocSet.java,,63-63,[  public static SortedIntDocSet zero = new SortedIntDocSet(zeroInts);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/SortedIntDocSet.java,,63-63,[  public static SortedIntDocSet zero = new SortedIntDocSet(zeroInts);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/search/SpatialOptions.java,,45-45,[    this.measStr = measStr;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/search/SwitchQParserPlugin.java,,145-145,[  public static String SWITCH_CASE = "case";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/search/SwitchQParserPlugin.java,,152-152,[  public static String SWITCH_DEFAULT = "default";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/SwitchQParserPlugin.java,,160-195,[    return new QParser(qstr, localParams, params, req) {,       QParser subParser;, ,       @Override,       public Query parse() throws SyntaxError {,         String val = localParams.get(QueryParsing.V);, ,         // we don't want to wrapDefaults arround params, because then ,         // clients could add their own switch options ,         String subQ = localParams.get(SWITCH_DEFAULT);,         subQ = StringUtils.isBlank(val),           ? localParams.get(SWITCH_CASE, subQ),           : localParams.get(SWITCH_CASE + "." + val.trim(), subQ);, ,         if (null == subQ) {,           throw new SyntaxError("No "+SWITCH_DEFAULT+", and no switch case matching specified query string: \"" + val + "\"");,         }, ,         subParser = subQuery(subQ, null);,         return subParser.getQuery();,       }, ,       @Override,       public String[] getDefaultHighlightFields() {,         return subParser.getDefaultHighlightFields();,       },                                            ,       @Override,       public Query getHighlightQuery() throws SyntaxError {,         return subParser.getHighlightQuery();,       }, ,       @Override,       public void addDebugInfo(NamedList<Object> debugInfo) {,         subParser.addDebugInfo(debugInfo);,       }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/SwitchQParserPlugin.java,addDebugInfo,194-194,[        subParser.addDebugInfo(debugInfo);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/SwitchQParserPlugin.java,getDefaultHighlightFields,184-184,[        return subParser.getDefaultHighlightFields();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/search/SwitchQParserPlugin.java,getHighlightQuery,189-189,[        return subParser.getHighlightQuery();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/TermQParserPlugin.java,,52-64,[    return new QParser(qstr, localParams, params, req) {,       @Override,       public Query parse() {,         String fname = localParams.get(QueryParsing.F);,         FieldType ft = req.getSchema().getFieldTypeNoEx(fname);,         String val = localParams.get(QueryParsing.V);,         BytesRefBuilder term = new BytesRefBuilder();,         if (ft != null) {,           ft.readableToIndexed(val, term);,         } else {,           term.copyChars(val);,         },         return new TermQuery(new Term(fname, term.get()));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/TermsQParserPlugin.java,,105-137,[    return new QParser(qstr, localParams, params, req) {,       @Override,       public Query parse() throws SyntaxError {,         String fname = localParams.get(QueryParsing.F);,         FieldType ft = req.getSchema().getFieldTypeNoEx(fname);,         String separator = localParams.get(SEPARATOR, ",");,         String qstr = localParams.get(QueryParsing.V);//never null,         Method method = Method.valueOf(localParams.get(METHOD, Method.termsFilter.name()));,         //TODO pick the default method based on various heuristics from benchmarks, ,         //if space then split on all whitespace & trim, otherwise strictly interpret,         final boolean sepIsSpace = separator.equals(" ");,         if (sepIsSpace),           qstr = qstr.trim();,         if (qstr.length() == 0),           return new BooleanQuery();//Matches nothing.,         final String[] splitVals = sepIsSpace ? qstr.split("\\s+") : qstr.split(Pattern.quote(separator), -1);,         assert splitVals.length > 0;, ,         BytesRef[] bytesRefs = new BytesRef[splitVals.length];,         BytesRefBuilder term = new BytesRefBuilder();,         for (int i = 0; i < splitVals.length; i++) {,           String stringVal = splitVals[i];,           //logic same as TermQParserPlugin,           if (ft != null) {,             ft.readableToIndexed(stringVal, term);,           } else {,             term.copyChars(stringVal);,           },           bytesRefs[i] = term.toBytesRef();,         }, ,         return new SolrConstantScoreQuery(method.makeFilter(fname, bytesRefs));],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/search/ValueSourceParser.java,,69-69,[  public static Map<String, ValueSourceParser> standardValueSourceParsers = new HashMap<>();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/search/function/CollapseScoreFunction.java,,53-70,[    public CollapseScoreFunctionValues(Map context) {,       this.cscore = (CollapseScore) context.get("CSCORE");,     }, ,     public int intVal(int doc) {,       return 0;,     }, ,     public String toString(int doc) {,       return Float.toString(cscore.score);,     }, ,     public float floatVal(int doc) {,       return cscore.score;,     }, ,     public double doubleVal(int doc) {,       return 0.0D;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/search/function/FileFloatSource.java,getFloats,321-321,[      try{r.close();}catch(Exception e){}],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/solr/search/function/FileFloatSource.java,equals,100-100,[    if (o.getClass() !=  FileFloatSource.class) return false;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/search/function/FileFloatSource.java,equals,103-103,[            && this.keyField.getName().equals(other.keyField.getName())],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/search/function/FileFloatSource.java,equals,100-105,[    if (o.getClass() !=  FileFloatSource.class) return false;,     FileFloatSource other = (FileFloatSource)o;,     return this.field.getName().equals(other.field.getName()),             && this.keyField.getName().equals(other.keyField.getName()),             && this.defVal == other.defVal,             && this.dataDir.equals(other.dataDir);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/function/FileFloatSource.java,,85-93,[    return new FloatDocValues(this) {,       @Override,       public float floatVal(int doc) {,         return arr[doc + off];,       }, ,       @Override,       public Object objectVal(int doc) {,         return floatVal(doc);   // TODO: keep track of missing values],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/search/function/FileFloatSource.java,get,193-193,[              onlyForTesting = progress.value;],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/solr/search/function/OrdFieldSource.java,equals,144-144,[    return o != null && o.getClass() == OrdFieldSource.class && this.field.equals(((OrdFieldSource)o).field);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/function/OrdFieldSource.java,,100-124,[    return new IntDocValues(this) {,       protected String toTerm(String readableValue) {,         return readableValue;,       },       @Override,       public int intVal(int doc) {,         return sindex.getOrd(doc+off);,       },       @Override,       public int ordVal(int doc) {,         return sindex.getOrd(doc+off);,       },       @Override,       public int numOrd() {,         return sindex.getValueCount();,       }, ,       @Override,       public boolean exists(int doc) {,         return sindex.getOrd(doc+off) != 0;,       }, ,       @Override,       public ValueFiller getValueFiller() {,         return new ValueFiller() {],,
CORRECTNESS,UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS,org/apache/solr/search/function/OrdFieldSource.java,toTerm,102-102,[        return readableValue;],,
BAD_PRACTICE,EQ_GETCLASS_AND_CLASS_CONSTANT,org/apache/solr/search/function/ReverseOrdFieldSource.java,equals,112-112,[    if (o == null || (o.getClass() !=  ReverseOrdFieldSource.class)) return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/function/ReverseOrdFieldSource.java,,102-105,[    return new IntDocValues(this) {,      @Override,       public int intVal(int doc) {,         return (end - sindex.getOrd(doc+off) - 1);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/search/function/distance/GeoDistValueSourceParser.java,getConstants,168-168,[    if (!(vs instanceof VectorValueSource)) return null;],,getConstants,173-173,[    return null;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/lucene/queries/function/valuesource/VectorValueSource.java,equals,208-213,[    if (this == o) return true;,     if (!(o instanceof VectorValueSource)) return false;, ,     VectorValueSource that = (VectorValueSource) o;, ,     return sources.equals(that.sources);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/search/function/distance/GeohashHaversineFunction.java,equals,112-112,[            geoHash2.equals(other.geoHash2) &&],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/search/function/distance/GeohashHaversineFunction.java,equals,108-112,[    if (this.getClass() != o.getClass()) return false;,     GeohashHaversineFunction other = (GeohashHaversineFunction) o;,     return this.name().equals(other.name()),             && geoHash1.equals(other.geoHash1) &&,             geoHash2.equals(other.geoHash2) &&],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/solr/search/function/distance/HaversineFunction.java,equals,126-130,[    if (this.getClass() != o.getClass()) return false;,     HaversineFunction other = (HaversineFunction) o;,     return this.name().equals(other.name()),             && p1.equals(other.p1) &&,             p2.equals(other.p2) && radius == other.radius;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/search/function/distance/StringDistanceFunction.java,floatVal,58-58,[          return (s1 == s2) ? 1.0F : 0.0F;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/search/grouping/GroupingSpecification.java,getFields,46-46,[    return fields;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/search/grouping/GroupingSpecification.java,getFunctions,70-70,[    return functions;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/search/grouping/GroupingSpecification.java,getQueries,58-58,[    return queries;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/search/grouping/GroupingSpecification.java,setFields,54-54,[    this.fields = fields;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/search/grouping/GroupingSpecification.java,setFunctions,78-78,[    this.functions = functions;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/search/grouping/GroupingSpecification.java,setQueries,66-66,[    this.queries = queries;],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/solr/search/grouping/collector/FilterCollector.java,,33-68,[public class FilterCollector extends org.apache.lucene.search.FilterCollector {, ,   private final DocSet filter;,   private int matches;, ,   public FilterCollector(DocSet filter, Collector delegate) {,     super(delegate);,     this.filter = filter;,   }, ,   @Override,   public LeafCollector getLeafCollector(LeafReaderContext context),       throws IOException {,     final int docBase = context.docBase;,     return new FilterLeafCollector(super.getLeafCollector(context)) {,       @Override,       public void collect(int doc) throws IOException {,         matches++;,         if (filter.exists(doc + docBase)) {,           super.collect(doc);,         },       },     };,   }, ,   public int getMatches() {,     return matches;,   }, ,   /**,    * Returns the delegate collector,    *,    * @return the delegate collector,    */,   public Collector getDelegate() {,     return in;],,
PERFORMANCE,BX_UNBOXING_IMMEDIATELY_REBOXED,org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor.java,process,116-116,[            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor.java,process,124-124,[          commandSearchGroups.get(field).add(searchGroups);],,process,140-140,[        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor.java,process,137-137,[        commandTopGroups.get(field).add(topGroups);],,process,155-155,[        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);],,process,165-165,[        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/search/grouping/distributed/shardresultserializer/TopGroupsResultTransformer.java,serializeTopDocs,268-268,[    CharsRef spare = new CharsRef();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/search/grouping/distributed/shardresultserializer/TopGroupsResultTransformer.java,serializeTopGroups,207-207,[    CharsRef spare = new CharsRef();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/search/mlt/CloudMLTQParser.java,,108-108,[    SolrQueryRequestBase request = new SolrQueryRequestBase(core, params) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/search/mlt/SimpleMLTQParser.java,parse,79-79,[          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/search/stats/ExactStatsCache.java,mergeToGlobalStats,109-109,[      if (terms != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/search/stats/StatsUtil.java,termStatsFromString,159-159,[    } catch (Exception e) {],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/servlet/LoadAdminUiServlet.java,doGet,54-54,[        Writer out = new OutputStreamWriter(response.getOutputStream(), StandardCharsets.UTF_8);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/servlet/SolrDispatchFilter.java,remoteQuery,530-530,[      URL url = new URL(urlstr);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/servlet/SolrDispatchFilter.java,doFilter,349-349,[          if( handler == null && path.length() > 1 ) { // don't match "" or "/" as valid path],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/servlet/SolrDispatchFilter.java,doFilter,319-319,[              remoteQuery(coreUrl + path, req, solrReq, resp);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/solr/servlet/SolrDispatchFilter.java,sendError,822-822,[      QueryResponseWriter writer = core.getQueryResponseWriter(req);],,sendError,807-807,[        localCore = cores.getCore(""); // default core],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/servlet/SolrDispatchFilter.java,doFilter,349-349,[          if( handler == null && path.length() > 1 ) { // don't match "" or "/" as valid path],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/solr/servlet/SolrDispatchFilter.java,checkStateIsValid,474-474,[          if (Boolean.TRUE != status) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/servlet/SolrDispatchFilter.java,loadConfigSolr,164-164,[      } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/servlet/SolrDispatchFilter.java,,820-820,[        req = new SolrQueryRequestBase(core, solrParams) {};],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/servlet/SolrRequestParsers.java,parseFormDataContent,324-324,[          final int upper = digit16(b = postContent.read());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/servlet/SolrRequestParsers.java,,209-209,[    SolrQueryRequestBase q = new SolrQueryRequestBase( core, params ) { };],,
MT_CORRECTNESS,MSF_MUTABLE_SERVLET_FIELD,org/apache/solr/servlet/ZookeeperInfoServlet.java,,398-398,[    printer.pagingSupport = pagingSupport;],,,334-334,[      if (pagingSupport == null) {],,,335-335,[        pagingSupport = new PagedCollectionSupport();],,,339-339,[          zkController.addOnReconnectListener(pagingSupport);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/servlet/ZookeeperInfoServlet.java,printZnode,720-720,[          for (String collection : page.selected) {],,printZnode,771-771,[            for (String next : page.selected)],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/servlet/ZookeeperInfoServlet.java,matchesStatusFilter,160-160,[        Map<String,Object> shard = (Map<String,Object>)shards.get(shardId);],,matchesStatusFilter,163-163,[          Map<String,Object> replicaState = (Map<String,Object>)replicas.get(replicaId);],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/solr/servlet/ZookeeperInfoServlet.java,,217-318,[  static final class PagedCollectionSupport implements Watcher, Comparator<String>, OnReconnect {, ,     // this is the full merged list of collections from ZooKeeper,     private List<String> cachedCollections;, ,     /**,      * If the list of collections changes, mark the cache as stale.,      */,     @Override,     public void process(WatchedEvent event) {,       synchronized (this) {,         cachedCollections = null;,       },     },     ,     /**,      * Create a merged view of all collections (internal from /clusterstate.json and external from /collections/?/state.json ,      */,     private synchronized List<String> getCollections(SolrZkClient zkClient) throws KeeperException, InterruptedException {,       if (cachedCollections == null) {,         // cache is stale, rebuild the full list ...,         cachedCollections = new ArrayList<String>();,         ,         List<String> fromZk = zkClient.getChildren("/collections", this, true);,         if (fromZk != null),           cachedCollections.addAll(fromZk);,                 ,         // sort the final merged set of collections,         Collections.sort(cachedCollections, this);,       },       ,       return cachedCollections;,     },                 ,     /**,      * Gets the requested page of collections after applying filters and offsets. ,      */,     public PageOfCollections fetchPage(PageOfCollections page, SolrZkClient zkClient) ,         throws KeeperException, InterruptedException {, , ,       List<String> children = getCollections(zkClient);,       page.selected = children; // start with the page being the full list,       ,       // activate paging (if disabled) for large collection sets,       if (page.start == 0 && page.rows == -1 && page.filter == null && children.size() > 10) {,         page.rows = 20;,         page.start = 0;,       },       ,       // apply the name filter if supplied (we don't need to pull state,       // data from ZK to do name filtering,       if (page.filterType == FilterType.name && page.filter != null),         children = page.applyNameFilter(children);, ,       // a little hacky ... we can't select the page when filtering by,       // status until reading all status objects from ZK,       if (page.filterType != FilterType.status),         page.selectPage(children);        ,       ,       return page;,     },         ,     @Override,     public int compare(String left, String right) {,       if (left == null),         return -1;,       ,       if (left.equals(right)),         return 0;,       ,       // sort lexically unless the two collection names start with the same base prefix,       // and end in a number (which is a common enough naming scheme to have direct ,       // support for it),       Matcher leftMatcher = endsWithDigits.matcher(left);,       if (leftMatcher.matches()) {,         Matcher rightMatcher = endsWithDigits.matcher(right);,         if (rightMatcher.matches()) {,           String leftGroup1 = leftMatcher.group(1);,           String rightGroup1 = rightMatcher.group(1);,           if (leftGroup1.equals(rightGroup1)) {,             // both start with the same prefix ... compare indexes,             // using longs here as we don't know how long the 2nd group is,             int leftGroup2 = Integer.parseInt(leftMatcher.group(2));,             int rightGroup2 = Integer.parseInt(rightMatcher.group(2));            ,             return (leftGroup2 > rightGroup2) ? 1 : ((leftGroup2 == rightGroup2) ? 0 : -1);,           },         },       },       return left.compareTo(right);,     }, ,     /**,      * Called after a ZooKeeper session expiration occurs,      */,     @Override,     public void command() {,       // we need to re-establish the watcher on the collections list after session expires,       synchronized (this) {,         cachedCollections = null;,       },     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/servlet/ZookeeperInfoServlet.java,printTree,596-596,[        byte[] data = zkClient.getData(path, null, stat, true);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/servlet/ZookeeperInfoServlet.java,printZnode,776-776,[          if (collectionStates != null) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/servlet/ZookeeperInfoServlet.java,,464-464,[      this.addr = addr;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/servlet/ZookeeperInfoServlet.java,,454-454,[    int maxData = 95;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/spelling/AbstractLuceneSpellChecker.java,getSuggestions,148-148,[    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/spelling/ConjunctionSolrSpellChecker.java,addChecker,70-70,[      } else if (accuracy != checker.getAccuracy()) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/solr/spelling/DirectSolrSpellChecker.java,getSuggestions,182-182,[    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/spelling/PossibilityIterator.java,internalNextAdvance,204-204,[      possibleCorrection = nextOnes.next();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/spelling/PossibilityIterator.java,,418-426,[  private class RankComparator implements Comparator<RankedSpellPossibility> {,     // Rank poorer suggestions ahead of better ones for use with a PriorityQueue,     @Override,     public int compare(RankedSpellPossibility r1, RankedSpellPossibility r2) {,       int retval = r2.rank - r1.rank;,       if (retval == 0) {,         retval = r2.index - r1.index;,       },       return retval;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/spelling/PossibilityIterator.java,,364-406,[  public class RankedSpellPossibility {,     public List<SpellCheckCorrection> corrections;,     public int rank;,     public int index;,     ,     @Override,     // hashCode() and equals() only consider the actual correction, not the rank,     // or index.,     public int hashCode() {,       final int prime = 31;,       int result = 1;,       result = prime * result,           + ((corrections == null) ? 0 : corrections.hashCode());,       return result;,     },     ,     @Override,     // hashCode() and equals() only consider the actual correction, not the rank,     // or index.,     public boolean equals(Object obj) {,       if (this == obj) return true;,       if (obj == null) return false;,       if (getClass() != obj.getClass()) return false;,       RankedSpellPossibility other = (RankedSpellPossibility) obj;,       if (corrections == null) {,         if (other.corrections != null) return false;,       } else if (!corrections.equals(other.corrections)) return false;,       return true;,     },     ,     @Override,     public String toString() {,       StringBuilder sb = new StringBuilder();,       sb.append("rank=").append(rank).append(" (").append(index).append(")");,       if (corrections != null) {,         for (SpellCheckCorrection corr : corrections) {,           sb.append("     ");,           sb.append(corr.getOriginal()).append(">"),               .append(corr.getCorrection()).append(" (").append(,                   corr.getNumberOfOccurences()).append(")");,         },       },       return sb.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/spelling/PossibilityIterator.java,,410-414,[  private class StartOffsetComparator implements,       Comparator<SpellCheckCorrection> {,     @Override,     public int compare(SpellCheckCorrection o1, SpellCheckCorrection o2) {,       return o1.getOriginal().startOffset() - o2.getOriginal().startOffset();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/spelling/SpellCheckCollation.java,compareTo,30-30,[    int c = new Integer(internalRank).compareTo(scc.internalRank);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/solr/spelling/SpellCheckCollation.java,compareTo,30-34,[    int c = new Integer(internalRank).compareTo(scc.internalRank);,     if (c == 0) {,       return collationQuery.compareTo(scc.collationQuery);,     },     return c;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/spelling/SpellCheckCollation.java,compareTo,32-32,[      return collationQuery.compareTo(scc.collationQuery);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/spelling/SpellCheckCollator.java,collate,144-144,[            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            ],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/spelling/SpellingOptions.java,,94-94,[    this.customParams = customParams;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/spelling/SpellingQueryConverter.java,convert,153-153,[      } else if (nextWord != null],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/spelling/SpellingResult.java,getTokenFrequency,117-117,[    return tokenFrequency.get(token);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/spelling/suggest/DictionaryFactory.java,,30-30,[  public static String DEFAULT_FILE_BASED_DICT = FileDictionaryFactory.class.getName();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/spelling/suggest/DictionaryFactory.java,,33-33,[  public static String DEFAULT_INDEX_BASED_DICT = HighFrequencyDictionaryFactory.class.getName(); ],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/spelling/suggest/LookupFactory.java,,31-31,[  public static String DEFAULT_FILE_BASED_DICT = JaspellLookupFactory.class.getName();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/solr/spelling/suggest/SolrSuggester.java,build,164-164,[      if(!lookup.store(new FileOutputStream(target))) {],,build,165-165,[        LOG.error("Store Lookup build failed");],,build,170-170,[  }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/solr/spelling/suggest/SolrSuggester.java,init,135-135,[          lookup.load(new FileInputStream(new File(storeDir, factory.storeFileName())));],,init,138-138,[        }],,init,143-143,[    if (dictionaryImpl == null) {],,init,149-149,[    dictionaryFactory = core.getResourceLoader().newInstance(dictionaryImpl, DictionaryFactory.class);],,init,150-150,[    dictionaryFactory.setParams(config);],,init,151-151,[    LOG.info("Dictionary loaded with params: " + config);],,init,153-153,[    return name;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/solr/spelling/suggest/SolrSuggester.java,reload,177-177,[      FileInputStream is = new FileInputStream(new File(storeDir, factory.storeFileName()));],,reload,179-179,[        if (lookup.load(is)) {],,reload,183-183,[        IOUtils.closeWhileHandlingException(is);],,reload,180-180,[          return;  // loaded ok],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/spelling/suggest/SolrSuggester.java,init,131-131,[        storeDir.mkdirs();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/solr/spelling/suggest/Suggester.java,build,164-164,[      if(!lookup.store(new FileOutputStream(target))) {],,build,172-172,[        LOG.info("Stored suggest data to: " + target.getAbsolutePath());],,build,175-175,[  }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/solr/spelling/suggest/Suggester.java,init,135-135,[          lookup.load(new FileInputStream(new File(storeDir, factory.storeFileName())));],,init,138-138,[        }],,init,142-142,[    return name;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/solr/spelling/suggest/Suggester.java,reload,182-182,[      FileInputStream is = new FileInputStream(new File(storeDir, factory.storeFileName()));],,reload,184-184,[        if (lookup.load(is)) {],,reload,188-188,[        IOUtils.closeWhileHandlingException(is);],,reload,185-185,[          return;  // loaded ok],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/spelling/suggest/Suggester.java,init,131-131,[        storeDir.mkdirs();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java,,100-116,[                                         queryAnalyzer, minPrefixChars, true) {,         @Override,         public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {,           List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);,           if (doHighlight) {,             List<LookupResult> res2 = new ArrayList<>();,             for(LookupResult hit : res) {,               res2.add(new LookupResult(hit.highlightKey.toString(),,                                         hit.highlightKey,,                                         hit.value,,                                         hit.payload,,                                         hit.contexts));,             },             res = res2;,           }, ,           return res;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java,,106-122,[                                       blenderType, numFactor, true) {,         @Override,         public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {,           List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);,           if (doHighlight) {,             List<LookupResult> res2 = new ArrayList<>();,             for(LookupResult hit : res) {,               res2.add(new LookupResult(hit.highlightKey.toString(),,                                         hit.highlightKey,,                                         hit.value,,                                         hit.payload,,                                         hit.contexts));,             },             res = res2;,           }, ,           return res;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/store/blockcache/BlockDirectory.java,,40-40,[  public static Logger LOG = LoggerFactory.getLogger(BlockDirectory.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/store/blockcache/BlockDirectory.java,,58-58,[  public static Cache NO_CACHE = new Cache() {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/store/hdfs/HdfsDirectory.java,,43-43,[  public static Logger LOG = LoggerFactory.getLogger(HdfsDirectory.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/store/hdfs/HdfsFileReader.java,,36-36,[  public static Logger LOG = LoggerFactory.getLogger(HdfsFileReader.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/store/hdfs/HdfsLockFactory.java,,37-37,[  public static Logger log = LoggerFactory.getLogger(HdfsLockFactory.class);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/uima/processor/SolrUIMAConfiguration.java,getFieldsToAnalyze,56-56,[    return fieldsToAnalyze;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/uima/processor/UIMAToSolrMapper.java,map,62-62,[          MapField mapField = featureFieldsmapping.get(featureName);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/uima/processor/UIMAUpdateRequestProcessor.java,processAdd,96-96,[    } catch (Exception e) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/uima/processor/UIMAUpdateRequestProcessorFactory.java,,69-69,[    return new UIMAUpdateRequestProcessor(next, req.getCore().getName(),],,,56-56,[      if (ae == null && pool == null) {],,,61-61,[          ae = aeProvider.getAE();],,,62-62,[          pool = new JCasPool(10, ae);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/uima/processor/UIMAUpdateRequestProcessorFactory.java,,69-69,[    return new UIMAUpdateRequestProcessor(next, req.getCore().getName(),],,,56-56,[      if (ae == null && pool == null) {],,,62-62,[          pool = new JCasPool(10, ae);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/AddUpdateCommand.java,<init>,168-168,[        SchemaField uniq = req.getSchema().getUniqueKeyField();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/update/DefaultSolrCoreState.java,,109-109,[      if (indexWriter == null) {],,,110-110,[        indexWriter = createMainIndexWriter(core, "DirectUpdateHandler2");],,,121-121,[    if (refCntWriter == null && indexWriter != null) {],,,122-122,[      refCntWriter = new RefCounted<IndexWriter>(indexWriter) {],,,69-69,[      } else if (indexWriter != null) {],,,73-73,[      indexWriter = null;],,,68-68,[        closer.closeWriter(indexWriter);],,,71-71,[        indexWriter.close();],,,250-250,[        indexWriter = createMainIndexWriter(core, "DirectUpdateHandler2");],,,160-160,[        if (indexWriter != null) {],,,179-179,[        indexWriter = createMainIndexWriter(core, "DirectUpdateHandler2");],,,172-172,[              indexWriter.rollback();],,,164-164,[              indexWriter.close();],,,218-218,[      if (indexWriter != null) {],,,230-230,[            indexWriter.rollback();],,,222-222,[            indexWriter.close();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/update/DefaultSolrCoreState.java,,87-87,[      while (pauseWriter) {],,,255-255,[        pauseWriter = false;],,,145-145,[      pauseWriter = true;],,,185-185,[        pauseWriter = false;],,,203-203,[      pauseWriter = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/update/DefaultSolrCoreState.java,,113-113,[      writerFree = false;],,,102-102,[        writerFree = false;],,,149-149,[      while (!writerFree) {],,,207-207,[      while (!writerFree) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/DefaultSolrCoreState.java,,37-37,[  public static Logger log = LoggerFactory.getLogger(DefaultSolrCoreState.class);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/DefaultSolrCoreState.java,getIndexWriter,104-104,[        if (refCntWriter != null) refCntWriter.incref();],,
MT_CORRECTNESS,TLW_TWO_LOCK_WAIT,org/apache/solr/update/DefaultSolrCoreState.java,closeIndexWriter,209-209,[          writerPauseLock.wait(100);],,closeIndexWriter,186-186,[        writerPauseLock.notifyAll();],,closeIndexWriter,256-256,[        writerPauseLock.notifyAll();],,
MT_CORRECTNESS,TLW_TWO_LOCK_WAIT,org/apache/solr/update/DefaultSolrCoreState.java,newIndexWriter,151-151,[          writerPauseLock.wait(100);],,newIndexWriter,186-186,[        writerPauseLock.notifyAll();],,newIndexWriter,256-256,[        writerPauseLock.notifyAll();],,
MALICIOUS_CODE,MS_CANNOT_BE_FINAL,org/apache/solr/update/DirectUpdateHandler2.java,,721-721,[  public static boolean commitOnClose = true;  // TODO: make this a real config option?],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/solr/update/DirectUpdateHandler2.java,getDocs,843-843,[    return null;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/HdfsTransactionLog.java,,57-57,[  public static Logger log = LoggerFactory.getLogger(HdfsTransactionLog.class);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/HdfsTransactionLog.java,readHeader,186-186,[      if (fis != null && closeFis) {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/solr/update/HdfsTransactionLog.java,endsWithCommit,148-148,[    dis.read(buf);],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/solr/update/HdfsTransactionLog.java,<init>,76-76,[      if (debug) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/HdfsUpdateLog.java,,333-337,[    FileStatus[] files = fs.listStatus(tlogDir, new PathFilter() {,       ,       @Override,       public boolean accept(Path name) {,         return name.getName().startsWith(prefix);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/MergeIndexesCommand.java,,51-53,[    Iterable<String> directories = Iterables.transform(readers, new Function<DirectoryReader, String>() {,       public String apply(DirectoryReader reader) {,         return reader.directory().toString();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/update/PeerSync.java,handleResponse,294-294,[        Throwable solrException = ((SolrServerException) srsp.getException())],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/update/PeerSync.java,handleResponse,305-305,[      if (cantReachIsSuccess && sreq.purpose == 1 && srsp.getException() instanceof SolrException && ((SolrException) srsp.getException()).code() == 503) {],,handleResponse,310-310,[      if (cantReachIsSuccess && sreq.purpose == 1 && srsp.getException() instanceof SolrException && ((SolrException) srsp.getException()).code() == 404) {],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/update/PeerSync.java,handleUpdates,452-452,[    SyncShardRequest sreq = (SyncShardRequest) srsp.getShardRequest();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/update/PeerSync.java,handleVersions,356-356,[    SyncShardRequest sreq = (SyncShardRequest) srsp.getShardRequest();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/PeerSync.java,sync,581-581,[    for (String replica : replicas) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/PeerSync.java,sync,582-582,[      ShardResponse srsp = shardHandler.takeCompletedOrError();],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/solr/update/PeerSync.java,handleUpdates,555-555,[        log.error(msg() + "Error applying updates from " + sreq.shards + " ,finish()", e);],,handleUpdates,542-542,[      log.error(msg() + "Error applying updates from " + sreq.shards + " ,update=" + o, e);],,handleUpdates,547-547,[      log.error(msg() + "Error applying updates from " + sreq.shards + " ,update=" + o, e);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/PeerSync.java,,59-59,[  public static Logger log = LoggerFactory.getLogger(PeerSync.class);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/update/PeerSync.java,handleUpdates,545-545,[    catch (Exception e) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/update/PeerSync.java,,357-357,[    sreq.reportedVersions =  otherVersions;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/update/PeerSync.java,,554-554,[        sreq.updateException = e;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/SolrCmdDistributor.java,,55-55,[  public static Logger log = LoggerFactory.getLogger(SolrCmdDistributor.class);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/update/SolrCmdDistributor.java,doRetriesIfNeeded,153-153,[      } catch (Exception e) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/update/SolrCmdDistributor.java,trackRequestResult,359-359,[              } catch (Exception ignore){}],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/update/SolrCmdDistributor.java,,373-373,[    public List<Error> errors = new ArrayList<>();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/SolrCmdDistributor.java,equals,537-537,[      if (nodeProps.getCoreUrl() == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/SolrCmdDistributor.java,equals,476-476,[      if (url == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/SolrCmdDistributor.java,hashCode,457-457,[      result = prime * result + ((url == null) ? 0 : url.hashCode());],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/SolrCoreState.java,,38-38,[  public static Logger log = LoggerFactory.getLogger(SolrCoreState.class);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/SolrIndexConfig.java,<init>,123-123,[    Object unused = solrConfig.getNode(prefix, false);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/SolrIndexSplitter.java,,50-50,[  public static Logger log = LoggerFactory.getLogger(SolrIndexSplitter.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/StreamingSolrClients.java,,43-43,[  public static Logger log = LoggerFactory.getLogger(StreamingSolrClients.class);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/solr/update/StreamingSolrClients.java,handleError,76-76,[          error.e = (Exception) ex;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/TransactionLog.java,,64-64,[  public static Logger log = LoggerFactory.getLogger(TransactionLog.class);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/update/TransactionLog.java,endsWithCommit,218-218,[    ChannelFastInputStream is = new ChannelFastInputStream(channel, pos);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/solr/update/TransactionLog.java,endsWithCommit,219-219,[    is.read(buf);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/TransactionLog.java,,88-96,[  JavaBinCodec.ObjectResolver resolver = new JavaBinCodec.ObjectResolver() {,     @Override,     public Object resolve(Object o, JavaBinCodec codec) throws IOException {,       if (o instanceof BytesRef) {,         BytesRef br = (BytesRef)o;,         codec.writeByteArray(br.bytes, br.offset, br.length);,         return null;,       },       return o;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/UpdateCommand.java,,32-32,[  public static int BUFFERING = 0x00000001;    // update command is being buffered.],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/UpdateCommand.java,,35-35,[  public static int IGNORE_AUTOCOMMIT = 0x00000008; // this update should not count toward triggering of autocommits.],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/UpdateCommand.java,,34-34,[  public static int PEER_SYNC    = 0x00000004; // update command is a missing update being provided by a peer.],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/UpdateCommand.java,,33-33,[  public static int REPLAY    = 0x00000002;    // update command is from replaying a log.],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/UpdateCommand.java,,36-36,[  public static int CLEAR_CACHES = 0x00000010; // clear caches associated with the update log.  used when applying reordered DBQ updates when doing an add.],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/update/UpdateCommand.java,,36-36,[  public static int CLEAR_CACHES = 0x00000010; // clear caches associated with the update log.  used when applying reordered DBQ updates when doing an add.],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/UpdateLog.java,lookupVersion,735-735,[        lookupLog = prevMapLog2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/UpdateLog.java,,73-73,[  public static String LOG_FILENAME_PATTERN = "%s.%019d";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/UpdateLog.java,,74-74,[  public static String TLOG_NAME="tlog";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/UpdateLog.java,,76-76,[  public static Logger log = LoggerFactory.getLogger(UpdateLog.class);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/update/UpdateLog.java,init,245-245,[    tlogDir.mkdirs();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/UpdateLog.java,,148-151,[  protected LinkedHashMap<BytesRef, LogPtr> oldDeletes = new LinkedHashMap<BytesRef, LogPtr>(numDeletesToKeep) {,     @Override,     protected boolean removeEldestEntry(Map.Entry eldest) {,       return size() > numDeletesToKeep;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/UpdateLog.java,,355-358,[    String[] names = directory.list(new FilenameFilter() {,       @Override,       public boolean accept(File dir, String name) {,         return name.startsWith(prefix);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/update/UpdateLog.java,,155-161,[  public class DBQ {,     public String q;     // the query string,     public long version; // positive version of the DBQ, ,     @Override,     public String toString() {,       return "DBQ{version=" + version + ",q="+q+"}";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/update/UpdateLog.java,doReplay,1256-1256,[        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/update/UpdateLog.java,doReplay,1376-1376,[            if (rsp.getException() != null) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/update/UpdateLog.java,,894-1022,[  public class RecentUpdates {,     Deque<TransactionLog> logList;    // newest first,     List<List<Update>> updateList;,     HashMap<Long, Update> updates;,     List<Update> deleteByQueryList;,     List<DeleteUpdate> deleteList;,     int latestOperation;, ,     public List<Long> getVersions(int n) {,       List<Long> ret = new ArrayList(n);,       ,       for (List<Update> singleList : updateList) {,         for (Update ptr : singleList) {,           ret.add(ptr.version);,           if (--n <= 0) return ret;,         },       },       ,       return ret;,     },     ,     public Object lookup(long version) {,       Update update = updates.get(version);,       if (update == null) return null;, ,       return update.log.lookup(update.pointer);,     }, ,     /** Returns the list of deleteByQueries that happened after the given version */,     public List<Object> getDeleteByQuery(long afterVersion) {,       List<Object> result = new ArrayList<>(deleteByQueryList.size());,       for (Update update : deleteByQueryList) {,         if (Math.abs(update.version) > afterVersion) {,           Object dbq = update.log.lookup(update.pointer);,           result.add(dbq);,         },       },       return result;,     }, ,     public int getLatestOperation() {,       return latestOperation;,     }, , ,     private void update() {,       int numUpdates = 0;,       updateList = new ArrayList<>(logList.size());,       deleteByQueryList = new ArrayList<>();,       deleteList = new ArrayList<>();,       updates = new HashMap<>(numRecordsToKeep);, ,       for (TransactionLog oldLog : logList) {,         List<Update> updatesForLog = new ArrayList<>();, ,         TransactionLog.ReverseReader reader = null;,         try {,           reader = oldLog.getReverseReader();, ,           while (numUpdates < numRecordsToKeep) {,             Object o = null;,             try {,               o = reader.next();,               if (o==null) break;,               ,               // should currently be a List<Oper,Ver,Doc/Id>,               List entry = (List)o;, ,               // TODO: refactor this out so we get common error handling,               int opAndFlags = (Integer)entry.get(0);,               if (latestOperation == 0) {,                 latestOperation = opAndFlags;,               },               int oper = opAndFlags & UpdateLog.OPERATION_MASK;,               long version = (Long) entry.get(1);, ,               switch (oper) {,                 case UpdateLog.ADD:,                 case UpdateLog.DELETE:,                 case UpdateLog.DELETE_BY_QUERY:,                   Update update = new Update();,                   update.log = oldLog;,                   update.pointer = reader.position();,                   update.version = version;, ,                   updatesForLog.add(update);,                   updates.put(version, update);,                   ,                   if (oper == UpdateLog.DELETE_BY_QUERY) {,                     deleteByQueryList.add(update);,                   } else if (oper == UpdateLog.DELETE) {,                     deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));,                   },                   ,                   break;, ,                 case UpdateLog.COMMIT:,                   break;,                 default:,                   throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  "Unknown Operation! " + oper);,               },             } catch (ClassCastException cl) {,               log.warn("Unexpected log entry or corrupt log.  Entry=" + o, cl);,               // would be caused by a corrupt transaction log,             } catch (Exception ex) {,               log.warn("Exception reverse reading log", ex);,               break;,             }, ,             numUpdates++;,           }, ,         } catch (IOException e) {,           // failure to read a log record isn't fatal,           log.error("Exception reading versions from log",e);,         } finally {,           if (reader != null) reader.close();,         }, ,         updateList.add(updatesForLog);,       }, ,     },     ,     public void close() {,       for (TransactionLog log : logList) {,         log.decref();,       },     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/update/UpdateLog.java,close,1019-1019,[      for (TransactionLog log : logList) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/update/UpdateLog.java,update,941-941,[      updateList = new ArrayList<>(logList.size());],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/update/VersionInfo.java,,83-83,[    idField = schema.getUniqueKeyField();],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/solr/update/processor/AbstractDefaultValueUpdateProcessorFactory.java,init,58-58,[      fieldName = obj.toString();],,init,54-54,[    if (null == obj && null == fieldName) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.java,mapValueClassesToFieldType,334-334,[          for (Class<?> valueClass : typeMapping.valueClasses) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/ConcatFieldUpdateProcessorFactory.java,,98-117,[    return new FieldMutatingUpdateProcessor.FieldNameSelector() {,       @Override,       public boolean shouldMutate(final String fieldName) {,         final IndexSchema schema = core.getLatestSchema();, ,         // first check type since it should be fastest,         FieldType type = schema.getFieldTypeNoEx(fieldName);,         if (null == type) return false;,         ,         if (! (TextField.class.isInstance(type) ,                || StrField.class.isInstance(type))) {,           return false;,         }, ,         // only ask for SchemaField if we passed the type check.,         SchemaField sf = schema.getFieldOrNull(fieldName);,         // shouldn't be null since since type wasn't, but just in case,         if (null == sf) return false;,         ,         return ! sf.multiValued();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/CountFieldValuesUpdateProcessorFactory.java,,82-88,[    return new FieldMutatingUpdateProcessor(getSelector(), next) {,       @Override,       protected SolrInputField mutate(final SolrInputField src) {,         SolrInputField result = new SolrInputField(src.getName());,         result.setValue(src.getValueCount(),,                         src.getBoost());,         return result;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,doFinish,855-855,[            if (((Replica) replicaProp.getNodeProps()).getName().equals(((Replica)stdNode.getNodeProps().getNodeProps()).getName()))  {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,setupRequest,365-365,[            slice = coll.getSlice(myShardId);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,versionAdd,1018-1018,[            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,setupRequest,368-368,[            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,versionDelete,1654-1654,[              versionOnUpdate = signedVersionOnUpdate = 0;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/solr/update/processor/DistributedUpdateProcessor.java,<init>,285-285,[    SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,getNodesByRoutingRules,525-525,[                    if (nodes == null) nodes = new ArrayList<>();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,setupRequest,389-389,[            if (nodes == null)  {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,getSubShardLeaders,474-474,[        if (isSubset &&],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,doRemove,1220-1220,[    if (sf != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,getNodesByRoutingRules,525-525,[                    if (nodes == null) nodes = new ArrayList<>();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,setupRequest,389-389,[            if (nodes == null)  {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/update/processor/DistributedUpdateProcessor.java,doFinish,876-876,[          } catch (Exception exc) {],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/solr/update/processor/DistributedUpdateProcessor.java,getSubShardLeaders,474-474,[        if (isSubset &&],,
STYLE,UC_USELESS_CONDITION,org/apache/solr/update/processor/DistributedUpdateProcessor.java,processCommit,1734-1734,[    } else if (zkEnabled) {],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/update/processor/DistributedUpdateProcessor.java,trackRequestResult,196-196,[          otherLeaderRf.put(shardId, rf != null ? rf : new Integer(1));],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/processor/DistributedUpdateProcessor.java,trackRequestResult,201-201,[      if (onLeaderShardId != null) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java,inform,168-168,[      ValueSource vs = userVersionField.getType().getValueSource(userVersionField, null);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java,inform,162-162,[    if (userVersionField == null || !userVersionField.stored() || userVersionField.multiValued()) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java,inform,248-248,[        Object ignored = core.getUpdateProcessingChain(deleteChainName);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java,initDeleteExpiredDocsScheduler,284-284,[    final long initialDelay = deletePeriodSeconds;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java,,260-263,[       new RejectedExecutionHandler() {,         public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {,           log.warn("Skipping execution of '{}' using '{}'", r, e);,         }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/update/processor/FieldLengthUpdateProcessorFactory.java,mutateValue,73-73,[          return new Integer(((CharSequence)src).length());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/FieldLengthUpdateProcessorFactory.java,,69-75,[    return new FieldValueMutatingUpdateProcessor(getSelector(), next) {,       @Override,       protected Object mutateValue(final Object src) {,         if (src instanceof CharSequence) {,           return new Integer(((CharSequence)src).length());,         },         return src;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/HTMLStripFieldUpdateProcessorFactory.java,,62-82,[    return new FieldValueMutatingUpdateProcessor(getSelector(), next) {,       @Override,       protected Object mutateValue(final Object src) {,         if (src instanceof CharSequence) {,           CharSequence s = (CharSequence)src;,           StringWriter result = new StringWriter(s.length());,           Reader in = null;,           try {,             in = new HTMLStripCharFilter,               (new StringReader(s.toString()));,             IOUtils.copy(in, result);,             return result.toString();,           } catch (IOException e) {,             // we tried and failed,             return s;,           } finally {,             IOUtils.closeQuietly(in);,           }, ,         },         return src;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/IgnoreFieldUpdateProcessorFactory.java,,61-64,[    return new FieldMutatingUpdateProcessor(getSelector(), next) {,       @Override,       protected SolrInputField mutate(final SolrInputField src) {,         return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/IgnoreFieldUpdateProcessorFactory.java,,73-78,[    return new FieldMutatingUpdateProcessor.FieldNameSelector() {,       @Override,       public boolean shouldMutate(final String fieldName) {,         final IndexSchema schema = core.getLatestSchema();,         FieldType type = schema.getFieldTypeNoEx(fieldName);,         return (null == type);],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/solr/update/processor/LangDetectLanguageIdentifierUpdateProcessorFactory.java,getInstance,109-109,[    return new LangDetectLanguageIdentifierUpdateProcessor(req, rsp, next);],,getInstance,106-106,[    if(req != null) {],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/solr/update/processor/LangDetectLanguageIdentifierUpdateProcessorFactory.java,loadData,132-132,[      BufferedReader reader = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8));],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor.java,initParams,132-132,[      String[] mapIndividualFields = {};],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor.java,process,220-220,[    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/MaxFieldValueUpdateProcessorFactory.java,pickSubset,60-60,[    Collection result = values;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/update/processor/MinFieldValueUpdateProcessorFactory.java,pickSubset,60-60,[    Collection result = values;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/ParseBooleanFieldUpdateProcessorFactory.java,,148-153,[    return new FieldMutatingUpdateProcessor.FieldNameSelector() {,       @Override,       public boolean shouldMutate(final String fieldName) {,         final IndexSchema schema = core.getLatestSchema();,         FieldType type = schema.getFieldTypeNoEx(fieldName);,         return (null == type) || (type instanceof BoolField);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory.java,init,154-154,[    if (null != formatsParam) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory.java,,170-175,[    return new FieldMutatingUpdateProcessor.FieldNameSelector() {,       @Override,       public boolean shouldMutate(final String fieldName) {,         final IndexSchema schema = core.getLatestSchema();,         FieldType type = schema.getFieldTypeNoEx(fieldName);,         return (null == type) || type instanceof DateValueFieldType;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/RemoveBlankFieldUpdateProcessorFactory.java,,58-65,[    return new FieldValueMutatingUpdateProcessor(getSelector(), next) {,       @Override,       protected Object mutateValue(final Object src) {,         if (src instanceof CharSequence ,             && 0 == ((CharSequence)src).length()) {,           return DELETE_VALUE_SINGLETON;,         },         return src;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/solr/update/processor/RunUpdateProcessorFactory.java,,56-56,[    this.req = req;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/update/processor/StatelessScriptUpdateProcessorFactory.java,,156-156,[  public static Logger log = LoggerFactory.getLogger(StatelessScriptUpdateProcessorFactory.class);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/solr/update/processor/StatelessScriptUpdateProcessorFactory.java,getSupportedEngines,339-339,[      if (null == factories) return result;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/solr/update/processor/TextProfileSignature.java,,155-158,[  private static class TokenComparator implements Comparator<Token> {,     @Override,     public int compare(Token t1, Token t2) {,       return t2.cnt - t1.cnt;],,
PERFORMANCE,BX_UNBOXING_IMMEDIATELY_REBOXED,org/apache/solr/update/processor/TikaLanguageIdentifierUpdateProcessor.java,detectLanguage,55-55,[      certainty = (certainty < 0) ? 0 : certainty;],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/solr/update/processor/TikaLanguageIdentifierUpdateProcessorFactory.java,getInstance,91-91,[    return new TikaLanguageIdentifierUpdateProcessor(req, rsp, next);],,getInstance,88-88,[    if(req != null) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/update/processor/TrimFieldUpdateProcessorFactory.java,,57-63,[    return new FieldValueMutatingUpdateProcessor(getSelector(), next) {,       @Override,       protected Object mutateValue(final Object src) {,         if (src instanceof CharSequence) {,           return ((CharSequence)src).toString().trim();,         },         return src;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/solr/update/processor/URLClassifyProcessor.java,landingPageSuffix,201-201,[      return landingPageSuffix(url) != "";],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/update/processor/UpdateRequestProcessorChain.java,getFactories,217-217,[    return chain;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/update/processor/UpdateRequestProcessorChain.java,<init>,164-164,[    this.chain = chain;],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/solr/util/AbstractSolrTestCase.java,ignoreException,69-70,[    if (SolrException.ignorePatterns == null),       SolrException.ignorePatterns = new HashSet<>();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/AbstractSolrTestCase.java,,64-64,[  public static Logger log = LoggerFactory.getLogger(AbstractSolrTestCase.class);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/util/AdjustableSemaphore.java,,71-77,[      super(size);,     },     ,     @Override,     protected void reducePermits(int reduction) {,       super.reducePermits(reduction);,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/solr/util/BoundedTreeSet.java,,29-68,[  private int maxSize = Integer.MAX_VALUE;,   public BoundedTreeSet(int maxSize) {,     super();,     this.setMaxSize(maxSize);,   },   public BoundedTreeSet(int maxSize, Collection<? extends E> c) {,     super(c);,     this.setMaxSize(maxSize);,   },   public BoundedTreeSet(int maxSize, Comparator<? super E> c) {,     super(c);,     this.setMaxSize(maxSize);,   },   public BoundedTreeSet(int maxSize, SortedSet<E> s) {,     super(s);,     this.setMaxSize(maxSize);,   },   public int getMaxSize() {,     return maxSize;,   },   public void setMaxSize(int max) {,     maxSize = max;,     adjust();,   },   private void adjust() {,     while (maxSize < size()) {,       remove(last());,     },   },   @Override,   public boolean add(E item) {,     boolean out = super.add(item);,     adjust();,     return out;,   },   @Override,   public boolean addAll(Collection<? extends E> c) {,     boolean out = super.addAll(c);,     adjust();,     return out;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/util/CommandOperation.java,parse,200-200,[      ev = parser.nextEvent();],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/solr/util/CommandOperation.java,getStr,49-49,[      return obj == def ? null: String.valueOf(obj);],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/solr/util/ConcurrentLFUCache.java,<init>,79-79,[    this(size, lowerWatermark, (int) Math.floor((lowerWatermark + size) / 2),],,
CORRECTNESS,SA_FIELD_SELF_ASSIGNMENT,org/apache/solr/util/ConcurrentLFUCache.java,markAndSweep,168-168,[      this.lowHitCount = lowHitCount;     // volatile write to make isCleaning visible],,
MT_CORRECTNESS,SC_START_IN_CTOR,org/apache/solr/util/ConcurrentLFUCache.java,<init>,74-74,[      cleanupThread.start();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/util/ConcurrentLFUCache.java,,443-443,[        if (stop) break;],,,458-458,[        stop = true;],,,437-437,[          if (stop) break;],,
MT_CORRECTNESS,NN_NAKED_NOTIFY,org/apache/solr/util/ConcurrentLFUCache.java,wakeThread,452-452,[        this.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/solr/util/ConcurrentLFUCache.java,stopThread,459-459,[        this.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/solr/util/ConcurrentLFUCache.java,wakeThread,452-452,[        this.notify();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/util/ConcurrentLRUCache.java,markAndSweep,283-283,[        newNewestEntry = -1;],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/solr/util/ConcurrentLRUCache.java,<init>,80-80,[    this(size, lowerWatermark, (int) Math.floor((lowerWatermark + size) / 2),],,
CORRECTNESS,SA_FIELD_SELF_ASSIGNMENT,org/apache/solr/util/ConcurrentLRUCache.java,markAndSweep,174-174,[      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible],,
MT_CORRECTNESS,SC_START_IN_CTOR,org/apache/solr/util/ConcurrentLRUCache.java,<init>,75-75,[      cleanupThread.start();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/solr/util/ConcurrentLRUCache.java,,602-602,[        if (stop) break;],,,617-617,[        stop=true;],,,597-597,[          if (stop) break;],,
MT_CORRECTNESS,NN_NAKED_NOTIFY,org/apache/solr/util/ConcurrentLRUCache.java,wakeThread,611-611,[        this.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/solr/util/ConcurrentLRUCache.java,stopThread,618-618,[        this.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/solr/util/ConcurrentLRUCache.java,wakeThread,611-611,[        this.notify();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/util/DOMUtilTestBase.java,getDocument,54-54,[    return builder.parse(new InputSource(new StringReader(xml)));],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/util/DateMathParser.java,parseMath,343-343,[          val = Integer.valueOf(ops[pos++]);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/util/DateMathParser.java,setNow,271-271,[    now = n;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/DateMathParser.java,,97-97,[  public static TimeZone UTC = TimeZone.getTimeZone("UTC");],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/solr/util/DateMathParser.java,round,185-188,[      c.clear(Calendar.MONTH);,       /* fall through */,     case Calendar.MONTH:,       c.clear(Calendar.DAY_OF_MONTH);],,round,193-196,[      c.clear(Calendar.WEEK_OF_YEAR);,       /* fall through */,     case Calendar.DATE:,       c.clear(Calendar.HOUR_OF_DAY);],,round,198-201,[      c.clear(Calendar.AM_PM);,       /* fall through */,     case Calendar.HOUR_OF_DAY:,       c.clear(Calendar.MINUTE);],,round,201-204,[      c.clear(Calendar.MINUTE);,       /* fall through */,     case Calendar.MINUTE:,       c.clear(Calendar.SECOND);],,round,204-207,[      c.clear(Calendar.SECOND);,       /* fall through */,     case Calendar.SECOND:,       c.clear(Calendar.MILLISECOND);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/util/EmptyEntityResolver.java,trySetSAXFeature,64-64,[    } catch (Exception ex) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/util/EmptyEntityResolver.java,trySetStAXProperty,83-83,[    } catch (Exception ex) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/util/EmptyEntityResolver.java,trySetSAXFeature,64-64,[    } catch (Exception ex) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/ExternalPaths.java,,54-54,[  public static String SERVER_HOME = new File(SOURCE_HOME, "server/solr").getAbsolutePath();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/ExternalPaths.java,,50-50,[      new File(SOURCE_HOME, "server/solr/configsets/data_driven_schema_configs/conf").getAbsolutePath();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/ExternalPaths.java,,52-52,[      new File(SOURCE_HOME, "server/solr/configsets/sample_techproducts_configs/conf").getAbsolutePath();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/ExternalPaths.java,,47-47,[  public static String WEBAPP_HOME = new File(SOURCE_HOME, "webapp/web").getAbsolutePath();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/util/ExternalPaths.java,determineSourceHome,69-69,[      } catch (Exception e) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/util/ExternalPaths.java,,50-50,[      new File(SOURCE_HOME, "server/solr/configsets/data_driven_schema_configs/conf").getAbsolutePath();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/util/ExternalPaths.java,,52-52,[      new File(SOURCE_HOME, "server/solr/configsets/sample_techproducts_configs/conf").getAbsolutePath();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/util/ExternalPaths.java,,47-47,[  public static String WEBAPP_HOME = new File(SOURCE_HOME, "webapp/web").getAbsolutePath();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/util/FastWriter.java,<init>,40-40,[    this.buf = tempBuffer;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/util/FileUtils.java,copyFile,51-51,[      try { if (in != null) in.close(); } catch (IOException e) {}],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/IOUtils.java,,27-27,[  public static Logger LOG = LoggerFactory.getLogger(IOUtils.class);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/util/LongPriorityQueue.java,getInternalArray,181-181,[    return heap;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/solr/util/LongPriorityQueue.java,sort,196-196,[    return heap;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2double,134-136,[    long f = SortableStr2long(val,0,6);,     if (f<0) f ^= 0x7fffffffffffffffL;,     return Double.longBitsToDouble(f);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2double,141-141,[    return SortableStr2double(val.utf8ToString());],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2doubleStr,145-145,[    return Double.toString(SortableStr2double(val));],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2float,108-110,[    int f = SortableStr2int(val,0,3);,     if (f<0) f ^= 0x7fffffff;,     return Float.intBitsToFloat(f);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2float,115-115,[    return SortableStr2float(val.utf8ToString());],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2floatStr,119-119,[    return Float.toString(SortableStr2float(val));],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2int,55-56,[    int ival = SortableStr2int(val,0,3);,     return Integer.toString(ival);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2int,162-166,[    int val = sval.charAt(offset++) << 24;,     val |= sval.charAt(offset++) << 12;,     val |= sval.charAt(offset++);,     val -= Integer.MIN_VALUE;,     return val;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2int,61-61,[    return SortableStr2int(val.utf8ToString());],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2int,171-171,[    return SortableStr2int(sval.utf8ToString(), offset, len);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2long,76-77,[    long ival = SortableStr2long(val,0,5);,     return Long.toString(ival);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2long,189-195,[    long val = (long)(sval.charAt(offset++)) << 60;,     val |= ((long)sval.charAt(offset++)) << 45;,     val |= ((long)sval.charAt(offset++)) << 30;,     val |= sval.charAt(offset++) << 15;,     val |= sval.charAt(offset);,     val -= Long.MIN_VALUE;,     return val;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2long,82-82,[    return SortableStr2long(val.utf8ToString());],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/solr/util/NumberUtils.java,SortableStr2long,200-200,[    return SortableStr2long(sval.utf8ToString(), offset, len);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/RandomMergePolicy.java,,40-40,[  public static Logger log = LoggerFactory.getLogger(RandomMergePolicy.class);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/solr/util/RevertDefaultThreadHandlerRule.java,,35-52,[    return new StatementAdapter(s) {,       @Override,       protected void before() throws Throwable {,         if (!applied.getAndSet(true)) {,           UncaughtExceptionHandler p = Thread.getDefaultUncaughtExceptionHandler();,           try {,             // Try to initialize a zookeeper class that reinitializes default exception handler.,             Class<?> cl = NIOServerCnxnFactory.class;,             // Make sure static initializers have been called.,             Class.forName(cl.getName(), true, cl.getClassLoader());,           } finally {,             if (p == Thread.getDefaultUncaughtExceptionHandler()) {,             //  throw new RuntimeException("Zookeeper no longer resets default thread handler.");,             },             Thread.setDefaultUncaughtExceptionHandler(p);,           },         },       }],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/solr/util/RevertDefaultThreadHandlerRule.java,before,46-46,[            if (p == Thread.getDefaultUncaughtExceptionHandler()) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/SSLTestConfig.java,,41-41,[  public static File TEST_KEYSTORE = ExternalPaths.SERVER_HOME == null ? null],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/util/SimplePostTool.java,parseArgsAndInit,251-251,[      } catch(Exception e) { }],,
PERFORMANCE,DMI_COLLECTION_OF_URLS,org/apache/solr/util/SimplePostTool.java,webCrawl,587-587,[        visited.add(u);],,
BAD_PRACTICE,DM_EXIT,org/apache/solr/util/SimplePostTool.java,fatal,725-725,[    System.exit(2);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/solr/util/SimplePostTool.java,<init>,293-293,[    this.args = args;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/solr/util/SimplePostTool.java,postFiles,518-518,[        Thread.sleep(delay * 1000);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/solr/util/SimplePostTool.java,webCrawl,597-597,[            Thread.sleep(delay * 1000);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/util/SimplePostTool.java,postDirectory,492-492,[    info("Indexing directory "+dir.getPath()+" ("+dir.listFiles(globFileFilter).length+" files, depth="+currentDepth+")");],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/util/SimplePostTool.java,postDirectory,494-494,[    posted += postFiles(dir.listFiles(globFileFilter), out, type);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/util/SimplePostTool.java,postDirectory,496-496,[      for(File d : dir.listFiles()) {],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/util/SimplePostTool.java,postFiles,448-448,[        filesPosted += postFiles(parent.listFiles(ff), out, type);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/util/SimplePostTool.java,checkResponseCode,933-933,[          BufferedReader br = new BufferedReader(new InputStreamReader(errStream, charset));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/util/SimplePostTool.java,parseArgsAndInit,251-251,[      } catch(Exception e) { }],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/util/SimplePostTool.java,<init>,294-294,[    pageFetcher = new PageFetcher();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/solr/util/SimplePostTool.java,typeSupported,698-698,[      if(mimeMap.get(key).equals(type)) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/util/SimplePostTool.java,,1032-1057,[    {,       _pattern = pattern;,       if(!isRegex) {,         _pattern = _pattern,             .replace("^", "\\^"),             .replace("$", "\\$"),             .replace(".", "\\."),             .replace("(", "\\("),             .replace(")", "\\)"),             .replace("+", "\\+"),             .replace("*", ".*"),             .replace("?", ".");,         _pattern = "^" + _pattern + "$";,       },       ,       try {,         p = Pattern.compile(_pattern,Pattern.CASE_INSENSITIVE);,       } catch(PatternSyntaxException e) {,         fatal("Invalid type list "+pattern+". "+e.getDescription());,       },     },     ,     @Override,     public boolean accept(File file),     {,       return p.matcher(file.getName()).find();],,
PERFORMANCE,DMI_COLLECTION_OF_URLS,org/apache/solr/util/SimplePostTool.java,getLinksFromWebPage,1183-1212,[      Set<URL> l = new HashSet<>();,       URL url = null;,       try {,         ByteArrayOutputStream os = new ByteArrayOutputStream();,         URL extractUrl = new URL(appendParam(postUrl.toString(), "extractOnly=true"));,         boolean success = postData(is, null, os, type, extractUrl);,         if(success) {,           Document d = makeDom(os.toByteArray());,           String innerXml = getXP(d, "/response/str/text()[1]", false);,           d = makeDom(innerXml.getBytes(StandardCharsets.UTF_8));,           NodeList links = getNodesFromXP(d, "/html/body//a/@href");,           for(int i = 0; i < links.getLength(); i++) {,             String link = links.item(i).getTextContent();,             link = computeFullUrl(u, link);,             if(link == null),               continue;,             url = new URL(link);,             if(url.getAuthority() == null || !url.getAuthority().equals(u.getAuthority())),               continue;,             l.add(url);,           },         },       } catch (MalformedURLException e) {,         warn("Malformed URL "+url);,       } catch (IOException e) {,         warn("IOException opening URL "+url+": "+e.getMessage());,       } catch (Exception e) {,         throw new RuntimeException();,       },       return l;],,
PERFORMANCE,DMI_COLLECTION_OF_URLS,org/apache/solr/util/SimplePostTool.java,getLinksFromWebPage,1202-1202,[            l.add(url);],,
PERFORMANCE,DMI_COLLECTION_OF_URLS,org/apache/solr/util/SimplePostTool.java,readPageFromUrl,1078-1078,[          visited.add(u);],,readPageFromUrl,1091-1091,[          visited.add(u);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/util/SimplePostTool.java,getLinksFromWebPage,1208-1208,[        warn("IOException opening URL "+url+": "+e.getMessage());],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/solr/util/SimplePostTool.java,readPageFromUrl,1101-1101,[              is = new GZIPInputStream(conn.getInputStream());],,readPageFromUrl,1103-1103,[              is = new InflaterInputStream(conn.getInputStream(), new Inflater(true));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/util/SimplePostTool.java,getLinksFromWebPage,1209-1209,[      } catch (Exception e) {],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/solr/util/SimplePostTool.java,,1066-1066,[    final String DISALLOW = "Disallow:";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/solr/util/SimplePostTool.java,,1219-1222,[  public class PageFetcherResult {,     int httpStatus = 200;,     String contentType = "text/html";,     URL redirectUrl = null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/util/SimplePostTool.java,webCrawl,594-594,[          boolean success = postData(new ByteArrayInputStream(result.content.array(), result.content.arrayOffset(),result.content.limit() ), null, out, result.contentType, postUrl);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/util/SolrCLI.java,closeHttpClient,395-395,[      } catch (Exception exc) {],,
BAD_PRACTICE,DM_EXIT,org/apache/solr/util/SolrCLI.java,processCommandLineArgs,308-308,[      System.exit(1);],,processCommandLineArgs,314-314,[      System.exit(0);],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/solr/util/SolrCLI.java,uptime,724-724,[    long numDays = (uptimeMs >= MS_IN_DAY) ],,uptime,727-727,[    long numHours = (rem >= MS_IN_HOUR) ],,uptime,730-730,[    long numMinutes = (rem >= MS_IN_MIN) ],,
CORRECTNESS,ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND,org/apache/solr/util/SolrCLI.java,uptime,733-733,[    long numSeconds = Math.round(rem / 1000);],,
MALICIOUS_CODE,MS_FINAL_PKGPROTECT,org/apache/solr/util/SolrCLI.java,,169-169,[        .create("collection")],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/SolrCLI.java,,152-152,[  public static Logger log = Logger.getLogger(SolrCLI.class);    ],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/solr/util/SolrCLI.java,findClasses,354-354,[      ZipInputStream zip = new ZipInputStream(jar.openStream());],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/util/SolrCLI.java,runTool,1125-1125,[          } catch (Exception ignore) {}],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/solr/util/SolrCLI.java,runTool,1352-1352,[        coreInstanceDir.mkdirs();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/solr/util/SolrCLI.java,runTool,138-138,[          } catch (Exception ignore) {}],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/util/SolrLogLayout.java,_format,125-125,[    long timeSinceLast = now - lastTime;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/solr/util/SolrLogLayout.java,_format,157-157,[      if (zkController == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/solr/util/SolrLogLayout.java,_format,157-157,[      if (zkController == null) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/solr/util/SolrLogLayout.java,_format,148-148,[        info.shortId = "C" + Integer.toString(CoreInfo.maxCoreNum++);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/solr/util/SolrLogLayout.java,,89-89,[  public Map<String,String> classAliases = new HashMap<>();],,
PERFORMANCE,BX_UNBOXING_IMMEDIATELY_REBOXED,org/apache/solr/util/SolrPluginUtils.java,parseFieldBoostsAndSlop,539-539,[        Float boost = (1 == fieldAndSlopVsBoost.length) ? 1  : Float.valueOf(fieldAndSlopVsBoost[1]);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/solr/util/SolrPluginUtils.java,invokeSetters,978-978,[        Class pClazz = method.getParameterTypes()[0];],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/solr/util/SolrPluginUtils.java,parseFieldBoostsAndSlop,538-538,[        int slop  = (2 == fieldVsSlop.length) ? Integer.valueOf(fieldVsSlop[1]) : defaultSlop;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/solr/util/SolrPluginUtils.java,docListToSolrDocumentList,951-951,[        ids.put( doc, new Integer(docid) );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/solr/util/SolrPluginUtils.java,getFieldQuery,810-810,[        for (String f : a.fields.keySet()) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/util/TestHarness.java,createConfig,75-75,[    } catch (Exception xany) {],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/solr/util/VersionedFile.java,getLatestFile,66-66,[          Arrays.sort(names);],,getLatestFile,60-60,[          String[] names = dir.list(new FilenameFilter() {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/util/VersionedFile.java,getLatestFile,75-75,[      } catch (Exception e) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/plugin/AbstractPluginLoader.java,,41-41,[  public static Logger log = LoggerFactory.getLogger(AbstractPluginLoader.class);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/solr/util/xslt/TransformerProvider.java,getTemplates,120-120,[    cacheExpires = System.currentTimeMillis() + (cacheLifetimeSeconds * 1000);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/solr/util/xslt/TransformerProvider.java,,53-53,[  public static TransformerProvider instance = new TransformerProvider();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/solr/util/xslt/TransformerProvider.java,getTemplates,113-113,[    } catch (Exception e) {],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/egothor/stemmer/Compile.java,main,93-93,[    args[0].toUpperCase(Locale.ROOT);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/egothor/stemmer/Diff.java,apply,122-141,[        switch (cmd) {,           case '-':,             pos = pos - par_num + 1;,             break;,           case 'R':,             dest.setCharAt(pos, param);,             break;,           case 'D':,             int o = pos;,             pos -= par_num - 1;,             /*,              * delete par_num chars from index pos,              */,             // String s = orig.toString();,             // s = s.substring( 0, pos ) + s.substring( o + 1 );,             // orig = new StringBuffer( s );,             dest.delete(pos, o + 1);        ,             break;,           case 'I':,             dest.insert(pos += 1, param);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/egothor/stemmer/Diff.java,exec,239-283,[      switch (way[x][y]) {,         case X:,           if (equals != base) {,             result.append("-" + (equals));,             equals = base;,           },           deletes++;,           x--;,           break;,         // delete,         case Y:,           if (deletes != base) {,             result.append("D" + (deletes));,             deletes = base;,           },           if (equals != base) {,             result.append("-" + (equals));,             equals = base;,           },           result.append('I');,           result.append(b.charAt(--y));,           break;,         // insert,         case R:,           if (deletes != base) {,             result.append("D" + (deletes));,             deletes = base;,           },           if (equals != base) {,             result.append("-" + (equals));,             equals = base;,           },           result.append('R');,           result.append(b.charAt(--y));,           x--;,           break;,         // replace,         case D:,           if (deletes != base) {,             result.append("D" + (deletes));,             deletes = base;,           },           equals++;,           x--;,           y--;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/egothor/stemmer/Gener.java,optimize,81-81,[    List<Row> rows = new ArrayList<>();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/egothor/stemmer/Lift.java,optimize,91-91,[    List<Row> rows = new ArrayList<>();],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/egothor/stemmer/MultiTrie.java,,70-70,[  final char EOM = '*';],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/egothor/stemmer/MultiTrie.java,,71-71,[  final String EOM_NODE = "" + EOM;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/egothor/stemmer/MultiTrie2.java,lengthPP,321-327,[      switch (cmd.charAt(i++)) {,         case '-':,         case 'D':,           len += cmd.charAt(i) - 'a' + 1;,           break;,         case 'R':,           len++; /* intentional fallthrough */],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/egothor/stemmer/Reduce.java,,117-132,[    public Remap(Row old, int remap[]) {,       super();,       Iterator<Character> i = old.cells.keySet().iterator();,       for (; i.hasNext();) {,         Character ch = i.next();,         Cell c = old.at(ch);,         Cell nc;,         if (c.ref >= 0) {,           nc = new Cell(c);,           nc.ref = remap[nc.ref];,         } else {,           nc = new Cell(c);,         },         cells.put(ch, nc);,       },     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/egothor/stemmer/Trie.java,getFully,250-250,[          aux = new Character(e.next());],,
PERFORMANCE,DM_NUMBER_CTOR,org/egothor/stemmer/Trie.java,add,354-354,[      Character ch = new Character(e.next());],,add,366-366,[    r.setCmd(new Character(e.next()), id_cmd);],,
PERFORMANCE,DM_NUMBER_CTOR,org/egothor/stemmer/Trie.java,getAll,138-138,[      Character ch = new Character(e.next());],,getAll,161-161,[      w = now.getCmd(new Character(e.next()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/egothor/stemmer/Trie.java,getFully,238-238,[      ch = new Character(e.next());],,getFully,250-250,[          aux = new Character(e.next());],,
PERFORMANCE,DM_NUMBER_CTOR,org/egothor/stemmer/Trie.java,getLastOnPath,281-281,[      Character ch = new Character(e.next());],,getLastOnPath,293-293,[    w = now.getCmd(new Character(e.next()));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/egothor/stemmer/Trie.java,getAll,177-177,[      return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/egothor/stemmer/Trie.java,,400-418,[    StrEnum(CharSequence s, boolean up) {,       this.s = s;,       if (up) {,         from = 0;,         by = 1;,       } else {,         from = s.length() - 1;,         by = -1;,       },     },     ,     int length() {,       return s.length();,     },     ,     char next() {,       char ch = s.charAt(from);,       from += by;,       return ch;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/tartarus/snowball/SnowballProgram.java,getCurrentBuffer,110-110,[      return current;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/tartarus/snowball/SnowballProgram.java,setCurrent,87-87,[      current = text;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/ArmenianStemmer.java,r_adjective,336-342,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 98,                             // delete, line 98,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/ArmenianStemmer.java,r_ending,416-422,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 287,                             // delete, line 287,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/ArmenianStemmer.java,r_noun,386-392,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 223,                             // delete, line 223,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/ArmenianStemmer.java,r_verb,361-367,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 176,                             // delete, line 176,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/ArmenianStemmer.java,stem,442-442,[                        if (!r_mark_regions())],,stem,466-466,[                        if (!r_ending())],,stem,476-476,[                        if (!r_verb())],,stem,486-486,[                        if (!r_adjective())],,stem,496-496,[                        if (!r_noun())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/ArmenianStemmer.java,copy_from,228-231,[                    I_p2 = other.I_p2;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/BasqueStemmer.java,stem,926-926,[                    cursor = limit_backward;                    return true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/BasqueStemmer.java,r_aditzak,704-740,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 61,                             // call RV, line 61,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 61,                             slice_del();,                             break;,                         case 2:,                             // (, line 63,                             // call R2, line 63,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 63,                             slice_del();,                             break;,                         case 3:,                             // (, line 65,                             // <-, line 65,                             slice_from("atseden");,                             break;,                         case 4:,                             // (, line 67,                             // <-, line 67,                             slice_from("arabera");,                             break;,                         case 5:,                             // (, line 69,                             // <-, line 69,                             slice_from("baditu");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/BasqueStemmer.java,r_adjetiboak,844-860,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 131,                             // call RV, line 131,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 131,                             slice_del();,                             break;,                         case 2:,                             // (, line 133,                             // <-, line 133,                             slice_from("z");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/BasqueStemmer.java,r_izenak,759-825,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 105,                             // call RV, line 105,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 105,                             slice_del();,                             break;,                         case 2:,                             // (, line 107,                             // call R2, line 107,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 107,                             slice_del();,                             break;,                         case 3:,                             // (, line 109,                             // <-, line 109,                             slice_from("jok");,                             break;,                         case 4:,                             // (, line 111,                             // call R1, line 111,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 111,                             slice_del();,                             break;,                         case 5:,                             // (, line 113,                             // <-, line 113,                             slice_from("tra");,                             break;,                         case 6:,                             // (, line 115,                             // <-, line 115,                             slice_from("minutu");,                             break;,                         case 7:,                             // (, line 117,                             // <-, line 117,                             slice_from("zehar");,                             break;,                         case 8:,                             // (, line 119,                             // <-, line 119,                             slice_from("geldi");,                             break;,                         case 9:,                             // (, line 121,                             // <-, line 121,                             slice_from("igaro");,                             break;,                         case 10:,                             // (, line 123,                             // <-, line 123,                             slice_from("aurka");],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/BasqueStemmer.java,stem,877-877,[                        if (!r_mark_regions())],,stem,920-920,[                        if (!r_adjetiboak())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/BasqueStemmer.java,copy_from,458-462,[                    I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/CatalanStemmer.java,stem,1046-1046,[                    cursor = limit_backward;                    // do, line 199],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/CatalanStemmer.java,r_attached_pronoun,813-824,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 86,                             // call R1, line 86,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 86,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/CatalanStemmer.java,r_residual_suffix,953-974,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 183,                             // call R1, line 183,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 183,                             slice_del();,                             break;,                         case 2:,                             // (, line 185,                             // call R1, line 185,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 185,                             slice_from("ic");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/CatalanStemmer.java,r_standard_suffix,843-894,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 115,                             // call R1, line 115,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 115,                             slice_del();,                             break;,                         case 2:,                             // (, line 117,                             // call R2, line 117,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 117,                             slice_del();,                             break;,                         case 3:,                             // (, line 119,                             // call R2, line 119,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 119,                             slice_from("log");,                             break;,                         case 4:,                             // (, line 121,                             // call R2, line 121,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 121,                             slice_from("ic");,                             break;,                         case 5:,                             // (, line 123,                             // call R1, line 123,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 123,                             slice_from("c");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/CatalanStemmer.java,r_verb_suffix,913-934,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 173,                             // call R1, line 173,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 173,                             slice_del();,                             break;,                         case 2:,                             // (, line 175,                             // call R2, line 175,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 175,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/CatalanStemmer.java,stem,993-993,[                        if (!r_mark_regions())],,stem,1006-1006,[                        if (!r_attached_pronoun())],,stem,1029-1029,[                            if (!r_verb_suffix())],,stem,1040-1040,[                        if (!r_residual_suffix())],,stem,1050-1050,[                        if (!r_cleaning())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/CatalanStemmer.java,copy_from,597-600,[                    I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/DanishStemmer.java,stem,427-427,[                    cursor = limit_backward;                    return true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/DanishStemmer.java,r_main_suffix,182-197,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 48,                             // delete, line 48,                             slice_del();,                             break;,                         case 2:,                             // (, line 50,                             if (!(in_grouping_b(g_s_ending, 97, 229))),                             {,                                 return false;,                             },                             // delete, line 50,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/DanishStemmer.java,r_other_suffix,301-322,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 70,                             // delete, line 70,                             slice_del();,                             // do, line 70,                             v_4 = limit - cursor;,                             lab1: do {,                                 // call consonant_pair, line 70,                                 if (!r_consonant_pair()),                                 {,                                     break lab1;,                                 },                             } while (false);,                             cursor = limit - v_4;,                             break;,                         case 2:,                             // (, line 72,                             // <-, line 72,                             slice_from("l\u00F8s");],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/DanishStemmer.java,r_other_suffix,312-312,[                                if (!r_consonant_pair())],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/DanishStemmer.java,stem,378-378,[                        if (!r_mark_regions())],,stem,391-391,[                        if (!r_main_suffix())],,stem,401-401,[                        if (!r_consonant_pair())],,stem,411-411,[                        if (!r_other_suffix())],,stem,421-421,[                        if (!r_undouble())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/DanishStemmer.java,copy_from,78-82,[                    I_x = other.I_x;,                     I_p1 = other.I_p1;,                     S_ch = other.S_ch;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/DutchStemmer.java,stem,831-831,[                    cursor = limit_backward;                    // do, line 163],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/DutchStemmer.java,r_standard_suffix,521-554,[                        switch(among_var) {,                             case 0:,                                 break lab0;,                             case 1:,                                 // (, line 110,                                 // call R1, line 110,                                 if (!r_R1()),                                 {,                                     break lab0;,                                 },                                 // <-, line 110,                                 slice_from("heid");,                                 break;,                             case 2:,                                 // (, line 113,                                 // call en_ending, line 113,                                 if (!r_en_ending()),                                 {,                                     break lab0;,                                 },                                 break;,                             case 3:,                                 // (, line 116,                                 // call R1, line 116,                                 if (!r_R1()),                                 {,                                     break lab0;,                                 },                                 if (!(out_grouping_b(g_v_j, 97, 232))),                                 {,                                     break lab0;,                                 },                                 // delete, line 116,                                 slice_del();],,r_standard_suffix,632-749,[                        switch(among_var) {,                             case 0:,                                 break lab4;,                             case 1:,                                 // (, line 129,                                 // call R2, line 129,                                 if (!r_R2()),                                 {,                                     break lab4;,                                 },                                 // delete, line 129,                                 slice_del();,                                 // or, line 130,                                 lab5: do {,                                     v_6 = limit - cursor;,                                     lab6: do {,                                         // (, line 130,                                         // [, line 130,                                         ket = cursor;,                                         // literal, line 130,                                         if (!(eq_s_b(2, "ig"))),                                         {,                                             break lab6;,                                         },                                         // ], line 130,                                         bra = cursor;,                                         // call R2, line 130,                                         if (!r_R2()),                                         {,                                             break lab6;,                                         },                                         // not, line 130,                                         {,                                             v_7 = limit - cursor;,                                             lab7: do {,                                                 // literal, line 130,                                                 if (!(eq_s_b(1, "e"))),                                                 {,                                                     break lab7;,                                                 },                                                 break lab6;,                                             } while (false);,                                             cursor = limit - v_7;,                                         },                                         // delete, line 130,                                         slice_del();,                                         break lab5;,                                     } while (false);,                                     cursor = limit - v_6;,                                     // call undouble, line 130,                                     if (!r_undouble()),                                     {,                                         break lab4;,                                     },                                 } while (false);,                                 break;,                             case 2:,                                 // (, line 133,                                 // call R2, line 133,                                 if (!r_R2()),                                 {,                                     break lab4;,                                 },                                 // not, line 133,                                 {,                                     v_8 = limit - cursor;,                                     lab8: do {,                                         // literal, line 133,                                         if (!(eq_s_b(1, "e"))),                                         {,                                             break lab8;,                                         },                                         break lab4;,                                     } while (false);,                                     cursor = limit - v_8;,                                 },                                 // delete, line 133,                                 slice_del();,                                 break;,                             case 3:,                                 // (, line 136,                                 // call R2, line 136,                                 if (!r_R2()),                                 {,                                     break lab4;,                                 },                                 // delete, line 136,                                 slice_del();,                                 // call e_ending, line 136,                                 if (!r_e_ending()),                                 {,                                     break lab4;,                                 },                                 break;,                             case 4:,                                 // (, line 139,                                 // call R2, line 139,                                 if (!r_R2()),                                 {,                                     break lab4;,                                 },                                 // delete, line 139,                                 slice_del();,                                 break;,                             case 5:,                                 // (, line 142,                                 // call R2, line 142,                                 if (!r_R2()),                                 {,                                     break lab4;,                                 },                                 // Boolean test e_found, line 142,                                 if (!(B_e_found)),                                 {,                                     break lab4;,                                 },                                 // delete, line 142,                                 slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/DutchStemmer.java,r_standard_suffix,563-563,[                        if (!r_e_ending())],,r_standard_suffix,612-612,[                        if (!r_en_ending())],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/DutchStemmer.java,stem,803-803,[                        if (!r_prelude())],,stem,813-813,[                        if (!r_mark_regions())],,stem,825-825,[                        if (!r_standard_suffix())],,stem,835-835,[                        if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/DutchStemmer.java,copy_from,80-84,[                    I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     B_e_found = other.B_e_found;,                     super.copy_from(other);,                 }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/EnglishStemmer.java,r_Step_2,763-764,[                            slice_from("ful");,                             break;],,r_Step_2,793-794,[                            slice_from("ful");,                             break;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/EnglishStemmer.java,r_Step_1a,450-457,[                        switch(among_var) {,                             case 0:,                                 cursor = limit - v_1;,                                 break lab0;,                             case 1:,                                 // (, line 62,                                 // delete, line 62,                                 slice_del();],,r_Step_1a,471-529,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 66,                             // <-, line 66,                             slice_from("ss");,                             break;,                         case 2:,                             // (, line 68,                             // or, line 68,                             lab1: do {,                                 v_2 = limit - cursor;,                                 lab2: do {,                                     // (, line 68,                                     // hop, line 68,                                     {,                                         int c = cursor - 2;,                                         if (limit_backward > c || c > limit),                                         {,                                             break lab2;,                                         },                                         cursor = c;,                                     },                                     // <-, line 68,                                     slice_from("i");,                                     break lab1;,                                 } while (false);,                                 cursor = limit - v_2;,                                 // <-, line 68,                                 slice_from("ie");,                             } while (false);,                             break;,                         case 3:,                             // (, line 69,                             // next, line 69,                             if (cursor <= limit_backward),                             {,                                 return false;,                             },                             cursor--;,                             // gopast, line 69,                             golab3: while(true),                             {,                                 lab4: do {,                                     if (!(in_grouping_b(g_v, 97, 121))),                                     {,                                         break lab4;,                                     },                                     break golab3;,                                 } while (false);,                                 if (cursor <= limit_backward),                                 {,                                     return false;,                                 },                                 cursor--;,                             },                             // delete, line 69,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/EnglishStemmer.java,r_Step_1b,596-642,[                            switch(among_var) {,                                 case 0:,                                     return false;,                                 case 1:,                                     // (, line 83,                                     // <+, line 83,                                     {,                                         int c = cursor;,                                         insert(cursor, cursor, "e");,                                         cursor = c;,                                     },                                     break;,                                 case 2:,                                     // (, line 86,                                     // [, line 86,                                     ket = cursor;,                                     // next, line 86,                                     if (cursor <= limit_backward),                                     {,                                         return false;,                                     },                                     cursor--;,                                     // ], line 86,                                     bra = cursor;,                                     // delete, line 86,                                     slice_del();,                                     break;,                                 case 3:,                                     // (, line 87,                                     // atmark, line 87,                                     if (cursor != I_p1),                                     {,                                         return false;,                                     },                                     // test, line 87,                                     v_4 = limit - cursor;,                                     // call shortv, line 87,                                     if (!r_shortv()),                                     {,                                         return false;,                                     },                                     cursor = limit - v_4;,                                     // <+, line 87,                                     {,                                         int c = cursor;,                                         insert(cursor, cursor, "e");,                                         cursor = c;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/EnglishStemmer.java,r_Step_2,717-807,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 101,                             // <-, line 101,                             slice_from("tion");,                             break;,                         case 2:,                             // (, line 102,                             // <-, line 102,                             slice_from("ence");,                             break;,                         case 3:,                             // (, line 103,                             // <-, line 103,                             slice_from("ance");,                             break;,                         case 4:,                             // (, line 104,                             // <-, line 104,                             slice_from("able");,                             break;,                         case 5:,                             // (, line 105,                             // <-, line 105,                             slice_from("ent");,                             break;,                         case 6:,                             // (, line 107,                             // <-, line 107,                             slice_from("ize");,                             break;,                         case 7:,                             // (, line 109,                             // <-, line 109,                             slice_from("ate");,                             break;,                         case 8:,                             // (, line 111,                             // <-, line 111,                             slice_from("al");,                             break;,                         case 9:,                             // (, line 112,                             // <-, line 112,                             slice_from("ful");,                             break;,                         case 10:,                             // (, line 114,                             // <-, line 114,                             slice_from("ous");,                             break;,                         case 11:,                             // (, line 116,                             // <-, line 116,                             slice_from("ive");,                             break;,                         case 12:,                             // (, line 118,                             // <-, line 118,                             slice_from("ble");,                             break;,                         case 13:,                             // (, line 119,                             // literal, line 119,                             if (!(eq_s_b(1, "l"))),                             {,                                 return false;,                             },                             // <-, line 119,                             slice_from("og");,                             break;,                         case 14:,                             // (, line 120,                             // <-, line 120,                             slice_from("ful");,                             break;,                         case 15:,                             // (, line 121,                             // <-, line 121,                             slice_from("less");,                             break;,                         case 16:,                             // (, line 122,                             if (!(in_grouping_b(g_valid_LI, 99, 116))),                             {,                                 return false;,                             },                             // delete, line 122,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/EnglishStemmer.java,r_Step_3,831-867,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 128,                             // <-, line 128,                             slice_from("tion");,                             break;,                         case 2:,                             // (, line 129,                             // <-, line 129,                             slice_from("ate");,                             break;,                         case 3:,                             // (, line 130,                             // <-, line 130,                             slice_from("al");,                             break;,                         case 4:,                             // (, line 132,                             // <-, line 132,                             slice_from("ic");,                             break;,                         case 5:,                             // (, line 134,                             // delete, line 134,                             slice_del();,                             break;,                         case 6:,                             // (, line 136,                             // call R2, line 136,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 136,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/EnglishStemmer.java,r_Step_4,892-921,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 144,                             // delete, line 144,                             slice_del();,                             break;,                         case 2:,                             // (, line 145,                             // or, line 145,                             lab0: do {,                                 v_1 = limit - cursor;,                                 lab1: do {,                                     // literal, line 145,                                     if (!(eq_s_b(1, "s"))),                                     {,                                         break lab1;,                                     },                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 // literal, line 145,                                 if (!(eq_s_b(1, "t"))),                                 {,                                     return false;,                                 },                             } while (false);,                             // delete, line 145,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/EnglishStemmer.java,r_Step_5,942-995,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 151,                             // or, line 151,                             lab0: do {,                                 v_1 = limit - cursor;,                                 lab1: do {,                                     // call R2, line 151,                                     if (!r_R2()),                                     {,                                         break lab1;,                                     },                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 // (, line 151,                                 // call R1, line 151,                                 if (!r_R1()),                                 {,                                     return false;,                                 },                                 // not, line 151,                                 {,                                     v_2 = limit - cursor;,                                     lab2: do {,                                         // call shortv, line 151,                                         if (!r_shortv()),                                         {,                                             break lab2;,                                         },                                         return false;,                                     } while (false);,                                     cursor = limit - v_2;,                                 },                             } while (false);,                             // delete, line 151,                             slice_del();,                             break;,                         case 2:,                             // (, line 152,                             // call R2, line 152,                             if (!r_R2()),                             {,                                 return false;,                             },                             // literal, line 152,                             if (!(eq_s_b(1, "l"))),                             {,                                 return false;,                             },                             // delete, line 152,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/EnglishStemmer.java,r_exception1,1038-1094,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 174,                             // <-, line 174,                             slice_from("ski");,                             break;,                         case 2:,                             // (, line 175,                             // <-, line 175,                             slice_from("sky");,                             break;,                         case 3:,                             // (, line 176,                             // <-, line 176,                             slice_from("die");,                             break;,                         case 4:,                             // (, line 177,                             // <-, line 177,                             slice_from("lie");,                             break;,                         case 5:,                             // (, line 178,                             // <-, line 178,                             slice_from("tie");,                             break;,                         case 6:,                             // (, line 182,                             // <-, line 182,                             slice_from("idl");,                             break;,                         case 7:,                             // (, line 183,                             // <-, line 183,                             slice_from("gentl");,                             break;,                         case 8:,                             // (, line 184,                             // <-, line 184,                             slice_from("ugli");,                             break;,                         case 9:,                             // (, line 185,                             // <-, line 185,                             slice_from("earli");,                             break;,                         case 10:,                             // (, line 186,                             // <-, line 186,                             slice_from("onli");,                             break;,                         case 11:,                             // (, line 187,                             // <-, line 187,                             slice_from("singl");],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/EnglishStemmer.java,stem,1204-1204,[                            if (!r_prelude())],,stem,1214-1214,[                            if (!r_mark_regions())],,stem,1227-1227,[                            if (!r_Step_1a())],,stem,1250-1250,[                                if (!r_Step_1b())],,stem,1260-1260,[                                if (!r_Step_1c())],,stem,1270-1270,[                                if (!r_Step_2())],,stem,1280-1280,[                                if (!r_Step_3())],,stem,1290-1290,[                                if (!r_Step_4())],,stem,1300-1300,[                                if (!r_Step_5())],,stem,1311-1311,[                            if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/EnglishStemmer.java,copy_from,173-177,[                    B_Y_found = other.B_Y_found;,                     I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/FinnishStemmer.java,r_case_ending,477-479,[                            if (!(eq_s_b(1, "e"))),                             {,                                 return false;],,r_case_ending,567-569,[                            if (!(eq_s_b(1, "e"))),                             {,                                 return false;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/FinnishStemmer.java,stem,1038-1038,[                    cursor = limit_backward;                    return true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/FinnishStemmer.java,r_other_endings,610-626,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 146,                             // not, line 146,                             {,                                 v_3 = limit - cursor;,                                 lab0: do {,                                     // literal, line 146,                                     if (!(eq_s_b(2, "po"))),                                     {,                                         break lab0;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_3;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/FinnishStemmer.java,r_possessive,332-402,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 72,                             // not, line 72,                             {,                                 v_3 = limit - cursor;,                                 lab0: do {,                                     // literal, line 72,                                     if (!(eq_s_b(1, "k"))),                                     {,                                         break lab0;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_3;,                             },                             // delete, line 72,                             slice_del();,                             break;,                         case 2:,                             // (, line 74,                             // delete, line 74,                             slice_del();,                             // [, line 74,                             ket = cursor;,                             // literal, line 74,                             if (!(eq_s_b(3, "kse"))),                             {,                                 return false;,                             },                             // ], line 74,                             bra = cursor;,                             // <-, line 74,                             slice_from("ksi");,                             break;,                         case 3:,                             // (, line 78,                             // delete, line 78,                             slice_del();,                             break;,                         case 4:,                             // (, line 81,                             // among, line 81,                             if (find_among_b(a_1, 6) == 0),                             {,                                 return false;,                             },                             // delete, line 81,                             slice_del();,                             break;,                         case 5:,                             // (, line 83,                             // among, line 83,                             if (find_among_b(a_2, 6) == 0),                             {,                                 return false;,                             },                             // delete, line 84,                             slice_del();,                             break;,                         case 6:,                             // (, line 86,                             // among, line 86,                             if (find_among_b(a_3, 2) == 0),                             {,                                 return false;,                             },                             // delete, line 86,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/FinnishStemmer.java,r_t_plural,733-749,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 167,                             // not, line 167,                             {,                                 v_6 = limit - cursor;,                                 lab0: do {,                                     // literal, line 167,                                     if (!(eq_s_b(2, "po"))),                                     {,                                         break lab0;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_6;],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/FinnishStemmer.java,stem,943-943,[                        if (!r_mark_regions())],,stem,958-958,[                        if (!r_particle_etc())],,stem,968-968,[                        if (!r_possessive())],,stem,978-978,[                        if (!r_case_ending())],,stem,988-988,[                        if (!r_other_endings())],,stem,1008-1008,[                                if (!r_i_plural())],,stem,1021-1021,[                            if (!r_t_plural())],,stem,1032-1032,[                        if (!r_tidy())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/FinnishStemmer.java,copy_from,151-156,[                    B_ending_removed = other.B_ending_removed;,                     S_x = other.S_x;,                     I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/FinnishStemmer.java,r_VI,420-428,[                    if (!(eq_s_b(1, "i"))),                     {,                         return false;,                     },                     if (!(in_grouping_b(g_V2, 97, 246))),                     {,                         return false;,                     },                     return true;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/FrenchStemmer.java,stem,1495-1495,[                    cursor = limit_backward;                    // do, line 246],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/FrenchStemmer.java,r_i_verb_suffix,1064-1076,[                    switch(among_var) {,                         case 0:,                             limit_backward = v_2;,                             return false;,                         case 1:,                             // (, line 170,                             if (!(out_grouping_b(g_v, 97, 251))),                             {,                                 limit_backward = v_2;,                                 return false;,                             },                             // delete, line 170,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/FrenchStemmer.java,r_residual_suffix,1214-1267,[                    switch(among_var) {,                         case 0:,                             limit_backward = v_4;,                             return false;,                         case 1:,                             // (, line 202,                             // call R2, line 202,                             if (!r_R2()),                             {,                                 limit_backward = v_4;,                                 return false;,                             },                             // or, line 202,                             lab1: do {,                                 v_5 = limit - cursor;,                                 lab2: do {,                                     // literal, line 202,                                     if (!(eq_s_b(1, "s"))),                                     {,                                         break lab2;,                                     },                                     break lab1;,                                 } while (false);,                                 cursor = limit - v_5;,                                 // literal, line 202,                                 if (!(eq_s_b(1, "t"))),                                 {,                                     limit_backward = v_4;,                                     return false;,                                 },                             } while (false);,                             // delete, line 202,                             slice_del();,                             break;,                         case 2:,                             // (, line 204,                             // <-, line 204,                             slice_from("i");,                             break;,                         case 3:,                             // (, line 205,                             // delete, line 205,                             slice_del();,                             break;,                         case 4:,                             // (, line 206,                             // literal, line 206,                             if (!(eq_s_b(2, "gu"))),                             {,                                 limit_backward = v_4;,                                 return false;,                             },                             // delete, line 206,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/FrenchStemmer.java,r_verb_suffix,1111-1150,[                    switch(among_var) {,                         case 0:,                             limit_backward = v_2;,                             return false;,                         case 1:,                             // (, line 177,                             // call R2, line 177,                             if (!r_R2()),                             {,                                 limit_backward = v_2;,                                 return false;,                             },                             // delete, line 177,                             slice_del();,                             break;,                         case 2:,                             // (, line 185,                             // delete, line 185,                             slice_del();,                             break;,                         case 3:,                             // (, line 190,                             // delete, line 190,                             slice_del();,                             // try, line 191,                             v_3 = limit - cursor;,                             lab0: do {,                                 // (, line 191,                                 // [, line 191,                                 ket = cursor;,                                 // literal, line 191,                                 if (!(eq_s_b(1, "e"))),                                 {,                                     cursor = limit - v_3;,                                     break lab0;,                                 },                                 // ], line 191,                                 bra = cursor;,                                 // delete, line 191,                                 slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/FrenchStemmer.java,stem,1369-1369,[                        if (!r_prelude())],,stem,1379-1379,[                        if (!r_mark_regions())],,stem,1468-1468,[                            if (!r_residual_suffix())],,stem,1479-1479,[                        if (!r_un_double())],,stem,1489-1489,[                        if (!r_un_accent())],,stem,1499-1499,[                        if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/FrenchStemmer.java,copy_from,199-203,[                    I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/German2Stemmer.java,r_postlude,365-366,[                                    slice_from("u");,                                     break;],,r_postlude,380-381,[                                    slice_from("u");,                                     break;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/German2Stemmer.java,stem,720-720,[                    cursor = limit_backward;                    // do, line 135],,
CORRECTNESS,SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH,org/tartarus/snowball/ext/German2Stemmer.java,r_standard_suffix,514-514,[                    cursor = limit - v_2;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/German2Stemmer.java,r_standard_suffix,447-462,[                        switch(among_var) {,                             case 0:,                                 break lab0;,                             case 1:,                                 // (, line 83,                                 // delete, line 83,                                 slice_del();,                                 break;,                             case 2:,                                 // (, line 86,                                 if (!(in_grouping_b(g_s_ending, 98, 116))),                                 {,                                     break lab0;,                                 },                                 // delete, line 86,                                 slice_del();],,r_standard_suffix,486-510,[                        switch(among_var) {,                             case 0:,                                 break lab1;,                             case 1:,                                 // (, line 93,                                 // delete, line 93,                                 slice_del();,                                 break;,                             case 2:,                                 // (, line 96,                                 if (!(in_grouping_b(g_st_ending, 98, 116))),                                 {,                                     break lab1;,                                 },                                 // hop, line 96,                                 {,                                     int c = cursor - 3;,                                     if (limit_backward > c || c > limit),                                     {,                                         break lab1;,                                     },                                     cursor = c;,                                 },                                 // delete, line 96,                                 slice_del();],,r_standard_suffix,663-670,[                                    switch(among_var) {,                                         case 0:,                                             cursor = limit - v_9;,                                             break lab9;,                                         case 1:,                                             // (, line 120,                                             // delete, line 120,                                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/German2Stemmer.java,stem,692-692,[                        if (!r_prelude())],,stem,702-702,[                        if (!r_mark_regions())],,stem,714-714,[                        if (!r_standard_suffix())],,stem,724-724,[                        if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/German2Stemmer.java,copy_from,81-85,[                    I_x = other.I_x;,                     I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/GermanStemmer.java,r_postlude,327-328,[                                    slice_from("u");,                                     break;],,r_postlude,342-343,[                                    slice_from("u");,                                     break;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/GermanStemmer.java,stem,682-682,[                    cursor = limit_backward;                    // do, line 129],,
CORRECTNESS,SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH,org/tartarus/snowball/ext/GermanStemmer.java,r_standard_suffix,476-476,[                    cursor = limit - v_2;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/GermanStemmer.java,r_standard_suffix,409-424,[                        switch(among_var) {,                             case 0:,                                 break lab0;,                             case 1:,                                 // (, line 77,                                 // delete, line 77,                                 slice_del();,                                 break;,                             case 2:,                                 // (, line 80,                                 if (!(in_grouping_b(g_s_ending, 98, 116))),                                 {,                                     break lab0;,                                 },                                 // delete, line 80,                                 slice_del();],,r_standard_suffix,448-472,[                        switch(among_var) {,                             case 0:,                                 break lab1;,                             case 1:,                                 // (, line 87,                                 // delete, line 87,                                 slice_del();,                                 break;,                             case 2:,                                 // (, line 90,                                 if (!(in_grouping_b(g_st_ending, 98, 116))),                                 {,                                     break lab1;,                                 },                                 // hop, line 90,                                 {,                                     int c = cursor - 3;,                                     if (limit_backward > c || c > limit),                                     {,                                         break lab1;,                                     },                                     cursor = c;,                                 },                                 // delete, line 90,                                 slice_del();],,r_standard_suffix,625-632,[                                    switch(among_var) {,                                         case 0:,                                             cursor = limit - v_9;,                                             break lab9;,                                         case 1:,                                             // (, line 114,                                             // delete, line 114,                                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/GermanStemmer.java,stem,654-654,[                        if (!r_prelude())],,stem,664-664,[                        if (!r_mark_regions())],,stem,676-676,[                        if (!r_standard_suffix())],,stem,686-686,[                        if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/GermanStemmer.java,copy_from,72-76,[                    I_x = other.I_x;,                     I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/HungarianStemmer.java,r_factive,597-599,[                            if (!r_double()),                             {,                                 return false;],,r_factive,605-607,[                            if (!r_double()),                             {,                                 return false;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/HungarianStemmer.java,r_instrum,438-440,[                            if (!r_double()),                             {,                                 return false;],,r_instrum,446-448,[                            if (!r_double()),                             {,                                 return false;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/HungarianStemmer.java,r_owned,710-711,[                            slice_from("e");,                             break;],,r_owned,725-726,[                            slice_from("e");,                             break;],,r_owned,740-741,[                            slice_from("e");,                             break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/HungarianStemmer.java,r_owned,715-716,[                            slice_from("a");,                             break;],,r_owned,730-731,[                            slice_from("a");,                             break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/HungarianStemmer.java,r_plur_owner,905-906,[                            slice_from("a");,                             break;],,r_plur_owner,930-931,[                            slice_from("a");,                             break;],,r_plur_owner,955-956,[                            slice_from("a");,                             break;],,r_plur_owner,985-986,[                            slice_from("a");,                             break;],,r_plur_owner,1005-1006,[                            slice_from("a");,                             break;],,r_plur_owner,1030-1031,[                            slice_from("a");,                             break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/HungarianStemmer.java,r_plur_owner,910-911,[                            slice_from("e");,                             break;],,r_plur_owner,935-936,[                            slice_from("e");,                             break;],,r_plur_owner,960-961,[                            slice_from("e");,                             break;],,r_plur_owner,990-991,[                            slice_from("e");,                             break;],,r_plur_owner,1010-1011,[                            slice_from("e");,                             break;],,r_plur_owner,1035-1036,[                            slice_from("e");,                             break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/HungarianStemmer.java,r_sing_owner,780-781,[                            slice_from("a");,                             break;],,r_sing_owner,795-796,[                            slice_from("a");,                             break;],,r_sing_owner,820-821,[                            slice_from("a");,                             break;],,r_sing_owner,840-841,[                            slice_from("a");,                             break;],,r_sing_owner,865-866,[                            slice_from("a");,                             break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/HungarianStemmer.java,r_sing_owner,785-786,[                            slice_from("e");,                             break;],,r_sing_owner,800-801,[                            slice_from("e");,                             break;],,r_sing_owner,825-826,[                            slice_from("e");,                             break;],,r_sing_owner,845-846,[                            slice_from("e");,                             break;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/HungarianStemmer.java,stem,1162-1162,[                    cursor = limit_backward;                    return true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/HungarianStemmer.java,r_case_other,546-567,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 125,                             // delete, line 125,                             slice_del();,                             break;,                         case 2:,                             // (, line 126,                             // delete, line 126,                             slice_del();,                             break;,                         case 3:,                             // (, line 127,                             // <-, line 127,                             slice_from("a");,                             break;,                         case 4:,                             // (, line 128,                             // <-, line 128,                             slice_from("e");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/HungarianStemmer.java,r_case_special,506-522,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 117,                             // <-, line 117,                             slice_from("e");,                             break;,                         case 2:,                             // (, line 118,                             // <-, line 118,                             slice_from("a");,                             break;,                         case 3:,                             // (, line 119,                             // <-, line 119,                             slice_from("a");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/HungarianStemmer.java,r_owned,699-745,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 155,                             // delete, line 155,                             slice_del();,                             break;,                         case 2:,                             // (, line 156,                             // <-, line 156,                             slice_from("e");,                             break;,                         case 3:,                             // (, line 157,                             // <-, line 157,                             slice_from("a");,                             break;,                         case 4:,                             // (, line 158,                             // delete, line 158,                             slice_del();,                             break;,                         case 5:,                             // (, line 159,                             // <-, line 159,                             slice_from("e");,                             break;,                         case 6:,                             // (, line 160,                             // <-, line 160,                             slice_from("a");,                             break;,                         case 7:,                             // (, line 161,                             // delete, line 161,                             slice_del();,                             break;,                         case 8:,                             // (, line 162,                             // <-, line 162,                             slice_from("e");,                             break;,                         case 9:,                             // (, line 163,                             // delete, line 163,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/HungarianStemmer.java,r_plur_owner,894-1040,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 194,                             // delete, line 194,                             slice_del();,                             break;,                         case 2:,                             // (, line 195,                             // <-, line 195,                             slice_from("a");,                             break;,                         case 3:,                             // (, line 196,                             // <-, line 196,                             slice_from("e");,                             break;,                         case 4:,                             // (, line 197,                             // delete, line 197,                             slice_del();,                             break;,                         case 5:,                             // (, line 198,                             // delete, line 198,                             slice_del();,                             break;,                         case 6:,                             // (, line 199,                             // delete, line 199,                             slice_del();,                             break;,                         case 7:,                             // (, line 200,                             // <-, line 200,                             slice_from("a");,                             break;,                         case 8:,                             // (, line 201,                             // <-, line 201,                             slice_from("e");,                             break;,                         case 9:,                             // (, line 202,                             // delete, line 202,                             slice_del();,                             break;,                         case 10:,                             // (, line 203,                             // delete, line 203,                             slice_del();,                             break;,                         case 11:,                             // (, line 204,                             // delete, line 204,                             slice_del();,                             break;,                         case 12:,                             // (, line 205,                             // <-, line 205,                             slice_from("a");,                             break;,                         case 13:,                             // (, line 206,                             // <-, line 206,                             slice_from("e");,                             break;,                         case 14:,                             // (, line 207,                             // delete, line 207,                             slice_del();,                             break;,                         case 15:,                             // (, line 208,                             // delete, line 208,                             slice_del();,                             break;,                         case 16:,                             // (, line 209,                             // delete, line 209,                             slice_del();,                             break;,                         case 17:,                             // (, line 210,                             // delete, line 210,                             slice_del();,                             break;,                         case 18:,                             // (, line 211,                             // <-, line 211,                             slice_from("a");,                             break;,                         case 19:,                             // (, line 212,                             // <-, line 212,                             slice_from("e");,                             break;,                         case 20:,                             // (, line 214,                             // delete, line 214,                             slice_del();,                             break;,                         case 21:,                             // (, line 215,                             // delete, line 215,                             slice_del();,                             break;,                         case 22:,                             // (, line 216,                             // <-, line 216,                             slice_from("a");,                             break;,                         case 23:,                             // (, line 217,                             // <-, line 217,                             slice_from("e");,                             break;,                         case 24:,                             // (, line 218,                             // delete, line 218,                             slice_del();,                             break;,                         case 25:,                             // (, line 219,                             // delete, line 219,                             slice_del();,                             break;,                         case 26:,                             // (, line 220,                             // delete, line 220,                             slice_del();,                             break;,                         case 27:,                             // (, line 221,                             // <-, line 221,                             slice_from("a");,                             break;,                         case 28:,                             // (, line 222,                             // <-, line 222,                             slice_from("e");,                             break;,                         case 29:,                             // (, line 223,                             // delete, line 223,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/HungarianStemmer.java,r_plural,639-675,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 143,                             // <-, line 143,                             slice_from("a");,                             break;,                         case 2:,                             // (, line 144,                             // <-, line 144,                             slice_from("e");,                             break;,                         case 3:,                             // (, line 145,                             // delete, line 145,                             slice_del();,                             break;,                         case 4:,                             // (, line 146,                             // delete, line 146,                             slice_del();,                             break;,                         case 5:,                             // (, line 147,                             // delete, line 147,                             slice_del();,                             break;,                         case 6:,                             // (, line 148,                             // delete, line 148,                             slice_del();,                             break;,                         case 7:,                             // (, line 149,                             // delete, line 149,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/HungarianStemmer.java,r_sing_owner,769-870,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 169,                             // delete, line 169,                             slice_del();,                             break;,                         case 2:,                             // (, line 170,                             // <-, line 170,                             slice_from("a");,                             break;,                         case 3:,                             // (, line 171,                             // <-, line 171,                             slice_from("e");,                             break;,                         case 4:,                             // (, line 172,                             // delete, line 172,                             slice_del();,                             break;,                         case 5:,                             // (, line 173,                             // <-, line 173,                             slice_from("a");,                             break;,                         case 6:,                             // (, line 174,                             // <-, line 174,                             slice_from("e");,                             break;,                         case 7:,                             // (, line 175,                             // delete, line 175,                             slice_del();,                             break;,                         case 8:,                             // (, line 176,                             // delete, line 176,                             slice_del();,                             break;,                         case 9:,                             // (, line 177,                             // delete, line 177,                             slice_del();,                             break;,                         case 10:,                             // (, line 178,                             // <-, line 178,                             slice_from("a");,                             break;,                         case 11:,                             // (, line 179,                             // <-, line 179,                             slice_from("e");,                             break;,                         case 12:,                             // (, line 180,                             // delete, line 180,                             slice_del();,                             break;,                         case 13:,                             // (, line 181,                             // delete, line 181,                             slice_del();,                             break;,                         case 14:,                             // (, line 182,                             // <-, line 182,                             slice_from("a");,                             break;,                         case 15:,                             // (, line 183,                             // <-, line 183,                             slice_from("e");,                             break;,                         case 16:,                             // (, line 184,                             // delete, line 184,                             slice_del();,                             break;,                         case 17:,                             // (, line 185,                             // delete, line 185,                             slice_del();,                             break;,                         case 18:,                             // (, line 186,                             // delete, line 186,                             slice_del();,                             break;,                         case 19:,                             // (, line 187,                             // <-, line 187,                             slice_from("a");,                             break;,                         case 20:,                             // (, line 188,                             // <-, line 188,                             slice_from("e");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/HungarianStemmer.java,r_v_ending,357-368,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 62,                             // <-, line 62,                             slice_from("a");,                             break;,                         case 2:,                             // (, line 63,                             // <-, line 63,                             slice_from("e");],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/HungarianStemmer.java,stem,1063-1063,[                        if (!r_mark_regions())],,stem,1076-1076,[                        if (!r_instrum())],,stem,1086-1086,[                        if (!r_case())],,stem,1096-1096,[                        if (!r_case_special())],,stem,1106-1106,[                        if (!r_case_other())],,stem,1116-1116,[                        if (!r_factive())],,stem,1126-1126,[                        if (!r_owned())],,stem,1136-1136,[                        if (!r_sing_owner())],,stem,1146-1146,[                        if (!r_plur_owner())],,stem,1156-1156,[                        if (!r_plural())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/HungarianStemmer.java,copy_from,242-244,[                    I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/IrishStemmer.java,stem,574-574,[                    cursor = limit_backward;                    return true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/IrishStemmer.java,r_deriv,431-467,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 116,                             // call R2, line 116,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 116,                             slice_del();,                             break;,                         case 2:,                             // (, line 118,                             // <-, line 118,                             slice_from("arc");,                             break;,                         case 3:,                             // (, line 120,                             // <-, line 120,                             slice_from("gin");,                             break;,                         case 4:,                             // (, line 122,                             // <-, line 122,                             slice_from("graf");,                             break;,                         case 5:,                             // (, line 124,                             // <-, line 124,                             slice_from("paite");,                             break;,                         case 6:,                             // (, line 126,                             // <-, line 126,                             slice_from("\u00F3id");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/IrishStemmer.java,r_initial_morph,242-348,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 46,                             // delete, line 46,                             slice_del();,                             break;,                         case 2:,                             // (, line 50,                             // delete, line 50,                             slice_del();,                             break;,                         case 3:,                             // (, line 52,                             // <-, line 52,                             slice_from("f");,                             break;,                         case 4:,                             // (, line 55,                             // delete, line 55,                             slice_del();,                             break;,                         case 5:,                             // (, line 58,                             // <-, line 58,                             slice_from("s");,                             break;,                         case 6:,                             // (, line 61,                             // <-, line 61,                             slice_from("b");,                             break;,                         case 7:,                             // (, line 63,                             // <-, line 63,                             slice_from("c");,                             break;,                         case 8:,                             // (, line 65,                             // <-, line 65,                             slice_from("d");,                             break;,                         case 9:,                             // (, line 67,                             // <-, line 67,                             slice_from("f");,                             break;,                         case 10:,                             // (, line 69,                             // <-, line 69,                             slice_from("g");,                             break;,                         case 11:,                             // (, line 71,                             // <-, line 71,                             slice_from("p");,                             break;,                         case 12:,                             // (, line 73,                             // <-, line 73,                             slice_from("s");,                             break;,                         case 13:,                             // (, line 75,                             // <-, line 75,                             slice_from("t");,                             break;,                         case 14:,                             // (, line 79,                             // <-, line 79,                             slice_from("b");,                             break;,                         case 15:,                             // (, line 81,                             // <-, line 81,                             slice_from("c");,                             break;,                         case 16:,                             // (, line 83,                             // <-, line 83,                             slice_from("d");,                             break;,                         case 17:,                             // (, line 85,                             // <-, line 85,                             slice_from("f");,                             break;,                         case 18:,                             // (, line 87,                             // <-, line 87,                             slice_from("g");,                             break;,                         case 19:,                             // (, line 89,                             // <-, line 89,                             slice_from("m");,                             break;,                         case 20:,                             // (, line 91,                             // <-, line 91,                             slice_from("p");,                             break;,                         case 21:,                             // (, line 93,                             // <-, line 93,                             slice_from("t");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/IrishStemmer.java,r_noun_sfx,391-412,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 108,                             // call R1, line 108,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 108,                             slice_del();,                             break;,                         case 2:,                             // (, line 110,                             // call R2, line 110,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 110,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/IrishStemmer.java,r_verb_sfx,486-507,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 133,                             // call RV, line 133,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 133,                             slice_del();,                             break;,                         case 2:,                             // (, line 138,                             // call R1, line 138,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 138,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/IrishStemmer.java,stem,525-525,[                        if (!r_initial_morph())],,stem,535-535,[                        if (!r_mark_regions())],,stem,548-548,[                        if (!r_noun_sfx())],,stem,558-558,[                        if (!r_deriv())],,stem,568-568,[                        if (!r_verb_sfx())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/IrishStemmer.java,copy_from,115-119,[                    I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/ItalianStemmer.java,stem,1174-1174,[                    cursor = limit_backward;                    // do, line 189],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/ItalianStemmer.java,r_attached_pronoun,704-715,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 98,                             // delete, line 98,                             slice_del();,                             break;,                         case 2:,                             // (, line 99,                             // <-, line 99,                             slice_from("e");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/ItalianStemmer.java,r_standard_suffix,738-974,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 111,                             // call R2, line 111,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 111,                             slice_del();,                             break;,                         case 2:,                             // (, line 113,                             // call R2, line 113,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 113,                             slice_del();,                             // try, line 114,                             v_1 = limit - cursor;,                             lab0: do {,                                 // (, line 114,                                 // [, line 114,                                 ket = cursor;,                                 // literal, line 114,                                 if (!(eq_s_b(2, "ic"))),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 // ], line 114,                                 bra = cursor;,                                 // call R2, line 114,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 // delete, line 114,                                 slice_del();,                             } while (false);,                             break;,                         case 3:,                             // (, line 117,                             // call R2, line 117,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 117,                             slice_from("log");,                             break;,                         case 4:,                             // (, line 119,                             // call R2, line 119,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 119,                             slice_from("u");,                             break;,                         case 5:,                             // (, line 121,                             // call R2, line 121,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 121,                             slice_from("ente");,                             break;,                         case 6:,                             // (, line 123,                             // call RV, line 123,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 123,                             slice_del();,                             break;,                         case 7:,                             // (, line 124,                             // call R1, line 125,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 125,                             slice_del();,                             // try, line 126,                             v_2 = limit - cursor;,                             lab1: do {,                                 // (, line 126,                                 // [, line 127,                                 ket = cursor;,                                 // substring, line 127,                                 among_var = find_among_b(a_4, 4);,                                 if (among_var == 0),                                 {,                                     cursor = limit - v_2;,                                     break lab1;,                                 },                                 // ], line 127,                                 bra = cursor;,                                 // call R2, line 127,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_2;,                                     break lab1;,                                 },                                 // delete, line 127,                                 slice_del();,                                 switch(among_var) {,                                     case 0:,                                         cursor = limit - v_2;,                                         break lab1;,                                     case 1:,                                         // (, line 128,                                         // [, line 128,                                         ket = cursor;,                                         // literal, line 128,                                         if (!(eq_s_b(2, "at"))),                                         {,                                             cursor = limit - v_2;,                                             break lab1;,                                         },                                         // ], line 128,                                         bra = cursor;,                                         // call R2, line 128,                                         if (!r_R2()),                                         {,                                             cursor = limit - v_2;,                                             break lab1;,                                         },                                         // delete, line 128,                                         slice_del();,                                         break;,                                 },                             } while (false);,                             break;,                         case 8:,                             // (, line 133,                             // call R2, line 134,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 134,                             slice_del();,                             // try, line 135,                             v_3 = limit - cursor;,                             lab2: do {,                                 // (, line 135,                                 // [, line 136,                                 ket = cursor;,                                 // substring, line 136,                                 among_var = find_among_b(a_5, 3);,                                 if (among_var == 0),                                 {,                                     cursor = limit - v_3;,                                     break lab2;,                                 },                                 // ], line 136,                                 bra = cursor;,                                 switch(among_var) {,                                     case 0:,                                         cursor = limit - v_3;,                                         break lab2;,                                     case 1:,                                         // (, line 137,                                         // call R2, line 137,                                         if (!r_R2()),                                         {,                                             cursor = limit - v_3;,                                             break lab2;,                                         },                                         // delete, line 137,                                         slice_del();,                                         break;,                                 },                             } while (false);,                             break;,                         case 9:,                             // (, line 141,                             // call R2, line 142,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 142,                             slice_del();,                             // try, line 143,                             v_4 = limit - cursor;,                             lab3: do {,                                 // (, line 143,                                 // [, line 143,                                 ket = cursor;,                                 // literal, line 143,                                 if (!(eq_s_b(2, "at"))),                                 {,                                     cursor = limit - v_4;,                                     break lab3;,                                 },                                 // ], line 143,                                 bra = cursor;,                                 // call R2, line 143,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_4;,                                     break lab3;,                                 },                                 // delete, line 143,                                 slice_del();,                                 // [, line 143,                                 ket = cursor;,                                 // literal, line 143,                                 if (!(eq_s_b(2, "ic"))),                                 {,                                     cursor = limit - v_4;,                                     break lab3;,                                 },                                 // ], line 143,                                 bra = cursor;,                                 // call R2, line 143,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_4;,                                     break lab3;,                                 },                                 // delete, line 143,                                 slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/ItalianStemmer.java,r_verb_suffix,1008-1015,[                    switch(among_var) {,                         case 0:,                             limit_backward = v_2;,                             return false;,                         case 1:,                             // (, line 163,                             // delete, line 163,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/ItalianStemmer.java,stem,1111-1111,[                        if (!r_prelude())],,stem,1121-1121,[                        if (!r_mark_regions())],,stem,1134-1134,[                        if (!r_attached_pronoun())],,stem,1157-1157,[                            if (!r_verb_suffix())],,stem,1168-1168,[                        if (!r_vowel_suffix())],,stem,1178-1178,[                        if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/ItalianStemmer.java,copy_from,251-255,[                    I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/KpStemmer.java,r_Step_3,992-1001,[                            if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 97,                             slice_del();,                             // call lengthen_V, line 97,                             if (!r_lengthen_V()),                             {,                                 return false;],,r_Step_3,1022-1031,[                            if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 104,                             slice_del();,                             // call lengthen_V, line 104,                             if (!r_lengthen_V()),                             {,                                 return false;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/KpStemmer.java,r_Step_4,1163-1169,[                                    if (!r_R1()),                                     {,                                         break lab1;,                                     },                                     // delete, line 118,                                     slice_del();,                                     break;],,r_Step_4,1238-1244,[                                    if (!r_R1()),                                     {,                                         break lab1;,                                     },                                     // delete, line 127,                                     slice_del();,                                     break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/KpStemmer.java,r_Step_6,1380-1381,[                            slice_from("f");,                             break;],,r_Step_6,1465-1466,[                            slice_from("f");,                             break;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/KpStemmer.java,stem,2013-2013,[                    cursor = limit_backward;                    // unset GE_removed, line 229],,stem,2053-2053,[                    cursor = limit_backward;                    // unset GE_removed, line 234],,stem,2093-2093,[                    cursor = limit_backward;                    // backwards, line 239],,stem,2136-2136,[                    cursor = limit_backward;                    // do, line 243],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/KpStemmer.java,r_Step_1,407-660,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 51,                             // delete, line 51,                             slice_del();,                             break;,                         case 2:,                             // (, line 52,                             // call R1, line 52,                             if (!r_R1()),                             {,                                 return false;,                             },                             // not, line 52,                             {,                                 v_1 = limit - cursor;,                                 lab0: do {,                                     // (, line 52,                                     // literal, line 52,                                     if (!(eq_s_b(1, "t"))),                                     {,                                         break lab0;,                                     },                                     // call R1, line 52,                                     if (!r_R1()),                                     {,                                         break lab0;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_1;,                             },                             // call C, line 52,                             if (!r_C()),                             {,                                 return false;,                             },                             // delete, line 52,                             slice_del();,                             break;,                         case 3:,                             // (, line 53,                             // call R1, line 53,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 53,                             slice_from("ie");,                             break;,                         case 4:,                             // (, line 55,                             // or, line 55,                             lab1: do {,                                 v_2 = limit - cursor;,                                 lab2: do {,                                     // (, line 55,                                     // literal, line 55,                                     if (!(eq_s_b(2, "ar"))),                                     {,                                         break lab2;,                                     },                                     // call R1, line 55,                                     if (!r_R1()),                                     {,                                         break lab2;,                                     },                                     // call C, line 55,                                     if (!r_C()),                                     {,                                         break lab2;,                                     },                                     // ], line 55,                                     bra = cursor;,                                     // delete, line 55,                                     slice_del();,                                     // call lengthen_V, line 55,                                     if (!r_lengthen_V()),                                     {,                                         break lab2;,                                     },                                     break lab1;,                                 } while (false);,                                 cursor = limit - v_2;,                                 lab3: do {,                                     // (, line 56,                                     // literal, line 56,                                     if (!(eq_s_b(2, "er"))),                                     {,                                         break lab3;,                                     },                                     // call R1, line 56,                                     if (!r_R1()),                                     {,                                         break lab3;,                                     },                                     // call C, line 56,                                     if (!r_C()),                                     {,                                         break lab3;,                                     },                                     // ], line 56,                                     bra = cursor;,                                     // delete, line 56,                                     slice_del();,                                     break lab1;,                                 } while (false);,                                 cursor = limit - v_2;,                                 // (, line 57,                                 // call R1, line 57,                                 if (!r_R1()),                                 {,                                     return false;,                                 },                                 // call C, line 57,                                 if (!r_C()),                                 {,                                     return false;,                                 },                                 // <-, line 57,                                 slice_from("e");,                             } while (false);,                             break;,                         case 5:,                             // (, line 59,                             // call R1, line 59,                             if (!r_R1()),                             {,                                 return false;,                             },                             // call V, line 59,                             if (!r_V()),                             {,                                 return false;,                             },                             // <-, line 59,                             slice_from("au");,                             break;,                         case 6:,                             // (, line 60,                             // or, line 60,                             lab4: do {,                                 v_3 = limit - cursor;,                                 lab5: do {,                                     // (, line 60,                                     // literal, line 60,                                     if (!(eq_s_b(3, "hed"))),                                     {,                                         break lab5;,                                     },                                     // call R1, line 60,                                     if (!r_R1()),                                     {,                                         break lab5;,                                     },                                     // ], line 60,                                     bra = cursor;,                                     // <-, line 60,                                     slice_from("heid");,                                     break lab4;,                                 } while (false);,                                 cursor = limit - v_3;,                                 lab6: do {,                                     // (, line 61,                                     // literal, line 61,                                     if (!(eq_s_b(2, "nd"))),                                     {,                                         break lab6;,                                     },                                     // delete, line 61,                                     slice_del();,                                     break lab4;,                                 } while (false);,                                 cursor = limit - v_3;,                                 lab7: do {,                                     // (, line 62,                                     // literal, line 62,                                     if (!(eq_s_b(1, "d"))),                                     {,                                         break lab7;,                                     },                                     // call R1, line 62,                                     if (!r_R1()),                                     {,                                         break lab7;,                                     },                                     // call C, line 62,                                     if (!r_C()),                                     {,                                         break lab7;,                                     },                                     // ], line 62,                                     bra = cursor;,                                     // delete, line 62,                                     slice_del();,                                     break lab4;,                                 } while (false);,                                 cursor = limit - v_3;,                                 lab8: do {,                                     // (, line 63,                                     // or, line 63,                                     lab9: do {,                                         v_4 = limit - cursor;,                                         lab10: do {,                                             // literal, line 63,                                             if (!(eq_s_b(1, "i"))),                                             {,                                                 break lab10;,                                             },                                             break lab9;,                                         } while (false);,                                         cursor = limit - v_4;,                                         // literal, line 63,                                         if (!(eq_s_b(1, "j"))),                                         {,                                             break lab8;,                                         },                                     } while (false);,                                     // call V, line 63,                                     if (!r_V()),                                     {,                                         break lab8;,                                     },                                     // delete, line 63,                                     slice_del();,                                     break lab4;,                                 } while (false);,                                 cursor = limit - v_3;,                                 // (, line 64,                                 // call R1, line 64,                                 if (!r_R1()),                                 {,                                     return false;,                                 },                                 // call C, line 64,                                 if (!r_C()),                                 {,                                     return false;,                                 },                                 // delete, line 64,                                 slice_del();,                                 // call lengthen_V, line 64,                                 if (!r_lengthen_V()),                                 {,                                     return false;,                                 },                             } while (false);,                             break;,                         case 7:,                             // (, line 65,                             // <-, line 65,                             slice_from("nd");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/KpStemmer.java,r_Step_1c,1502-1551,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 183,                             // not, line 183,                             {,                                 v_1 = limit - cursor;,                                 lab0: do {,                                     // (, line 183,                                     // literal, line 183,                                     if (!(eq_s_b(1, "n"))),                                     {,                                         break lab0;,                                     },                                     // call R1, line 183,                                     if (!r_R1()),                                     {,                                         break lab0;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_1;,                             },                             // delete, line 183,                             slice_del();,                             break;,                         case 2:,                             // (, line 184,                             // not, line 184,                             {,                                 v_2 = limit - cursor;,                                 lab1: do {,                                     // (, line 184,                                     // literal, line 184,                                     if (!(eq_s_b(1, "h"))),                                     {,                                         break lab1;,                                     },                                     // call R1, line 184,                                     if (!r_R1()),                                     {,                                         break lab1;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_2;,                             },                             // delete, line 184,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/KpStemmer.java,r_Step_2,681-956,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 72,                             // or, line 72,                             lab0: do {,                                 v_1 = limit - cursor;,                                 lab1: do {,                                     // (, line 72,                                     // literal, line 72,                                     if (!(eq_s_b(2, "'t"))),                                     {,                                         break lab1;,                                     },                                     // ], line 72,                                     bra = cursor;,                                     // delete, line 72,                                     slice_del();,                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 lab2: do {,                                     // (, line 73,                                     // literal, line 73,                                     if (!(eq_s_b(2, "et"))),                                     {,                                         break lab2;,                                     },                                     // ], line 73,                                     bra = cursor;,                                     // call R1, line 73,                                     if (!r_R1()),                                     {,                                         break lab2;,                                     },                                     // call C, line 73,                                     if (!r_C()),                                     {,                                         break lab2;,                                     },                                     // delete, line 73,                                     slice_del();,                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 lab3: do {,                                     // (, line 74,                                     // literal, line 74,                                     if (!(eq_s_b(3, "rnt"))),                                     {,                                         break lab3;,                                     },                                     // ], line 74,                                     bra = cursor;,                                     // <-, line 74,                                     slice_from("rn");,                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 lab4: do {,                                     // (, line 75,                                     // literal, line 75,                                     if (!(eq_s_b(1, "t"))),                                     {,                                         break lab4;,                                     },                                     // ], line 75,                                     bra = cursor;,                                     // call R1, line 75,                                     if (!r_R1()),                                     {,                                         break lab4;,                                     },                                     // call VX, line 75,                                     if (!r_VX()),                                     {,                                         break lab4;,                                     },                                     // delete, line 75,                                     slice_del();,                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 lab5: do {,                                     // (, line 76,                                     // literal, line 76,                                     if (!(eq_s_b(3, "ink"))),                                     {,                                         break lab5;,                                     },                                     // ], line 76,                                     bra = cursor;,                                     // <-, line 76,                                     slice_from("ing");,                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 lab6: do {,                                     // (, line 77,                                     // literal, line 77,                                     if (!(eq_s_b(2, "mp"))),                                     {,                                         break lab6;,                                     },                                     // ], line 77,                                     bra = cursor;,                                     // <-, line 77,                                     slice_from("m");,                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 lab7: do {,                                     // (, line 78,                                     // literal, line 78,                                     if (!(eq_s_b(1, "'"))),                                     {,                                         break lab7;,                                     },                                     // ], line 78,                                     bra = cursor;,                                     // call R1, line 78,                                     if (!r_R1()),                                     {,                                         break lab7;,                                     },                                     // delete, line 78,                                     slice_del();,                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 // (, line 79,                                 // ], line 79,                                 bra = cursor;,                                 // call R1, line 79,                                 if (!r_R1()),                                 {,                                     return false;,                                 },                                 // call C, line 79,                                 if (!r_C()),                                 {,                                     return false;,                                 },                                 // delete, line 79,                                 slice_del();,                             } while (false);,                             break;,                         case 2:,                             // (, line 80,                             // call R1, line 80,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 80,                             slice_from("g");,                             break;,                         case 3:,                             // (, line 81,                             // call R1, line 81,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 81,                             slice_from("lijk");,                             break;,                         case 4:,                             // (, line 82,                             // call R1, line 82,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 82,                             slice_from("isch");,                             break;,                         case 5:,                             // (, line 83,                             // call R1, line 83,                             if (!r_R1()),                             {,                                 return false;,                             },                             // call C, line 83,                             if (!r_C()),                             {,                                 return false;,                             },                             // delete, line 83,                             slice_del();,                             break;,                         case 6:,                             // (, line 84,                             // call R1, line 84,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 84,                             slice_from("t");,                             break;,                         case 7:,                             // (, line 85,                             // call R1, line 85,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 85,                             slice_from("s");,                             break;,                         case 8:,                             // (, line 86,                             // call R1, line 86,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 86,                             slice_from("r");,                             break;,                         case 9:,                             // (, line 87,                             // call R1, line 87,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 87,                             slice_del();,                             // attach, line 87,                             insert(cursor, cursor, "l");,                             // call lengthen_V, line 87,                             if (!r_lengthen_V()),                             {,                                 return false;,                             },                             break;,                         case 10:,                             // (, line 88,                             // call R1, line 88,                             if (!r_R1()),                             {,                                 return false;,                             },                             // call C, line 88,                             if (!r_C()),                             {,                                 return false;,                             },                             // delete, line 88,                             slice_del();,                             // attach, line 88,                             insert(cursor, cursor, "en");,                             // call lengthen_V, line 88,                             if (!r_lengthen_V()),                             {,                                 return false;,                             },                             break;,                         case 11:,                             // (, line 89,                             // call R1, line 89,                             if (!r_R1()),                             {,                                 return false;,                             },                             // call C, line 89,                             if (!r_C()),                             {,                                 return false;,                             },                             // <-, line 89,                             slice_from("ief");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/KpStemmer.java,r_Step_3,976-1111,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 96,                             // call R1, line 96,                             if (!r_R1()),                             {,                                 return false;,                             },                             // <-, line 96,                             slice_from("eer");,                             break;,                         case 2:,                             // (, line 97,                             // call R1, line 97,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 97,                             slice_del();,                             // call lengthen_V, line 97,                             if (!r_lengthen_V()),                             {,                                 return false;,                             },                             break;,                         case 3:,                             // (, line 100,                             // call R1, line 100,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 100,                             slice_del();,                             break;,                         case 4:,                             // (, line 101,                             // <-, line 101,                             slice_from("r");,                             break;,                         case 5:,                             // (, line 104,                             // call R1, line 104,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 104,                             slice_del();,                             // call lengthen_V, line 104,                             if (!r_lengthen_V()),                             {,                                 return false;,                             },                             break;,                         case 6:,                             // (, line 105,                             // call R1, line 105,                             if (!r_R1()),                             {,                                 return false;,                             },                             // call C, line 105,                             if (!r_C()),                             {,                                 return false;,                             },                             // <-, line 105,                             slice_from("aar");,                             break;,                         case 7:,                             // (, line 106,                             // call R2, line 106,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 106,                             slice_del();,                             // attach, line 106,                             insert(cursor, cursor, "f");,                             // call lengthen_V, line 106,                             if (!r_lengthen_V()),                             {,                                 return false;,                             },                             break;,                         case 8:,                             // (, line 107,                             // call R2, line 107,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 107,                             slice_del();,                             // attach, line 107,                             insert(cursor, cursor, "g");,                             // call lengthen_V, line 107,                             if (!r_lengthen_V()),                             {,                                 return false;,                             },                             break;,                         case 9:,                             // (, line 108,                             // call R1, line 108,                             if (!r_R1()),                             {,                                 return false;,                             },                             // call C, line 108,                             if (!r_C()),                             {,                                 return false;,                             },                             // <-, line 108,                             slice_from("t");,                             break;,                         case 10:,                             // (, line 109,                             // call R1, line 109,                             if (!r_R1()),                             {,                                 return false;,                             },                             // call C, line 109,                             if (!r_C()),                             {,                                 return false;,                             },                             // <-, line 109,                             slice_from("d");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/KpStemmer.java,r_Step_6,1359-1470,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 155,                             // <-, line 155,                             slice_from("b");,                             break;,                         case 2:,                             // (, line 156,                             // <-, line 156,                             slice_from("c");,                             break;,                         case 3:,                             // (, line 157,                             // <-, line 157,                             slice_from("d");,                             break;,                         case 4:,                             // (, line 158,                             // <-, line 158,                             slice_from("f");,                             break;,                         case 5:,                             // (, line 159,                             // <-, line 159,                             slice_from("g");,                             break;,                         case 6:,                             // (, line 160,                             // <-, line 160,                             slice_from("h");,                             break;,                         case 7:,                             // (, line 161,                             // <-, line 161,                             slice_from("j");,                             break;,                         case 8:,                             // (, line 162,                             // <-, line 162,                             slice_from("k");,                             break;,                         case 9:,                             // (, line 163,                             // <-, line 163,                             slice_from("l");,                             break;,                         case 10:,                             // (, line 164,                             // <-, line 164,                             slice_from("m");,                             break;,                         case 11:,                             // (, line 165,                             // <-, line 165,                             slice_from("n");,                             break;,                         case 12:,                             // (, line 166,                             // <-, line 166,                             slice_from("p");,                             break;,                         case 13:,                             // (, line 167,                             // <-, line 167,                             slice_from("q");,                             break;,                         case 14:,                             // (, line 168,                             // <-, line 168,                             slice_from("r");,                             break;,                         case 15:,                             // (, line 169,                             // <-, line 169,                             slice_from("s");,                             break;,                         case 16:,                             // (, line 170,                             // <-, line 170,                             slice_from("t");,                             break;,                         case 17:,                             // (, line 171,                             // <-, line 171,                             slice_from("v");,                             break;,                         case 18:,                             // (, line 172,                             // <-, line 172,                             slice_from("w");,                             break;,                         case 19:,                             // (, line 173,                             // <-, line 173,                             slice_from("x");,                             break;,                         case 20:,                             // (, line 174,                             // <-, line 174,                             slice_from("z");,                             break;,                         case 21:,                             // (, line 175,                             // <-, line 175,                             slice_from("f");,                             break;,                         case 22:,                             // (, line 176,                             // <-, line 176,                             slice_from("s");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/KpStemmer.java,r_Step_7,1323-1339,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 146,                             // <-, line 146,                             slice_from("k");,                             break;,                         case 2:,                             // (, line 147,                             // <-, line 147,                             slice_from("f");,                             break;,                         case 3:,                             // (, line 148,                             // <-, line 148,                             slice_from("p");],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/KpStemmer.java,stem,2028-2028,[                        if (!r_measure())],,stem,2047-2047,[                        if (!r_Step_1c())],,stem,2068-2068,[                        if (!r_measure())],,stem,2087-2087,[                        if (!r_Step_1c())],,stem,2130-2130,[                        if (!r_Step_6())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/KpStemmer.java,copy_from,138-146,[                    B_GE_removed = other.B_GE_removed;,                     B_stemmed = other.B_stemmed;,                     B_Y_found = other.B_Y_found;,                     I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     I_x = other.I_x;,                     S_ch = other.S_ch;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/LovinsStemmer.java,stem,1912-1912,[                    cursor = limit_backward;                    return true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/LovinsStemmer.java,r_endings,1533-1539,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 145,                             // delete, line 145,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/LovinsStemmer.java,r_respell,1592-1867,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 161,                             // <-, line 161,                             slice_from("ief");,                             break;,                         case 2:,                             // (, line 162,                             // <-, line 162,                             slice_from("uc");,                             break;,                         case 3:,                             // (, line 163,                             // <-, line 163,                             slice_from("um");,                             break;,                         case 4:,                             // (, line 164,                             // <-, line 164,                             slice_from("rb");,                             break;,                         case 5:,                             // (, line 165,                             // <-, line 165,                             slice_from("ur");,                             break;,                         case 6:,                             // (, line 166,                             // <-, line 166,                             slice_from("ister");,                             break;,                         case 7:,                             // (, line 167,                             // <-, line 167,                             slice_from("meter");,                             break;,                         case 8:,                             // (, line 168,                             // <-, line 168,                             slice_from("olut");,                             break;,                         case 9:,                             // (, line 169,                             // not, line 169,                             {,                                 v_1 = limit - cursor;,                                 lab0: do {,                                     // literal, line 169,                                     if (!(eq_s_b(1, "a"))),                                     {,                                         break lab0;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_1;,                             },                             // not, line 169,                             {,                                 v_2 = limit - cursor;,                                 lab1: do {,                                     // literal, line 169,                                     if (!(eq_s_b(1, "i"))),                                     {,                                         break lab1;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_2;,                             },                             // not, line 169,                             {,                                 v_3 = limit - cursor;,                                 lab2: do {,                                     // literal, line 169,                                     if (!(eq_s_b(1, "o"))),                                     {,                                         break lab2;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_3;,                             },                             // <-, line 169,                             slice_from("l");,                             break;,                         case 10:,                             // (, line 170,                             // <-, line 170,                             slice_from("bic");,                             break;,                         case 11:,                             // (, line 171,                             // <-, line 171,                             slice_from("dic");,                             break;,                         case 12:,                             // (, line 172,                             // <-, line 172,                             slice_from("pic");,                             break;,                         case 13:,                             // (, line 173,                             // <-, line 173,                             slice_from("tic");,                             break;,                         case 14:,                             // (, line 174,                             // <-, line 174,                             slice_from("ac");,                             break;,                         case 15:,                             // (, line 175,                             // <-, line 175,                             slice_from("ec");,                             break;,                         case 16:,                             // (, line 176,                             // <-, line 176,                             slice_from("ic");,                             break;,                         case 17:,                             // (, line 177,                             // <-, line 177,                             slice_from("luc");,                             break;,                         case 18:,                             // (, line 178,                             // <-, line 178,                             slice_from("uas");,                             break;,                         case 19:,                             // (, line 179,                             // <-, line 179,                             slice_from("vas");,                             break;,                         case 20:,                             // (, line 180,                             // <-, line 180,                             slice_from("cis");,                             break;,                         case 21:,                             // (, line 181,                             // <-, line 181,                             slice_from("lis");,                             break;,                         case 22:,                             // (, line 182,                             // <-, line 182,                             slice_from("eris");,                             break;,                         case 23:,                             // (, line 183,                             // <-, line 183,                             slice_from("pans");,                             break;,                         case 24:,                             // (, line 184,                             // not, line 184,                             {,                                 v_4 = limit - cursor;,                                 lab3: do {,                                     // literal, line 184,                                     if (!(eq_s_b(1, "s"))),                                     {,                                         break lab3;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_4;,                             },                             // <-, line 184,                             slice_from("ens");,                             break;,                         case 25:,                             // (, line 185,                             // <-, line 185,                             slice_from("ons");,                             break;,                         case 26:,                             // (, line 186,                             // <-, line 186,                             slice_from("lus");,                             break;,                         case 27:,                             // (, line 187,                             // <-, line 187,                             slice_from("rus");,                             break;,                         case 28:,                             // (, line 188,                             // not, line 188,                             {,                                 v_5 = limit - cursor;,                                 lab4: do {,                                     // literal, line 188,                                     if (!(eq_s_b(1, "p"))),                                     {,                                         break lab4;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_5;,                             },                             // not, line 188,                             {,                                 v_6 = limit - cursor;,                                 lab5: do {,                                     // literal, line 188,                                     if (!(eq_s_b(1, "t"))),                                     {,                                         break lab5;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_6;,                             },                             // <-, line 188,                             slice_from("hes");,                             break;,                         case 29:,                             // (, line 189,                             // <-, line 189,                             slice_from("mis");,                             break;,                         case 30:,                             // (, line 190,                             // not, line 190,                             {,                                 v_7 = limit - cursor;,                                 lab6: do {,                                     // literal, line 190,                                     if (!(eq_s_b(1, "m"))),                                     {,                                         break lab6;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_7;,                             },                             // <-, line 190,                             slice_from("ens");,                             break;,                         case 31:,                             // (, line 192,                             // <-, line 192,                             slice_from("ers");,                             break;,                         case 32:,                             // (, line 193,                             // not, line 193,                             {,                                 v_8 = limit - cursor;,                                 lab7: do {,                                     // literal, line 193,                                     if (!(eq_s_b(1, "n"))),                                     {,                                         break lab7;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_8;,                             },                             // <-, line 193,                             slice_from("es");,                             break;,                         case 33:,                             // (, line 194,                             // <-, line 194,                             slice_from("ys");,                             break;,                         case 34:,                             // (, line 195,                             // <-, line 195,                             slice_from("ys");],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/LovinsStemmer.java,stem,1886-1886,[                        if (!r_endings())],,stem,1896-1896,[                        if (!r_undouble())],,stem,1906-1906,[                        if (!r_respell())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,copy_from,380-381,[                    super.copy_from(other);,                 }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_A,387-394,[                        int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_AA,1432-1448,[                    v_1 = limit - cursor;,                     // hop, line 47,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // among, line 47,                     if (find_among_b(a_0, 9) == 0),                     {,                         return false;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_B,401-408,[                        int c = cursor - 3;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_BB,1457-1494,[                    v_1 = limit - cursor;,                     // hop, line 49,                     {,                         int c = cursor - 3;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 49,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 49,                             if (!(eq_s_b(3, "met"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     // not, line 49,                     {,                         v_3 = limit - cursor;,                         lab1: do {,                             // literal, line 49,                             if (!(eq_s_b(4, "ryst"))),                             {,                                 break lab1;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_3;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_C,415-422,[                        int c = cursor - 4;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_CC,1501-1517,[                    v_1 = limit - cursor;,                     // hop, line 50,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // literal, line 50,                     if (!(eq_s_b(1, "l"))),                     {,                         return false;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_D,429-436,[                        int c = cursor - 5;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_E,444-468,[                    v_1 = limit - cursor;,                     // hop, line 25,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 25,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 25,                             if (!(eq_s_b(1, "e"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_F,476-500,[                    v_1 = limit - cursor;,                     // hop, line 26,                     {,                         int c = cursor - 3;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 26,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 26,                             if (!(eq_s_b(1, "e"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_G,507-523,[                    v_1 = limit - cursor;,                     // hop, line 27,                     {,                         int c = cursor - 3;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // literal, line 27,                     if (!(eq_s_b(1, "f"))),                     {,                         return false;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_H,531-560,[                    v_1 = limit - cursor;,                     // hop, line 28,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // or, line 28,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // literal, line 28,                             if (!(eq_s_b(1, "t"))),                             {,                                 break lab1;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // literal, line 28,                         if (!(eq_s_b(2, "ll"))),                         {,                             return false;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_I,569-606,[                    v_1 = limit - cursor;,                     // hop, line 29,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 29,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 29,                             if (!(eq_s_b(1, "o"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     // not, line 29,                     {,                         v_3 = limit - cursor;,                         lab1: do {,                             // literal, line 29,                             if (!(eq_s_b(1, "e"))),                             {,                                 break lab1;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_3;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_J,615-652,[                    v_1 = limit - cursor;,                     // hop, line 30,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 30,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 30,                             if (!(eq_s_b(1, "a"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     // not, line 30,                     {,                         v_3 = limit - cursor;,                         lab1: do {,                             // literal, line 30,                             if (!(eq_s_b(1, "e"))),                             {,                                 break lab1;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_3;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_K,660-710,[                    v_1 = limit - cursor;,                     // hop, line 31,                     {,                         int c = cursor - 3;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // or, line 31,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // literal, line 31,                             if (!(eq_s_b(1, "l"))),                             {,                                 break lab1;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         lab2: do {,                             // literal, line 31,                             if (!(eq_s_b(1, "i"))),                             {,                                 break lab2;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // (, line 31,                         // literal, line 31,                         if (!(eq_s_b(1, "e"))),                         {,                             return false;,                         },                         // next, line 31,                         if (cursor <= limit_backward),                         {,                             return false;,                         },                         cursor--;,                         // literal, line 31,                         if (!(eq_s_b(1, "u"))),                         {,                             return false;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_L,721-785,[                    v_1 = limit - cursor;,                     // hop, line 32,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 32,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 32,                             if (!(eq_s_b(1, "u"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     // not, line 32,                     {,                         v_3 = limit - cursor;,                         lab1: do {,                             // literal, line 32,                             if (!(eq_s_b(1, "x"))),                             {,                                 break lab1;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_3;,                     },                     // not, line 32,                     {,                         v_4 = limit - cursor;,                         lab2: do {,                             // (, line 32,                             // literal, line 32,                             if (!(eq_s_b(1, "s"))),                             {,                                 break lab2;,                             },                             // not, line 32,                             {,                                 v_5 = limit - cursor;,                                 lab3: do {,                                     // literal, line 32,                                     if (!(eq_s_b(1, "o"))),                                     {,                                         break lab3;,                                     },                                     break lab2;,                                 } while (false);,                                 cursor = limit - v_5;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_4;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_M,796-859,[                    v_1 = limit - cursor;,                     // hop, line 33,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 33,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 33,                             if (!(eq_s_b(1, "a"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     // not, line 33,                     {,                         v_3 = limit - cursor;,                         lab1: do {,                             // literal, line 33,                             if (!(eq_s_b(1, "c"))),                             {,                                 break lab1;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_3;,                     },                     // not, line 33,                     {,                         v_4 = limit - cursor;,                         lab2: do {,                             // literal, line 33,                             if (!(eq_s_b(1, "e"))),                             {,                                 break lab2;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_4;,                     },                     // not, line 33,                     {,                         v_5 = limit - cursor;,                         lab3: do {,                             // literal, line 33,                             if (!(eq_s_b(1, "m"))),                             {,                                 break lab3;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_5;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_N,868-919,[                    v_1 = limit - cursor;,                     // hop, line 34,                     {,                         int c = cursor - 3;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // (, line 34,                     // hop, line 34,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     // or, line 34,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // not, line 34,                             {,                                 v_3 = limit - cursor;,                                 lab2: do {,                                     // literal, line 34,                                     if (!(eq_s_b(1, "s"))),                                     {,                                         break lab2;,                                     },                                     break lab1;,                                 } while (false);,                                 cursor = limit - v_3;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // hop, line 34,                         {,                             int c = cursor - 2;,                             if (limit_backward > c || c > limit),                             {,                                 return false;,                             },                             cursor = c;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_O,927-956,[                    v_1 = limit - cursor;,                     // hop, line 35,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // or, line 35,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // literal, line 35,                             if (!(eq_s_b(1, "l"))),                             {,                                 break lab1;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // literal, line 35,                         if (!(eq_s_b(1, "i"))),                         {,                             return false;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_P,964-988,[                    v_1 = limit - cursor;,                     // hop, line 36,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 36,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 36,                             if (!(eq_s_b(1, "c"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_Q,998-1047,[                    v_1 = limit - cursor;,                     // hop, line 37,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // test, line 37,                     v_2 = limit - cursor;,                     // hop, line 37,                     {,                         int c = cursor - 3;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_2;,                     // not, line 37,                     {,                         v_3 = limit - cursor;,                         lab0: do {,                             // literal, line 37,                             if (!(eq_s_b(1, "l"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_3;,                     },                     // not, line 37,                     {,                         v_4 = limit - cursor;,                         lab1: do {,                             // literal, line 37,                             if (!(eq_s_b(1, "n"))),                             {,                                 break lab1;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_4;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_R,1055-1084,[                    v_1 = limit - cursor;,                     // hop, line 38,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // or, line 38,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // literal, line 38,                             if (!(eq_s_b(1, "n"))),                             {,                                 break lab1;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // literal, line 38,                         if (!(eq_s_b(1, "r"))),                         {,                             return false;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_S,1093-1136,[                    v_1 = limit - cursor;,                     // hop, line 39,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // or, line 39,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // literal, line 39,                             if (!(eq_s_b(2, "dr"))),                             {,                                 break lab1;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // (, line 39,                         // literal, line 39,                         if (!(eq_s_b(1, "t"))),                         {,                             return false;,                         },                         // not, line 39,                         {,                             v_3 = limit - cursor;,                             lab2: do {,                                 // literal, line 39,                                 if (!(eq_s_b(1, "t"))),                                 {,                                     break lab2;,                                 },                                 return false;,                             } while (false);,                             cursor = limit - v_3;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_T,1145-1188,[                    v_1 = limit - cursor;,                     // hop, line 40,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // or, line 40,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // literal, line 40,                             if (!(eq_s_b(1, "s"))),                             {,                                 break lab1;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // (, line 40,                         // literal, line 40,                         if (!(eq_s_b(1, "t"))),                         {,                             return false;,                         },                         // not, line 40,                         {,                             v_3 = limit - cursor;,                             lab2: do {,                                 // literal, line 40,                                 if (!(eq_s_b(1, "o"))),                                 {,                                     break lab2;,                                 },                                 return false;,                             } while (false);,                             cursor = limit - v_3;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_U,1196-1243,[                    v_1 = limit - cursor;,                     // hop, line 41,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // or, line 41,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // literal, line 41,                             if (!(eq_s_b(1, "l"))),                             {,                                 break lab1;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         lab2: do {,                             // literal, line 41,                             if (!(eq_s_b(1, "m"))),                             {,                                 break lab2;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         lab3: do {,                             // literal, line 41,                             if (!(eq_s_b(1, "n"))),                             {,                                 break lab3;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // literal, line 41,                         if (!(eq_s_b(1, "r"))),                         {,                             return false;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_V,1250-1266,[                    v_1 = limit - cursor;,                     // hop, line 42,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // literal, line 42,                     if (!(eq_s_b(1, "c"))),                     {,                         return false;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_W,1275-1312,[                    v_1 = limit - cursor;,                     // hop, line 43,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 43,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 43,                             if (!(eq_s_b(1, "s"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     // not, line 43,                     {,                         v_3 = limit - cursor;,                         lab1: do {,                             // literal, line 43,                             if (!(eq_s_b(1, "u"))),                             {,                                 break lab1;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_3;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_X,1320-1370,[                    v_1 = limit - cursor;,                     // hop, line 44,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // or, line 44,                     lab0: do {,                         v_2 = limit - cursor;,                         lab1: do {,                             // literal, line 44,                             if (!(eq_s_b(1, "l"))),                             {,                                 break lab1;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         lab2: do {,                             // literal, line 44,                             if (!(eq_s_b(1, "i"))),                             {,                                 break lab2;,                             },                             break lab0;,                         } while (false);,                         cursor = limit - v_2;,                         // (, line 44,                         // literal, line 44,                         if (!(eq_s_b(1, "e"))),                         {,                             return false;,                         },                         // next, line 44,                         if (cursor <= limit_backward),                         {,                             return false;,                         },                         cursor--;,                         // literal, line 44,                         if (!(eq_s_b(1, "u"))),                         {,                             return false;,                         },                     } while (false);,                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_Y,1377-1393,[                    v_1 = limit - cursor;,                     // hop, line 45,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // literal, line 45,                     if (!(eq_s_b(2, "in"))),                     {,                         return false;,                     },                     return true;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/LovinsStemmer.java,r_Z,1401-1425,[                    v_1 = limit - cursor;,                     // hop, line 46,                     {,                         int c = cursor - 2;,                         if (limit_backward > c || c > limit),                         {,                             return false;,                         },                         cursor = c;,                     },                     cursor = limit - v_1;,                     // not, line 46,                     {,                         v_2 = limit - cursor;,                         lab0: do {,                             // literal, line 46,                             if (!(eq_s_b(1, "f"))),                             {,                                 break lab0;,                             },                             return false;,                         } while (false);,                         cursor = limit - v_2;,                     },                     return true;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/NorwegianStemmer.java,stem,362-362,[                    cursor = limit_backward;                    return true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/NorwegianStemmer.java,r_main_suffix,182-220,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 44,                             // delete, line 44,                             slice_del();,                             break;,                         case 2:,                             // (, line 46,                             // or, line 46,                             lab0: do {,                                 v_3 = limit - cursor;,                                 lab1: do {,                                     if (!(in_grouping_b(g_s_ending, 98, 122))),                                     {,                                         break lab1;,                                     },                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_3;,                                 // (, line 46,                                 // literal, line 46,                                 if (!(eq_s_b(1, "k"))),                                 {,                                     return false;,                                 },                                 if (!(out_grouping_b(g_v, 97, 248))),                                 {,                                     return false;,                                 },                             } while (false);,                             // delete, line 46,                             slice_del();,                             break;,                         case 3:,                             // (, line 48,                             // <-, line 48,                             slice_from("er");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/NorwegianStemmer.java,r_other_suffix,300-306,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 67,                             // delete, line 67,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/NorwegianStemmer.java,stem,323-323,[                        if (!r_mark_regions())],,stem,336-336,[                        if (!r_main_suffix())],,stem,346-346,[                        if (!r_consonant_pair())],,stem,356-356,[                        if (!r_other_suffix())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/NorwegianStemmer.java,copy_from,78-81,[                    I_x = other.I_x;,                     I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/tartarus/snowball/ext/PorterStemmer.java,r_Step_2,412-413,[                            slice_from("al");,                             break;],,r_Step_2,417-418,[                            slice_from("al");,                             break;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/PorterStemmer.java,stem,861-861,[                    cursor = limit_backward;                    // do, line 137],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PorterStemmer.java,r_Step_1a,164-180,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 26,                             // <-, line 26,                             slice_from("ss");,                             break;,                         case 2:,                             // (, line 27,                             // <-, line 27,                             slice_from("i");,                             break;,                         case 3:,                             // (, line 29,                             // delete, line 29,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PorterStemmer.java,r_Step_1b,247-293,[                            switch(among_var) {,                                 case 0:,                                     return false;,                                 case 1:,                                     // (, line 41,                                     // <+, line 41,                                     {,                                         int c = cursor;,                                         insert(cursor, cursor, "e");,                                         cursor = c;,                                     },                                     break;,                                 case 2:,                                     // (, line 44,                                     // [, line 44,                                     ket = cursor;,                                     // next, line 44,                                     if (cursor <= limit_backward),                                     {,                                         return false;,                                     },                                     cursor--;,                                     // ], line 44,                                     bra = cursor;,                                     // delete, line 44,                                     slice_del();,                                     break;,                                 case 3:,                                     // (, line 45,                                     // atmark, line 45,                                     if (cursor != I_p1),                                     {,                                         return false;,                                     },                                     // test, line 45,                                     v_4 = limit - cursor;,                                     // call shortv, line 45,                                     if (!r_shortv()),                                     {,                                         return false;,                                     },                                     cursor = limit - v_4;,                                     // <+, line 45,                                     {,                                         int c = cursor;,                                         insert(cursor, cursor, "e");,                                         cursor = c;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PorterStemmer.java,r_Step_2,366-437,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 59,                             // <-, line 59,                             slice_from("tion");,                             break;,                         case 2:,                             // (, line 60,                             // <-, line 60,                             slice_from("ence");,                             break;,                         case 3:,                             // (, line 61,                             // <-, line 61,                             slice_from("ance");,                             break;,                         case 4:,                             // (, line 62,                             // <-, line 62,                             slice_from("able");,                             break;,                         case 5:,                             // (, line 63,                             // <-, line 63,                             slice_from("ent");,                             break;,                         case 6:,                             // (, line 64,                             // <-, line 64,                             slice_from("e");,                             break;,                         case 7:,                             // (, line 66,                             // <-, line 66,                             slice_from("ize");,                             break;,                         case 8:,                             // (, line 68,                             // <-, line 68,                             slice_from("ate");,                             break;,                         case 9:,                             // (, line 69,                             // <-, line 69,                             slice_from("al");,                             break;,                         case 10:,                             // (, line 71,                             // <-, line 71,                             slice_from("al");,                             break;,                         case 11:,                             // (, line 72,                             // <-, line 72,                             slice_from("ful");,                             break;,                         case 12:,                             // (, line 74,                             // <-, line 74,                             slice_from("ous");,                             break;,                         case 13:,                             // (, line 76,                             // <-, line 76,                             slice_from("ive");,                             break;,                         case 14:,                             // (, line 77,                             // <-, line 77,                             slice_from("ble");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PorterStemmer.java,r_Step_3,461-477,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 83,                             // <-, line 83,                             slice_from("al");,                             break;,                         case 2:,                             // (, line 85,                             // <-, line 85,                             slice_from("ic");,                             break;,                         case 3:,                             // (, line 87,                             // delete, line 87,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PorterStemmer.java,r_Step_4,502-531,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 95,                             // delete, line 95,                             slice_del();,                             break;,                         case 2:,                             // (, line 96,                             // or, line 96,                             lab0: do {,                                 v_1 = limit - cursor;,                                 lab1: do {,                                     // literal, line 96,                                     if (!(eq_s_b(1, "s"))),                                     {,                                         break lab1;,                                     },                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 // literal, line 96,                                 if (!(eq_s_b(1, "t"))),                                 {,                                     return false;,                                 },                             } while (false);,                             // delete, line 96,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/PorterStemmer.java,stem,785-785,[                        if (!r_Step_1a())],,stem,795-795,[                        if (!r_Step_1b())],,stem,805-805,[                        if (!r_Step_1c())],,stem,815-815,[                        if (!r_Step_2())],,stem,825-825,[                        if (!r_Step_3())],,stem,835-835,[                        if (!r_Step_4())],,stem,845-845,[                        if (!r_Step_5a())],,stem,855-855,[                        if (!r_Step_5b())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/PorterStemmer.java,copy_from,112-116,[                    B_Y_found = other.B_Y_found;,                     I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/PortugueseStemmer.java,stem,1110-1110,[                    cursor = limit_backward;                    // do, line 213],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PortugueseStemmer.java,r_residual_form,921-986,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 194,                             // call RV, line 194,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 194,                             slice_del();,                             // [, line 194,                             ket = cursor;,                             // or, line 194,                             lab0: do {,                                 v_1 = limit - cursor;,                                 lab1: do {,                                     // (, line 194,                                     // literal, line 194,                                     if (!(eq_s_b(1, "u"))),                                     {,                                         break lab1;,                                     },                                     // ], line 194,                                     bra = cursor;,                                     // test, line 194,                                     v_2 = limit - cursor;,                                     // literal, line 194,                                     if (!(eq_s_b(1, "g"))),                                     {,                                         break lab1;,                                     },                                     cursor = limit - v_2;,                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 // (, line 195,                                 // literal, line 195,                                 if (!(eq_s_b(1, "i"))),                                 {,                                     return false;,                                 },                                 // ], line 195,                                 bra = cursor;,                                 // test, line 195,                                 v_3 = limit - cursor;,                                 // literal, line 195,                                 if (!(eq_s_b(1, "c"))),                                 {,                                     return false;,                                 },                                 cursor = limit - v_3;,                             } while (false);,                             // call RV, line 195,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 195,                             slice_del();,                             break;,                         case 2:,                             // (, line 196,                             // <-, line 196,                             slice_from("c");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PortugueseStemmer.java,r_residual_suffix,888-899,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 187,                             // call RV, line 187,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 187,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PortugueseStemmer.java,r_standard_suffix,595-828,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 92,                             // call R2, line 93,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 93,                             slice_del();,                             break;,                         case 2:,                             // (, line 97,                             // call R2, line 98,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 98,                             slice_from("log");,                             break;,                         case 3:,                             // (, line 101,                             // call R2, line 102,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 102,                             slice_from("u");,                             break;,                         case 4:,                             // (, line 105,                             // call R2, line 106,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 106,                             slice_from("ente");,                             break;,                         case 5:,                             // (, line 109,                             // call R1, line 110,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 110,                             slice_del();,                             // try, line 111,                             v_1 = limit - cursor;,                             lab0: do {,                                 // (, line 111,                                 // [, line 112,                                 ket = cursor;,                                 // substring, line 112,                                 among_var = find_among_b(a_2, 4);,                                 if (among_var == 0),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 // ], line 112,                                 bra = cursor;,                                 // call R2, line 112,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 // delete, line 112,                                 slice_del();,                                 switch(among_var) {,                                     case 0:,                                         cursor = limit - v_1;,                                         break lab0;,                                     case 1:,                                         // (, line 113,                                         // [, line 113,                                         ket = cursor;,                                         // literal, line 113,                                         if (!(eq_s_b(2, "at"))),                                         {,                                             cursor = limit - v_1;,                                             break lab0;,                                         },                                         // ], line 113,                                         bra = cursor;,                                         // call R2, line 113,                                         if (!r_R2()),                                         {,                                             cursor = limit - v_1;,                                             break lab0;,                                         },                                         // delete, line 113,                                         slice_del();,                                         break;,                                 },                             } while (false);,                             break;,                         case 6:,                             // (, line 121,                             // call R2, line 122,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 122,                             slice_del();,                             // try, line 123,                             v_2 = limit - cursor;,                             lab1: do {,                                 // (, line 123,                                 // [, line 124,                                 ket = cursor;,                                 // substring, line 124,                                 among_var = find_among_b(a_3, 3);,                                 if (among_var == 0),                                 {,                                     cursor = limit - v_2;,                                     break lab1;,                                 },                                 // ], line 124,                                 bra = cursor;,                                 switch(among_var) {,                                     case 0:,                                         cursor = limit - v_2;,                                         break lab1;,                                     case 1:,                                         // (, line 127,                                         // call R2, line 127,                                         if (!r_R2()),                                         {,                                             cursor = limit - v_2;,                                             break lab1;,                                         },                                         // delete, line 127,                                         slice_del();,                                         break;,                                 },                             } while (false);,                             break;,                         case 7:,                             // (, line 133,                             // call R2, line 134,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 134,                             slice_del();,                             // try, line 135,                             v_3 = limit - cursor;,                             lab2: do {,                                 // (, line 135,                                 // [, line 136,                                 ket = cursor;,                                 // substring, line 136,                                 among_var = find_among_b(a_4, 3);,                                 if (among_var == 0),                                 {,                                     cursor = limit - v_3;,                                     break lab2;,                                 },                                 // ], line 136,                                 bra = cursor;,                                 switch(among_var) {,                                     case 0:,                                         cursor = limit - v_3;,                                         break lab2;,                                     case 1:,                                         // (, line 139,                                         // call R2, line 139,                                         if (!r_R2()),                                         {,                                             cursor = limit - v_3;,                                             break lab2;,                                         },                                         // delete, line 139,                                         slice_del();,                                         break;,                                 },                             } while (false);,                             break;,                         case 8:,                             // (, line 145,                             // call R2, line 146,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 146,                             slice_del();,                             // try, line 147,                             v_4 = limit - cursor;,                             lab3: do {,                                 // (, line 147,                                 // [, line 148,                                 ket = cursor;,                                 // literal, line 148,                                 if (!(eq_s_b(2, "at"))),                                 {,                                     cursor = limit - v_4;,                                     break lab3;,                                 },                                 // ], line 148,                                 bra = cursor;,                                 // call R2, line 148,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_4;,                                     break lab3;,                                 },                                 // delete, line 148,                                 slice_del();,                             } while (false);,                             break;,                         case 9:,                             // (, line 152,                             // call RV, line 153,                             if (!r_RV()),                             {,                                 return false;,                             },                             // literal, line 153,                             if (!(eq_s_b(1, "e"))),                             {,                                 return false;,                             },                             // <-, line 154,                             slice_from("ir");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/PortugueseStemmer.java,r_verb_suffix,861-868,[                    switch(among_var) {,                         case 0:,                             limit_backward = v_2;,                             return false;,                         case 1:,                             // (, line 179,                             // delete, line 179,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/PortugueseStemmer.java,stem,1009-1009,[                        if (!r_prelude())],,stem,1019-1019,[                        if (!r_mark_regions())],,stem,1093-1093,[                            if (!r_residual_suffix())],,stem,1104-1104,[                        if (!r_residual_form())],,stem,1114-1114,[                        if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/PortugueseStemmer.java,copy_from,245-249,[                    I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/RomanianStemmer.java,stem,1018-1018,[                    cursor = limit_backward;                    // do, line 234],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RomanianStemmer.java,r_combo_suffix,727-758,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 100,                             // <-, line 101,                             slice_from("abil");,                             break;,                         case 2:,                             // (, line 103,                             // <-, line 104,                             slice_from("ibil");,                             break;,                         case 3:,                             // (, line 106,                             // <-, line 107,                             slice_from("iv");,                             break;,                         case 4:,                             // (, line 112,                             // <-, line 113,                             slice_from("ic");,                             break;,                         case 5:,                             // (, line 117,                             // <-, line 118,                             slice_from("at");,                             break;,                         case 6:,                             // (, line 121,                             // <-, line 122,                             slice_from("it");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RomanianStemmer.java,r_standard_suffix,804-827,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 148,                             // delete, line 149,                             slice_del();,                             break;,                         case 2:,                             // (, line 151,                             // literal, line 152,                             if (!(eq_s_b(1, "\u0163"))),                             {,                                 return false;,                             },                             // ], line 152,                             bra = cursor;,                             // <-, line 152,                             slice_from("t");,                             break;,                         case 3:,                             // (, line 155,                             // <-, line 156,                             slice_from("ist");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RomanianStemmer.java,r_step_0,650-699,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 75,                             // delete, line 75,                             slice_del();,                             break;,                         case 2:,                             // (, line 77,                             // <-, line 77,                             slice_from("a");,                             break;,                         case 3:,                             // (, line 79,                             // <-, line 79,                             slice_from("e");,                             break;,                         case 4:,                             // (, line 81,                             // <-, line 81,                             slice_from("i");,                             break;,                         case 5:,                             // (, line 83,                             // not, line 83,                             {,                                 v_1 = limit - cursor;,                                 lab0: do {,                                     // literal, line 83,                                     if (!(eq_s_b(2, "ab"))),                                     {,                                         break lab0;,                                     },                                     return false;,                                 } while (false);,                                 cursor = limit - v_1;,                             },                             // <-, line 83,                             slice_from("i");,                             break;,                         case 6:,                             // (, line 85,                             // <-, line 85,                             slice_from("at");,                             break;,                         case 7:,                             // (, line 87,                             // <-, line 87,                             slice_from("a\u0163i");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RomanianStemmer.java,r_verb_suffix,863-893,[                    switch(among_var) {,                         case 0:,                             limit_backward = v_2;,                             return false;,                         case 1:,                             // (, line 200,                             // or, line 200,                             lab0: do {,                                 v_3 = limit - cursor;,                                 lab1: do {,                                     if (!(out_grouping_b(g_v, 97, 259))),                                     {,                                         break lab1;,                                     },                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_3;,                                 // literal, line 200,                                 if (!(eq_s_b(1, "u"))),                                 {,                                     limit_backward = v_2;,                                     return false;,                                 },                             } while (false);,                             // delete, line 200,                             slice_del();,                             break;,                         case 2:,                             // (, line 214,                             // delete, line 214,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RomanianStemmer.java,r_vowel_suffix,918-924,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 220,                             // delete, line 220,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/RomanianStemmer.java,stem,945-945,[                        if (!r_prelude())],,stem,955-955,[                        if (!r_mark_regions())],,stem,968-968,[                        if (!r_step_0())],,stem,978-978,[                        if (!r_standard_suffix())],,stem,1001-1001,[                            if (!r_verb_suffix())],,stem,1012-1012,[                        if (!r_vowel_suffix())],,stem,1022-1022,[                        if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/RomanianStemmer.java,copy_from,271-276,[                    B_standard_suffix_removed = other.B_standard_suffix_removed;,                     I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RussianStemmer.java,r_adjectival,376-407,[                        switch(among_var) {,                             case 0:,                                 cursor = limit - v_1;,                                 break lab0;,                             case 1:,                                 // (, line 115,                                 // or, line 115,                                 lab1: do {,                                     v_2 = limit - cursor;,                                     lab2: do {,                                         // literal, line 115,                                         if (!(eq_s_b(1, "\u0430"))),                                         {,                                             break lab2;,                                         },                                         break lab1;,                                     } while (false);,                                     cursor = limit - v_2;,                                     // literal, line 115,                                     if (!(eq_s_b(1, "\u044F"))),                                     {,                                         cursor = limit - v_1;,                                         break lab0;,                                     },                                 } while (false);,                                 // delete, line 115,                                 slice_del();,                                 break;,                             case 2:,                                 // (, line 122,                                 // delete, line 122,                                 slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RussianStemmer.java,r_adjective,339-345,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 97,                             // delete, line 97,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RussianStemmer.java,r_derivational,531-537,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 179,                             // delete, line 179,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RussianStemmer.java,r_noun,501-507,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 167,                             // delete, line 167,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RussianStemmer.java,r_perfective_gerund,291-320,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 76,                             // or, line 76,                             lab0: do {,                                 v_1 = limit - cursor;,                                 lab1: do {,                                     // literal, line 76,                                     if (!(eq_s_b(1, "\u0430"))),                                     {,                                         break lab1;,                                     },                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 // literal, line 76,                                 if (!(eq_s_b(1, "\u044F"))),                                 {,                                     return false;,                                 },                             } while (false);,                             // delete, line 76,                             slice_del();,                             break;,                         case 2:,                             // (, line 83,                             // delete, line 83,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RussianStemmer.java,r_reflexive,427-433,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 132,                             // delete, line 132,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RussianStemmer.java,r_tidy_up,556-593,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 188,                             // delete, line 188,                             slice_del();,                             // [, line 189,                             ket = cursor;,                             // literal, line 189,                             if (!(eq_s_b(1, "\u043D"))),                             {,                                 return false;,                             },                             // ], line 189,                             bra = cursor;,                             // literal, line 189,                             if (!(eq_s_b(1, "\u043D"))),                             {,                                 return false;,                             },                             // delete, line 189,                             slice_del();,                             break;,                         case 2:,                             // (, line 192,                             // literal, line 192,                             if (!(eq_s_b(1, "\u043D"))),                             {,                                 return false;,                             },                             // delete, line 192,                             slice_del();,                             break;,                         case 3:,                             // (, line 194,                             // delete, line 194,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/RussianStemmer.java,r_verb,453-482,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 143,                             // or, line 143,                             lab0: do {,                                 v_1 = limit - cursor;,                                 lab1: do {,                                     // literal, line 143,                                     if (!(eq_s_b(1, "\u0430"))),                                     {,                                         break lab1;,                                     },                                     break lab0;,                                 } while (false);,                                 cursor = limit - v_1;,                                 // literal, line 143,                                 if (!(eq_s_b(1, "\u044F"))),                                 {,                                     return false;,                                 },                             } while (false);,                             // delete, line 143,                             slice_del();,                             break;,                         case 2:,                             // (, line 151,                             // delete, line 151,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/RussianStemmer.java,stem,616-616,[                        if (!r_mark_regions())],,stem,685-685,[                                if (!r_noun())],,stem,714-714,[                        if (!r_derivational())],,stem,724-724,[                        if (!r_tidy_up())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/RussianStemmer.java,copy_from,182-185,[                    I_p2 = other.I_p2;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/SpanishStemmer.java,stem,1176-1176,[                    cursor = limit_backward;                    // do, line 225],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/SpanishStemmer.java,r_attached_pronoun,579-630,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 73,                             // ], line 73,                             bra = cursor;,                             // <-, line 73,                             slice_from("iendo");,                             break;,                         case 2:,                             // (, line 74,                             // ], line 74,                             bra = cursor;,                             // <-, line 74,                             slice_from("ando");,                             break;,                         case 3:,                             // (, line 75,                             // ], line 75,                             bra = cursor;,                             // <-, line 75,                             slice_from("ar");,                             break;,                         case 4:,                             // (, line 76,                             // ], line 76,                             bra = cursor;,                             // <-, line 76,                             slice_from("er");,                             break;,                         case 5:,                             // (, line 77,                             // ], line 77,                             bra = cursor;,                             // <-, line 77,                             slice_from("ir");,                             break;,                         case 6:,                             // (, line 81,                             // delete, line 81,                             slice_del();,                             break;,                         case 7:,                             // (, line 82,                             // literal, line 82,                             if (!(eq_s_b(1, "u"))),                             {,                                 return false;,                             },                             // delete, line 82,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/SpanishStemmer.java,r_residual_suffix,1042-1094,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 208,                             // call RV, line 208,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 208,                             slice_del();,                             break;,                         case 2:,                             // (, line 210,                             // call RV, line 210,                             if (!r_RV()),                             {,                                 return false;,                             },                             // delete, line 210,                             slice_del();,                             // try, line 210,                             v_1 = limit - cursor;,                             lab0: do {,                                 // (, line 210,                                 // [, line 210,                                 ket = cursor;,                                 // literal, line 210,                                 if (!(eq_s_b(1, "u"))),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 // ], line 210,                                 bra = cursor;,                                 // test, line 210,                                 v_2 = limit - cursor;,                                 // literal, line 210,                                 if (!(eq_s_b(1, "g"))),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 cursor = limit - v_2;,                                 // call RV, line 210,                                 if (!r_RV()),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 // delete, line 210,                                 slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/SpanishStemmer.java,r_standard_suffix,654-904,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 98,                             // call R2, line 99,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 99,                             slice_del();,                             break;,                         case 2:,                             // (, line 104,                             // call R2, line 105,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 105,                             slice_del();,                             // try, line 106,                             v_1 = limit - cursor;,                             lab0: do {,                                 // (, line 106,                                 // [, line 106,                                 ket = cursor;,                                 // literal, line 106,                                 if (!(eq_s_b(2, "ic"))),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 // ], line 106,                                 bra = cursor;,                                 // call R2, line 106,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_1;,                                     break lab0;,                                 },                                 // delete, line 106,                                 slice_del();,                             } while (false);,                             break;,                         case 3:,                             // (, line 110,                             // call R2, line 111,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 111,                             slice_from("log");,                             break;,                         case 4:,                             // (, line 114,                             // call R2, line 115,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 115,                             slice_from("u");,                             break;,                         case 5:,                             // (, line 118,                             // call R2, line 119,                             if (!r_R2()),                             {,                                 return false;,                             },                             // <-, line 119,                             slice_from("ente");,                             break;,                         case 6:,                             // (, line 122,                             // call R1, line 123,                             if (!r_R1()),                             {,                                 return false;,                             },                             // delete, line 123,                             slice_del();,                             // try, line 124,                             v_2 = limit - cursor;,                             lab1: do {,                                 // (, line 124,                                 // [, line 125,                                 ket = cursor;,                                 // substring, line 125,                                 among_var = find_among_b(a_3, 4);,                                 if (among_var == 0),                                 {,                                     cursor = limit - v_2;,                                     break lab1;,                                 },                                 // ], line 125,                                 bra = cursor;,                                 // call R2, line 125,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_2;,                                     break lab1;,                                 },                                 // delete, line 125,                                 slice_del();,                                 switch(among_var) {,                                     case 0:,                                         cursor = limit - v_2;,                                         break lab1;,                                     case 1:,                                         // (, line 126,                                         // [, line 126,                                         ket = cursor;,                                         // literal, line 126,                                         if (!(eq_s_b(2, "at"))),                                         {,                                             cursor = limit - v_2;,                                             break lab1;,                                         },                                         // ], line 126,                                         bra = cursor;,                                         // call R2, line 126,                                         if (!r_R2()),                                         {,                                             cursor = limit - v_2;,                                             break lab1;,                                         },                                         // delete, line 126,                                         slice_del();,                                         break;,                                 },                             } while (false);,                             break;,                         case 7:,                             // (, line 134,                             // call R2, line 135,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 135,                             slice_del();,                             // try, line 136,                             v_3 = limit - cursor;,                             lab2: do {,                                 // (, line 136,                                 // [, line 137,                                 ket = cursor;,                                 // substring, line 137,                                 among_var = find_among_b(a_4, 3);,                                 if (among_var == 0),                                 {,                                     cursor = limit - v_3;,                                     break lab2;,                                 },                                 // ], line 137,                                 bra = cursor;,                                 switch(among_var) {,                                     case 0:,                                         cursor = limit - v_3;,                                         break lab2;,                                     case 1:,                                         // (, line 140,                                         // call R2, line 140,                                         if (!r_R2()),                                         {,                                             cursor = limit - v_3;,                                             break lab2;,                                         },                                         // delete, line 140,                                         slice_del();,                                         break;,                                 },                             } while (false);,                             break;,                         case 8:,                             // (, line 146,                             // call R2, line 147,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 147,                             slice_del();,                             // try, line 148,                             v_4 = limit - cursor;,                             lab3: do {,                                 // (, line 148,                                 // [, line 149,                                 ket = cursor;,                                 // substring, line 149,                                 among_var = find_among_b(a_5, 3);,                                 if (among_var == 0),                                 {,                                     cursor = limit - v_4;,                                     break lab3;,                                 },                                 // ], line 149,                                 bra = cursor;,                                 switch(among_var) {,                                     case 0:,                                         cursor = limit - v_4;,                                         break lab3;,                                     case 1:,                                         // (, line 152,                                         // call R2, line 152,                                         if (!r_R2()),                                         {,                                             cursor = limit - v_4;,                                             break lab3;,                                         },                                         // delete, line 152,                                         slice_del();,                                         break;,                                 },                             } while (false);,                             break;,                         case 9:,                             // (, line 158,                             // call R2, line 159,                             if (!r_R2()),                             {,                                 return false;,                             },                             // delete, line 159,                             slice_del();,                             // try, line 160,                             v_5 = limit - cursor;,                             lab4: do {,                                 // (, line 160,                                 // [, line 161,                                 ket = cursor;,                                 // literal, line 161,                                 if (!(eq_s_b(2, "at"))),                                 {,                                     cursor = limit - v_5;,                                     break lab4;,                                 },                                 // ], line 161,                                 bra = cursor;,                                 // call R2, line 161,                                 if (!r_R2()),                                 {,                                     cursor = limit - v_5;,                                     break lab4;,                                 },                                 // delete, line 161,                                 slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/SpanishStemmer.java,r_verb_suffix,988-1021,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 179,                             // try, line 179,                             v_3 = limit - cursor;,                             lab0: do {,                                 // (, line 179,                                 // literal, line 179,                                 if (!(eq_s_b(1, "u"))),                                 {,                                     cursor = limit - v_3;,                                     break lab0;,                                 },                                 // test, line 179,                                 v_4 = limit - cursor;,                                 // literal, line 179,                                 if (!(eq_s_b(1, "g"))),                                 {,                                     cursor = limit - v_3;,                                     break lab0;,                                 },                                 cursor = limit - v_4;,                             } while (false);,                             // ], line 179,                             bra = cursor;,                             // delete, line 179,                             slice_del();,                             break;,                         case 2:,                             // (, line 200,                             // delete, line 200,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/SpanishStemmer.java,r_y_verb_suffix,940-951,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 171,                             // literal, line 171,                             if (!(eq_s_b(1, "u"))),                             {,                                 return false;,                             },                             // delete, line 171,                             slice_del();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/SpanishStemmer.java,stem,1114-1114,[                        if (!r_mark_regions())],,stem,1127-1127,[                        if (!r_attached_pronoun())],,stem,1159-1159,[                            if (!r_verb_suffix())],,stem,1170-1170,[                        if (!r_residual_suffix())],,stem,1180-1180,[                        if (!r_postlude())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/SpanishStemmer.java,copy_from,258-262,[                    I_p2 = other.I_p2;,                     I_p1 = other.I_p1;,                     I_pV = other.I_pV;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/SwedishStemmer.java,stem,353-353,[                    cursor = limit_backward;                    return true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/SwedishStemmer.java,r_main_suffix,188-203,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 44,                             // delete, line 44,                             slice_del();,                             break;,                         case 2:,                             // (, line 46,                             if (!(in_grouping_b(g_s_ending, 98, 121))),                             {,                                 return false;,                             },                             // delete, line 46,                             slice_del();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/SwedishStemmer.java,r_other_suffix,279-296,[                    switch(among_var) {,                         case 0:,                             limit_backward = v_2;,                             return false;,                         case 1:,                             // (, line 57,                             // delete, line 57,                             slice_del();,                             break;,                         case 2:,                             // (, line 58,                             // <-, line 58,                             slice_from("l\u00F6s");,                             break;,                         case 3:,                             // (, line 59,                             // <-, line 59,                             slice_from("full");],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/SwedishStemmer.java,stem,314-314,[                        if (!r_mark_regions())],,stem,327-327,[                        if (!r_main_suffix())],,stem,337-337,[                        if (!r_consonant_pair())],,stem,347-347,[                        if (!r_other_suffix())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/SwedishStemmer.java,copy_from,85-88,[                    I_x = other.I_x;,                     I_p1 = other.I_p1;,                     super.copy_from(other);,                 }],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/TurkishStemmer.java,r_postlude,3086-3086,[                    cursor = limit_backward;                    return true;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/tartarus/snowball/ext/TurkishStemmer.java,stem,3129-3129,[                    cursor = limit_backward;                    // call postlude, line 473],,
STYLE,SF_SWITCH_NO_DEFAULT,org/tartarus/snowball/ext/TurkishStemmer.java,r_post_process_last_consonants,2644-2665,[                    switch(among_var) {,                         case 0:,                             return false;,                         case 1:,                             // (, line 417,                             // <-, line 417,                             slice_from("p");,                             break;,                         case 2:,                             // (, line 418,                             // <-, line 418,                             slice_from("\u00E7");,                             break;,                         case 3:,                             // (, line 419,                             // <-, line 419,                             slice_from("t");,                             break;,                         case 4:,                             // (, line 420,                             // <-, line 420,                             slice_from("k");],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/TurkishStemmer.java,r_postlude,3070-3070,[                        if (!r_append_U_to_stems_ending_with_d_or_g())],,r_postlude,3080-3080,[                        if (!r_post_process_last_consonants())],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/tartarus/snowball/ext/TurkishStemmer.java,stem,3108-3108,[                        if (!r_stem_nominal_verb_suffixes())],,stem,3123-3123,[                        if (!r_stem_noun_suffixes())],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/tartarus/snowball/ext/TurkishStemmer.java,copy_from,231-234,[                    B_continue_stemming_noun_suffixes = other.B_continue_stemming_noun_suffixes;,                     I_strlen = other.I_strlen;,                     super.copy_from(other);,                 }],,
